
/*
* Licensed to the Apache Software Foundation (ASF) under one
* or more contributor license agreements.  See the NOTICE file
* distributed with this work for additional information
* regarding copyright ownership.  The ASF licenses this file
* to you under the Apache License, Version 2.0 (the
* "License"); you may not use this file except in compliance
* with the License.  You may obtain a copy of the License at
*
*   http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing,
* software distributed under the License is distributed on an
* "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
* KIND, either express or implied.  See the License for the
* specific language governing permissions and limitations
* under the License.
*/

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined'
    ? factory(exports)
    : typeof define === 'function' && define.amd
      ? define(['exports'], factory)
      : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.echarts = {}))
}(this, function (exports) {
  'use strict'

  /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
  /* global Reflect, Promise */

  var extendStatics = function (d, b) {
    extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b }) ||
            function (d, b) { for (const p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p] }
    return extendStatics(d, b)
  }

  function __extends (d, b) {
    if (typeof b !== 'function' && b !== null) { throw new TypeError('Class extends value ' + String(b) + ' is not a constructor or null') }
    extendStatics(d, b)
    function __ () { this.constructor = d }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __())
  }

  const Browser = (function () {
    function Browser () {
      this.firefox = false
      this.ie = false
      this.edge = false
      this.newEdge = false
      this.weChat = false
    }
    return Browser
  }())
  const Env = (function () {
    function Env () {
      this.browser = new Browser()
      this.node = false
      this.wxa = false
      this.worker = false
      this.svgSupported = false
      this.touchEventsSupported = false
      this.pointerEventsSupported = false
      this.domSupported = false
      this.transformSupported = false
      this.transform3dSupported = false
      this.hasGlobalWindow = typeof window !== 'undefined'
    }
    return Env
  }())
  const env = new Env()
  if (typeof wx === 'object' && typeof wx.getSystemInfoSync === 'function') {
    env.wxa = true
    env.touchEventsSupported = true
  } else if (typeof document === 'undefined' && typeof self !== 'undefined') {
    env.worker = true
  } else if (typeof navigator === 'undefined') {
    env.node = true
    env.svgSupported = true
  } else {
    detect(navigator.userAgent, env)
  }
  function detect (ua, env) {
    const browser = env.browser
    const firefox = ua.match(/Firefox\/([\d.]+)/)
    const ie = ua.match(/MSIE\s([\d.]+)/) ||
            ua.match(/Trident\/.+?rv:(([\d.]+))/)
    const edge = ua.match(/Edge?\/([\d.]+)/)
    const weChat = (/micromessenger/i).test(ua)
    if (firefox) {
      browser.firefox = true
      browser.version = firefox[1]
    }
    if (ie) {
      browser.ie = true
      browser.version = ie[1]
    }
    if (edge) {
      browser.edge = true
      browser.version = edge[1]
      browser.newEdge = +edge[1].split('.')[0] > 18
    }
    if (weChat) {
      browser.weChat = true
    }
    env.svgSupported = typeof SVGRect !== 'undefined'
    env.touchEventsSupported = 'ontouchstart' in window && !browser.ie && !browser.edge
    env.pointerEventsSupported = 'onpointerdown' in window &&
            (browser.edge || (browser.ie && +browser.version >= 11))
    env.domSupported = typeof document !== 'undefined'
    const style = document.documentElement.style
    env.transform3dSupported = ((browser.ie && 'transition' in style) ||
            browser.edge ||
            (('WebKitCSSMatrix' in window) && ('m11' in new WebKitCSSMatrix())) ||
            'MozPerspective' in style) &&
            !('OTransition' in style)
    env.transformSupported = env.transform3dSupported ||
            (browser.ie && +browser.version >= 9)
  }

  const DEFAULT_FONT_SIZE = 12
  const DEFAULT_FONT_FAMILY = 'sans-serif'
  const DEFAULT_FONT = DEFAULT_FONT_SIZE + 'px ' + DEFAULT_FONT_FAMILY
  const OFFSET = 20
  const SCALE = 100
  const defaultWidthMapStr = "007LLmW'55;N0500LLLLLLLLLL00NNNLzWW\\\\WQb\\0FWLg\\bWb\\WQ\\WrWWQ000CL5LLFLL0LL**F*gLLLL5F0LF\\FFF5.5N"
  function getTextWidthMap (mapStr) {
    const map = {}
    if (typeof JSON === 'undefined') {
      return map
    }
    for (let i = 0; i < mapStr.length; i++) {
      const char = String.fromCharCode(i + 32)
      const size = (mapStr.charCodeAt(i) - OFFSET) / SCALE
      map[char] = size
    }
    return map
  }
  const DEFAULT_TEXT_WIDTH_MAP = getTextWidthMap(defaultWidthMapStr)
  var platformApi = {
    createCanvas: function () {
      return typeof document !== 'undefined' &&
                document.createElement('canvas')
    },
    measureText: (function () {
      let _ctx
      let _cachedFont
      return function (text, font) {
        if (!_ctx) {
          const canvas = platformApi.createCanvas()
          _ctx = canvas && canvas.getContext('2d')
        }
        if (_ctx) {
          if (_cachedFont !== font) {
            _cachedFont = _ctx.font = font || DEFAULT_FONT
          }
          return _ctx.measureText(text)
        } else {
          text = text || ''
          font = font || DEFAULT_FONT
          const res = /^([0-9]*?)px$/.exec(font)
          const fontSize = +(res && res[1]) || DEFAULT_FONT_SIZE
          let width = 0
          if (font.indexOf('mono') >= 0) {
            width = fontSize * text.length
          } else {
            for (let i = 0; i < text.length; i++) {
              const preCalcWidth = DEFAULT_TEXT_WIDTH_MAP[text[i]]
              width += preCalcWidth == null ? fontSize : (preCalcWidth * fontSize)
            }
          }
          return { width: width }
        }
      }
    })(),
    loadImage: function (src, onload, onerror) {
      const image = new Image()
      image.onload = onload
      image.onerror = onerror
      image.src = src
      return image
    }
  }
  function setPlatformAPI (newPlatformApis) {
    for (const key in platformApi) {
      if (newPlatformApis[key]) {
        platformApi[key] = newPlatformApis[key]
      }
    }
  }

  const BUILTIN_OBJECT = reduce([
    'Function',
    'RegExp',
    'Date',
    'Error',
    'CanvasGradient',
    'CanvasPattern',
    'Image',
    'Canvas'
  ], function (obj, val) {
    obj['[object ' + val + ']'] = true
    return obj
  }, {})
  const TYPED_ARRAY = reduce([
    'Int8',
    'Uint8',
    'Uint8Clamped',
    'Int16',
    'Uint16',
    'Int32',
    'Uint32',
    'Float32',
    'Float64'
  ], function (obj, val) {
    obj['[object ' + val + 'Array]'] = true
    return obj
  }, {})
  const objToString = Object.prototype.toString
  const arrayProto = Array.prototype
  const nativeForEach = arrayProto.forEach
  const nativeFilter = arrayProto.filter
  const nativeSlice = arrayProto.slice
  const nativeMap = arrayProto.map
  const ctorFunction = function () { }.constructor
  const protoFunction = ctorFunction ? ctorFunction.prototype : null
  const protoKey = '__proto__'
  let idStart = 0x0907
  function guid () {
    return idStart++
  }
  function logError () {
    const args = []
    for (let _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i]
    }
    if (typeof console !== 'undefined') {
      console.error.apply(console, args)
    }
  }
  function clone (source) {
    if (source == null || typeof source !== 'object') {
      return source
    }
    let result = source
    const typeStr = objToString.call(source)
    if (typeStr === '[object Array]') {
      if (!isPrimitive(source)) {
        result = []
        for (var i = 0, len = source.length; i < len; i++) {
          result[i] = clone(source[i])
        }
      }
    } else if (TYPED_ARRAY[typeStr]) {
      if (!isPrimitive(source)) {
        const Ctor = source.constructor
        if (Ctor.from) {
          result = Ctor.from(source)
        } else {
          result = new Ctor(source.length)
          for (var i = 0, len = source.length; i < len; i++) {
            result[i] = source[i]
          }
        }
      }
    } else if (!BUILTIN_OBJECT[typeStr] && !isPrimitive(source) && !isDom(source)) {
      result = {}
      for (const key in source) {
        if (source.hasOwnProperty(key) && key !== protoKey) {
          result[key] = clone(source[key])
        }
      }
    }
    return result
  }
  function merge (target, source, overwrite) {
    if (!isObject(source) || !isObject(target)) {
      return overwrite ? clone(source) : target
    }
    for (const key in source) {
      if (source.hasOwnProperty(key) && key !== protoKey) {
        const targetProp = target[key]
        const sourceProp = source[key]
        if (isObject(sourceProp) &&
                    isObject(targetProp) &&
                    !isArray(sourceProp) &&
                    !isArray(targetProp) &&
                    !isDom(sourceProp) &&
                    !isDom(targetProp) &&
                    !isBuiltInObject(sourceProp) &&
                    !isBuiltInObject(targetProp) &&
                    !isPrimitive(sourceProp) &&
                    !isPrimitive(targetProp)) {
          merge(targetProp, sourceProp, overwrite)
        } else if (overwrite || !(key in target)) {
          target[key] = clone(source[key])
        }
      }
    }
    return target
  }
  function mergeAll (targetAndSources, overwrite) {
    let result = targetAndSources[0]
    for (let i = 1, len = targetAndSources.length; i < len; i++) {
      result = merge(result, targetAndSources[i], overwrite)
    }
    return result
  }
  function extend (target, source) {
    if (Object.assign) {
      Object.assign(target, source)
    } else {
      for (const key in source) {
        if (source.hasOwnProperty(key) && key !== protoKey) {
          target[key] = source[key]
        }
      }
    }
    return target
  }
  function defaults (target, source, overlay) {
    const keysArr = keys(source)
    for (let i = 0; i < keysArr.length; i++) {
      const key = keysArr[i]
      if ((overlay ? source[key] != null : target[key] == null)) {
        target[key] = source[key]
      }
    }
    return target
  }
  const createCanvas = platformApi.createCanvas
  function indexOf (array, value) {
    if (array) {
      if (array.indexOf) {
        return array.indexOf(value)
      }
      for (let i = 0, len = array.length; i < len; i++) {
        if (array[i] === value) {
          return i
        }
      }
    }
    return -1
  }
  function inherits (clazz, baseClazz) {
    const clazzPrototype = clazz.prototype
    function F () { }
    F.prototype = baseClazz.prototype
    clazz.prototype = new F()
    for (const prop in clazzPrototype) {
      if (clazzPrototype.hasOwnProperty(prop)) {
        clazz.prototype[prop] = clazzPrototype[prop]
      }
    }
    clazz.prototype.constructor = clazz
    clazz.superClass = baseClazz
  }
  function mixin (target, source, override) {
    target = 'prototype' in target ? target.prototype : target
    source = 'prototype' in source ? source.prototype : source
    if (Object.getOwnPropertyNames) {
      const keyList = Object.getOwnPropertyNames(source)
      for (let i = 0; i < keyList.length; i++) {
        const key = keyList[i]
        if (key !== 'constructor') {
          if ((override ? source[key] != null : target[key] == null)) {
            target[key] = source[key]
          }
        }
      }
    } else {
      defaults(target, source, override)
    }
  }
  function isArrayLike (data) {
    if (!data) {
      return false
    }
    if (typeof data === 'string') {
      return false
    }
    return typeof data.length === 'number'
  }
  function each (arr, cb, context) {
    if (!(arr && cb)) {
      return
    }
    if (arr.forEach && arr.forEach === nativeForEach) {
      arr.forEach(cb, context)
    } else if (arr.length === +arr.length) {
      for (let i = 0, len = arr.length; i < len; i++) {
        cb.call(context, arr[i], i, arr)
      }
    } else {
      for (const key in arr) {
        if (arr.hasOwnProperty(key)) {
          cb.call(context, arr[key], key, arr)
        }
      }
    }
  }
  function map (arr, cb, context) {
    if (!arr) {
      return []
    }
    if (!cb) {
      return slice(arr)
    }
    if (arr.map && arr.map === nativeMap) {
      return arr.map(cb, context)
    } else {
      const result = []
      for (let i = 0, len = arr.length; i < len; i++) {
        result.push(cb.call(context, arr[i], i, arr))
      }
      return result
    }
  }
  function reduce (arr, cb, memo, context) {
    if (!(arr && cb)) {
      return
    }
    for (let i = 0, len = arr.length; i < len; i++) {
      memo = cb.call(context, memo, arr[i], i, arr)
    }
    return memo
  }
  function filter (arr, cb, context) {
    if (!arr) {
      return []
    }
    if (!cb) {
      return slice(arr)
    }
    if (arr.filter && arr.filter === nativeFilter) {
      return arr.filter(cb, context)
    } else {
      const result = []
      for (let i = 0, len = arr.length; i < len; i++) {
        if (cb.call(context, arr[i], i, arr)) {
          result.push(arr[i])
        }
      }
      return result
    }
  }
  function find (arr, cb, context) {
    if (!(arr && cb)) {
      return
    }
    for (let i = 0, len = arr.length; i < len; i++) {
      if (cb.call(context, arr[i], i, arr)) {
        return arr[i]
      }
    }
  }
  function keys (obj) {
    if (!obj) {
      return []
    }
    if (Object.keys) {
      return Object.keys(obj)
    }
    const keyList = []
    for (const key in obj) {
      if (obj.hasOwnProperty(key)) {
        keyList.push(key)
      }
    }
    return keyList
  }
  function bindPolyfill (func, context) {
    const args = []
    for (let _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i]
    }
    return function () {
      return func.apply(context, args.concat(nativeSlice.call(arguments)))
    }
  }
  const bind = (protoFunction && isFunction(protoFunction.bind))
    ? protoFunction.call.bind(protoFunction.bind)
    : bindPolyfill
  function curry (func) {
    const args = []
    for (let _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i]
    }
    return function () {
      return func.apply(this, args.concat(nativeSlice.call(arguments)))
    }
  }
  function isArray (value) {
    if (Array.isArray) {
      return Array.isArray(value)
    }
    return objToString.call(value) === '[object Array]'
  }
  function isFunction (value) {
    return typeof value === 'function'
  }
  function isString (value) {
    return typeof value === 'string'
  }
  function isStringSafe (value) {
    return objToString.call(value) === '[object String]'
  }
  function isNumber (value) {
    return typeof value === 'number'
  }
  function isObject (value) {
    const type = typeof value
    return type === 'function' || (!!value && type === 'object')
  }
  function isBuiltInObject (value) {
    return !!BUILTIN_OBJECT[objToString.call(value)]
  }
  function isTypedArray (value) {
    return !!TYPED_ARRAY[objToString.call(value)]
  }
  function isDom (value) {
    return typeof value === 'object' &&
            typeof value.nodeType === 'number' &&
            typeof value.ownerDocument === 'object'
  }
  function isGradientObject (value) {
    return value.colorStops != null
  }
  function isImagePatternObject (value) {
    return value.image != null
  }
  function isRegExp (value) {
    return objToString.call(value) === '[object RegExp]'
  }
  function eqNaN (value) {
    return value !== value
  }
  function retrieve () {
    const args = []
    for (let _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i]
    }
    for (let i = 0, len = args.length; i < len; i++) {
      if (args[i] != null) {
        return args[i]
      }
    }
  }
  function retrieve2 (value0, value1) {
    return value0 != null
      ? value0
      : value1
  }
  function retrieve3 (value0, value1, value2) {
    return value0 != null
      ? value0
      : value1 != null
        ? value1
        : value2
  }
  function slice (arr) {
    const args = []
    for (let _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i]
    }
    return nativeSlice.apply(arr, args)
  }
  function normalizeCssArray (val) {
    if (typeof (val) === 'number') {
      return [val, val, val, val]
    }
    const len = val.length
    if (len === 2) {
      return [val[0], val[1], val[0], val[1]]
    } else if (len === 3) {
      return [val[0], val[1], val[2], val[1]]
    }
    return val
  }
  function assert (condition, message) {
    if (!condition) {
      throw new Error(message)
    }
  }
  function trim (str) {
    if (str == null) {
      return null
    } else if (typeof str.trim === 'function') {
      return str.trim()
    } else {
      return str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, '')
    }
  }
  const primitiveKey = '__ec_primitive__'
  function setAsPrimitive (obj) {
    obj[primitiveKey] = true
  }
  function isPrimitive (obj) {
    return obj[primitiveKey]
  }
  const HashMap = (function () {
    function HashMap (obj) {
      this.data = {}
      const isArr = isArray(obj)
      this.data = {}
      const thisMap = this;
      (obj instanceof HashMap)
        ? obj.each(visit)
        : (obj && each(obj, visit))
      function visit (value, key) {
        isArr ? thisMap.set(value, key) : thisMap.set(key, value)
      }
    }
    HashMap.prototype.get = function (key) {
      return this.data.hasOwnProperty(key) ? this.data[key] : null
    }
    HashMap.prototype.set = function (key, value) {
      return (this.data[key] = value)
    }
    HashMap.prototype.each = function (cb, context) {
      for (const key in this.data) {
        if (this.data.hasOwnProperty(key)) {
          cb.call(context, this.data[key], key)
        }
      }
    }
    HashMap.prototype.keys = function () {
      return keys(this.data)
    }
    HashMap.prototype.removeKey = function (key) {
      delete this.data[key]
    }
    return HashMap
  }())
  function createHashMap (obj) {
    return new HashMap(obj)
  }
  function concatArray (a, b) {
    const newArray = new a.constructor(a.length + b.length)
    for (var i = 0; i < a.length; i++) {
      newArray[i] = a[i]
    }
    const offset = a.length
    for (var i = 0; i < b.length; i++) {
      newArray[i + offset] = b[i]
    }
    return newArray
  }
  function createObject (proto, properties) {
    let obj
    if (Object.create) {
      obj = Object.create(proto)
    } else {
      const StyleCtor = function () { }
      StyleCtor.prototype = proto
      obj = new StyleCtor()
    }
    if (properties) {
      extend(obj, properties)
    }
    return obj
  }
  function disableUserSelect (dom) {
    const domStyle = dom.style
    domStyle.webkitUserSelect = 'none'
    domStyle.userSelect = 'none'
    domStyle.webkitTapHighlightColor = 'rgba(0,0,0,0)'
    domStyle['-webkit-touch-callout'] = 'none'
  }
  function hasOwn (own, prop) {
    return own.hasOwnProperty(prop)
  }
  function noop () { }
  const RADIAN_TO_DEGREE = 180 / Math.PI

  const util = /* #__PURE__ */Object.freeze({
    __proto__: null,
    guid: guid,
    logError: logError,
    clone: clone,
    merge: merge,
    mergeAll: mergeAll,
    extend: extend,
    defaults: defaults,
    createCanvas: createCanvas,
    indexOf: indexOf,
    inherits: inherits,
    mixin: mixin,
    isArrayLike: isArrayLike,
    each: each,
    map: map,
    reduce: reduce,
    filter: filter,
    find: find,
    keys: keys,
    bind: bind,
    curry: curry,
    isArray: isArray,
    isFunction: isFunction,
    isString: isString,
    isStringSafe: isStringSafe,
    isNumber: isNumber,
    isObject: isObject,
    isBuiltInObject: isBuiltInObject,
    isTypedArray: isTypedArray,
    isDom: isDom,
    isGradientObject: isGradientObject,
    isImagePatternObject: isImagePatternObject,
    isRegExp: isRegExp,
    eqNaN: eqNaN,
    retrieve: retrieve,
    retrieve2: retrieve2,
    retrieve3: retrieve3,
    slice: slice,
    normalizeCssArray: normalizeCssArray,
    assert: assert,
    trim: trim,
    setAsPrimitive: setAsPrimitive,
    isPrimitive: isPrimitive,
    HashMap: HashMap,
    createHashMap: createHashMap,
    concatArray: concatArray,
    createObject: createObject,
    disableUserSelect: disableUserSelect,
    hasOwn: hasOwn,
    noop: noop,
    RADIAN_TO_DEGREE: RADIAN_TO_DEGREE
  })

  function create (x, y) {
    if (x == null) {
      x = 0
    }
    if (y == null) {
      y = 0
    }
    return [x, y]
  }
  function copy (out, v) {
    out[0] = v[0]
    out[1] = v[1]
    return out
  }
  function clone$1 (v) {
    return [v[0], v[1]]
  }
  function set (out, a, b) {
    out[0] = a
    out[1] = b
    return out
  }
  function add (out, v1, v2) {
    out[0] = v1[0] + v2[0]
    out[1] = v1[1] + v2[1]
    return out
  }
  function scaleAndAdd (out, v1, v2, a) {
    out[0] = v1[0] + v2[0] * a
    out[1] = v1[1] + v2[1] * a
    return out
  }
  function sub (out, v1, v2) {
    out[0] = v1[0] - v2[0]
    out[1] = v1[1] - v2[1]
    return out
  }
  function len (v) {
    return Math.sqrt(lenSquare(v))
  }
  const length = len
  function lenSquare (v) {
    return v[0] * v[0] + v[1] * v[1]
  }
  const lengthSquare = lenSquare
  function mul (out, v1, v2) {
    out[0] = v1[0] * v2[0]
    out[1] = v1[1] * v2[1]
    return out
  }
  function div (out, v1, v2) {
    out[0] = v1[0] / v2[0]
    out[1] = v1[1] / v2[1]
    return out
  }
  function dot (v1, v2) {
    return v1[0] * v2[0] + v1[1] * v2[1]
  }
  function scale (out, v, s) {
    out[0] = v[0] * s
    out[1] = v[1] * s
    return out
  }
  function normalize (out, v) {
    const d = len(v)
    if (d === 0) {
      out[0] = 0
      out[1] = 0
    } else {
      out[0] = v[0] / d
      out[1] = v[1] / d
    }
    return out
  }
  function distance (v1, v2) {
    return Math.sqrt((v1[0] - v2[0]) * (v1[0] - v2[0]) +
            (v1[1] - v2[1]) * (v1[1] - v2[1]))
  }
  const dist = distance
  function distanceSquare (v1, v2) {
    return (v1[0] - v2[0]) * (v1[0] - v2[0]) +
            (v1[1] - v2[1]) * (v1[1] - v2[1])
  }
  const distSquare = distanceSquare
  function negate (out, v) {
    out[0] = -v[0]
    out[1] = -v[1]
    return out
  }
  function lerp (out, v1, v2, t) {
    out[0] = v1[0] + t * (v2[0] - v1[0])
    out[1] = v1[1] + t * (v2[1] - v1[1])
    return out
  }
  function applyTransform (out, v, m) {
    const x = v[0]
    const y = v[1]
    out[0] = m[0] * x + m[2] * y + m[4]
    out[1] = m[1] * x + m[3] * y + m[5]
    return out
  }
  function min (out, v1, v2) {
    out[0] = Math.min(v1[0], v2[0])
    out[1] = Math.min(v1[1], v2[1])
    return out
  }
  function max (out, v1, v2) {
    out[0] = Math.max(v1[0], v2[0])
    out[1] = Math.max(v1[1], v2[1])
    return out
  }

  const vector = /* #__PURE__ */Object.freeze({
    __proto__: null,
    create: create,
    copy: copy,
    clone: clone$1,
    set: set,
    add: add,
    scaleAndAdd: scaleAndAdd,
    sub: sub,
    len: len,
    length: length,
    lenSquare: lenSquare,
    lengthSquare: lengthSquare,
    mul: mul,
    div: div,
    dot: dot,
    scale: scale,
    normalize: normalize,
    distance: distance,
    dist: dist,
    distanceSquare: distanceSquare,
    distSquare: distSquare,
    negate: negate,
    lerp: lerp,
    applyTransform: applyTransform,
    min: min,
    max: max
  })

  const Param = (function () {
    function Param (target, e) {
      this.target = target
      this.topTarget = e && e.topTarget
    }
    return Param
  }())
  const Draggable = (function () {
    function Draggable (handler) {
      this.handler = handler
      handler.on('mousedown', this._dragStart, this)
      handler.on('mousemove', this._drag, this)
      handler.on('mouseup', this._dragEnd, this)
    }
    Draggable.prototype._dragStart = function (e) {
      let draggingTarget = e.target
      while (draggingTarget && !draggingTarget.draggable) {
        draggingTarget = draggingTarget.parent || draggingTarget.__hostTarget
      }
      if (draggingTarget) {
        this._draggingTarget = draggingTarget
        draggingTarget.dragging = true
        this._x = e.offsetX
        this._y = e.offsetY
        this.handler.dispatchToElement(new Param(draggingTarget, e), 'dragstart', e.event)
      }
    }
    Draggable.prototype._drag = function (e) {
      const draggingTarget = this._draggingTarget
      if (draggingTarget) {
        const x = e.offsetX
        const y = e.offsetY
        const dx = x - this._x
        const dy = y - this._y
        this._x = x
        this._y = y
        draggingTarget.drift(dx, dy, e)
        this.handler.dispatchToElement(new Param(draggingTarget, e), 'drag', e.event)
        const dropTarget = this.handler.findHover(x, y, draggingTarget).target
        const lastDropTarget = this._dropTarget
        this._dropTarget = dropTarget
        if (draggingTarget !== dropTarget) {
          if (lastDropTarget && dropTarget !== lastDropTarget) {
            this.handler.dispatchToElement(new Param(lastDropTarget, e), 'dragleave', e.event)
          }
          if (dropTarget && dropTarget !== lastDropTarget) {
            this.handler.dispatchToElement(new Param(dropTarget, e), 'dragenter', e.event)
          }
        }
      }
    }
    Draggable.prototype._dragEnd = function (e) {
      const draggingTarget = this._draggingTarget
      if (draggingTarget) {
        draggingTarget.dragging = false
      }
      this.handler.dispatchToElement(new Param(draggingTarget, e), 'dragend', e.event)
      if (this._dropTarget) {
        this.handler.dispatchToElement(new Param(this._dropTarget, e), 'drop', e.event)
      }
      this._draggingTarget = null
      this._dropTarget = null
    }
    return Draggable
  }())

  const Eventful = (function () {
    function Eventful (eventProcessors) {
      if (eventProcessors) {
        this._$eventProcessor = eventProcessors
      }
    }
    Eventful.prototype.on = function (event, query, handler, context) {
      if (!this._$handlers) {
        this._$handlers = {}
      }
      const _h = this._$handlers
      if (typeof query === 'function') {
        context = handler
        handler = query
        query = null
      }
      if (!handler || !event) {
        return this
      }
      const eventProcessor = this._$eventProcessor
      if (query != null && eventProcessor && eventProcessor.normalizeQuery) {
        query = eventProcessor.normalizeQuery(query)
      }
      if (!_h[event]) {
        _h[event] = []
      }
      for (let i = 0; i < _h[event].length; i++) {
        if (_h[event][i].h === handler) {
          return this
        }
      }
      const wrap = {
        h: handler,
        query: query,
        ctx: (context || this),
        callAtLast: handler.zrEventfulCallAtLast
      }
      const lastIndex = _h[event].length - 1
      const lastWrap = _h[event][lastIndex];
      (lastWrap && lastWrap.callAtLast)
        ? _h[event].splice(lastIndex, 0, wrap)
        : _h[event].push(wrap)
      return this
    }
    Eventful.prototype.isSilent = function (eventName) {
      const _h = this._$handlers
      return !_h || !_h[eventName] || !_h[eventName].length
    }
    Eventful.prototype.off = function (eventType, handler) {
      const _h = this._$handlers
      if (!_h) {
        return this
      }
      if (!eventType) {
        this._$handlers = {}
        return this
      }
      if (handler) {
        if (_h[eventType]) {
          const newList = []
          for (let i = 0, l = _h[eventType].length; i < l; i++) {
            if (_h[eventType][i].h !== handler) {
              newList.push(_h[eventType][i])
            }
          }
          _h[eventType] = newList
        }
        if (_h[eventType] && _h[eventType].length === 0) {
          delete _h[eventType]
        }
      } else {
        delete _h[eventType]
      }
      return this
    }
    Eventful.prototype.trigger = function (eventType) {
      const args = []
      for (let _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i]
      }
      if (!this._$handlers) {
        return this
      }
      const _h = this._$handlers[eventType]
      const eventProcessor = this._$eventProcessor
      if (_h) {
        const argLen = args.length
        const len = _h.length
        for (let i = 0; i < len; i++) {
          const hItem = _h[i]
          if (eventProcessor &&
                        eventProcessor.filter &&
                        hItem.query != null &&
                        !eventProcessor.filter(eventType, hItem.query)) {
            continue
          }
          switch (argLen) {
            case 0:
              hItem.h.call(hItem.ctx)
              break
            case 1:
              hItem.h.call(hItem.ctx, args[0])
              break
            case 2:
              hItem.h.call(hItem.ctx, args[0], args[1])
              break
            default:
              hItem.h.apply(hItem.ctx, args)
              break
          }
        }
      }
      eventProcessor && eventProcessor.afterTrigger &&
                eventProcessor.afterTrigger(eventType)
      return this
    }
    Eventful.prototype.triggerWithContext = function (type) {
      const args = []
      for (let _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i]
      }
      if (!this._$handlers) {
        return this
      }
      const _h = this._$handlers[type]
      const eventProcessor = this._$eventProcessor
      if (_h) {
        const argLen = args.length
        const ctx = args[argLen - 1]
        const len = _h.length
        for (let i = 0; i < len; i++) {
          const hItem = _h[i]
          if (eventProcessor &&
                        eventProcessor.filter &&
                        hItem.query != null &&
                        !eventProcessor.filter(type, hItem.query)) {
            continue
          }
          switch (argLen) {
            case 0:
              hItem.h.call(ctx)
              break
            case 1:
              hItem.h.call(ctx, args[0])
              break
            case 2:
              hItem.h.call(ctx, args[0], args[1])
              break
            default:
              hItem.h.apply(ctx, args.slice(1, argLen - 1))
              break
          }
        }
      }
      eventProcessor && eventProcessor.afterTrigger &&
                eventProcessor.afterTrigger(type)
      return this
    }
    return Eventful
  }())

  const LN2 = Math.log(2)
  function determinant (rows, rank, rowStart, rowMask, colMask, detCache) {
    const cacheKey = rowMask + '-' + colMask
    const fullRank = rows.length
    if (detCache.hasOwnProperty(cacheKey)) {
      return detCache[cacheKey]
    }
    if (rank === 1) {
      const colStart = Math.round(Math.log(((1 << fullRank) - 1) & ~colMask) / LN2)
      return rows[rowStart][colStart]
    }
    const subRowMask = rowMask | (1 << rowStart)
    let subRowStart = rowStart + 1
    while (rowMask & (1 << subRowStart)) {
      subRowStart++
    }
    let sum = 0
    for (let j = 0, colLocalIdx = 0; j < fullRank; j++) {
      const colTag = 1 << j
      if (!(colTag & colMask)) {
        sum += (colLocalIdx % 2 ? -1 : 1) * rows[rowStart][j] *
                    determinant(rows, rank - 1, subRowStart, subRowMask, colMask | colTag, detCache)
        colLocalIdx++
      }
    }
    detCache[cacheKey] = sum
    return sum
  }
  function buildTransformer (src, dest) {
    const mA = [
      [src[0], src[1], 1, 0, 0, 0, -dest[0] * src[0], -dest[0] * src[1]],
      [0, 0, 0, src[0], src[1], 1, -dest[1] * src[0], -dest[1] * src[1]],
      [src[2], src[3], 1, 0, 0, 0, -dest[2] * src[2], -dest[2] * src[3]],
      [0, 0, 0, src[2], src[3], 1, -dest[3] * src[2], -dest[3] * src[3]],
      [src[4], src[5], 1, 0, 0, 0, -dest[4] * src[4], -dest[4] * src[5]],
      [0, 0, 0, src[4], src[5], 1, -dest[5] * src[4], -dest[5] * src[5]],
      [src[6], src[7], 1, 0, 0, 0, -dest[6] * src[6], -dest[6] * src[7]],
      [0, 0, 0, src[6], src[7], 1, -dest[7] * src[6], -dest[7] * src[7]]
    ]
    const detCache = {}
    const det = determinant(mA, 8, 0, 0, 0, detCache)
    if (det === 0) {
      return
    }
    const vh = []
    for (let i = 0; i < 8; i++) {
      for (let j = 0; j < 8; j++) {
        vh[j] == null && (vh[j] = 0)
        vh[j] += ((i + j) % 2 ? -1 : 1) *
                    determinant(mA, 7, i === 0 ? 1 : 0, 1 << i, 1 << j, detCache) /
                    det * dest[i]
      }
    }
    return function (out, srcPointX, srcPointY) {
      const pk = srcPointX * vh[6] + srcPointY * vh[7] + 1
      out[0] = (srcPointX * vh[0] + srcPointY * vh[1] + vh[2]) / pk
      out[1] = (srcPointX * vh[3] + srcPointY * vh[4] + vh[5]) / pk
    }
  }

  const EVENT_SAVED_PROP = '___zrEVENTSAVED'
  const _calcOut = []
  function transformLocalCoord (out, elFrom, elTarget, inX, inY) {
    return transformCoordWithViewport(_calcOut, elFrom, inX, inY, true) &&
            transformCoordWithViewport(out, elTarget, _calcOut[0], _calcOut[1])
  }
  function transformCoordWithViewport (out, el, inX, inY, inverse) {
    if (el.getBoundingClientRect && env.domSupported && !isCanvasEl(el)) {
      const saved = el[EVENT_SAVED_PROP] || (el[EVENT_SAVED_PROP] = {})
      const markers = prepareCoordMarkers(el, saved)
      const transformer = preparePointerTransformer(markers, saved, inverse)
      if (transformer) {
        transformer(out, inX, inY)
        return true
      }
    }
    return false
  }
  function prepareCoordMarkers (el, saved) {
    let markers = saved.markers
    if (markers) {
      return markers
    }
    markers = saved.markers = []
    const propLR = ['left', 'right']
    const propTB = ['top', 'bottom']
    for (let i = 0; i < 4; i++) {
      const marker = document.createElement('div')
      const stl = marker.style
      const idxLR = i % 2
      const idxTB = (i >> 1) % 2
      stl.cssText = [
        'position: absolute',
        'visibility: hidden',
        'padding: 0',
        'margin: 0',
        'border-width: 0',
        'user-select: none',
        'width:0',
        'height:0',
        propLR[idxLR] + ':0',
        propTB[idxTB] + ':0',
        propLR[1 - idxLR] + ':auto',
        propTB[1 - idxTB] + ':auto',
        ''
      ].join('!important;')
      el.appendChild(marker)
      markers.push(marker)
    }
    return markers
  }
  function preparePointerTransformer (markers, saved, inverse) {
    const transformerName = inverse ? 'invTrans' : 'trans'
    const transformer = saved[transformerName]
    const oldSrcCoords = saved.srcCoords
    const srcCoords = []
    const destCoords = []
    let oldCoordTheSame = true
    for (let i = 0; i < 4; i++) {
      const rect = markers[i].getBoundingClientRect()
      const ii = 2 * i
      const x = rect.left
      const y = rect.top
      srcCoords.push(x, y)
      oldCoordTheSame = oldCoordTheSame && oldSrcCoords && x === oldSrcCoords[ii] && y === oldSrcCoords[ii + 1]
      destCoords.push(markers[i].offsetLeft, markers[i].offsetTop)
    }
    return (oldCoordTheSame && transformer)
      ? transformer
      : (saved.srcCoords = srcCoords,
        saved[transformerName] = inverse
          ? buildTransformer(destCoords, srcCoords)
          : buildTransformer(srcCoords, destCoords))
  }
  function isCanvasEl (el) {
    return el.nodeName.toUpperCase() === 'CANVAS'
  }

  const MOUSE_EVENT_REG = /^(?:mouse|pointer|contextmenu|drag|drop)|click/
  const _calcOut$1 = []
  const firefoxNotSupportOffsetXY = env.browser.firefox &&
        +env.browser.version.split('.')[0] < 39
  function clientToLocal (el, e, out, calculate) {
    out = out || {}
    if (calculate) {
      calculateZrXY(el, e, out)
    } else if (firefoxNotSupportOffsetXY &&
            e.layerX != null &&
            e.layerX !== e.offsetX) {
      out.zrX = e.layerX
      out.zrY = e.layerY
    } else if (e.offsetX != null) {
      out.zrX = e.offsetX
      out.zrY = e.offsetY
    } else {
      calculateZrXY(el, e, out)
    }
    return out
  }
  function calculateZrXY (el, e, out) {
    if (env.domSupported && el.getBoundingClientRect) {
      const ex = e.clientX
      const ey = e.clientY
      if (isCanvasEl(el)) {
        const box = el.getBoundingClientRect()
        out.zrX = ex - box.left
        out.zrY = ey - box.top
        return
      } else {
        if (transformCoordWithViewport(_calcOut$1, el, ex, ey)) {
          out.zrX = _calcOut$1[0]
          out.zrY = _calcOut$1[1]
          return
        }
      }
    }
    out.zrX = out.zrY = 0
  }
  function getNativeEvent (e) {
    return e ||
            window.event
  }
  function normalizeEvent (el, e, calculate) {
    e = getNativeEvent(e)
    if (e.zrX != null) {
      return e
    }
    const eventType = e.type
    const isTouch = eventType && eventType.indexOf('touch') >= 0
    if (!isTouch) {
      clientToLocal(el, e, e, calculate)
      const wheelDelta = getWheelDeltaMayPolyfill(e)
      e.zrDelta = wheelDelta ? wheelDelta / 120 : -(e.detail || 0) / 3
    } else {
      const touch = eventType !== 'touchend'
        ? e.targetTouches[0]
        : e.changedTouches[0]
      touch && clientToLocal(el, touch, e, calculate)
    }
    const button = e.button
    if (e.which == null && button !== undefined && MOUSE_EVENT_REG.test(e.type)) {
      e.which = (button & 1 ? 1 : (button & 2 ? 3 : (button & 4 ? 2 : 0)))
    }
    return e
  }
  function getWheelDeltaMayPolyfill (e) {
    const rawWheelDelta = e.wheelDelta
    if (rawWheelDelta) {
      return rawWheelDelta
    }
    const deltaX = e.deltaX
    const deltaY = e.deltaY
    if (deltaX == null || deltaY == null) {
      return rawWheelDelta
    }
    const delta = deltaY !== 0 ? Math.abs(deltaY) : Math.abs(deltaX)
    const sign = deltaY > 0
      ? -1
      : deltaY < 0
        ? 1
        : deltaX > 0
          ? -1
          : 1
    return 3 * delta * sign
  }
  function addEventListener (el, name, handler, opt) {
    el.addEventListener(name, handler, opt)
  }
  function removeEventListener (el, name, handler, opt) {
    el.removeEventListener(name, handler, opt)
  }
  const stop = function (e) {
    e.preventDefault()
    e.stopPropagation()
    e.cancelBubble = true
  }
  function isMiddleOrRightButtonOnMouseUpDown (e) {
    return e.which === 2 || e.which === 3
  }

  const GestureMgr = (function () {
    function GestureMgr () {
      this._track = []
    }
    GestureMgr.prototype.recognize = function (event, target, root) {
      this._doTrack(event, target, root)
      return this._recognize(event)
    }
    GestureMgr.prototype.clear = function () {
      this._track.length = 0
      return this
    }
    GestureMgr.prototype._doTrack = function (event, target, root) {
      const touches = event.touches
      if (!touches) {
        return
      }
      const trackItem = {
        points: [],
        touches: [],
        target: target,
        event: event
      }
      for (let i = 0, len = touches.length; i < len; i++) {
        const touch = touches[i]
        const pos = clientToLocal(root, touch, {})
        trackItem.points.push([pos.zrX, pos.zrY])
        trackItem.touches.push(touch)
      }
      this._track.push(trackItem)
    }
    GestureMgr.prototype._recognize = function (event) {
      for (const eventName in recognizers) {
        if (recognizers.hasOwnProperty(eventName)) {
          const gestureInfo = recognizers[eventName](this._track, event)
          if (gestureInfo) {
            return gestureInfo
          }
        }
      }
    }
    return GestureMgr
  }())
  function dist$1 (pointPair) {
    const dx = pointPair[1][0] - pointPair[0][0]
    const dy = pointPair[1][1] - pointPair[0][1]
    return Math.sqrt(dx * dx + dy * dy)
  }
  function center (pointPair) {
    return [
      (pointPair[0][0] + pointPair[1][0]) / 2,
      (pointPair[0][1] + pointPair[1][1]) / 2
    ]
  }
  var recognizers = {
    pinch: function (tracks, event) {
      const trackLen = tracks.length
      if (!trackLen) {
        return
      }
      const pinchEnd = (tracks[trackLen - 1] || {}).points
      const pinchPre = (tracks[trackLen - 2] || {}).points || pinchEnd
      if (pinchPre &&
                pinchPre.length > 1 &&
                pinchEnd &&
                pinchEnd.length > 1) {
        let pinchScale = dist$1(pinchEnd) / dist$1(pinchPre)
        !isFinite(pinchScale) && (pinchScale = 1)
        event.pinchScale = pinchScale
        const pinchCenter = center(pinchEnd)
        event.pinchX = pinchCenter[0]
        event.pinchY = pinchCenter[1]
        return {
          type: 'pinch',
          target: tracks[0].target,
          event: event
        }
      }
    }
  }

  const SILENT = 'silent'
  function makeEventPacket (eveType, targetInfo, event) {
    return {
      type: eveType,
      event: event,
      target: targetInfo.target,
      topTarget: targetInfo.topTarget,
      cancelBubble: false,
      offsetX: event.zrX,
      offsetY: event.zrY,
      gestureEvent: event.gestureEvent,
      pinchX: event.pinchX,
      pinchY: event.pinchY,
      pinchScale: event.pinchScale,
      wheelDelta: event.zrDelta,
      zrByTouch: event.zrByTouch,
      which: event.which,
      stop: stopEvent
    }
  }
  function stopEvent () {
    stop(this.event)
  }
  const EmptyProxy = (function (_super) {
    __extends(EmptyProxy, _super)
    function EmptyProxy () {
      const _this = _super !== null && _super.apply(this, arguments) || this
      _this.handler = null
      return _this
    }
    EmptyProxy.prototype.dispose = function () { }
    EmptyProxy.prototype.setCursor = function () { }
    return EmptyProxy
  }(Eventful))
  const HoveredResult = (function () {
    function HoveredResult (x, y) {
      this.x = x
      this.y = y
    }
    return HoveredResult
  }())
  const handlerNames = [
    'click', 'dblclick', 'mousewheel', 'mouseout',
    'mouseup', 'mousedown', 'mousemove', 'contextmenu'
  ]
  const Handler = (function (_super) {
    __extends(Handler, _super)
    function Handler (storage, painter, proxy, painterRoot) {
      const _this = _super.call(this) || this
      _this._hovered = new HoveredResult(0, 0)
      _this.storage = storage
      _this.painter = painter
      _this.painterRoot = painterRoot
      proxy = proxy || new EmptyProxy()
      _this.proxy = null
      _this.setHandlerProxy(proxy)
      _this._draggingMgr = new Draggable(_this)
      return _this
    }
    Handler.prototype.setHandlerProxy = function (proxy) {
      if (this.proxy) {
        this.proxy.dispose()
      }
      if (proxy) {
        each(handlerNames, function (name) {
          proxy.on && proxy.on(name, this[name], this)
        }, this)
        proxy.handler = this
      }
      this.proxy = proxy
    }
    Handler.prototype.mousemove = function (event) {
      const x = event.zrX
      const y = event.zrY
      const isOutside = isOutsideBoundary(this, x, y)
      let lastHovered = this._hovered
      let lastHoveredTarget = lastHovered.target
      if (lastHoveredTarget && !lastHoveredTarget.__zr) {
        lastHovered = this.findHover(lastHovered.x, lastHovered.y)
        lastHoveredTarget = lastHovered.target
      }
      const hovered = this._hovered = isOutside ? new HoveredResult(x, y) : this.findHover(x, y)
      const hoveredTarget = hovered.target
      const proxy = this.proxy
      proxy.setCursor && proxy.setCursor(hoveredTarget ? hoveredTarget.cursor : 'default')
      if (lastHoveredTarget && hoveredTarget !== lastHoveredTarget) {
        this.dispatchToElement(lastHovered, 'mouseout', event)
      }
      this.dispatchToElement(hovered, 'mousemove', event)
      if (hoveredTarget && hoveredTarget !== lastHoveredTarget) {
        this.dispatchToElement(hovered, 'mouseover', event)
      }
    }
    Handler.prototype.mouseout = function (event) {
      const eventControl = event.zrEventControl
      if (eventControl !== 'only_globalout') {
        this.dispatchToElement(this._hovered, 'mouseout', event)
      }
      if (eventControl !== 'no_globalout') {
        this.trigger('globalout', { type: 'globalout', event: event })
      }
    }
    Handler.prototype.resize = function () {
      this._hovered = new HoveredResult(0, 0)
    }
    Handler.prototype.dispatch = function (eventName, eventArgs) {
      const handler = this[eventName]
      handler && handler.call(this, eventArgs)
    }
    Handler.prototype.dispose = function () {
      this.proxy.dispose()
      this.storage = null
      this.proxy = null
      this.painter = null
    }
    Handler.prototype.setCursorStyle = function (cursorStyle) {
      const proxy = this.proxy
      proxy.setCursor && proxy.setCursor(cursorStyle)
    }
    Handler.prototype.dispatchToElement = function (targetInfo, eventName, event) {
      targetInfo = targetInfo || {}
      let el = targetInfo.target
      if (el && el.silent) {
        return
      }
      const eventKey = ('on' + eventName)
      const eventPacket = makeEventPacket(eventName, targetInfo, event)
      while (el) {
        el[eventKey] &&
                    (eventPacket.cancelBubble = !!el[eventKey].call(el, eventPacket))
        el.trigger(eventName, eventPacket)
        el = el.__hostTarget ? el.__hostTarget : el.parent
        if (eventPacket.cancelBubble) {
          break
        }
      }
      if (!eventPacket.cancelBubble) {
        this.trigger(eventName, eventPacket)
        if (this.painter && this.painter.eachOtherLayer) {
          this.painter.eachOtherLayer(function (layer) {
            if (typeof (layer[eventKey]) === 'function') {
              layer[eventKey].call(layer, eventPacket)
            }
            if (layer.trigger) {
              layer.trigger(eventName, eventPacket)
            }
          })
        }
      }
    }
    Handler.prototype.findHover = function (x, y, exclude) {
      const list = this.storage.getDisplayList()
      const out = new HoveredResult(x, y)
      for (let i = list.length - 1; i >= 0; i--) {
        let hoverCheckResult = void 0
        if (list[i] !== exclude &&
                    !list[i].ignore &&
                    (hoverCheckResult = isHover(list[i], x, y))) {
          !out.topTarget && (out.topTarget = list[i])
          if (hoverCheckResult !== SILENT) {
            out.target = list[i]
            break
          }
        }
      }
      return out
    }
    Handler.prototype.processGesture = function (event, stage) {
      if (!this._gestureMgr) {
        this._gestureMgr = new GestureMgr()
      }
      const gestureMgr = this._gestureMgr
      stage === 'start' && gestureMgr.clear()
      const gestureInfo = gestureMgr.recognize(event, this.findHover(event.zrX, event.zrY, null).target, this.proxy.dom)
      stage === 'end' && gestureMgr.clear()
      if (gestureInfo) {
        const type = gestureInfo.type
        event.gestureEvent = type
        const res = new HoveredResult()
        res.target = gestureInfo.target
        this.dispatchToElement(res, type, gestureInfo.event)
      }
    }
    return Handler
  }(Eventful))
  each(['click', 'mousedown', 'mouseup', 'mousewheel', 'dblclick', 'contextmenu'], function (name) {
    Handler.prototype[name] = function (event) {
      const x = event.zrX
      const y = event.zrY
      const isOutside = isOutsideBoundary(this, x, y)
      let hovered
      let hoveredTarget
      if (name !== 'mouseup' || !isOutside) {
        hovered = this.findHover(x, y)
        hoveredTarget = hovered.target
      }
      if (name === 'mousedown') {
        this._downEl = hoveredTarget
        this._downPoint = [event.zrX, event.zrY]
        this._upEl = hoveredTarget
      } else if (name === 'mouseup') {
        this._upEl = hoveredTarget
      } else if (name === 'click') {
        if (this._downEl !== this._upEl ||
                    !this._downPoint ||
                    dist(this._downPoint, [event.zrX, event.zrY]) > 4) {
          return
        }
        this._downPoint = null
      }
      this.dispatchToElement(hovered, name, event)
    }
  })
  function isHover (displayable, x, y) {
    if (displayable[displayable.rectHover ? 'rectContain' : 'contain'](x, y)) {
      let el = displayable
      let isSilent = void 0
      let ignoreClip = false
      while (el) {
        if (el.ignoreClip) {
          ignoreClip = true
        }
        if (!ignoreClip) {
          const clipPath = el.getClipPath()
          if (clipPath && !clipPath.contain(x, y)) {
            return false
          }
          if (el.silent) {
            isSilent = true
          }
        }
        const hostEl = el.__hostTarget
        el = hostEl || el.parent
      }
      return isSilent ? SILENT : true
    }
    return false
  }
  function isOutsideBoundary (handlerInstance, x, y) {
    const painter = handlerInstance.painter
    return x < 0 || x > painter.getWidth() || y < 0 || y > painter.getHeight()
  }

  const DEFAULT_MIN_MERGE = 32
  const DEFAULT_MIN_GALLOPING = 7
  function minRunLength (n) {
    let r = 0
    while (n >= DEFAULT_MIN_MERGE) {
      r |= n & 1
      n >>= 1
    }
    return n + r
  }
  function makeAscendingRun (array, lo, hi, compare) {
    let runHi = lo + 1
    if (runHi === hi) {
      return 1
    }
    if (compare(array[runHi++], array[lo]) < 0) {
      while (runHi < hi && compare(array[runHi], array[runHi - 1]) < 0) {
        runHi++
      }
      reverseRun(array, lo, runHi)
    } else {
      while (runHi < hi && compare(array[runHi], array[runHi - 1]) >= 0) {
        runHi++
      }
    }
    return runHi - lo
  }
  function reverseRun (array, lo, hi) {
    hi--
    while (lo < hi) {
      const t = array[lo]
      array[lo++] = array[hi]
      array[hi--] = t
    }
  }
  function binaryInsertionSort (array, lo, hi, start, compare) {
    if (start === lo) {
      start++
    }
    for (; start < hi; start++) {
      const pivot = array[start]
      let left = lo
      let right = start
      var mid
      while (left < right) {
        mid = left + right >>> 1
        if (compare(pivot, array[mid]) < 0) {
          right = mid
        } else {
          left = mid + 1
        }
      }
      let n = start - left
      switch (n) {
        case 3:
          array[left + 3] = array[left + 2]
        case 2:
          array[left + 2] = array[left + 1]
        case 1:
          array[left + 1] = array[left]
          break
        default:
          while (n > 0) {
            array[left + n] = array[left + n - 1]
            n--
          }
      }
      array[left] = pivot
    }
  }
  function gallopLeft (value, array, start, length, hint, compare) {
    let lastOffset = 0
    let maxOffset = 0
    let offset = 1
    if (compare(value, array[start + hint]) > 0) {
      maxOffset = length - hint
      while (offset < maxOffset && compare(value, array[start + hint + offset]) > 0) {
        lastOffset = offset
        offset = (offset << 1) + 1
        if (offset <= 0) {
          offset = maxOffset
        }
      }
      if (offset > maxOffset) {
        offset = maxOffset
      }
      lastOffset += hint
      offset += hint
    } else {
      maxOffset = hint + 1
      while (offset < maxOffset && compare(value, array[start + hint - offset]) <= 0) {
        lastOffset = offset
        offset = (offset << 1) + 1
        if (offset <= 0) {
          offset = maxOffset
        }
      }
      if (offset > maxOffset) {
        offset = maxOffset
      }
      const tmp = lastOffset
      lastOffset = hint - offset
      offset = hint - tmp
    }
    lastOffset++
    while (lastOffset < offset) {
      const m = lastOffset + (offset - lastOffset >>> 1)
      if (compare(value, array[start + m]) > 0) {
        lastOffset = m + 1
      } else {
        offset = m
      }
    }
    return offset
  }
  function gallopRight (value, array, start, length, hint, compare) {
    let lastOffset = 0
    let maxOffset = 0
    let offset = 1
    if (compare(value, array[start + hint]) < 0) {
      maxOffset = hint + 1
      while (offset < maxOffset && compare(value, array[start + hint - offset]) < 0) {
        lastOffset = offset
        offset = (offset << 1) + 1
        if (offset <= 0) {
          offset = maxOffset
        }
      }
      if (offset > maxOffset) {
        offset = maxOffset
      }
      const tmp = lastOffset
      lastOffset = hint - offset
      offset = hint - tmp
    } else {
      maxOffset = length - hint
      while (offset < maxOffset && compare(value, array[start + hint + offset]) >= 0) {
        lastOffset = offset
        offset = (offset << 1) + 1
        if (offset <= 0) {
          offset = maxOffset
        }
      }
      if (offset > maxOffset) {
        offset = maxOffset
      }
      lastOffset += hint
      offset += hint
    }
    lastOffset++
    while (lastOffset < offset) {
      const m = lastOffset + (offset - lastOffset >>> 1)
      if (compare(value, array[start + m]) < 0) {
        offset = m
      } else {
        lastOffset = m + 1
      }
    }
    return offset
  }
  function TimSort (array, compare) {
    let minGallop = DEFAULT_MIN_GALLOPING
    let length = 0
    let runStart
    let runLength
    let stackSize = 0
    length = array.length
    const tmp = []
    runStart = []
    runLength = []
    function pushRun (_runStart, _runLength) {
      runStart[stackSize] = _runStart
      runLength[stackSize] = _runLength
      stackSize += 1
    }
    function mergeRuns () {
      while (stackSize > 1) {
        let n = stackSize - 2
        if ((n >= 1 && runLength[n - 1] <= runLength[n] + runLength[n + 1]) ||
                    (n >= 2 && runLength[n - 2] <= runLength[n] + runLength[n - 1])) {
          if (runLength[n - 1] < runLength[n + 1]) {
            n--
          }
        } else if (runLength[n] > runLength[n + 1]) {
          break
        }
        mergeAt(n)
      }
    }
    function forceMergeRuns () {
      while (stackSize > 1) {
        let n = stackSize - 2
        if (n > 0 && runLength[n - 1] < runLength[n + 1]) {
          n--
        }
        mergeAt(n)
      }
    }
    function mergeAt (i) {
      let start1 = runStart[i]
      let length1 = runLength[i]
      const start2 = runStart[i + 1]
      let length2 = runLength[i + 1]
      runLength[i] = length1 + length2
      if (i === stackSize - 3) {
        runStart[i + 1] = runStart[i + 2]
        runLength[i + 1] = runLength[i + 2]
      }
      stackSize--
      const k = gallopRight(array[start2], array, start1, length1, 0, compare)
      start1 += k
      length1 -= k
      if (length1 === 0) {
        return
      }
      length2 = gallopLeft(array[start1 + length1 - 1], array, start2, length2, length2 - 1, compare)
      if (length2 === 0) {
        return
      }
      if (length1 <= length2) {
        mergeLow(start1, length1, start2, length2)
      } else {
        mergeHigh(start1, length1, start2, length2)
      }
    }
    function mergeLow (start1, length1, start2, length2) {
      let i = 0
      for (i = 0; i < length1; i++) {
        tmp[i] = array[start1 + i]
      }
      let cursor1 = 0
      let cursor2 = start2
      let dest = start1
      array[dest++] = array[cursor2++]
      if (--length2 === 0) {
        for (i = 0; i < length1; i++) {
          array[dest + i] = tmp[cursor1 + i]
        }
        return
      }
      if (length1 === 1) {
        for (i = 0; i < length2; i++) {
          array[dest + i] = array[cursor2 + i]
        }
        array[dest + length2] = tmp[cursor1]
        return
      }
      let _minGallop = minGallop
      let count1
      let count2
      let exit
      while (1) {
        count1 = 0
        count2 = 0
        exit = false
        do {
          if (compare(array[cursor2], tmp[cursor1]) < 0) {
            array[dest++] = array[cursor2++]
            count2++
            count1 = 0
            if (--length2 === 0) {
              exit = true
              break
            }
          } else {
            array[dest++] = tmp[cursor1++]
            count1++
            count2 = 0
            if (--length1 === 1) {
              exit = true
              break
            }
          }
        } while ((count1 | count2) < _minGallop)
        if (exit) {
          break
        }
        do {
          count1 = gallopRight(array[cursor2], tmp, cursor1, length1, 0, compare)
          if (count1 !== 0) {
            for (i = 0; i < count1; i++) {
              array[dest + i] = tmp[cursor1 + i]
            }
            dest += count1
            cursor1 += count1
            length1 -= count1
            if (length1 <= 1) {
              exit = true
              break
            }
          }
          array[dest++] = array[cursor2++]
          if (--length2 === 0) {
            exit = true
            break
          }
          count2 = gallopLeft(tmp[cursor1], array, cursor2, length2, 0, compare)
          if (count2 !== 0) {
            for (i = 0; i < count2; i++) {
              array[dest + i] = array[cursor2 + i]
            }
            dest += count2
            cursor2 += count2
            length2 -= count2
            if (length2 === 0) {
              exit = true
              break
            }
          }
          array[dest++] = tmp[cursor1++]
          if (--length1 === 1) {
            exit = true
            break
          }
          _minGallop--
        } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING)
        if (exit) {
          break
        }
        if (_minGallop < 0) {
          _minGallop = 0
        }
        _minGallop += 2
      }
      minGallop = _minGallop
      minGallop < 1 && (minGallop = 1)
      if (length1 === 1) {
        for (i = 0; i < length2; i++) {
          array[dest + i] = array[cursor2 + i]
        }
        array[dest + length2] = tmp[cursor1]
      } else if (length1 === 0) {
        throw new Error()
      } else {
        for (i = 0; i < length1; i++) {
          array[dest + i] = tmp[cursor1 + i]
        }
      }
    }
    function mergeHigh (start1, length1, start2, length2) {
      let i = 0
      for (i = 0; i < length2; i++) {
        tmp[i] = array[start2 + i]
      }
      let cursor1 = start1 + length1 - 1
      let cursor2 = length2 - 1
      let dest = start2 + length2 - 1
      let customCursor = 0
      let customDest = 0
      array[dest--] = array[cursor1--]
      if (--length1 === 0) {
        customCursor = dest - (length2 - 1)
        for (i = 0; i < length2; i++) {
          array[customCursor + i] = tmp[i]
        }
        return
      }
      if (length2 === 1) {
        dest -= length1
        cursor1 -= length1
        customDest = dest + 1
        customCursor = cursor1 + 1
        for (i = length1 - 1; i >= 0; i--) {
          array[customDest + i] = array[customCursor + i]
        }
        array[dest] = tmp[cursor2]
        return
      }
      let _minGallop = minGallop
      while (true) {
        let count1 = 0
        let count2 = 0
        let exit = false
        do {
          if (compare(tmp[cursor2], array[cursor1]) < 0) {
            array[dest--] = array[cursor1--]
            count1++
            count2 = 0
            if (--length1 === 0) {
              exit = true
              break
            }
          } else {
            array[dest--] = tmp[cursor2--]
            count2++
            count1 = 0
            if (--length2 === 1) {
              exit = true
              break
            }
          }
        } while ((count1 | count2) < _minGallop)
        if (exit) {
          break
        }
        do {
          count1 = length1 - gallopRight(tmp[cursor2], array, start1, length1, length1 - 1, compare)
          if (count1 !== 0) {
            dest -= count1
            cursor1 -= count1
            length1 -= count1
            customDest = dest + 1
            customCursor = cursor1 + 1
            for (i = count1 - 1; i >= 0; i--) {
              array[customDest + i] = array[customCursor + i]
            }
            if (length1 === 0) {
              exit = true
              break
            }
          }
          array[dest--] = tmp[cursor2--]
          if (--length2 === 1) {
            exit = true
            break
          }
          count2 = length2 - gallopLeft(array[cursor1], tmp, 0, length2, length2 - 1, compare)
          if (count2 !== 0) {
            dest -= count2
            cursor2 -= count2
            length2 -= count2
            customDest = dest + 1
            customCursor = cursor2 + 1
            for (i = 0; i < count2; i++) {
              array[customDest + i] = tmp[customCursor + i]
            }
            if (length2 <= 1) {
              exit = true
              break
            }
          }
          array[dest--] = array[cursor1--]
          if (--length1 === 0) {
            exit = true
            break
          }
          _minGallop--
        } while (count1 >= DEFAULT_MIN_GALLOPING || count2 >= DEFAULT_MIN_GALLOPING)
        if (exit) {
          break
        }
        if (_minGallop < 0) {
          _minGallop = 0
        }
        _minGallop += 2
      }
      minGallop = _minGallop
      if (minGallop < 1) {
        minGallop = 1
      }
      if (length2 === 1) {
        dest -= length1
        cursor1 -= length1
        customDest = dest + 1
        customCursor = cursor1 + 1
        for (i = length1 - 1; i >= 0; i--) {
          array[customDest + i] = array[customCursor + i]
        }
        array[dest] = tmp[cursor2]
      } else if (length2 === 0) {
        throw new Error()
      } else {
        customCursor = dest - (length2 - 1)
        for (i = 0; i < length2; i++) {
          array[customCursor + i] = tmp[i]
        }
      }
    }
    return {
      mergeRuns: mergeRuns,
      forceMergeRuns: forceMergeRuns,
      pushRun: pushRun
    }
  }
  function sort (array, compare, lo, hi) {
    if (!lo) {
      lo = 0
    }
    if (!hi) {
      hi = array.length
    }
    let remaining = hi - lo
    if (remaining < 2) {
      return
    }
    let runLength = 0
    if (remaining < DEFAULT_MIN_MERGE) {
      runLength = makeAscendingRun(array, lo, hi, compare)
      binaryInsertionSort(array, lo, hi, lo + runLength, compare)
      return
    }
    const ts = TimSort(array, compare)
    const minRun = minRunLength(remaining)
    do {
      runLength = makeAscendingRun(array, lo, hi, compare)
      if (runLength < minRun) {
        let force = remaining
        if (force > minRun) {
          force = minRun
        }
        binaryInsertionSort(array, lo, lo + force, lo + runLength, compare)
        runLength = force
      }
      ts.pushRun(lo, runLength)
      ts.mergeRuns()
      remaining -= runLength
      lo += runLength
    } while (remaining !== 0)
    ts.forceMergeRuns()
  }

  const REDRAW_BIT = 1
  const STYLE_CHANGED_BIT = 2
  const SHAPE_CHANGED_BIT = 4

  let invalidZErrorLogged = false
  function logInvalidZError () {
    if (invalidZErrorLogged) {
      return
    }
    invalidZErrorLogged = true
    console.warn('z / z2 / zlevel of displayable is invalid, which may cause unexpected errors')
  }
  function shapeCompareFunc (a, b) {
    if (a.zlevel === b.zlevel) {
      if (a.z === b.z) {
        return a.z2 - b.z2
      }
      return a.z - b.z
    }
    return a.zlevel - b.zlevel
  }
  const Storage = (function () {
    function Storage () {
      this._roots = []
      this._displayList = []
      this._displayListLen = 0
      this.displayableSortFunc = shapeCompareFunc
    }
    Storage.prototype.traverse = function (cb, context) {
      for (let i = 0; i < this._roots.length; i++) {
        this._roots[i].traverse(cb, context)
      }
    }
    Storage.prototype.getDisplayList = function (update, includeIgnore) {
      includeIgnore = includeIgnore || false
      const displayList = this._displayList
      if (update || !displayList.length) {
        this.updateDisplayList(includeIgnore)
      }
      return displayList
    }
    Storage.prototype.updateDisplayList = function (includeIgnore) {
      this._displayListLen = 0
      const roots = this._roots
      const displayList = this._displayList
      for (let i = 0, len = roots.length; i < len; i++) {
        this._updateAndAddDisplayable(roots[i], null, includeIgnore)
      }
      displayList.length = this._displayListLen
      sort(displayList, shapeCompareFunc)
    }
    Storage.prototype._updateAndAddDisplayable = function (el, clipPaths, includeIgnore) {
      if (el.ignore && !includeIgnore) {
        return
      }
      el.beforeUpdate()
      el.update()
      el.afterUpdate()
      const userSetClipPath = el.getClipPath()
      if (el.ignoreClip) {
        clipPaths = null
      } else if (userSetClipPath) {
        if (clipPaths) {
          clipPaths = clipPaths.slice()
        } else {
          clipPaths = []
        }
        let currentClipPath = userSetClipPath
        let parentClipPath = el
        while (currentClipPath) {
          currentClipPath.parent = parentClipPath
          currentClipPath.updateTransform()
          clipPaths.push(currentClipPath)
          parentClipPath = currentClipPath
          currentClipPath = currentClipPath.getClipPath()
        }
      }
      if (el.childrenRef) {
        const children = el.childrenRef()
        for (let i = 0; i < children.length; i++) {
          const child = children[i]
          if (el.__dirty) {
            child.__dirty |= REDRAW_BIT
          }
          this._updateAndAddDisplayable(child, clipPaths, includeIgnore)
        }
        el.__dirty = 0
      } else {
        const disp = el
        if (clipPaths && clipPaths.length) {
          disp.__clipPaths = clipPaths
        } else if (disp.__clipPaths && disp.__clipPaths.length > 0) {
          disp.__clipPaths = []
        }
        if (isNaN(disp.z)) {
          logInvalidZError()
          disp.z = 0
        }
        if (isNaN(disp.z2)) {
          logInvalidZError()
          disp.z2 = 0
        }
        if (isNaN(disp.zlevel)) {
          logInvalidZError()
          disp.zlevel = 0
        }
        this._displayList[this._displayListLen++] = disp
      }
      const decalEl = el.getDecalElement && el.getDecalElement()
      if (decalEl) {
        this._updateAndAddDisplayable(decalEl, clipPaths, includeIgnore)
      }
      const textGuide = el.getTextGuideLine()
      if (textGuide) {
        this._updateAndAddDisplayable(textGuide, clipPaths, includeIgnore)
      }
      const textEl = el.getTextContent()
      if (textEl) {
        this._updateAndAddDisplayable(textEl, clipPaths, includeIgnore)
      }
    }
    Storage.prototype.addRoot = function (el) {
      if (el.__zr && el.__zr.storage === this) {
        return
      }
      this._roots.push(el)
    }
    Storage.prototype.delRoot = function (el) {
      if (el instanceof Array) {
        for (let i = 0, l = el.length; i < l; i++) {
          this.delRoot(el[i])
        }
        return
      }
      const idx = indexOf(this._roots, el)
      if (idx >= 0) {
        this._roots.splice(idx, 1)
      }
    }
    Storage.prototype.delAllRoots = function () {
      this._roots = []
      this._displayList = []
      this._displayListLen = 0
    }
    Storage.prototype.getRoots = function () {
      return this._roots
    }
    Storage.prototype.dispose = function () {
      this._displayList = null
      this._roots = null
    }
    return Storage
  }())

  let requestAnimationFrame
  requestAnimationFrame = (env.hasGlobalWindow &&
        ((window.requestAnimationFrame && window.requestAnimationFrame.bind(window)) ||
            (window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window)) ||
            window.mozRequestAnimationFrame ||
            window.webkitRequestAnimationFrame)) || function (func) {
    return setTimeout(func, 16)
  }
  const requestAnimationFrame$1 = requestAnimationFrame

  var easingFuncs = {
    linear: function (k) {
      return k
    },
    quadraticIn: function (k) {
      return k * k
    },
    quadraticOut: function (k) {
      return k * (2 - k)
    },
    quadraticInOut: function (k) {
      if ((k *= 2) < 1) {
        return 0.5 * k * k
      }
      return -0.5 * (--k * (k - 2) - 1)
    },
    cubicIn: function (k) {
      return k * k * k
    },
    cubicOut: function (k) {
      return --k * k * k + 1
    },
    cubicInOut: function (k) {
      if ((k *= 2) < 1) {
        return 0.5 * k * k * k
      }
      return 0.5 * ((k -= 2) * k * k + 2)
    },
    quarticIn: function (k) {
      return k * k * k * k
    },
    quarticOut: function (k) {
      return 1 - (--k * k * k * k)
    },
    quarticInOut: function (k) {
      if ((k *= 2) < 1) {
        return 0.5 * k * k * k * k
      }
      return -0.5 * ((k -= 2) * k * k * k - 2)
    },
    quinticIn: function (k) {
      return k * k * k * k * k
    },
    quinticOut: function (k) {
      return --k * k * k * k * k + 1
    },
    quinticInOut: function (k) {
      if ((k *= 2) < 1) {
        return 0.5 * k * k * k * k * k
      }
      return 0.5 * ((k -= 2) * k * k * k * k + 2)
    },
    sinusoidalIn: function (k) {
      return 1 - Math.cos(k * Math.PI / 2)
    },
    sinusoidalOut: function (k) {
      return Math.sin(k * Math.PI / 2)
    },
    sinusoidalInOut: function (k) {
      return 0.5 * (1 - Math.cos(Math.PI * k))
    },
    exponentialIn: function (k) {
      return k === 0 ? 0 : Math.pow(1024, k - 1)
    },
    exponentialOut: function (k) {
      return k === 1 ? 1 : 1 - Math.pow(2, -10 * k)
    },
    exponentialInOut: function (k) {
      if (k === 0) {
        return 0
      }
      if (k === 1) {
        return 1
      }
      if ((k *= 2) < 1) {
        return 0.5 * Math.pow(1024, k - 1)
      }
      return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2)
    },
    circularIn: function (k) {
      return 1 - Math.sqrt(1 - k * k)
    },
    circularOut: function (k) {
      return Math.sqrt(1 - (--k * k))
    },
    circularInOut: function (k) {
      if ((k *= 2) < 1) {
        return -0.5 * (Math.sqrt(1 - k * k) - 1)
      }
      return 0.5 * (Math.sqrt(1 - (k -= 2) * k) + 1)
    },
    elasticIn: function (k) {
      let s
      let a = 0.1
      const p = 0.4
      if (k === 0) {
        return 0
      }
      if (k === 1) {
        return 1
      }
      if (!a || a < 1) {
        a = 1
        s = p / 4
      } else {
        s = p * Math.asin(1 / a) / (2 * Math.PI)
      }
      return -(a * Math.pow(2, 10 * (k -= 1)) *
                Math.sin((k - s) * (2 * Math.PI) / p))
    },
    elasticOut: function (k) {
      let s
      let a = 0.1
      const p = 0.4
      if (k === 0) {
        return 0
      }
      if (k === 1) {
        return 1
      }
      if (!a || a < 1) {
        a = 1
        s = p / 4
      } else {
        s = p * Math.asin(1 / a) / (2 * Math.PI)
      }
      return (a * Math.pow(2, -10 * k) *
                Math.sin((k - s) * (2 * Math.PI) / p) + 1)
    },
    elasticInOut: function (k) {
      let s
      let a = 0.1
      const p = 0.4
      if (k === 0) {
        return 0
      }
      if (k === 1) {
        return 1
      }
      if (!a || a < 1) {
        a = 1
        s = p / 4
      } else {
        s = p * Math.asin(1 / a) / (2 * Math.PI)
      }
      if ((k *= 2) < 1) {
        return -0.5 * (a * Math.pow(2, 10 * (k -= 1)) *
                    Math.sin((k - s) * (2 * Math.PI) / p))
      }
      return a * Math.pow(2, -10 * (k -= 1)) *
                Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1
    },
    backIn: function (k) {
      const s = 1.70158
      return k * k * ((s + 1) * k - s)
    },
    backOut: function (k) {
      const s = 1.70158
      return --k * k * ((s + 1) * k + s) + 1
    },
    backInOut: function (k) {
      const s = 1.70158 * 1.525
      if ((k *= 2) < 1) {
        return 0.5 * (k * k * ((s + 1) * k - s))
      }
      return 0.5 * ((k -= 2) * k * ((s + 1) * k + s) + 2)
    },
    bounceIn: function (k) {
      return 1 - easingFuncs.bounceOut(1 - k)
    },
    bounceOut: function (k) {
      if (k < (1 / 2.75)) {
        return 7.5625 * k * k
      } else if (k < (2 / 2.75)) {
        return 7.5625 * (k -= (1.5 / 2.75)) * k + 0.75
      } else if (k < (2.5 / 2.75)) {
        return 7.5625 * (k -= (2.25 / 2.75)) * k + 0.9375
      } else {
        return 7.5625 * (k -= (2.625 / 2.75)) * k + 0.984375
      }
    },
    bounceInOut: function (k) {
      if (k < 0.5) {
        return easingFuncs.bounceIn(k * 2) * 0.5
      }
      return easingFuncs.bounceOut(k * 2 - 1) * 0.5 + 0.5
    }
  }

  const mathPow = Math.pow
  const mathSqrt = Math.sqrt
  const EPSILON = 1e-8
  const EPSILON_NUMERIC = 1e-4
  const THREE_SQRT = mathSqrt(3)
  const ONE_THIRD = 1 / 3
  const _v0 = create()
  const _v1 = create()
  const _v2 = create()
  function isAroundZero (val) {
    return val > -EPSILON && val < EPSILON
  }
  function isNotAroundZero (val) {
    return val > EPSILON || val < -EPSILON
  }
  function cubicAt (p0, p1, p2, p3, t) {
    const onet = 1 - t
    return onet * onet * (onet * p0 + 3 * t * p1) +
            t * t * (t * p3 + 3 * onet * p2)
  }
  function cubicDerivativeAt (p0, p1, p2, p3, t) {
    const onet = 1 - t
    return 3 * (((p1 - p0) * onet + 2 * (p2 - p1) * t) * onet +
            (p3 - p2) * t * t)
  }
  function cubicRootAt (p0, p1, p2, p3, val, roots) {
    const a = p3 + 3 * (p1 - p2) - p0
    const b = 3 * (p2 - p1 * 2 + p0)
    const c = 3 * (p1 - p0)
    const d = p0 - val
    const A = b * b - 3 * a * c
    const B = b * c - 9 * a * d
    const C = c * c - 3 * b * d
    let n = 0
    if (isAroundZero(A) && isAroundZero(B)) {
      if (isAroundZero(b)) {
        roots[0] = 0
      } else {
        var t1 = -c / b
        if (t1 >= 0 && t1 <= 1) {
          roots[n++] = t1
        }
      }
    } else {
      const disc = B * B - 4 * A * C
      if (isAroundZero(disc)) {
        const K = B / A
        var t1 = -b / a + K
        var t2 = -K / 2
        if (t1 >= 0 && t1 <= 1) {
          roots[n++] = t1
        }
        if (t2 >= 0 && t2 <= 1) {
          roots[n++] = t2
        }
      } else if (disc > 0) {
        const discSqrt = mathSqrt(disc)
        let Y1 = A * b + 1.5 * a * (-B + discSqrt)
        let Y2 = A * b + 1.5 * a * (-B - discSqrt)
        if (Y1 < 0) {
          Y1 = -mathPow(-Y1, ONE_THIRD)
        } else {
          Y1 = mathPow(Y1, ONE_THIRD)
        }
        if (Y2 < 0) {
          Y2 = -mathPow(-Y2, ONE_THIRD)
        } else {
          Y2 = mathPow(Y2, ONE_THIRD)
        }
        var t1 = (-b - (Y1 + Y2)) / (3 * a)
        if (t1 >= 0 && t1 <= 1) {
          roots[n++] = t1
        }
      } else {
        const T = (2 * A * b - 3 * a * B) / (2 * mathSqrt(A * A * A))
        const theta = Math.acos(T) / 3
        const ASqrt = mathSqrt(A)
        const tmp = Math.cos(theta)
        var t1 = (-b - 2 * ASqrt * tmp) / (3 * a)
        var t2 = (-b + ASqrt * (tmp + THREE_SQRT * Math.sin(theta))) / (3 * a)
        const t3 = (-b + ASqrt * (tmp - THREE_SQRT * Math.sin(theta))) / (3 * a)
        if (t1 >= 0 && t1 <= 1) {
          roots[n++] = t1
        }
        if (t2 >= 0 && t2 <= 1) {
          roots[n++] = t2
        }
        if (t3 >= 0 && t3 <= 1) {
          roots[n++] = t3
        }
      }
    }
    return n
  }
  function cubicExtrema (p0, p1, p2, p3, extrema) {
    const b = 6 * p2 - 12 * p1 + 6 * p0
    const a = 9 * p1 + 3 * p3 - 3 * p0 - 9 * p2
    const c = 3 * p1 - 3 * p0
    let n = 0
    if (isAroundZero(a)) {
      if (isNotAroundZero(b)) {
        var t1 = -c / b
        if (t1 >= 0 && t1 <= 1) {
          extrema[n++] = t1
        }
      }
    } else {
      const disc = b * b - 4 * a * c
      if (isAroundZero(disc)) {
        extrema[0] = -b / (2 * a)
      } else if (disc > 0) {
        const discSqrt = mathSqrt(disc)
        var t1 = (-b + discSqrt) / (2 * a)
        const t2 = (-b - discSqrt) / (2 * a)
        if (t1 >= 0 && t1 <= 1) {
          extrema[n++] = t1
        }
        if (t2 >= 0 && t2 <= 1) {
          extrema[n++] = t2
        }
      }
    }
    return n
  }
  function cubicSubdivide (p0, p1, p2, p3, t, out) {
    const p01 = (p1 - p0) * t + p0
    const p12 = (p2 - p1) * t + p1
    const p23 = (p3 - p2) * t + p2
    const p012 = (p12 - p01) * t + p01
    const p123 = (p23 - p12) * t + p12
    const p0123 = (p123 - p012) * t + p012
    out[0] = p0
    out[1] = p01
    out[2] = p012
    out[3] = p0123
    out[4] = p0123
    out[5] = p123
    out[6] = p23
    out[7] = p3
  }
  function cubicProjectPoint (x0, y0, x1, y1, x2, y2, x3, y3, x, y, out) {
    let t
    let interval = 0.005
    let d = Infinity
    let prev
    let next
    let d1
    let d2
    _v0[0] = x
    _v0[1] = y
    for (let _t = 0; _t < 1; _t += 0.05) {
      _v1[0] = cubicAt(x0, x1, x2, x3, _t)
      _v1[1] = cubicAt(y0, y1, y2, y3, _t)
      d1 = distSquare(_v0, _v1)
      if (d1 < d) {
        t = _t
        d = d1
      }
    }
    d = Infinity
    for (let i = 0; i < 32; i++) {
      if (interval < EPSILON_NUMERIC) {
        break
      }
      prev = t - interval
      next = t + interval
      _v1[0] = cubicAt(x0, x1, x2, x3, prev)
      _v1[1] = cubicAt(y0, y1, y2, y3, prev)
      d1 = distSquare(_v1, _v0)
      if (prev >= 0 && d1 < d) {
        t = prev
        d = d1
      } else {
        _v2[0] = cubicAt(x0, x1, x2, x3, next)
        _v2[1] = cubicAt(y0, y1, y2, y3, next)
        d2 = distSquare(_v2, _v0)
        if (next <= 1 && d2 < d) {
          t = next
          d = d2
        } else {
          interval *= 0.5
        }
      }
    }
    if (out) {
      out[0] = cubicAt(x0, x1, x2, x3, t)
      out[1] = cubicAt(y0, y1, y2, y3, t)
    }
    return mathSqrt(d)
  }
  function cubicLength (x0, y0, x1, y1, x2, y2, x3, y3, iteration) {
    let px = x0
    let py = y0
    let d = 0
    const step = 1 / iteration
    for (let i = 1; i <= iteration; i++) {
      const t = i * step
      const x = cubicAt(x0, x1, x2, x3, t)
      const y = cubicAt(y0, y1, y2, y3, t)
      const dx = x - px
      const dy = y - py
      d += Math.sqrt(dx * dx + dy * dy)
      px = x
      py = y
    }
    return d
  }
  function quadraticAt (p0, p1, p2, t) {
    const onet = 1 - t
    return onet * (onet * p0 + 2 * t * p1) + t * t * p2
  }
  function quadraticDerivativeAt (p0, p1, p2, t) {
    return 2 * ((1 - t) * (p1 - p0) + t * (p2 - p1))
  }
  function quadraticRootAt (p0, p1, p2, val, roots) {
    const a = p0 - 2 * p1 + p2
    const b = 2 * (p1 - p0)
    const c = p0 - val
    let n = 0
    if (isAroundZero(a)) {
      if (isNotAroundZero(b)) {
        var t1 = -c / b
        if (t1 >= 0 && t1 <= 1) {
          roots[n++] = t1
        }
      }
    } else {
      const disc = b * b - 4 * a * c
      if (isAroundZero(disc)) {
        var t1 = -b / (2 * a)
        if (t1 >= 0 && t1 <= 1) {
          roots[n++] = t1
        }
      } else if (disc > 0) {
        const discSqrt = mathSqrt(disc)
        var t1 = (-b + discSqrt) / (2 * a)
        const t2 = (-b - discSqrt) / (2 * a)
        if (t1 >= 0 && t1 <= 1) {
          roots[n++] = t1
        }
        if (t2 >= 0 && t2 <= 1) {
          roots[n++] = t2
        }
      }
    }
    return n
  }
  function quadraticExtremum (p0, p1, p2) {
    const divider = p0 + p2 - 2 * p1
    if (divider === 0) {
      return 0.5
    } else {
      return (p0 - p1) / divider
    }
  }
  function quadraticSubdivide (p0, p1, p2, t, out) {
    const p01 = (p1 - p0) * t + p0
    const p12 = (p2 - p1) * t + p1
    const p012 = (p12 - p01) * t + p01
    out[0] = p0
    out[1] = p01
    out[2] = p012
    out[3] = p012
    out[4] = p12
    out[5] = p2
  }
  function quadraticProjectPoint (x0, y0, x1, y1, x2, y2, x, y, out) {
    let t
    let interval = 0.005
    let d = Infinity
    _v0[0] = x
    _v0[1] = y
    for (let _t = 0; _t < 1; _t += 0.05) {
      _v1[0] = quadraticAt(x0, x1, x2, _t)
      _v1[1] = quadraticAt(y0, y1, y2, _t)
      var d1 = distSquare(_v0, _v1)
      if (d1 < d) {
        t = _t
        d = d1
      }
    }
    d = Infinity
    for (let i = 0; i < 32; i++) {
      if (interval < EPSILON_NUMERIC) {
        break
      }
      const prev = t - interval
      const next = t + interval
      _v1[0] = quadraticAt(x0, x1, x2, prev)
      _v1[1] = quadraticAt(y0, y1, y2, prev)
      var d1 = distSquare(_v1, _v0)
      if (prev >= 0 && d1 < d) {
        t = prev
        d = d1
      } else {
        _v2[0] = quadraticAt(x0, x1, x2, next)
        _v2[1] = quadraticAt(y0, y1, y2, next)
        const d2 = distSquare(_v2, _v0)
        if (next <= 1 && d2 < d) {
          t = next
          d = d2
        } else {
          interval *= 0.5
        }
      }
    }
    if (out) {
      out[0] = quadraticAt(x0, x1, x2, t)
      out[1] = quadraticAt(y0, y1, y2, t)
    }
    return mathSqrt(d)
  }
  function quadraticLength (x0, y0, x1, y1, x2, y2, iteration) {
    let px = x0
    let py = y0
    let d = 0
    const step = 1 / iteration
    for (let i = 1; i <= iteration; i++) {
      const t = i * step
      const x = quadraticAt(x0, x1, x2, t)
      const y = quadraticAt(y0, y1, y2, t)
      const dx = x - px
      const dy = y - py
      d += Math.sqrt(dx * dx + dy * dy)
      px = x
      py = y
    }
    return d
  }

  const regexp = /cubic-bezier\(([0-9,\.e ]+)\)/
  function createCubicEasingFunc (cubicEasingStr) {
    const cubic = cubicEasingStr && regexp.exec(cubicEasingStr)
    if (cubic) {
      const points = cubic[1].split(',')
      const a_1 = +trim(points[0])
      const b_1 = +trim(points[1])
      const c_1 = +trim(points[2])
      const d_1 = +trim(points[3])
      if (isNaN(a_1 + b_1 + c_1 + d_1)) {
        return
      }
      const roots_1 = []
      return function (p) {
        return p <= 0
          ? 0
          : p >= 1
            ? 1
            : cubicRootAt(0, a_1, c_1, 1, p, roots_1) && cubicAt(0, b_1, d_1, 1, roots_1[0])
      }
    }
  }

  const Clip = (function () {
    function Clip (opts) {
      this._inited = false
      this._startTime = 0
      this._pausedTime = 0
      this._paused = false
      this._life = opts.life || 1000
      this._delay = opts.delay || 0
      this.loop = opts.loop || false
      this.onframe = opts.onframe || noop
      this.ondestroy = opts.ondestroy || noop
      this.onrestart = opts.onrestart || noop
      opts.easing && this.setEasing(opts.easing)
    }
    Clip.prototype.step = function (globalTime, deltaTime) {
      if (!this._inited) {
        this._startTime = globalTime + this._delay
        this._inited = true
      }
      if (this._paused) {
        this._pausedTime += deltaTime
        return
      }
      const life = this._life
      const elapsedTime = globalTime - this._startTime - this._pausedTime
      let percent = elapsedTime / life
      if (percent < 0) {
        percent = 0
      }
      percent = Math.min(percent, 1)
      const easingFunc = this.easingFunc
      const schedule = easingFunc ? easingFunc(percent) : percent
      this.onframe(schedule)
      if (percent === 1) {
        if (this.loop) {
          const remainder = elapsedTime % life
          this._startTime = globalTime - remainder
          this._pausedTime = 0
          this.onrestart()
        } else {
          return true
        }
      }
      return false
    }
    Clip.prototype.pause = function () {
      this._paused = true
    }
    Clip.prototype.resume = function () {
      this._paused = false
    }
    Clip.prototype.setEasing = function (easing) {
      this.easing = easing
      this.easingFunc = isFunction(easing)
        ? easing
        : easingFuncs[easing] || createCubicEasingFunc(easing)
    }
    return Clip
  }())

  const Entry = (function () {
    function Entry (val) {
      this.value = val
    }
    return Entry
  }())
  const LinkedList = (function () {
    function LinkedList () {
      this._len = 0
    }
    LinkedList.prototype.insert = function (val) {
      const entry = new Entry(val)
      this.insertEntry(entry)
      return entry
    }
    LinkedList.prototype.insertEntry = function (entry) {
      if (!this.head) {
        this.head = this.tail = entry
      } else {
        this.tail.next = entry
        entry.prev = this.tail
        entry.next = null
        this.tail = entry
      }
      this._len++
    }
    LinkedList.prototype.remove = function (entry) {
      const prev = entry.prev
      const next = entry.next
      if (prev) {
        prev.next = next
      } else {
        this.head = next
      }
      if (next) {
        next.prev = prev
      } else {
        this.tail = prev
      }
      entry.next = entry.prev = null
      this._len--
    }
    LinkedList.prototype.len = function () {
      return this._len
    }
    LinkedList.prototype.clear = function () {
      this.head = this.tail = null
      this._len = 0
    }
    return LinkedList
  }())
  const LRU = (function () {
    function LRU (maxSize) {
      this._list = new LinkedList()
      this._maxSize = 10
      this._map = {}
      this._maxSize = maxSize
    }
    LRU.prototype.put = function (key, value) {
      const list = this._list
      const map = this._map
      let removed = null
      if (map[key] == null) {
        const len = list.len()
        let entry = this._lastRemovedEntry
        if (len >= this._maxSize && len > 0) {
          const leastUsedEntry = list.head
          list.remove(leastUsedEntry)
          delete map[leastUsedEntry.key]
          removed = leastUsedEntry.value
          this._lastRemovedEntry = leastUsedEntry
        }
        if (entry) {
          entry.value = value
        } else {
          entry = new Entry(value)
        }
        entry.key = key
        list.insertEntry(entry)
        map[key] = entry
      }
      return removed
    }
    LRU.prototype.get = function (key) {
      const entry = this._map[key]
      const list = this._list
      if (entry != null) {
        if (entry !== list.tail) {
          list.remove(entry)
          list.insertEntry(entry)
        }
        return entry.value
      }
    }
    LRU.prototype.clear = function () {
      this._list.clear()
      this._map = {}
    }
    LRU.prototype.len = function () {
      return this._list.len()
    }
    return LRU
  }())

  const kCSSColorTable = {
    transparent: [0, 0, 0, 0],
    aliceblue: [240, 248, 255, 1],
    antiquewhite: [250, 235, 215, 1],
    aqua: [0, 255, 255, 1],
    aquamarine: [127, 255, 212, 1],
    azure: [240, 255, 255, 1],
    beige: [245, 245, 220, 1],
    bisque: [255, 228, 196, 1],
    black: [0, 0, 0, 1],
    blanchedalmond: [255, 235, 205, 1],
    blue: [0, 0, 255, 1],
    blueviolet: [138, 43, 226, 1],
    brown: [165, 42, 42, 1],
    burlywood: [222, 184, 135, 1],
    cadetblue: [95, 158, 160, 1],
    chartreuse: [127, 255, 0, 1],
    chocolate: [210, 105, 30, 1],
    coral: [255, 127, 80, 1],
    cornflowerblue: [100, 149, 237, 1],
    cornsilk: [255, 248, 220, 1],
    crimson: [220, 20, 60, 1],
    cyan: [0, 255, 255, 1],
    darkblue: [0, 0, 139, 1],
    darkcyan: [0, 139, 139, 1],
    darkgoldenrod: [184, 134, 11, 1],
    darkgray: [169, 169, 169, 1],
    darkgreen: [0, 100, 0, 1],
    darkgrey: [169, 169, 169, 1],
    darkkhaki: [189, 183, 107, 1],
    darkmagenta: [139, 0, 139, 1],
    darkolivegreen: [85, 107, 47, 1],
    darkorange: [255, 140, 0, 1],
    darkorchid: [153, 50, 204, 1],
    darkred: [139, 0, 0, 1],
    darksalmon: [233, 150, 122, 1],
    darkseagreen: [143, 188, 143, 1],
    darkslateblue: [72, 61, 139, 1],
    darkslategray: [47, 79, 79, 1],
    darkslategrey: [47, 79, 79, 1],
    darkturquoise: [0, 206, 209, 1],
    darkviolet: [148, 0, 211, 1],
    deeppink: [255, 20, 147, 1],
    deepskyblue: [0, 191, 255, 1],
    dimgray: [105, 105, 105, 1],
    dimgrey: [105, 105, 105, 1],
    dodgerblue: [30, 144, 255, 1],
    firebrick: [178, 34, 34, 1],
    floralwhite: [255, 250, 240, 1],
    forestgreen: [34, 139, 34, 1],
    fuchsia: [255, 0, 255, 1],
    gainsboro: [220, 220, 220, 1],
    ghostwhite: [248, 248, 255, 1],
    gold: [255, 215, 0, 1],
    goldenrod: [218, 165, 32, 1],
    gray: [128, 128, 128, 1],
    green: [0, 128, 0, 1],
    greenyellow: [173, 255, 47, 1],
    grey: [128, 128, 128, 1],
    honeydew: [240, 255, 240, 1],
    hotpink: [255, 105, 180, 1],
    indianred: [205, 92, 92, 1],
    indigo: [75, 0, 130, 1],
    ivory: [255, 255, 240, 1],
    khaki: [240, 230, 140, 1],
    lavender: [230, 230, 250, 1],
    lavenderblush: [255, 240, 245, 1],
    lawngreen: [124, 252, 0, 1],
    lemonchiffon: [255, 250, 205, 1],
    lightblue: [173, 216, 230, 1],
    lightcoral: [240, 128, 128, 1],
    lightcyan: [224, 255, 255, 1],
    lightgoldenrodyellow: [250, 250, 210, 1],
    lightgray: [211, 211, 211, 1],
    lightgreen: [144, 238, 144, 1],
    lightgrey: [211, 211, 211, 1],
    lightpink: [255, 182, 193, 1],
    lightsalmon: [255, 160, 122, 1],
    lightseagreen: [32, 178, 170, 1],
    lightskyblue: [135, 206, 250, 1],
    lightslategray: [119, 136, 153, 1],
    lightslategrey: [119, 136, 153, 1],
    lightsteelblue: [176, 196, 222, 1],
    lightyellow: [255, 255, 224, 1],
    lime: [0, 255, 0, 1],
    limegreen: [50, 205, 50, 1],
    linen: [250, 240, 230, 1],
    magenta: [255, 0, 255, 1],
    maroon: [128, 0, 0, 1],
    mediumaquamarine: [102, 205, 170, 1],
    mediumblue: [0, 0, 205, 1],
    mediumorchid: [186, 85, 211, 1],
    mediumpurple: [147, 112, 219, 1],
    mediumseagreen: [60, 179, 113, 1],
    mediumslateblue: [123, 104, 238, 1],
    mediumspringgreen: [0, 250, 154, 1],
    mediumturquoise: [72, 209, 204, 1],
    mediumvioletred: [199, 21, 133, 1],
    midnightblue: [25, 25, 112, 1],
    mintcream: [245, 255, 250, 1],
    mistyrose: [255, 228, 225, 1],
    moccasin: [255, 228, 181, 1],
    navajowhite: [255, 222, 173, 1],
    navy: [0, 0, 128, 1],
    oldlace: [253, 245, 230, 1],
    olive: [128, 128, 0, 1],
    olivedrab: [107, 142, 35, 1],
    orange: [255, 165, 0, 1],
    orangered: [255, 69, 0, 1],
    orchid: [218, 112, 214, 1],
    palegoldenrod: [238, 232, 170, 1],
    palegreen: [152, 251, 152, 1],
    paleturquoise: [175, 238, 238, 1],
    palevioletred: [219, 112, 147, 1],
    papayawhip: [255, 239, 213, 1],
    peachpuff: [255, 218, 185, 1],
    peru: [205, 133, 63, 1],
    pink: [255, 192, 203, 1],
    plum: [221, 160, 221, 1],
    powderblue: [176, 224, 230, 1],
    purple: [128, 0, 128, 1],
    red: [255, 0, 0, 1],
    rosybrown: [188, 143, 143, 1],
    royalblue: [65, 105, 225, 1],
    saddlebrown: [139, 69, 19, 1],
    salmon: [250, 128, 114, 1],
    sandybrown: [244, 164, 96, 1],
    seagreen: [46, 139, 87, 1],
    seashell: [255, 245, 238, 1],
    sienna: [160, 82, 45, 1],
    silver: [192, 192, 192, 1],
    skyblue: [135, 206, 235, 1],
    slateblue: [106, 90, 205, 1],
    slategray: [112, 128, 144, 1],
    slategrey: [112, 128, 144, 1],
    snow: [255, 250, 250, 1],
    springgreen: [0, 255, 127, 1],
    steelblue: [70, 130, 180, 1],
    tan: [210, 180, 140, 1],
    teal: [0, 128, 128, 1],
    thistle: [216, 191, 216, 1],
    tomato: [255, 99, 71, 1],
    turquoise: [64, 224, 208, 1],
    violet: [238, 130, 238, 1],
    wheat: [245, 222, 179, 1],
    white: [255, 255, 255, 1],
    whitesmoke: [245, 245, 245, 1],
    yellow: [255, 255, 0, 1],
    yellowgreen: [154, 205, 50, 1]
  }
  function clampCssByte (i) {
    i = Math.round(i)
    return i < 0 ? 0 : i > 255 ? 255 : i
  }
  function clampCssAngle (i) {
    i = Math.round(i)
    return i < 0 ? 0 : i > 360 ? 360 : i
  }
  function clampCssFloat (f) {
    return f < 0 ? 0 : f > 1 ? 1 : f
  }
  function parseCssInt (val) {
    const str = val
    if (str.length && str.charAt(str.length - 1) === '%') {
      return clampCssByte(parseFloat(str) / 100 * 255)
    }
    return clampCssByte(parseInt(str, 10))
  }
  function parseCssFloat (val) {
    const str = val
    if (str.length && str.charAt(str.length - 1) === '%') {
      return clampCssFloat(parseFloat(str) / 100)
    }
    return clampCssFloat(parseFloat(str))
  }
  function cssHueToRgb (m1, m2, h) {
    if (h < 0) {
      h += 1
    } else if (h > 1) {
      h -= 1
    }
    if (h * 6 < 1) {
      return m1 + (m2 - m1) * h * 6
    }
    if (h * 2 < 1) {
      return m2
    }
    if (h * 3 < 2) {
      return m1 + (m2 - m1) * (2 / 3 - h) * 6
    }
    return m1
  }
  function lerpNumber (a, b, p) {
    return a + (b - a) * p
  }
  function setRgba (out, r, g, b, a) {
    out[0] = r
    out[1] = g
    out[2] = b
    out[3] = a
    return out
  }
  function copyRgba (out, a) {
    out[0] = a[0]
    out[1] = a[1]
    out[2] = a[2]
    out[3] = a[3]
    return out
  }
  const colorCache = new LRU(20)
  let lastRemovedArr = null
  function putToCache (colorStr, rgbaArr) {
    if (lastRemovedArr) {
      copyRgba(lastRemovedArr, rgbaArr)
    }
    lastRemovedArr = colorCache.put(colorStr, lastRemovedArr || (rgbaArr.slice()))
  }
  function parse (colorStr, rgbaArr) {
    if (!colorStr) {
      return
    }
    rgbaArr = rgbaArr || []
    const cached = colorCache.get(colorStr)
    if (cached) {
      return copyRgba(rgbaArr, cached)
    }
    colorStr = colorStr + ''
    const str = colorStr.replace(/ /g, '').toLowerCase()
    if (str in kCSSColorTable) {
      copyRgba(rgbaArr, kCSSColorTable[str])
      putToCache(colorStr, rgbaArr)
      return rgbaArr
    }
    const strLen = str.length
    if (str.charAt(0) === '#') {
      if (strLen === 4 || strLen === 5) {
        var iv = parseInt(str.slice(1, 4), 16)
        if (!(iv >= 0 && iv <= 0xfff)) {
          setRgba(rgbaArr, 0, 0, 0, 1)
          return
        }
        setRgba(rgbaArr, ((iv & 0xf00) >> 4) | ((iv & 0xf00) >> 8), (iv & 0xf0) | ((iv & 0xf0) >> 4), (iv & 0xf) | ((iv & 0xf) << 4), strLen === 5 ? parseInt(str.slice(4), 16) / 0xf : 1)
        putToCache(colorStr, rgbaArr)
        return rgbaArr
      } else if (strLen === 7 || strLen === 9) {
        var iv = parseInt(str.slice(1, 7), 16)
        if (!(iv >= 0 && iv <= 0xffffff)) {
          setRgba(rgbaArr, 0, 0, 0, 1)
          return
        }
        setRgba(rgbaArr, (iv & 0xff0000) >> 16, (iv & 0xff00) >> 8, iv & 0xff, strLen === 9 ? parseInt(str.slice(7), 16) / 0xff : 1)
        putToCache(colorStr, rgbaArr)
        return rgbaArr
      }
      return
    }
    const op = str.indexOf('(')
    const ep = str.indexOf(')')
    if (op !== -1 && ep + 1 === strLen) {
      const fname = str.substr(0, op)
      const params = str.substr(op + 1, ep - (op + 1)).split(',')
      let alpha = 1
      switch (fname) {
        case 'rgba':
          if (params.length !== 4) {
            return params.length === 3
              ? setRgba(rgbaArr, +params[0], +params[1], +params[2], 1)
              : setRgba(rgbaArr, 0, 0, 0, 1)
          }
          alpha = parseCssFloat(params.pop())
        case 'rgb':
          if (params.length !== 3) {
            setRgba(rgbaArr, 0, 0, 0, 1)
            return
          }
          setRgba(rgbaArr, parseCssInt(params[0]), parseCssInt(params[1]), parseCssInt(params[2]), alpha)
          putToCache(colorStr, rgbaArr)
          return rgbaArr
        case 'hsla':
          if (params.length !== 4) {
            setRgba(rgbaArr, 0, 0, 0, 1)
            return
          }
          params[3] = parseCssFloat(params[3])
          hsla2rgba(params, rgbaArr)
          putToCache(colorStr, rgbaArr)
          return rgbaArr
        case 'hsl':
          if (params.length !== 3) {
            setRgba(rgbaArr, 0, 0, 0, 1)
            return
          }
          hsla2rgba(params, rgbaArr)
          putToCache(colorStr, rgbaArr)
          return rgbaArr
        default:
          return
      }
    }
    setRgba(rgbaArr, 0, 0, 0, 1)
  }
  function hsla2rgba (hsla, rgba) {
    const h = (((parseFloat(hsla[0]) % 360) + 360) % 360) / 360
    const s = parseCssFloat(hsla[1])
    const l = parseCssFloat(hsla[2])
    const m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s
    const m1 = l * 2 - m2
    rgba = rgba || []
    setRgba(rgba, clampCssByte(cssHueToRgb(m1, m2, h + 1 / 3) * 255), clampCssByte(cssHueToRgb(m1, m2, h) * 255), clampCssByte(cssHueToRgb(m1, m2, h - 1 / 3) * 255), 1)
    if (hsla.length === 4) {
      rgba[3] = hsla[3]
    }
    return rgba
  }
  function rgba2hsla (rgba) {
    if (!rgba) {
      return
    }
    const R = rgba[0] / 255
    const G = rgba[1] / 255
    const B = rgba[2] / 255
    const vMin = Math.min(R, G, B)
    const vMax = Math.max(R, G, B)
    const delta = vMax - vMin
    const L = (vMax + vMin) / 2
    let H
    let S
    if (delta === 0) {
      H = 0
      S = 0
    } else {
      if (L < 0.5) {
        S = delta / (vMax + vMin)
      } else {
        S = delta / (2 - vMax - vMin)
      }
      const deltaR = (((vMax - R) / 6) + (delta / 2)) / delta
      const deltaG = (((vMax - G) / 6) + (delta / 2)) / delta
      const deltaB = (((vMax - B) / 6) + (delta / 2)) / delta
      if (R === vMax) {
        H = deltaB - deltaG
      } else if (G === vMax) {
        H = (1 / 3) + deltaR - deltaB
      } else if (B === vMax) {
        H = (2 / 3) + deltaG - deltaR
      }
      if (H < 0) {
        H += 1
      }
      if (H > 1) {
        H -= 1
      }
    }
    const hsla = [H * 360, S, L]
    if (rgba[3] != null) {
      hsla.push(rgba[3])
    }
    return hsla
  }
  function lift (color, level) {
    const colorArr = parse(color)
    if (colorArr) {
      for (let i = 0; i < 3; i++) {
        if (level < 0) {
          colorArr[i] = colorArr[i] * (1 - level) | 0
        } else {
          colorArr[i] = ((255 - colorArr[i]) * level + colorArr[i]) | 0
        }
        if (colorArr[i] > 255) {
          colorArr[i] = 255
        } else if (colorArr[i] < 0) {
          colorArr[i] = 0
        }
      }
      return stringify(colorArr, colorArr.length === 4 ? 'rgba' : 'rgb')
    }
  }
  function toHex (color) {
    const colorArr = parse(color)
    if (colorArr) {
      return ((1 << 24) + (colorArr[0] << 16) + (colorArr[1] << 8) + (+colorArr[2])).toString(16).slice(1)
    }
  }
  function fastLerp (normalizedValue, colors, out) {
    if (!(colors && colors.length) ||
            !(normalizedValue >= 0 && normalizedValue <= 1)) {
      return
    }
    out = out || []
    const value = normalizedValue * (colors.length - 1)
    const leftIndex = Math.floor(value)
    const rightIndex = Math.ceil(value)
    const leftColor = colors[leftIndex]
    const rightColor = colors[rightIndex]
    const dv = value - leftIndex
    out[0] = clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv))
    out[1] = clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv))
    out[2] = clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv))
    out[3] = clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv))
    return out
  }
  const fastMapToColor = fastLerp
  function lerp$1 (normalizedValue, colors, fullOutput) {
    if (!(colors && colors.length) ||
            !(normalizedValue >= 0 && normalizedValue <= 1)) {
      return
    }
    const value = normalizedValue * (colors.length - 1)
    const leftIndex = Math.floor(value)
    const rightIndex = Math.ceil(value)
    const leftColor = parse(colors[leftIndex])
    const rightColor = parse(colors[rightIndex])
    const dv = value - leftIndex
    const color = stringify([
      clampCssByte(lerpNumber(leftColor[0], rightColor[0], dv)),
      clampCssByte(lerpNumber(leftColor[1], rightColor[1], dv)),
      clampCssByte(lerpNumber(leftColor[2], rightColor[2], dv)),
      clampCssFloat(lerpNumber(leftColor[3], rightColor[3], dv))
    ], 'rgba')
    return fullOutput
      ? {
          color: color,
          leftIndex: leftIndex,
          rightIndex: rightIndex,
          value: value
        }
      : color
  }
  const mapToColor = lerp$1
  function modifyHSL (color, h, s, l) {
    let colorArr = parse(color)
    if (color) {
      colorArr = rgba2hsla(colorArr)
      h != null && (colorArr[0] = clampCssAngle(h))
      s != null && (colorArr[1] = parseCssFloat(s))
      l != null && (colorArr[2] = parseCssFloat(l))
      return stringify(hsla2rgba(colorArr), 'rgba')
    }
  }
  function modifyAlpha (color, alpha) {
    const colorArr = parse(color)
    if (colorArr && alpha != null) {
      colorArr[3] = clampCssFloat(alpha)
      return stringify(colorArr, 'rgba')
    }
  }
  function stringify (arrColor, type) {
    if (!arrColor || !arrColor.length) {
      return
    }
    let colorStr = arrColor[0] + ',' + arrColor[1] + ',' + arrColor[2]
    if (type === 'rgba' || type === 'hsva' || type === 'hsla') {
      colorStr += ',' + arrColor[3]
    }
    return type + '(' + colorStr + ')'
  }
  function lum (color, backgroundLum) {
    const arr = parse(color)
    return arr
      ? (0.299 * arr[0] + 0.587 * arr[1] + 0.114 * arr[2]) * arr[3] / 255 +
                (1 - arr[3]) * backgroundLum
      : 0
  }
  function random () {
    return stringify([
      Math.round(Math.random() * 255),
      Math.round(Math.random() * 255),
      Math.round(Math.random() * 255)
    ], 'rgb')
  }

  const color = /* #__PURE__ */Object.freeze({
    __proto__: null,
    parse: parse,
    lift: lift,
    toHex: toHex,
    fastLerp: fastLerp,
    fastMapToColor: fastMapToColor,
    lerp: lerp$1,
    mapToColor: mapToColor,
    modifyHSL: modifyHSL,
    modifyAlpha: modifyAlpha,
    stringify: stringify,
    lum: lum,
    random: random
  })

  const mathRound = Math.round
  function normalizeColor (color) {
    let opacity
    if (!color || color === 'transparent') {
      color = 'none'
    } else if (typeof color === 'string' && color.indexOf('rgba') > -1) {
      const arr = parse(color)
      if (arr) {
        color = 'rgb(' + arr[0] + ',' + arr[1] + ',' + arr[2] + ')'
        opacity = arr[3]
      }
    }
    return {
      color: color,
      opacity: opacity == null ? 1 : opacity
    }
  }
  const EPSILON$1 = 1e-4
  function isAroundZero$1 (transform) {
    return transform < EPSILON$1 && transform > -EPSILON$1
  }
  function round3 (transform) {
    return mathRound(transform * 1e3) / 1e3
  }
  function round4 (transform) {
    return mathRound(transform * 1e4) / 1e4
  }
  function getMatrixStr (m) {
    return 'matrix(' +
            round3(m[0]) + ',' +
            round3(m[1]) + ',' +
            round3(m[2]) + ',' +
            round3(m[3]) + ',' +
            round4(m[4]) + ',' +
            round4(m[5]) +
            ')'
  }
  const TEXT_ALIGN_TO_ANCHOR = {
    left: 'start',
    right: 'end',
    center: 'middle',
    middle: 'middle'
  }
  function adjustTextY (y, lineHeight, textBaseline) {
    if (textBaseline === 'top') {
      y += lineHeight / 2
    } else if (textBaseline === 'bottom') {
      y -= lineHeight / 2
    }
    return y
  }
  function hasShadow (style) {
    return style &&
            (style.shadowBlur || style.shadowOffsetX || style.shadowOffsetY)
  }
  function getShadowKey (displayable) {
    const style = displayable.style
    const globalScale = displayable.getGlobalScale()
    return [
      style.shadowColor,
      (style.shadowBlur || 0).toFixed(2),
      (style.shadowOffsetX || 0).toFixed(2),
      (style.shadowOffsetY || 0).toFixed(2),
      globalScale[0],
      globalScale[1]
    ].join(',')
  }
  function isImagePattern (val) {
    return val && (!!val.image)
  }
  function isSVGPattern (val) {
    return val && (!!val.svgElement)
  }
  function isPattern (val) {
    return isImagePattern(val) || isSVGPattern(val)
  }
  function isLinearGradient (val) {
    return val.type === 'linear'
  }
  function isRadialGradient (val) {
    return val.type === 'radial'
  }
  function isGradient (val) {
    return val && (val.type === 'linear' ||
            val.type === 'radial')
  }
  function getIdURL (id) {
    return 'url(#' + id + ')'
  }
  function getPathPrecision (el) {
    const scale = el.getGlobalScale()
    const size = Math.max(scale[0], scale[1])
    return Math.max(Math.ceil(Math.log(size) / Math.log(10)), 1)
  }
  function getSRTTransformString (transform) {
    const x = transform.x || 0
    const y = transform.y || 0
    const rotation = (transform.rotation || 0) * RADIAN_TO_DEGREE
    const scaleX = retrieve2(transform.scaleX, 1)
    const scaleY = retrieve2(transform.scaleY, 1)
    const skewX = transform.skewX || 0
    const skewY = transform.skewY || 0
    const res = []
    if (x || y) {
      res.push('translate(' + x + 'px,' + y + 'px)')
    }
    if (rotation) {
      res.push('rotate(' + rotation + ')')
    }
    if (scaleX !== 1 || scaleY !== 1) {
      res.push('scale(' + scaleX + ',' + scaleY + ')')
    }
    if (skewX || skewY) {
      res.push('skew(' + mathRound(skewX * RADIAN_TO_DEGREE) + 'deg, ' + mathRound(skewY * RADIAN_TO_DEGREE) + 'deg)')
    }
    return res.join(' ')
  }
  const encodeBase64 = (function () {
    if (env.hasGlobalWindow && isFunction(window.btoa)) {
      return function (str) {
        return window.btoa(unescape(str))
      }
    }
    if (typeof Buffer !== 'undefined') {
      return function (str) {
        return Buffer.from(str).toString('base64')
      }
    }
    return function (str) {
      if ('development' !== 'production') {
        logError('Base64 isn\'t natively supported in the current environment.')
      }
      return null
    }
  })()

  const arraySlice = Array.prototype.slice
  function interpolateNumber (p0, p1, percent) {
    return (p1 - p0) * percent + p0
  }
  function interpolate1DArray (out, p0, p1, percent) {
    const len = p0.length
    for (let i = 0; i < len; i++) {
      out[i] = interpolateNumber(p0[i], p1[i], percent)
    }
    return out
  }
  function interpolate2DArray (out, p0, p1, percent) {
    const len = p0.length
    const len2 = len && p0[0].length
    for (let i = 0; i < len; i++) {
      if (!out[i]) {
        out[i] = []
      }
      for (let j = 0; j < len2; j++) {
        out[i][j] = interpolateNumber(p0[i][j], p1[i][j], percent)
      }
    }
    return out
  }
  function add1DArray (out, p0, p1, sign) {
    const len = p0.length
    for (let i = 0; i < len; i++) {
      out[i] = p0[i] + p1[i] * sign
    }
    return out
  }
  function add2DArray (out, p0, p1, sign) {
    const len = p0.length
    const len2 = len && p0[0].length
    for (let i = 0; i < len; i++) {
      if (!out[i]) {
        out[i] = []
      }
      for (let j = 0; j < len2; j++) {
        out[i][j] = p0[i][j] + p1[i][j] * sign
      }
    }
    return out
  }
  function fillColorStops (val0, val1) {
    const len0 = val0.length
    const len1 = val1.length
    const shorterArr = len0 > len1 ? val1 : val0
    const shorterLen = Math.min(len0, len1)
    const last = shorterArr[shorterLen - 1] || { color: [0, 0, 0, 0], offset: 0 }
    for (let i = shorterLen; i < Math.max(len0, len1); i++) {
      shorterArr.push({
        offset: last.offset,
        color: last.color.slice()
      })
    }
  }
  function fillArray (val0, val1, arrDim) {
    const arr0 = val0
    const arr1 = val1
    if (!arr0.push || !arr1.push) {
      return
    }
    const arr0Len = arr0.length
    const arr1Len = arr1.length
    if (arr0Len !== arr1Len) {
      const isPreviousLarger = arr0Len > arr1Len
      if (isPreviousLarger) {
        arr0.length = arr1Len
      } else {
        for (var i = arr0Len; i < arr1Len; i++) {
          arr0.push(arrDim === 1 ? arr1[i] : arraySlice.call(arr1[i]))
        }
      }
    }
    const len2 = arr0[0] && arr0[0].length
    for (var i = 0; i < arr0.length; i++) {
      if (arrDim === 1) {
        if (isNaN(arr0[i])) {
          arr0[i] = arr1[i]
        }
      } else {
        for (let j = 0; j < len2; j++) {
          if (isNaN(arr0[i][j])) {
            arr0[i][j] = arr1[i][j]
          }
        }
      }
    }
  }
  function cloneValue (value) {
    if (isArrayLike(value)) {
      const len = value.length
      if (isArrayLike(value[0])) {
        const ret = []
        for (let i = 0; i < len; i++) {
          ret.push(arraySlice.call(value[i]))
        }
        return ret
      }
      return arraySlice.call(value)
    }
    return value
  }
  function rgba2String (rgba) {
    rgba[0] = Math.floor(rgba[0]) || 0
    rgba[1] = Math.floor(rgba[1]) || 0
    rgba[2] = Math.floor(rgba[2]) || 0
    rgba[3] = rgba[3] == null ? 1 : rgba[3]
    return 'rgba(' + rgba.join(',') + ')'
  }
  function guessArrayDim (value) {
    return isArrayLike(value && value[0]) ? 2 : 1
  }
  const VALUE_TYPE_NUMBER = 0
  const VALUE_TYPE_1D_ARRAY = 1
  const VALUE_TYPE_2D_ARRAY = 2
  const VALUE_TYPE_COLOR = 3
  const VALUE_TYPE_LINEAR_GRADIENT = 4
  const VALUE_TYPE_RADIAL_GRADIENT = 5
  const VALUE_TYPE_UNKOWN = 6
  function isGradientValueType (valType) {
    return valType === VALUE_TYPE_LINEAR_GRADIENT || valType === VALUE_TYPE_RADIAL_GRADIENT
  }
  function isArrayValueType (valType) {
    return valType === VALUE_TYPE_1D_ARRAY || valType === VALUE_TYPE_2D_ARRAY
  }
  const tmpRgba = [0, 0, 0, 0]
  const Track = (function () {
    function Track (propName) {
      this.keyframes = []
      this.discrete = false
      this._invalid = false
      this._needsSort = false
      this._lastFr = 0
      this._lastFrP = 0
      this.propName = propName
    }
    Track.prototype.isFinished = function () {
      return this._finished
    }
    Track.prototype.setFinished = function () {
      this._finished = true
      if (this._additiveTrack) {
        this._additiveTrack.setFinished()
      }
    }
    Track.prototype.needsAnimate = function () {
      return this.keyframes.length >= 1
    }
    Track.prototype.getAdditiveTrack = function () {
      return this._additiveTrack
    }
    Track.prototype.addKeyframe = function (time, rawValue, easing) {
      this._needsSort = true
      const keyframes = this.keyframes
      const len = keyframes.length
      let discrete = false
      let valType = VALUE_TYPE_UNKOWN
      let value = rawValue
      if (isArrayLike(rawValue)) {
        const arrayDim = guessArrayDim(rawValue)
        valType = arrayDim
        if (arrayDim === 1 && !isNumber(rawValue[0]) ||
                    arrayDim === 2 && !isNumber(rawValue[0][0])) {
          discrete = true
        }
      } else {
        if (isNumber(rawValue) && !eqNaN(rawValue)) {
          valType = VALUE_TYPE_NUMBER
        } else if (isString(rawValue)) {
          if (!isNaN(+rawValue)) {
            valType = VALUE_TYPE_NUMBER
          } else {
            const colorArray = parse(rawValue)
            if (colorArray) {
              value = colorArray
              valType = VALUE_TYPE_COLOR
            }
          }
        } else if (isGradientObject(rawValue)) {
          const parsedGradient = extend({}, value)
          parsedGradient.colorStops = map(rawValue.colorStops, function (colorStop) {
            return ({
              offset: colorStop.offset,
              color: parse(colorStop.color)
            })
          })
          if (isLinearGradient(rawValue)) {
            valType = VALUE_TYPE_LINEAR_GRADIENT
          } else if (isRadialGradient(rawValue)) {
            valType = VALUE_TYPE_RADIAL_GRADIENT
          }
          value = parsedGradient
        }
      }
      if (len === 0) {
        this.valType = valType
      } else if (valType !== this.valType || valType === VALUE_TYPE_UNKOWN) {
        discrete = true
      }
      this.discrete = this.discrete || discrete
      const kf = {
        time: time,
        value: value,
        rawValue: rawValue,
        percent: 0
      }
      if (easing) {
        kf.easing = easing
        kf.easingFunc = isFunction(easing)
          ? easing
          : easingFuncs[easing] || createCubicEasingFunc(easing)
      }
      keyframes.push(kf)
      return kf
    }
    Track.prototype.prepare = function (maxTime, additiveTrack) {
      const kfs = this.keyframes
      if (this._needsSort) {
        kfs.sort(function (a, b) {
          return a.time - b.time
        })
      }
      const valType = this.valType
      const kfsLen = kfs.length
      const lastKf = kfs[kfsLen - 1]
      const isDiscrete = this.discrete
      const isArr = isArrayValueType(valType)
      const isGradient = isGradientValueType(valType)
      for (var i = 0; i < kfsLen; i++) {
        const kf = kfs[i]
        const value = kf.value
        const lastValue = lastKf.value
        kf.percent = kf.time / maxTime
        if (!isDiscrete) {
          if (isArr && i !== kfsLen - 1) {
            fillArray(value, lastValue, valType)
          } else if (isGradient) {
            fillColorStops(value.colorStops, lastValue.colorStops)
          }
        }
      }
      if (!isDiscrete &&
                valType !== VALUE_TYPE_RADIAL_GRADIENT &&
                additiveTrack &&
                this.needsAnimate() &&
                additiveTrack.needsAnimate() &&
                valType === additiveTrack.valType &&
                !additiveTrack._finished) {
        this._additiveTrack = additiveTrack
        const startValue = kfs[0].value
        for (var i = 0; i < kfsLen; i++) {
          if (valType === VALUE_TYPE_NUMBER) {
            kfs[i].additiveValue = kfs[i].value - startValue
          } else if (valType === VALUE_TYPE_COLOR) {
            kfs[i].additiveValue =
                            add1DArray([], kfs[i].value, startValue, -1)
          } else if (isArrayValueType(valType)) {
            kfs[i].additiveValue = valType === VALUE_TYPE_1D_ARRAY
              ? add1DArray([], kfs[i].value, startValue, -1)
              : add2DArray([], kfs[i].value, startValue, -1)
          }
        }
      }
    }
    Track.prototype.step = function (target, percent) {
      if (this._finished) {
        return
      }
      if (this._additiveTrack && this._additiveTrack._finished) {
        this._additiveTrack = null
      }
      const isAdditive = this._additiveTrack != null
      const valueKey = isAdditive ? 'additiveValue' : 'value'
      const valType = this.valType
      const keyframes = this.keyframes
      const kfsNum = keyframes.length
      const propName = this.propName
      const isValueColor = valType === VALUE_TYPE_COLOR
      let frameIdx
      const lastFrame = this._lastFr
      const mathMin = Math.min
      let frame
      let nextFrame
      if (kfsNum === 1) {
        frame = nextFrame = keyframes[0]
      } else {
        if (percent < 0) {
          frameIdx = 0
        } else if (percent < this._lastFrP) {
          const start = mathMin(lastFrame + 1, kfsNum - 1)
          for (frameIdx = start; frameIdx >= 0; frameIdx--) {
            if (keyframes[frameIdx].percent <= percent) {
              break
            }
          }
          frameIdx = mathMin(frameIdx, kfsNum - 2)
        } else {
          for (frameIdx = lastFrame; frameIdx < kfsNum; frameIdx++) {
            if (keyframes[frameIdx].percent > percent) {
              break
            }
          }
          frameIdx = mathMin(frameIdx - 1, kfsNum - 2)
        }
        nextFrame = keyframes[frameIdx + 1]
        frame = keyframes[frameIdx]
      }
      if (!(frame && nextFrame)) {
        return
      }
      this._lastFr = frameIdx
      this._lastFrP = percent
      const interval = (nextFrame.percent - frame.percent)
      let w = interval === 0 ? 1 : mathMin((percent - frame.percent) / interval, 1)
      if (nextFrame.easingFunc) {
        w = nextFrame.easingFunc(w)
      }
      let targetArr = isAdditive
        ? this._additiveValue
        : (isValueColor ? tmpRgba : target[propName])
      if ((isArrayValueType(valType) || isValueColor) && !targetArr) {
        targetArr = this._additiveValue = []
      }
      if (this.discrete) {
        target[propName] = w < 1 ? frame.rawValue : nextFrame.rawValue
      } else if (isArrayValueType(valType)) {
        valType === VALUE_TYPE_1D_ARRAY
          ? interpolate1DArray(targetArr, frame[valueKey], nextFrame[valueKey], w)
          : interpolate2DArray(targetArr, frame[valueKey], nextFrame[valueKey], w)
      } else if (isGradientValueType(valType)) {
        const val = frame[valueKey]
        const nextVal_1 = nextFrame[valueKey]
        const isLinearGradient_1 = valType === VALUE_TYPE_LINEAR_GRADIENT
        target[propName] = {
          type: isLinearGradient_1 ? 'linear' : 'radial',
          x: interpolateNumber(val.x, nextVal_1.x, w),
          y: interpolateNumber(val.y, nextVal_1.y, w),
          colorStops: map(val.colorStops, function (colorStop, idx) {
            const nextColorStop = nextVal_1.colorStops[idx]
            return {
              offset: interpolateNumber(colorStop.offset, nextColorStop.offset, w),
              color: rgba2String(interpolate1DArray([], colorStop.color, nextColorStop.color, w))
            }
          }),
          global: nextVal_1.global
        }
        if (isLinearGradient_1) {
          target[propName].x2 = interpolateNumber(val.x2, nextVal_1.x2, w)
          target[propName].y2 = interpolateNumber(val.y2, nextVal_1.y2, w)
        } else {
          target[propName].r = interpolateNumber(val.r, nextVal_1.r, w)
        }
      } else if (isValueColor) {
        interpolate1DArray(targetArr, frame[valueKey], nextFrame[valueKey], w)
        if (!isAdditive) {
          target[propName] = rgba2String(targetArr)
        }
      } else {
        const value = interpolateNumber(frame[valueKey], nextFrame[valueKey], w)
        if (isAdditive) {
          this._additiveValue = value
        } else {
          target[propName] = value
        }
      }
      if (isAdditive) {
        this._addToTarget(target)
      }
    }
    Track.prototype._addToTarget = function (target) {
      const valType = this.valType
      const propName = this.propName
      const additiveValue = this._additiveValue
      if (valType === VALUE_TYPE_NUMBER) {
        target[propName] = target[propName] + additiveValue
      } else if (valType === VALUE_TYPE_COLOR) {
        parse(target[propName], tmpRgba)
        add1DArray(tmpRgba, tmpRgba, additiveValue, 1)
        target[propName] = rgba2String(tmpRgba)
      } else if (valType === VALUE_TYPE_1D_ARRAY) {
        add1DArray(target[propName], target[propName], additiveValue, 1)
      } else if (valType === VALUE_TYPE_2D_ARRAY) {
        add2DArray(target[propName], target[propName], additiveValue, 1)
      }
    }
    return Track
  }())
  const Animator = (function () {
    function Animator (target, loop, allowDiscreteAnimation, additiveTo) {
      this._tracks = {}
      this._trackKeys = []
      this._maxTime = 0
      this._started = 0
      this._clip = null
      this._target = target
      this._loop = loop
      if (loop && additiveTo) {
        logError('Can\' use additive animation on looped animation.')
        return
      }
      this._additiveAnimators = additiveTo
      this._allowDiscrete = allowDiscreteAnimation
    }
    Animator.prototype.getMaxTime = function () {
      return this._maxTime
    }
    Animator.prototype.getDelay = function () {
      return this._delay
    }
    Animator.prototype.getLoop = function () {
      return this._loop
    }
    Animator.prototype.getTarget = function () {
      return this._target
    }
    Animator.prototype.changeTarget = function (target) {
      this._target = target
    }
    Animator.prototype.when = function (time, props, easing) {
      return this.whenWithKeys(time, props, keys(props), easing)
    }
    Animator.prototype.whenWithKeys = function (time, props, propNames, easing) {
      const tracks = this._tracks
      for (let i = 0; i < propNames.length; i++) {
        const propName = propNames[i]
        let track = tracks[propName]
        if (!track) {
          track = tracks[propName] = new Track(propName)
          let initialValue = void 0
          const additiveTrack = this._getAdditiveTrack(propName)
          if (additiveTrack) {
            const addtiveTrackKfs = additiveTrack.keyframes
            const lastFinalKf = addtiveTrackKfs[addtiveTrackKfs.length - 1]
            initialValue = lastFinalKf && lastFinalKf.value
            if (additiveTrack.valType === VALUE_TYPE_COLOR && initialValue) {
              initialValue = rgba2String(initialValue)
            }
          } else {
            initialValue = this._target[propName]
          }
          if (initialValue == null) {
            continue
          }
          if (time > 0) {
            track.addKeyframe(0, cloneValue(initialValue), easing)
          }
          this._trackKeys.push(propName)
        }
        track.addKeyframe(time, cloneValue(props[propName]), easing)
      }
      this._maxTime = Math.max(this._maxTime, time)
      return this
    }
    Animator.prototype.pause = function () {
      this._clip.pause()
      this._paused = true
    }
    Animator.prototype.resume = function () {
      this._clip.resume()
      this._paused = false
    }
    Animator.prototype.isPaused = function () {
      return !!this._paused
    }
    Animator.prototype.duration = function (duration) {
      this._maxTime = duration
      this._force = true
      return this
    }
    Animator.prototype._doneCallback = function () {
      this._setTracksFinished()
      this._clip = null
      const doneList = this._doneCbs
      if (doneList) {
        const len = doneList.length
        for (let i = 0; i < len; i++) {
          doneList[i].call(this)
        }
      }
    }
    Animator.prototype._abortedCallback = function () {
      this._setTracksFinished()
      const animation = this.animation
      const abortedList = this._abortedCbs
      if (animation) {
        animation.removeClip(this._clip)
      }
      this._clip = null
      if (abortedList) {
        for (let i = 0; i < abortedList.length; i++) {
          abortedList[i].call(this)
        }
      }
    }
    Animator.prototype._setTracksFinished = function () {
      const tracks = this._tracks
      const tracksKeys = this._trackKeys
      for (let i = 0; i < tracksKeys.length; i++) {
        tracks[tracksKeys[i]].setFinished()
      }
    }
    Animator.prototype._getAdditiveTrack = function (trackName) {
      let additiveTrack
      const additiveAnimators = this._additiveAnimators
      if (additiveAnimators) {
        for (let i = 0; i < additiveAnimators.length; i++) {
          const track = additiveAnimators[i].getTrack(trackName)
          if (track) {
            additiveTrack = track
          }
        }
      }
      return additiveTrack
    }
    Animator.prototype.start = function (easing) {
      if (this._started > 0) {
        return
      }
      this._started = 1
      const self = this
      const tracks = []
      const maxTime = this._maxTime || 0
      for (let i = 0; i < this._trackKeys.length; i++) {
        const propName = this._trackKeys[i]
        const track = this._tracks[propName]
        const additiveTrack = this._getAdditiveTrack(propName)
        const kfs = track.keyframes
        const kfsNum = kfs.length
        track.prepare(maxTime, additiveTrack)
        if (track.needsAnimate()) {
          if (!this._allowDiscrete && track.discrete) {
            const lastKf = kfs[kfsNum - 1]
            if (lastKf) {
              self._target[track.propName] = lastKf.rawValue
            }
            track.setFinished()
          } else {
            tracks.push(track)
          }
        }
      }
      if (tracks.length || this._force) {
        const clip = new Clip({
          life: maxTime,
          loop: this._loop,
          delay: this._delay || 0,
          onframe: function (percent) {
            self._started = 2
            const additiveAnimators = self._additiveAnimators
            if (additiveAnimators) {
              let stillHasAdditiveAnimator = false
              for (var i = 0; i < additiveAnimators.length; i++) {
                if (additiveAnimators[i]._clip) {
                  stillHasAdditiveAnimator = true
                  break
                }
              }
              if (!stillHasAdditiveAnimator) {
                self._additiveAnimators = null
              }
            }
            for (var i = 0; i < tracks.length; i++) {
              tracks[i].step(self._target, percent)
            }
            const onframeList = self._onframeCbs
            if (onframeList) {
              for (var i = 0; i < onframeList.length; i++) {
                onframeList[i](self._target, percent)
              }
            }
          },
          ondestroy: function () {
            self._doneCallback()
          }
        })
        this._clip = clip
        if (this.animation) {
          this.animation.addClip(clip)
        }
        if (easing) {
          clip.setEasing(easing)
        }
      } else {
        this._doneCallback()
      }
      return this
    }
    Animator.prototype.stop = function (forwardToLast) {
      if (!this._clip) {
        return
      }
      const clip = this._clip
      if (forwardToLast) {
        clip.onframe(1)
      }
      this._abortedCallback()
    }
    Animator.prototype.delay = function (time) {
      this._delay = time
      return this
    }
    Animator.prototype.during = function (cb) {
      if (cb) {
        if (!this._onframeCbs) {
          this._onframeCbs = []
        }
        this._onframeCbs.push(cb)
      }
      return this
    }
    Animator.prototype.done = function (cb) {
      if (cb) {
        if (!this._doneCbs) {
          this._doneCbs = []
        }
        this._doneCbs.push(cb)
      }
      return this
    }
    Animator.prototype.aborted = function (cb) {
      if (cb) {
        if (!this._abortedCbs) {
          this._abortedCbs = []
        }
        this._abortedCbs.push(cb)
      }
      return this
    }
    Animator.prototype.getClip = function () {
      return this._clip
    }
    Animator.prototype.getTrack = function (propName) {
      return this._tracks[propName]
    }
    Animator.prototype.getTracks = function () {
      const _this = this
      return map(this._trackKeys, function (key) { return _this._tracks[key] })
    }
    Animator.prototype.stopTracks = function (propNames, forwardToLast) {
      if (!propNames.length || !this._clip) {
        return true
      }
      const tracks = this._tracks
      const tracksKeys = this._trackKeys
      for (var i = 0; i < propNames.length; i++) {
        const track = tracks[propNames[i]]
        if (track && !track.isFinished()) {
          if (forwardToLast) {
            track.step(this._target, 1)
          } else if (this._started === 1) {
            track.step(this._target, 0)
          }
          track.setFinished()
        }
      }
      let allAborted = true
      for (var i = 0; i < tracksKeys.length; i++) {
        if (!tracks[tracksKeys[i]].isFinished()) {
          allAborted = false
          break
        }
      }
      if (allAborted) {
        this._abortedCallback()
      }
      return allAborted
    }
    Animator.prototype.saveTo = function (target, trackKeys, firstOrLast) {
      if (!target) {
        return
      }
      trackKeys = trackKeys || this._trackKeys
      for (let i = 0; i < trackKeys.length; i++) {
        const propName = trackKeys[i]
        const track = this._tracks[propName]
        if (!track || track.isFinished()) {
          continue
        }
        const kfs = track.keyframes
        const kf = kfs[firstOrLast ? 0 : kfs.length - 1]
        if (kf) {
          target[propName] = cloneValue(kf.rawValue)
        }
      }
    }
    Animator.prototype.__changeFinalValue = function (finalProps, trackKeys) {
      trackKeys = trackKeys || keys(finalProps)
      for (let i = 0; i < trackKeys.length; i++) {
        const propName = trackKeys[i]
        const track = this._tracks[propName]
        if (!track) {
          continue
        }
        const kfs = track.keyframes
        if (kfs.length > 1) {
          const lastKf = kfs.pop()
          track.addKeyframe(lastKf.time, finalProps[propName])
          track.prepare(this._maxTime, track.getAdditiveTrack())
        }
      }
    }
    return Animator
  }())

  function getTime () {
    return new Date().getTime()
  }
  const Animation = (function (_super) {
    __extends(Animation, _super)
    function Animation (opts) {
      const _this = _super.call(this) || this
      _this._running = false
      _this._time = 0
      _this._pausedTime = 0
      _this._pauseStart = 0
      _this._paused = false
      opts = opts || {}
      _this.stage = opts.stage || {}
      return _this
    }
    Animation.prototype.addClip = function (clip) {
      if (clip.animation) {
        this.removeClip(clip)
      }
      if (!this._head) {
        this._head = this._tail = clip
      } else {
        this._tail.next = clip
        clip.prev = this._tail
        clip.next = null
        this._tail = clip
      }
      clip.animation = this
    }
    Animation.prototype.addAnimator = function (animator) {
      animator.animation = this
      const clip = animator.getClip()
      if (clip) {
        this.addClip(clip)
      }
    }
    Animation.prototype.removeClip = function (clip) {
      if (!clip.animation) {
        return
      }
      const prev = clip.prev
      const next = clip.next
      if (prev) {
        prev.next = next
      } else {
        this._head = next
      }
      if (next) {
        next.prev = prev
      } else {
        this._tail = prev
      }
      clip.next = clip.prev = clip.animation = null
    }
    Animation.prototype.removeAnimator = function (animator) {
      const clip = animator.getClip()
      if (clip) {
        this.removeClip(clip)
      }
      animator.animation = null
    }
    Animation.prototype.update = function (notTriggerFrameAndStageUpdate) {
      const time = getTime() - this._pausedTime
      const delta = time - this._time
      let clip = this._head
      while (clip) {
        const nextClip = clip.next
        const finished = clip.step(time, delta)
        if (finished) {
          clip.ondestroy()
          this.removeClip(clip)
          clip = nextClip
        } else {
          clip = nextClip
        }
      }
      this._time = time
      if (!notTriggerFrameAndStageUpdate) {
        this.trigger('frame', delta)
        this.stage.update && this.stage.update()
      }
    }
    Animation.prototype._startLoop = function () {
      const self = this
      this._running = true
      function step () {
        if (self._running) {
          requestAnimationFrame$1(step)
          !self._paused && self.update()
        }
      }
      requestAnimationFrame$1(step)
    }
    Animation.prototype.start = function () {
      if (this._running) {
        return
      }
      this._time = getTime()
      this._pausedTime = 0
      this._startLoop()
    }
    Animation.prototype.stop = function () {
      this._running = false
    }
    Animation.prototype.pause = function () {
      if (!this._paused) {
        this._pauseStart = getTime()
        this._paused = true
      }
    }
    Animation.prototype.resume = function () {
      if (this._paused) {
        this._pausedTime += getTime() - this._pauseStart
        this._paused = false
      }
    }
    Animation.prototype.clear = function () {
      let clip = this._head
      while (clip) {
        const nextClip = clip.next
        clip.prev = clip.next = clip.animation = null
        clip = nextClip
      }
      this._head = this._tail = null
    }
    Animation.prototype.isFinished = function () {
      return this._head == null
    }
    Animation.prototype.animate = function (target, options) {
      options = options || {}
      this.start()
      const animator = new Animator(target, options.loop)
      this.addAnimator(animator)
      return animator
    }
    return Animation
  }(Eventful))

  const TOUCH_CLICK_DELAY = 300
  const globalEventSupported = env.domSupported
  const localNativeListenerNames = (function () {
    const mouseHandlerNames = [
      'click', 'dblclick', 'mousewheel', 'wheel', 'mouseout',
      'mouseup', 'mousedown', 'mousemove', 'contextmenu'
    ]
    const touchHandlerNames = [
      'touchstart', 'touchend', 'touchmove'
    ]
    const pointerEventNameMap = {
      pointerdown: 1, pointerup: 1, pointermove: 1, pointerout: 1
    }
    const pointerHandlerNames = map(mouseHandlerNames, function (name) {
      const nm = name.replace('mouse', 'pointer')
      return pointerEventNameMap.hasOwnProperty(nm) ? nm : name
    })
    return {
      mouse: mouseHandlerNames,
      touch: touchHandlerNames,
      pointer: pointerHandlerNames
    }
  })()
  const globalNativeListenerNames = {
    mouse: ['mousemove', 'mouseup'],
    pointer: ['pointermove', 'pointerup']
  }
  let wheelEventSupported = false
  function isPointerFromTouch (event) {
    const pointerType = event.pointerType
    return pointerType === 'pen' || pointerType === 'touch'
  }
  function setTouchTimer (scope) {
    scope.touching = true
    if (scope.touchTimer != null) {
      clearTimeout(scope.touchTimer)
      scope.touchTimer = null
    }
    scope.touchTimer = setTimeout(function () {
      scope.touching = false
      scope.touchTimer = null
    }, 700)
  }
  function markTouch (event) {
    event && (event.zrByTouch = true)
  }
  function normalizeGlobalEvent (instance, event) {
    return normalizeEvent(instance.dom, new FakeGlobalEvent(instance, event), true)
  }
  function isLocalEl (instance, el) {
    let elTmp = el
    let isLocal = false
    while (elTmp && elTmp.nodeType !== 9 &&
            !(isLocal = elTmp.domBelongToZr ||
                (elTmp !== el && elTmp === instance.painterRoot))) {
      elTmp = elTmp.parentNode
    }
    return isLocal
  }
  var FakeGlobalEvent = (function () {
    function FakeGlobalEvent (instance, event) {
      this.stopPropagation = noop
      this.stopImmediatePropagation = noop
      this.preventDefault = noop
      this.type = event.type
      this.target = this.currentTarget = instance.dom
      this.pointerType = event.pointerType
      this.clientX = event.clientX
      this.clientY = event.clientY
    }
    return FakeGlobalEvent
  }())
  var localDOMHandlers = {
    mousedown: function (event) {
      event = normalizeEvent(this.dom, event)
      this.__mayPointerCapture = [event.zrX, event.zrY]
      this.trigger('mousedown', event)
    },
    mousemove: function (event) {
      event = normalizeEvent(this.dom, event)
      const downPoint = this.__mayPointerCapture
      if (downPoint && (event.zrX !== downPoint[0] || event.zrY !== downPoint[1])) {
        this.__togglePointerCapture(true)
      }
      this.trigger('mousemove', event)
    },
    mouseup: function (event) {
      event = normalizeEvent(this.dom, event)
      this.__togglePointerCapture(false)
      this.trigger('mouseup', event)
    },
    mouseout: function (event) {
      event = normalizeEvent(this.dom, event)
      const element = event.toElement || event.relatedTarget
      if (!isLocalEl(this, element)) {
        if (this.__pointerCapturing) {
          event.zrEventControl = 'no_globalout'
        }
        this.trigger('mouseout', event)
      }
    },
    wheel: function (event) {
      wheelEventSupported = true
      event = normalizeEvent(this.dom, event)
      this.trigger('mousewheel', event)
    },
    mousewheel: function (event) {
      if (wheelEventSupported) {
        return
      }
      event = normalizeEvent(this.dom, event)
      this.trigger('mousewheel', event)
    },
    touchstart: function (event) {
      event = normalizeEvent(this.dom, event)
      markTouch(event)
      this.__lastTouchMoment = new Date()
      this.handler.processGesture(event, 'start')
      localDOMHandlers.mousemove.call(this, event)
      localDOMHandlers.mousedown.call(this, event)
    },
    touchmove: function (event) {
      event = normalizeEvent(this.dom, event)
      markTouch(event)
      this.handler.processGesture(event, 'change')
      localDOMHandlers.mousemove.call(this, event)
    },
    touchend: function (event) {
      event = normalizeEvent(this.dom, event)
      markTouch(event)
      this.handler.processGesture(event, 'end')
      localDOMHandlers.mouseup.call(this, event)
      if (+new Date() - (+this.__lastTouchMoment) < TOUCH_CLICK_DELAY) {
        localDOMHandlers.click.call(this, event)
      }
    },
    pointerdown: function (event) {
      localDOMHandlers.mousedown.call(this, event)
    },
    pointermove: function (event) {
      if (!isPointerFromTouch(event)) {
        localDOMHandlers.mousemove.call(this, event)
      }
    },
    pointerup: function (event) {
      localDOMHandlers.mouseup.call(this, event)
    },
    pointerout: function (event) {
      if (!isPointerFromTouch(event)) {
        localDOMHandlers.mouseout.call(this, event)
      }
    }
  }
  each(['click', 'dblclick', 'contextmenu'], function (name) {
    localDOMHandlers[name] = function (event) {
      event = normalizeEvent(this.dom, event)
      this.trigger(name, event)
    }
  })
  var globalDOMHandlers = {
    pointermove: function (event) {
      if (!isPointerFromTouch(event)) {
        globalDOMHandlers.mousemove.call(this, event)
      }
    },
    pointerup: function (event) {
      globalDOMHandlers.mouseup.call(this, event)
    },
    mousemove: function (event) {
      this.trigger('mousemove', event)
    },
    mouseup: function (event) {
      const pointerCaptureReleasing = this.__pointerCapturing
      this.__togglePointerCapture(false)
      this.trigger('mouseup', event)
      if (pointerCaptureReleasing) {
        event.zrEventControl = 'only_globalout'
        this.trigger('mouseout', event)
      }
    }
  }
  function mountLocalDOMEventListeners (instance, scope) {
    const domHandlers = scope.domHandlers
    if (env.pointerEventsSupported) {
      each(localNativeListenerNames.pointer, function (nativeEventName) {
        mountSingleDOMEventListener(scope, nativeEventName, function (event) {
          domHandlers[nativeEventName].call(instance, event)
        })
      })
    } else {
      if (env.touchEventsSupported) {
        each(localNativeListenerNames.touch, function (nativeEventName) {
          mountSingleDOMEventListener(scope, nativeEventName, function (event) {
            domHandlers[nativeEventName].call(instance, event)
            setTouchTimer(scope)
          })
        })
      }
      each(localNativeListenerNames.mouse, function (nativeEventName) {
        mountSingleDOMEventListener(scope, nativeEventName, function (event) {
          event = getNativeEvent(event)
          if (!scope.touching) {
            domHandlers[nativeEventName].call(instance, event)
          }
        })
      })
    }
  }
  function mountGlobalDOMEventListeners (instance, scope) {
    if (env.pointerEventsSupported) {
      each(globalNativeListenerNames.pointer, mount)
    } else if (!env.touchEventsSupported) {
      each(globalNativeListenerNames.mouse, mount)
    }
    function mount (nativeEventName) {
      function nativeEventListener (event) {
        event = getNativeEvent(event)
        if (!isLocalEl(instance, event.target)) {
          event = normalizeGlobalEvent(instance, event)
          scope.domHandlers[nativeEventName].call(instance, event)
        }
      }
      mountSingleDOMEventListener(scope, nativeEventName, nativeEventListener, { capture: true })
    }
  }
  function mountSingleDOMEventListener (scope, nativeEventName, listener, opt) {
    scope.mounted[nativeEventName] = listener
    scope.listenerOpts[nativeEventName] = opt
    addEventListener(scope.domTarget, nativeEventName, listener, opt)
  }
  function unmountDOMEventListeners (scope) {
    const mounted = scope.mounted
    for (const nativeEventName in mounted) {
      if (mounted.hasOwnProperty(nativeEventName)) {
        removeEventListener(scope.domTarget, nativeEventName, mounted[nativeEventName], scope.listenerOpts[nativeEventName])
      }
    }
    scope.mounted = {}
  }
  const DOMHandlerScope = (function () {
    function DOMHandlerScope (domTarget, domHandlers) {
      this.mounted = {}
      this.listenerOpts = {}
      this.touching = false
      this.domTarget = domTarget
      this.domHandlers = domHandlers
    }
    return DOMHandlerScope
  }())
  const HandlerDomProxy = (function (_super) {
    __extends(HandlerDomProxy, _super)
    function HandlerDomProxy (dom, painterRoot) {
      const _this = _super.call(this) || this
      _this.__pointerCapturing = false
      _this.dom = dom
      _this.painterRoot = painterRoot
      _this._localHandlerScope = new DOMHandlerScope(dom, localDOMHandlers)
      if (globalEventSupported) {
        _this._globalHandlerScope = new DOMHandlerScope(document, globalDOMHandlers)
      }
      mountLocalDOMEventListeners(_this, _this._localHandlerScope)
      return _this
    }
    HandlerDomProxy.prototype.dispose = function () {
      unmountDOMEventListeners(this._localHandlerScope)
      if (globalEventSupported) {
        unmountDOMEventListeners(this._globalHandlerScope)
      }
    }
    HandlerDomProxy.prototype.setCursor = function (cursorStyle) {
      this.dom.style && (this.dom.style.cursor = cursorStyle || 'default')
    }
    HandlerDomProxy.prototype.__togglePointerCapture = function (isPointerCapturing) {
      this.__mayPointerCapture = null
      if (globalEventSupported &&
                ((+this.__pointerCapturing) ^ (+isPointerCapturing))) {
        this.__pointerCapturing = isPointerCapturing
        const globalHandlerScope = this._globalHandlerScope
        isPointerCapturing
          ? mountGlobalDOMEventListeners(this, globalHandlerScope)
          : unmountDOMEventListeners(globalHandlerScope)
      }
    }
    return HandlerDomProxy
  }(Eventful))

  let dpr = 1
  if (env.hasGlobalWindow) {
    dpr = Math.max(window.devicePixelRatio ||
            (window.screen && window.screen.deviceXDPI / window.screen.logicalXDPI) ||
            1, 1)
  }
  const devicePixelRatio = dpr
  const DARK_MODE_THRESHOLD = 0.4
  const DARK_LABEL_COLOR = '#333'
  const LIGHT_LABEL_COLOR = '#ccc'
  const LIGHTER_LABEL_COLOR = '#eee'

  function create$1 () {
    return [1, 0, 0, 1, 0, 0]
  }
  function identity (out) {
    out[0] = 1
    out[1] = 0
    out[2] = 0
    out[3] = 1
    out[4] = 0
    out[5] = 0
    return out
  }
  function copy$1 (out, m) {
    out[0] = m[0]
    out[1] = m[1]
    out[2] = m[2]
    out[3] = m[3]
    out[4] = m[4]
    out[5] = m[5]
    return out
  }
  function mul$1 (out, m1, m2) {
    const out0 = m1[0] * m2[0] + m1[2] * m2[1]
    const out1 = m1[1] * m2[0] + m1[3] * m2[1]
    const out2 = m1[0] * m2[2] + m1[2] * m2[3]
    const out3 = m1[1] * m2[2] + m1[3] * m2[3]
    const out4 = m1[0] * m2[4] + m1[2] * m2[5] + m1[4]
    const out5 = m1[1] * m2[4] + m1[3] * m2[5] + m1[5]
    out[0] = out0
    out[1] = out1
    out[2] = out2
    out[3] = out3
    out[4] = out4
    out[5] = out5
    return out
  }
  function translate (out, a, v) {
    out[0] = a[0]
    out[1] = a[1]
    out[2] = a[2]
    out[3] = a[3]
    out[4] = a[4] + v[0]
    out[5] = a[5] + v[1]
    return out
  }
  function rotate (out, a, rad) {
    const aa = a[0]
    const ac = a[2]
    const atx = a[4]
    const ab = a[1]
    const ad = a[3]
    const aty = a[5]
    const st = Math.sin(rad)
    const ct = Math.cos(rad)
    out[0] = aa * ct + ab * st
    out[1] = -aa * st + ab * ct
    out[2] = ac * ct + ad * st
    out[3] = -ac * st + ct * ad
    out[4] = ct * atx + st * aty
    out[5] = ct * aty - st * atx
    return out
  }
  function scale$1 (out, a, v) {
    const vx = v[0]
    const vy = v[1]
    out[0] = a[0] * vx
    out[1] = a[1] * vy
    out[2] = a[2] * vx
    out[3] = a[3] * vy
    out[4] = a[4] * vx
    out[5] = a[5] * vy
    return out
  }
  function invert (out, a) {
    const aa = a[0]
    const ac = a[2]
    const atx = a[4]
    const ab = a[1]
    const ad = a[3]
    const aty = a[5]
    let det = aa * ad - ab * ac
    if (!det) {
      return null
    }
    det = 1.0 / det
    out[0] = ad * det
    out[1] = -ab * det
    out[2] = -ac * det
    out[3] = aa * det
    out[4] = (ac * aty - ad * atx) * det
    out[5] = (ab * atx - aa * aty) * det
    return out
  }
  function clone$2 (a) {
    const b = create$1()
    copy$1(b, a)
    return b
  }

  const matrix = /* #__PURE__ */Object.freeze({
    __proto__: null,
    create: create$1,
    identity: identity,
    copy: copy$1,
    mul: mul$1,
    translate: translate,
    rotate: rotate,
    scale: scale$1,
    invert: invert,
    clone: clone$2
  })

  const mIdentity = identity
  const EPSILON$2 = 5e-5
  function isNotAroundZero$1 (val) {
    return val > EPSILON$2 || val < -EPSILON$2
  }
  const scaleTmp = []
  const tmpTransform = []
  const originTransform = create$1()
  const abs = Math.abs
  const Transformable = (function () {
    function Transformable () {
    }
    Transformable.prototype.getLocalTransform = function (m) {
      return Transformable.getLocalTransform(this, m)
    }
    Transformable.prototype.setPosition = function (arr) {
      this.x = arr[0]
      this.y = arr[1]
    }
    Transformable.prototype.setScale = function (arr) {
      this.scaleX = arr[0]
      this.scaleY = arr[1]
    }
    Transformable.prototype.setSkew = function (arr) {
      this.skewX = arr[0]
      this.skewY = arr[1]
    }
    Transformable.prototype.setOrigin = function (arr) {
      this.originX = arr[0]
      this.originY = arr[1]
    }
    Transformable.prototype.needLocalTransform = function () {
      return isNotAroundZero$1(this.rotation) ||
                isNotAroundZero$1(this.x) ||
                isNotAroundZero$1(this.y) ||
                isNotAroundZero$1(this.scaleX - 1) ||
                isNotAroundZero$1(this.scaleY - 1) ||
                isNotAroundZero$1(this.skewX) ||
                isNotAroundZero$1(this.skewY)
    }
    Transformable.prototype.updateTransform = function () {
      const parentTransform = this.parent && this.parent.transform
      const needLocalTransform = this.needLocalTransform()
      let m = this.transform
      if (!(needLocalTransform || parentTransform)) {
        m && mIdentity(m)
        return
      }
      m = m || create$1()
      if (needLocalTransform) {
        this.getLocalTransform(m)
      } else {
        mIdentity(m)
      }
      if (parentTransform) {
        if (needLocalTransform) {
          mul$1(m, parentTransform, m)
        } else {
          copy$1(m, parentTransform)
        }
      }
      this.transform = m
      this._resolveGlobalScaleRatio(m)
    }
    Transformable.prototype._resolveGlobalScaleRatio = function (m) {
      const globalScaleRatio = this.globalScaleRatio
      if (globalScaleRatio != null && globalScaleRatio !== 1) {
        this.getGlobalScale(scaleTmp)
        const relX = scaleTmp[0] < 0 ? -1 : 1
        const relY = scaleTmp[1] < 0 ? -1 : 1
        const sx = ((scaleTmp[0] - relX) * globalScaleRatio + relX) / scaleTmp[0] || 0
        const sy = ((scaleTmp[1] - relY) * globalScaleRatio + relY) / scaleTmp[1] || 0
        m[0] *= sx
        m[1] *= sx
        m[2] *= sy
        m[3] *= sy
      }
      this.invTransform = this.invTransform || create$1()
      invert(this.invTransform, m)
    }
    Transformable.prototype.getComputedTransform = function () {
      let transformNode = this
      const ancestors = []
      while (transformNode) {
        ancestors.push(transformNode)
        transformNode = transformNode.parent
      }
      while (transformNode = ancestors.pop()) {
        transformNode.updateTransform()
      }
      return this.transform
    }
    Transformable.prototype.setLocalTransform = function (m) {
      if (!m) {
        return
      }
      let sx = m[0] * m[0] + m[1] * m[1]
      let sy = m[2] * m[2] + m[3] * m[3]
      const rotation = Math.atan2(m[1], m[0])
      const shearX = Math.PI / 2 + rotation - Math.atan2(m[3], m[2])
      sy = Math.sqrt(sy) * Math.cos(shearX)
      sx = Math.sqrt(sx)
      this.skewX = shearX
      this.skewY = 0
      this.rotation = -rotation
      this.x = +m[4]
      this.y = +m[5]
      this.scaleX = sx
      this.scaleY = sy
      this.originX = 0
      this.originY = 0
    }
    Transformable.prototype.decomposeTransform = function () {
      if (!this.transform) {
        return
      }
      const parent = this.parent
      let m = this.transform
      if (parent && parent.transform) {
        mul$1(tmpTransform, parent.invTransform, m)
        m = tmpTransform
      }
      const ox = this.originX
      const oy = this.originY
      if (ox || oy) {
        originTransform[4] = ox
        originTransform[5] = oy
        mul$1(tmpTransform, m, originTransform)
        tmpTransform[4] -= ox
        tmpTransform[5] -= oy
        m = tmpTransform
      }
      this.setLocalTransform(m)
    }
    Transformable.prototype.getGlobalScale = function (out) {
      const m = this.transform
      out = out || []
      if (!m) {
        out[0] = 1
        out[1] = 1
        return out
      }
      out[0] = Math.sqrt(m[0] * m[0] + m[1] * m[1])
      out[1] = Math.sqrt(m[2] * m[2] + m[3] * m[3])
      if (m[0] < 0) {
        out[0] = -out[0]
      }
      if (m[3] < 0) {
        out[1] = -out[1]
      }
      return out
    }
    Transformable.prototype.transformCoordToLocal = function (x, y) {
      const v2 = [x, y]
      const invTransform = this.invTransform
      if (invTransform) {
        applyTransform(v2, v2, invTransform)
      }
      return v2
    }
    Transformable.prototype.transformCoordToGlobal = function (x, y) {
      const v2 = [x, y]
      const transform = this.transform
      if (transform) {
        applyTransform(v2, v2, transform)
      }
      return v2
    }
    Transformable.prototype.getLineScale = function () {
      const m = this.transform
      return m && abs(m[0] - 1) > 1e-10 && abs(m[3] - 1) > 1e-10
        ? Math.sqrt(abs(m[0] * m[3] - m[2] * m[1]))
        : 1
    }
    Transformable.prototype.copyTransform = function (source) {
      copyTransform(this, source)
    }
    Transformable.getLocalTransform = function (target, m) {
      m = m || []
      const ox = target.originX || 0
      const oy = target.originY || 0
      const sx = target.scaleX
      const sy = target.scaleY
      const ax = target.anchorX
      const ay = target.anchorY
      const rotation = target.rotation || 0
      const x = target.x
      const y = target.y
      const skewX = target.skewX ? Math.tan(target.skewX) : 0
      const skewY = target.skewY ? Math.tan(-target.skewY) : 0
      if (ox || oy || ax || ay) {
        const dx = ox + ax
        const dy = oy + ay
        m[4] = -dx * sx - skewX * dy * sy
        m[5] = -dy * sy - skewY * dx * sx
      } else {
        m[4] = m[5] = 0
      }
      m[0] = sx
      m[3] = sy
      m[1] = skewY * sx
      m[2] = skewX * sy
      rotation && rotate(m, m, rotation)
      m[4] += ox + x
      m[5] += oy + y
      return m
    }
    Transformable.initDefaultProps = (function () {
      const proto = Transformable.prototype
      proto.scaleX =
                proto.scaleY =
                    proto.globalScaleRatio = 1
      proto.x =
                proto.y =
                    proto.originX =
                        proto.originY =
                            proto.skewX =
                                proto.skewY =
                                    proto.rotation =
                                        proto.anchorX =
                                            proto.anchorY = 0
    })()
    return Transformable
  }())
  const TRANSFORMABLE_PROPS = [
    'x', 'y', 'originX', 'originY', 'anchorX', 'anchorY', 'rotation', 'scaleX', 'scaleY', 'skewX', 'skewY'
  ]
  function copyTransform (target, source) {
    for (let i = 0; i < TRANSFORMABLE_PROPS.length; i++) {
      const propName = TRANSFORMABLE_PROPS[i]
      target[propName] = source[propName]
    }
  }

  const Point = (function () {
    function Point (x, y) {
      this.x = x || 0
      this.y = y || 0
    }
    Point.prototype.copy = function (other) {
      this.x = other.x
      this.y = other.y
      return this
    }
    Point.prototype.clone = function () {
      return new Point(this.x, this.y)
    }
    Point.prototype.set = function (x, y) {
      this.x = x
      this.y = y
      return this
    }
    Point.prototype.equal = function (other) {
      return other.x === this.x && other.y === this.y
    }
    Point.prototype.add = function (other) {
      this.x += other.x
      this.y += other.y
      return this
    }
    Point.prototype.scale = function (scalar) {
      this.x *= scalar
      this.y *= scalar
    }
    Point.prototype.scaleAndAdd = function (other, scalar) {
      this.x += other.x * scalar
      this.y += other.y * scalar
    }
    Point.prototype.sub = function (other) {
      this.x -= other.x
      this.y -= other.y
      return this
    }
    Point.prototype.dot = function (other) {
      return this.x * other.x + this.y * other.y
    }
    Point.prototype.len = function () {
      return Math.sqrt(this.x * this.x + this.y * this.y)
    }
    Point.prototype.lenSquare = function () {
      return this.x * this.x + this.y * this.y
    }
    Point.prototype.normalize = function () {
      const len = this.len()
      this.x /= len
      this.y /= len
      return this
    }
    Point.prototype.distance = function (other) {
      const dx = this.x - other.x
      const dy = this.y - other.y
      return Math.sqrt(dx * dx + dy * dy)
    }
    Point.prototype.distanceSquare = function (other) {
      const dx = this.x - other.x
      const dy = this.y - other.y
      return dx * dx + dy * dy
    }
    Point.prototype.negate = function () {
      this.x = -this.x
      this.y = -this.y
      return this
    }
    Point.prototype.transform = function (m) {
      if (!m) {
        return
      }
      const x = this.x
      const y = this.y
      this.x = m[0] * x + m[2] * y + m[4]
      this.y = m[1] * x + m[3] * y + m[5]
      return this
    }
    Point.prototype.toArray = function (out) {
      out[0] = this.x
      out[1] = this.y
      return out
    }
    Point.prototype.fromArray = function (input) {
      this.x = input[0]
      this.y = input[1]
    }
    Point.set = function (p, x, y) {
      p.x = x
      p.y = y
    }
    Point.copy = function (p, p2) {
      p.x = p2.x
      p.y = p2.y
    }
    Point.len = function (p) {
      return Math.sqrt(p.x * p.x + p.y * p.y)
    }
    Point.lenSquare = function (p) {
      return p.x * p.x + p.y * p.y
    }
    Point.dot = function (p0, p1) {
      return p0.x * p1.x + p0.y * p1.y
    }
    Point.add = function (out, p0, p1) {
      out.x = p0.x + p1.x
      out.y = p0.y + p1.y
    }
    Point.sub = function (out, p0, p1) {
      out.x = p0.x - p1.x
      out.y = p0.y - p1.y
    }
    Point.scale = function (out, p0, scalar) {
      out.x = p0.x * scalar
      out.y = p0.y * scalar
    }
    Point.scaleAndAdd = function (out, p0, p1, scalar) {
      out.x = p0.x + p1.x * scalar
      out.y = p0.y + p1.y * scalar
    }
    Point.lerp = function (out, p0, p1, t) {
      const onet = 1 - t
      out.x = onet * p0.x + t * p1.x
      out.y = onet * p0.y + t * p1.y
    }
    return Point
  }())

  const mathMin = Math.min
  const mathMax = Math.max
  const lt = new Point()
  const rb = new Point()
  const lb = new Point()
  const rt = new Point()
  const minTv = new Point()
  const maxTv = new Point()
  const BoundingRect = (function () {
    function BoundingRect (x, y, width, height) {
      if (width < 0) {
        x = x + width
        width = -width
      }
      if (height < 0) {
        y = y + height
        height = -height
      }
      this.x = x
      this.y = y
      this.width = width
      this.height = height
    }
    BoundingRect.prototype.union = function (other) {
      const x = mathMin(other.x, this.x)
      const y = mathMin(other.y, this.y)
      if (isFinite(this.x) && isFinite(this.width)) {
        this.width = mathMax(other.x + other.width, this.x + this.width) - x
      } else {
        this.width = other.width
      }
      if (isFinite(this.y) && isFinite(this.height)) {
        this.height = mathMax(other.y + other.height, this.y + this.height) - y
      } else {
        this.height = other.height
      }
      this.x = x
      this.y = y
    }
    BoundingRect.prototype.applyTransform = function (m) {
      BoundingRect.applyTransform(this, this, m)
    }
    BoundingRect.prototype.calculateTransform = function (b) {
      const a = this
      const sx = b.width / a.width
      const sy = b.height / a.height
      const m = create$1()
      translate(m, m, [-a.x, -a.y])
      scale$1(m, m, [sx, sy])
      translate(m, m, [b.x, b.y])
      return m
    }
    BoundingRect.prototype.intersect = function (b, mtv) {
      if (!b) {
        return false
      }
      if (!(b instanceof BoundingRect)) {
        b = BoundingRect.create(b)
      }
      const a = this
      const ax0 = a.x
      const ax1 = a.x + a.width
      const ay0 = a.y
      const ay1 = a.y + a.height
      const bx0 = b.x
      const bx1 = b.x + b.width
      const by0 = b.y
      const by1 = b.y + b.height
      const overlap = !(ax1 < bx0 || bx1 < ax0 || ay1 < by0 || by1 < ay0)
      if (mtv) {
        let dMin = Infinity
        let dMax = 0
        const d0 = Math.abs(ax1 - bx0)
        const d1 = Math.abs(bx1 - ax0)
        const d2 = Math.abs(ay1 - by0)
        const d3 = Math.abs(by1 - ay0)
        const dx = Math.min(d0, d1)
        const dy = Math.min(d2, d3)
        if (ax1 < bx0 || bx1 < ax0) {
          if (dx > dMax) {
            dMax = dx
            if (d0 < d1) {
              Point.set(maxTv, -d0, 0)
            } else {
              Point.set(maxTv, d1, 0)
            }
          }
        } else {
          if (dx < dMin) {
            dMin = dx
            if (d0 < d1) {
              Point.set(minTv, d0, 0)
            } else {
              Point.set(minTv, -d1, 0)
            }
          }
        }
        if (ay1 < by0 || by1 < ay0) {
          if (dy > dMax) {
            dMax = dy
            if (d2 < d3) {
              Point.set(maxTv, 0, -d2)
            } else {
              Point.set(maxTv, 0, d3)
            }
          }
        } else {
          if (dx < dMin) {
            dMin = dx
            if (d2 < d3) {
              Point.set(minTv, 0, d2)
            } else {
              Point.set(minTv, 0, -d3)
            }
          }
        }
      }
      if (mtv) {
        Point.copy(mtv, overlap ? minTv : maxTv)
      }
      return overlap
    }
    BoundingRect.prototype.contain = function (x, y) {
      const rect = this
      return x >= rect.x &&
                x <= (rect.x + rect.width) &&
                y >= rect.y &&
                y <= (rect.y + rect.height)
    }
    BoundingRect.prototype.clone = function () {
      return new BoundingRect(this.x, this.y, this.width, this.height)
    }
    BoundingRect.prototype.copy = function (other) {
      BoundingRect.copy(this, other)
    }
    BoundingRect.prototype.plain = function () {
      return {
        x: this.x,
        y: this.y,
        width: this.width,
        height: this.height
      }
    }
    BoundingRect.prototype.isFinite = function () {
      return isFinite(this.x) &&
                isFinite(this.y) &&
                isFinite(this.width) &&
                isFinite(this.height)
    }
    BoundingRect.prototype.isZero = function () {
      return this.width === 0 || this.height === 0
    }
    BoundingRect.create = function (rect) {
      return new BoundingRect(rect.x, rect.y, rect.width, rect.height)
    }
    BoundingRect.copy = function (target, source) {
      target.x = source.x
      target.y = source.y
      target.width = source.width
      target.height = source.height
    }
    BoundingRect.applyTransform = function (target, source, m) {
      if (!m) {
        if (target !== source) {
          BoundingRect.copy(target, source)
        }
        return
      }
      if (m[1] < 1e-5 && m[1] > -1e-5 && m[2] < 1e-5 && m[2] > -1e-5) {
        const sx = m[0]
        const sy = m[3]
        const tx = m[4]
        const ty = m[5]
        target.x = source.x * sx + tx
        target.y = source.y * sy + ty
        target.width = source.width * sx
        target.height = source.height * sy
        if (target.width < 0) {
          target.x += target.width
          target.width = -target.width
        }
        if (target.height < 0) {
          target.y += target.height
          target.height = -target.height
        }
        return
      }
      lt.x = lb.x = source.x
      lt.y = rt.y = source.y
      rb.x = rt.x = source.x + source.width
      rb.y = lb.y = source.y + source.height
      lt.transform(m)
      rt.transform(m)
      rb.transform(m)
      lb.transform(m)
      target.x = mathMin(lt.x, rb.x, lb.x, rt.x)
      target.y = mathMin(lt.y, rb.y, lb.y, rt.y)
      const maxX = mathMax(lt.x, rb.x, lb.x, rt.x)
      const maxY = mathMax(lt.y, rb.y, lb.y, rt.y)
      target.width = maxX - target.x
      target.height = maxY - target.y
    }
    return BoundingRect
  }())

  const textWidthCache = {}
  function getWidth (text, font) {
    font = font || DEFAULT_FONT
    let cacheOfFont = textWidthCache[font]
    if (!cacheOfFont) {
      cacheOfFont = textWidthCache[font] = new LRU(500)
    }
    let width = cacheOfFont.get(text)
    if (width == null) {
      width = platformApi.measureText(text, font).width
      cacheOfFont.put(text, width)
    }
    return width
  }
  function innerGetBoundingRect (text, font, textAlign, textBaseline) {
    const width = getWidth(text, font)
    const height = getLineHeight(font)
    const x = adjustTextX(0, width, textAlign)
    const y = adjustTextY$1(0, height, textBaseline)
    const rect = new BoundingRect(x, y, width, height)
    return rect
  }
  function getBoundingRect (text, font, textAlign, textBaseline) {
    const textLines = ((text || '') + '').split('\n')
    const len = textLines.length
    if (len === 1) {
      return innerGetBoundingRect(textLines[0], font, textAlign, textBaseline)
    } else {
      const uniondRect = new BoundingRect(0, 0, 0, 0)
      for (let i = 0; i < textLines.length; i++) {
        const rect = innerGetBoundingRect(textLines[i], font, textAlign, textBaseline)
        i === 0 ? uniondRect.copy(rect) : uniondRect.union(rect)
      }
      return uniondRect
    }
  }
  function adjustTextX (x, width, textAlign) {
    if (textAlign === 'right') {
      x -= width
    } else if (textAlign === 'center') {
      x -= width / 2
    }
    return x
  }
  function adjustTextY$1 (y, height, verticalAlign) {
    if (verticalAlign === 'middle') {
      y -= height / 2
    } else if (verticalAlign === 'bottom') {
      y -= height
    }
    return y
  }
  function getLineHeight (font) {
    return getWidth('国', font)
  }
  function parsePercent (value, maxValue) {
    if (typeof value === 'string') {
      if (value.lastIndexOf('%') >= 0) {
        return parseFloat(value) / 100 * maxValue
      }
      return parseFloat(value)
    }
    return value
  }
  function calculateTextPosition (out, opts, rect) {
    const textPosition = opts.position || 'inside'
    const distance = opts.distance != null ? opts.distance : 5
    const height = rect.height
    const width = rect.width
    const halfHeight = height / 2
    let x = rect.x
    let y = rect.y
    let textAlign = 'left'
    let textVerticalAlign = 'top'
    if (textPosition instanceof Array) {
      x += parsePercent(textPosition[0], rect.width)
      y += parsePercent(textPosition[1], rect.height)
      textAlign = null
      textVerticalAlign = null
    } else {
      switch (textPosition) {
        case 'left':
          x -= distance
          y += halfHeight
          textAlign = 'right'
          textVerticalAlign = 'middle'
          break
        case 'right':
          x += distance + width
          y += halfHeight
          textVerticalAlign = 'middle'
          break
        case 'top':
          x += width / 2
          y -= distance
          textAlign = 'center'
          textVerticalAlign = 'bottom'
          break
        case 'bottom':
          x += width / 2
          y += height + distance
          textAlign = 'center'
          break
        case 'inside':
          x += width / 2
          y += halfHeight
          textAlign = 'center'
          textVerticalAlign = 'middle'
          break
        case 'insideLeft':
          x += distance
          y += halfHeight
          textVerticalAlign = 'middle'
          break
        case 'insideRight':
          x += width - distance
          y += halfHeight
          textAlign = 'right'
          textVerticalAlign = 'middle'
          break
        case 'insideTop':
          x += width / 2
          y += distance
          textAlign = 'center'
          break
        case 'insideBottom':
          x += width / 2
          y += height - distance
          textAlign = 'center'
          textVerticalAlign = 'bottom'
          break
        case 'insideTopLeft':
          x += distance
          y += distance
          break
        case 'insideTopRight':
          x += width - distance
          y += distance
          textAlign = 'right'
          break
        case 'insideBottomLeft':
          x += distance
          y += height - distance
          textVerticalAlign = 'bottom'
          break
        case 'insideBottomRight':
          x += width - distance
          y += height - distance
          textAlign = 'right'
          textVerticalAlign = 'bottom'
          break
      }
    }
    out = out || {}
    out.x = x
    out.y = y
    out.align = textAlign
    out.verticalAlign = textVerticalAlign
    return out
  }

  const PRESERVED_NORMAL_STATE = '__zr_normal__'
  const PRIMARY_STATES_KEYS = TRANSFORMABLE_PROPS.concat(['ignore'])
  const DEFAULT_ANIMATABLE_MAP = reduce(TRANSFORMABLE_PROPS, function (obj, key) {
    obj[key] = true
    return obj
  }, { ignore: false })
  const tmpTextPosCalcRes = {}
  const tmpBoundingRect = new BoundingRect(0, 0, 0, 0)
  const Element = (function () {
    function Element (props) {
      this.id = guid()
      this.animators = []
      this.currentStates = []
      this.states = {}
      this._init(props)
    }
    Element.prototype._init = function (props) {
      this.attr(props)
    }
    Element.prototype.drift = function (dx, dy, e) {
      switch (this.draggable) {
        case 'horizontal':
          dy = 0
          break
        case 'vertical':
          dx = 0
          break
      }
      let m = this.transform
      if (!m) {
        m = this.transform = [1, 0, 0, 1, 0, 0]
      }
      m[4] += dx
      m[5] += dy
      this.decomposeTransform()
      this.markRedraw()
    }
    Element.prototype.beforeUpdate = function () { }
    Element.prototype.afterUpdate = function () { }
    Element.prototype.update = function () {
      this.updateTransform()
      if (this.__dirty) {
        this.updateInnerText()
      }
    }
    Element.prototype.updateInnerText = function (forceUpdate) {
      const textEl = this._textContent
      if (textEl && (!textEl.ignore || forceUpdate)) {
        if (!this.textConfig) {
          this.textConfig = {}
        }
        const textConfig = this.textConfig
        const isLocal = textConfig.local
        const innerTransformable = textEl.innerTransformable
        let textAlign = void 0
        let textVerticalAlign = void 0
        let textStyleChanged = false
        innerTransformable.parent = isLocal ? this : null
        let innerOrigin = false
        innerTransformable.copyTransform(textEl)
        if (textConfig.position != null) {
          const layoutRect = tmpBoundingRect
          if (textConfig.layoutRect) {
            layoutRect.copy(textConfig.layoutRect)
          } else {
            layoutRect.copy(this.getBoundingRect())
          }
          if (!isLocal) {
            layoutRect.applyTransform(this.transform)
          }
          if (this.calculateTextPosition) {
            this.calculateTextPosition(tmpTextPosCalcRes, textConfig, layoutRect)
          } else {
            calculateTextPosition(tmpTextPosCalcRes, textConfig, layoutRect)
          }
          innerTransformable.x = tmpTextPosCalcRes.x
          innerTransformable.y = tmpTextPosCalcRes.y
          textAlign = tmpTextPosCalcRes.align
          textVerticalAlign = tmpTextPosCalcRes.verticalAlign
          const textOrigin = textConfig.origin
          if (textOrigin && textConfig.rotation != null) {
            let relOriginX = void 0
            let relOriginY = void 0
            if (textOrigin === 'center') {
              relOriginX = layoutRect.width * 0.5
              relOriginY = layoutRect.height * 0.5
            } else {
              relOriginX = parsePercent(textOrigin[0], layoutRect.width)
              relOriginY = parsePercent(textOrigin[1], layoutRect.height)
            }
            innerOrigin = true
            innerTransformable.originX = -innerTransformable.x + relOriginX + (isLocal ? 0 : layoutRect.x)
            innerTransformable.originY = -innerTransformable.y + relOriginY + (isLocal ? 0 : layoutRect.y)
          }
        }
        if (textConfig.rotation != null) {
          innerTransformable.rotation = textConfig.rotation
        }
        const textOffset = textConfig.offset
        if (textOffset) {
          innerTransformable.x += textOffset[0]
          innerTransformable.y += textOffset[1]
          if (!innerOrigin) {
            innerTransformable.originX = -textOffset[0]
            innerTransformable.originY = -textOffset[1]
          }
        }
        const isInside = textConfig.inside == null
          ? (typeof textConfig.position === 'string' && textConfig.position.indexOf('inside') >= 0)
          : textConfig.inside
        const innerTextDefaultStyle = this._innerTextDefaultStyle || (this._innerTextDefaultStyle = {})
        let textFill = void 0
        let textStroke = void 0
        let autoStroke = void 0
        if (isInside && this.canBeInsideText()) {
          textFill = textConfig.insideFill
          textStroke = textConfig.insideStroke
          if (textFill == null || textFill === 'auto') {
            textFill = this.getInsideTextFill()
          }
          if (textStroke == null || textStroke === 'auto') {
            textStroke = this.getInsideTextStroke(textFill)
            autoStroke = true
          }
        } else {
          textFill = textConfig.outsideFill
          textStroke = textConfig.outsideStroke
          if (textFill == null || textFill === 'auto') {
            textFill = this.getOutsideFill()
          }
          if (textStroke == null || textStroke === 'auto') {
            textStroke = this.getOutsideStroke(textFill)
            autoStroke = true
          }
        }
        textFill = textFill || '#000'
        if (textFill !== innerTextDefaultStyle.fill ||
                    textStroke !== innerTextDefaultStyle.stroke ||
                    autoStroke !== innerTextDefaultStyle.autoStroke ||
                    textAlign !== innerTextDefaultStyle.align ||
                    textVerticalAlign !== innerTextDefaultStyle.verticalAlign) {
          textStyleChanged = true
          innerTextDefaultStyle.fill = textFill
          innerTextDefaultStyle.stroke = textStroke
          innerTextDefaultStyle.autoStroke = autoStroke
          innerTextDefaultStyle.align = textAlign
          innerTextDefaultStyle.verticalAlign = textVerticalAlign
          textEl.setDefaultTextStyle(innerTextDefaultStyle)
        }
        textEl.__dirty |= REDRAW_BIT
        if (textStyleChanged) {
          textEl.dirtyStyle(true)
        }
      }
    }
    Element.prototype.canBeInsideText = function () {
      return true
    }
    Element.prototype.getInsideTextFill = function () {
      return '#fff'
    }
    Element.prototype.getInsideTextStroke = function (textFill) {
      return '#000'
    }
    Element.prototype.getOutsideFill = function () {
      return this.__zr && this.__zr.isDarkMode() ? LIGHT_LABEL_COLOR : DARK_LABEL_COLOR
    }
    Element.prototype.getOutsideStroke = function (textFill) {
      const backgroundColor = this.__zr && this.__zr.getBackgroundColor()
      let colorArr = typeof backgroundColor === 'string' && parse(backgroundColor)
      if (!colorArr) {
        colorArr = [255, 255, 255, 1]
      }
      const alpha = colorArr[3]
      const isDark = this.__zr.isDarkMode()
      for (let i = 0; i < 3; i++) {
        colorArr[i] = colorArr[i] * alpha + (isDark ? 0 : 255) * (1 - alpha)
      }
      colorArr[3] = 1
      return stringify(colorArr, 'rgba')
    }
    Element.prototype.traverse = function (cb, context) { }
    Element.prototype.attrKV = function (key, value) {
      if (key === 'textConfig') {
        this.setTextConfig(value)
      } else if (key === 'textContent') {
        this.setTextContent(value)
      } else if (key === 'clipPath') {
        this.setClipPath(value)
      } else if (key === 'extra') {
        this.extra = this.extra || {}
        extend(this.extra, value)
      } else {
        this[key] = value
      }
    }
    Element.prototype.hide = function () {
      this.ignore = true
      this.markRedraw()
    }
    Element.prototype.show = function () {
      this.ignore = false
      this.markRedraw()
    }
    Element.prototype.attr = function (keyOrObj, value) {
      if (typeof keyOrObj === 'string') {
        this.attrKV(keyOrObj, value)
      } else if (isObject(keyOrObj)) {
        const obj = keyOrObj
        const keysArr = keys(obj)
        for (let i = 0; i < keysArr.length; i++) {
          const key = keysArr[i]
          this.attrKV(key, keyOrObj[key])
        }
      }
      this.markRedraw()
      return this
    }
    Element.prototype.saveCurrentToNormalState = function (toState) {
      this._innerSaveToNormal(toState)
      const normalState = this._normalState
      for (let i = 0; i < this.animators.length; i++) {
        const animator = this.animators[i]
        const fromStateTransition = animator.__fromStateTransition
        if (animator.getLoop() || fromStateTransition && fromStateTransition !== PRESERVED_NORMAL_STATE) {
          continue
        }
        const targetName = animator.targetName
        const target = targetName
          ? normalState[targetName]
          : normalState
        animator.saveTo(target)
      }
    }
    Element.prototype._innerSaveToNormal = function (toState) {
      let normalState = this._normalState
      if (!normalState) {
        normalState = this._normalState = {}
      }
      if (toState.textConfig && !normalState.textConfig) {
        normalState.textConfig = this.textConfig
      }
      this._savePrimaryToNormal(toState, normalState, PRIMARY_STATES_KEYS)
    }
    Element.prototype._savePrimaryToNormal = function (toState, normalState, primaryKeys) {
      for (let i = 0; i < primaryKeys.length; i++) {
        const key = primaryKeys[i]
        if (toState[key] != null && !(key in normalState)) {
          normalState[key] = this[key]
        }
      }
    }
    Element.prototype.hasState = function () {
      return this.currentStates.length > 0
    }
    Element.prototype.getState = function (name) {
      return this.states[name]
    }
    Element.prototype.ensureState = function (name) {
      const states = this.states
      if (!states[name]) {
        states[name] = {}
      }
      return states[name]
    }
    Element.prototype.clearStates = function (noAnimation) {
      this.useState(PRESERVED_NORMAL_STATE, false, noAnimation)
    }
    Element.prototype.useState = function (stateName, keepCurrentStates, noAnimation, forceUseHoverLayer) {
      const toNormalState = stateName === PRESERVED_NORMAL_STATE
      const hasStates = this.hasState()
      if (!hasStates && toNormalState) {
        return
      }
      const currentStates = this.currentStates
      const animationCfg = this.stateTransition
      if (indexOf(currentStates, stateName) >= 0 && (keepCurrentStates || currentStates.length === 1)) {
        return
      }
      let state
      if (this.stateProxy && !toNormalState) {
        state = this.stateProxy(stateName)
      }
      if (!state) {
        state = (this.states && this.states[stateName])
      }
      if (!state && !toNormalState) {
        logError('State ' + stateName + ' not exists.')
        return
      }
      if (!toNormalState) {
        this.saveCurrentToNormalState(state)
      }
      const useHoverLayer = !!((state && state.hoverLayer) || forceUseHoverLayer)
      if (useHoverLayer) {
        this._toggleHoverLayerFlag(true)
      }
      this._applyStateObj(stateName, state, this._normalState, keepCurrentStates, !noAnimation && !this.__inHover && animationCfg && animationCfg.duration > 0, animationCfg)
      const textContent = this._textContent
      const textGuide = this._textGuide
      if (textContent) {
        textContent.useState(stateName, keepCurrentStates, noAnimation, useHoverLayer)
      }
      if (textGuide) {
        textGuide.useState(stateName, keepCurrentStates, noAnimation, useHoverLayer)
      }
      if (toNormalState) {
        this.currentStates = []
        this._normalState = {}
      } else {
        if (!keepCurrentStates) {
          this.currentStates = [stateName]
        } else {
          this.currentStates.push(stateName)
        }
      }
      this._updateAnimationTargets()
      this.markRedraw()
      if (!useHoverLayer && this.__inHover) {
        this._toggleHoverLayerFlag(false)
        this.__dirty &= ~REDRAW_BIT
      }
      return state
    }
    Element.prototype.useStates = function (states, noAnimation, forceUseHoverLayer) {
      if (!states.length) {
        this.clearStates()
      } else {
        const stateObjects = []
        const currentStates = this.currentStates
        const len = states.length
        let notChange = len === currentStates.length
        if (notChange) {
          for (var i = 0; i < len; i++) {
            if (states[i] !== currentStates[i]) {
              notChange = false
              break
            }
          }
        }
        if (notChange) {
          return
        }
        for (var i = 0; i < len; i++) {
          const stateName = states[i]
          let stateObj = void 0
          if (this.stateProxy) {
            stateObj = this.stateProxy(stateName, states)
          }
          if (!stateObj) {
            stateObj = this.states[stateName]
          }
          if (stateObj) {
            stateObjects.push(stateObj)
          }
        }
        const lastStateObj = stateObjects[len - 1]
        const useHoverLayer = !!((lastStateObj && lastStateObj.hoverLayer) || forceUseHoverLayer)
        if (useHoverLayer) {
          this._toggleHoverLayerFlag(true)
        }
        const mergedState = this._mergeStates(stateObjects)
        const animationCfg = this.stateTransition
        this.saveCurrentToNormalState(mergedState)
        this._applyStateObj(states.join(','), mergedState, this._normalState, false, !noAnimation && !this.__inHover && animationCfg && animationCfg.duration > 0, animationCfg)
        const textContent = this._textContent
        const textGuide = this._textGuide
        if (textContent) {
          textContent.useStates(states, noAnimation, useHoverLayer)
        }
        if (textGuide) {
          textGuide.useStates(states, noAnimation, useHoverLayer)
        }
        this._updateAnimationTargets()
        this.currentStates = states.slice()
        this.markRedraw()
        if (!useHoverLayer && this.__inHover) {
          this._toggleHoverLayerFlag(false)
          this.__dirty &= ~REDRAW_BIT
        }
      }
    }
    Element.prototype._updateAnimationTargets = function () {
      for (let i = 0; i < this.animators.length; i++) {
        const animator = this.animators[i]
        if (animator.targetName) {
          animator.changeTarget(this[animator.targetName])
        }
      }
    }
    Element.prototype.removeState = function (state) {
      const idx = indexOf(this.currentStates, state)
      if (idx >= 0) {
        const currentStates = this.currentStates.slice()
        currentStates.splice(idx, 1)
        this.useStates(currentStates)
      }
    }
    Element.prototype.replaceState = function (oldState, newState, forceAdd) {
      const currentStates = this.currentStates.slice()
      const idx = indexOf(currentStates, oldState)
      const newStateExists = indexOf(currentStates, newState) >= 0
      if (idx >= 0) {
        if (!newStateExists) {
          currentStates[idx] = newState
        } else {
          currentStates.splice(idx, 1)
        }
      } else if (forceAdd && !newStateExists) {
        currentStates.push(newState)
      }
      this.useStates(currentStates)
    }
    Element.prototype.toggleState = function (state, enable) {
      if (enable) {
        this.useState(state, true)
      } else {
        this.removeState(state)
      }
    }
    Element.prototype._mergeStates = function (states) {
      const mergedState = {}
      let mergedTextConfig
      for (let i = 0; i < states.length; i++) {
        const state = states[i]
        extend(mergedState, state)
        if (state.textConfig) {
          mergedTextConfig = mergedTextConfig || {}
          extend(mergedTextConfig, state.textConfig)
        }
      }
      if (mergedTextConfig) {
        mergedState.textConfig = mergedTextConfig
      }
      return mergedState
    }
    Element.prototype._applyStateObj = function (stateName, state, normalState, keepCurrentStates, transition, animationCfg) {
      const needsRestoreToNormal = !(state && keepCurrentStates)
      if (state && state.textConfig) {
        this.textConfig = extend({}, keepCurrentStates ? this.textConfig : normalState.textConfig)
        extend(this.textConfig, state.textConfig)
      } else if (needsRestoreToNormal) {
        if (normalState.textConfig) {
          this.textConfig = normalState.textConfig
        }
      }
      const transitionTarget = {}
      let hasTransition = false
      for (var i = 0; i < PRIMARY_STATES_KEYS.length; i++) {
        const key = PRIMARY_STATES_KEYS[i]
        const propNeedsTransition = transition && DEFAULT_ANIMATABLE_MAP[key]
        if (state && state[key] != null) {
          if (propNeedsTransition) {
            hasTransition = true
            transitionTarget[key] = state[key]
          } else {
            this[key] = state[key]
          }
        } else if (needsRestoreToNormal) {
          if (normalState[key] != null) {
            if (propNeedsTransition) {
              hasTransition = true
              transitionTarget[key] = normalState[key]
            } else {
              this[key] = normalState[key]
            }
          }
        }
      }
      if (!transition) {
        for (var i = 0; i < this.animators.length; i++) {
          const animator = this.animators[i]
          const targetName = animator.targetName
          if (!animator.getLoop()) {
            animator.__changeFinalValue(targetName
              ? (state || normalState)[targetName]
              : (state || normalState))
          }
        }
      }
      if (hasTransition) {
        this._transitionState(stateName, transitionTarget, animationCfg)
      }
    }
    Element.prototype._attachComponent = function (componentEl) {
      if (componentEl.__zr && !componentEl.__hostTarget) {
        if ('development' !== 'production') {
          throw new Error('Text element has been added to zrender.')
        }
        return
      }
      if (componentEl === this) {
        if ('development' !== 'production') {
          throw new Error('Recursive component attachment.')
        }
        return
      }
      const zr = this.__zr
      if (zr) {
        componentEl.addSelfToZr(zr)
      }
      componentEl.__zr = zr
      componentEl.__hostTarget = this
    }
    Element.prototype._detachComponent = function (componentEl) {
      if (componentEl.__zr) {
        componentEl.removeSelfFromZr(componentEl.__zr)
      }
      componentEl.__zr = null
      componentEl.__hostTarget = null
    }
    Element.prototype.getClipPath = function () {
      return this._clipPath
    }
    Element.prototype.setClipPath = function (clipPath) {
      if (this._clipPath && this._clipPath !== clipPath) {
        this.removeClipPath()
      }
      this._attachComponent(clipPath)
      this._clipPath = clipPath
      this.markRedraw()
    }
    Element.prototype.removeClipPath = function () {
      const clipPath = this._clipPath
      if (clipPath) {
        this._detachComponent(clipPath)
        this._clipPath = null
        this.markRedraw()
      }
    }
    Element.prototype.getTextContent = function () {
      return this._textContent
    }
    Element.prototype.setTextContent = function (textEl) {
      const previousTextContent = this._textContent
      if (previousTextContent === textEl) {
        return
      }
      if (previousTextContent && previousTextContent !== textEl) {
        this.removeTextContent()
      }
      if ('development' !== 'production') {
        if (textEl.__zr && !textEl.__hostTarget) {
          throw new Error('Text element has been added to zrender.')
        }
      }
      textEl.innerTransformable = new Transformable()
      this._attachComponent(textEl)
      this._textContent = textEl
      this.markRedraw()
    }
    Element.prototype.setTextConfig = function (cfg) {
      if (!this.textConfig) {
        this.textConfig = {}
      }
      extend(this.textConfig, cfg)
      this.markRedraw()
    }
    Element.prototype.removeTextConfig = function () {
      this.textConfig = null
      this.markRedraw()
    }
    Element.prototype.removeTextContent = function () {
      const textEl = this._textContent
      if (textEl) {
        textEl.innerTransformable = null
        this._detachComponent(textEl)
        this._textContent = null
        this._innerTextDefaultStyle = null
        this.markRedraw()
      }
    }
    Element.prototype.getTextGuideLine = function () {
      return this._textGuide
    }
    Element.prototype.setTextGuideLine = function (guideLine) {
      if (this._textGuide && this._textGuide !== guideLine) {
        this.removeTextGuideLine()
      }
      this._attachComponent(guideLine)
      this._textGuide = guideLine
      this.markRedraw()
    }
    Element.prototype.removeTextGuideLine = function () {
      const textGuide = this._textGuide
      if (textGuide) {
        this._detachComponent(textGuide)
        this._textGuide = null
        this.markRedraw()
      }
    }
    Element.prototype.markRedraw = function () {
      this.__dirty |= REDRAW_BIT
      const zr = this.__zr
      if (zr) {
        if (this.__inHover) {
          zr.refreshHover()
        } else {
          zr.refresh()
        }
      }
      if (this.__hostTarget) {
        this.__hostTarget.markRedraw()
      }
    }
    Element.prototype.dirty = function () {
      this.markRedraw()
    }
    Element.prototype._toggleHoverLayerFlag = function (inHover) {
      this.__inHover = inHover
      const textContent = this._textContent
      const textGuide = this._textGuide
      if (textContent) {
        textContent.__inHover = inHover
      }
      if (textGuide) {
        textGuide.__inHover = inHover
      }
    }
    Element.prototype.addSelfToZr = function (zr) {
      if (this.__zr === zr) {
        return
      }
      this.__zr = zr
      const animators = this.animators
      if (animators) {
        for (let i = 0; i < animators.length; i++) {
          zr.animation.addAnimator(animators[i])
        }
      }
      if (this._clipPath) {
        this._clipPath.addSelfToZr(zr)
      }
      if (this._textContent) {
        this._textContent.addSelfToZr(zr)
      }
      if (this._textGuide) {
        this._textGuide.addSelfToZr(zr)
      }
    }
    Element.prototype.removeSelfFromZr = function (zr) {
      if (!this.__zr) {
        return
      }
      this.__zr = null
      const animators = this.animators
      if (animators) {
        for (let i = 0; i < animators.length; i++) {
          zr.animation.removeAnimator(animators[i])
        }
      }
      if (this._clipPath) {
        this._clipPath.removeSelfFromZr(zr)
      }
      if (this._textContent) {
        this._textContent.removeSelfFromZr(zr)
      }
      if (this._textGuide) {
        this._textGuide.removeSelfFromZr(zr)
      }
    }
    Element.prototype.animate = function (key, loop, allowDiscreteAnimation) {
      const target = key ? this[key] : this
      if ('development' !== 'production') {
        if (!target) {
          logError('Property "' +
                        key +
                        '" is not existed in element ' +
                        this.id)
          return
        }
      }
      const animator = new Animator(target, loop, allowDiscreteAnimation)
      key && (animator.targetName = key)
      this.addAnimator(animator, key)
      return animator
    }
    Element.prototype.addAnimator = function (animator, key) {
      const zr = this.__zr
      const el = this
      animator.during(function () {
        el.updateDuringAnimation(key)
      }).done(function () {
        const animators = el.animators
        const idx = indexOf(animators, animator)
        if (idx >= 0) {
          animators.splice(idx, 1)
        }
      })
      this.animators.push(animator)
      if (zr) {
        zr.animation.addAnimator(animator)
      }
      zr && zr.wakeUp()
    }
    Element.prototype.updateDuringAnimation = function (key) {
      this.markRedraw()
    }
    Element.prototype.stopAnimation = function (scope, forwardToLast) {
      const animators = this.animators
      const len = animators.length
      const leftAnimators = []
      for (let i = 0; i < len; i++) {
        const animator = animators[i]
        if (!scope || scope === animator.scope) {
          animator.stop(forwardToLast)
        } else {
          leftAnimators.push(animator)
        }
      }
      this.animators = leftAnimators
      return this
    }
    Element.prototype.animateTo = function (target, cfg, animationProps) {
      animateTo(this, target, cfg, animationProps)
    }
    Element.prototype.animateFrom = function (target, cfg, animationProps) {
      animateTo(this, target, cfg, animationProps, true)
    }
    Element.prototype._transitionState = function (stateName, target, cfg, animationProps) {
      const animators = animateTo(this, target, cfg, animationProps)
      for (let i = 0; i < animators.length; i++) {
        animators[i].__fromStateTransition = stateName
      }
    }
    Element.prototype.getBoundingRect = function () {
      return null
    }
    Element.prototype.getPaintRect = function () {
      return null
    }
    Element.initDefaultProps = (function () {
      const elProto = Element.prototype
      elProto.type = 'element'
      elProto.name = ''
      elProto.ignore =
                elProto.silent =
                    elProto.isGroup =
                        elProto.draggable =
                            elProto.dragging =
                                elProto.ignoreClip =
                                    elProto.__inHover = false
      elProto.__dirty = REDRAW_BIT
      const logs = {}
      function logDeprecatedError (key, xKey, yKey) {
        if (!logs[key + xKey + yKey]) {
          console.warn("DEPRECATED: '" + key + "' has been deprecated. use '" + xKey + "', '" + yKey + "' instead")
          logs[key + xKey + yKey] = true
        }
      }
      function createLegacyProperty (key, privateKey, xKey, yKey) {
        Object.defineProperty(elProto, key, {
          get: function () {
            if ('development' !== 'production') {
              logDeprecatedError(key, xKey, yKey)
            }
            if (!this[privateKey]) {
              const pos = this[privateKey] = []
              enhanceArray(this, pos)
            }
            return this[privateKey]
          },
          set: function (pos) {
            if ('development' !== 'production') {
              logDeprecatedError(key, xKey, yKey)
            }
            this[xKey] = pos[0]
            this[yKey] = pos[1]
            this[privateKey] = pos
            enhanceArray(this, pos)
          }
        })
        function enhanceArray (self, pos) {
          Object.defineProperty(pos, 0, {
            get: function () {
              return self[xKey]
            },
            set: function (val) {
              self[xKey] = val
            }
          })
          Object.defineProperty(pos, 1, {
            get: function () {
              return self[yKey]
            },
            set: function (val) {
              self[yKey] = val
            }
          })
        }
      }
      if (Object.defineProperty) {
        createLegacyProperty('position', '_legacyPos', 'x', 'y')
        createLegacyProperty('scale', '_legacyScale', 'scaleX', 'scaleY')
        createLegacyProperty('origin', '_legacyOrigin', 'originX', 'originY')
      }
    })()
    return Element
  }())
  mixin(Element, Eventful)
  mixin(Element, Transformable)
  function animateTo (animatable, target, cfg, animationProps, reverse) {
    cfg = cfg || {}
    const animators = []
    animateToShallow(animatable, '', animatable, target, cfg, animationProps, animators, reverse)
    let finishCount = animators.length
    let doneHappened = false
    const cfgDone = cfg.done
    const cfgAborted = cfg.aborted
    const doneCb = function () {
      doneHappened = true
      finishCount--
      if (finishCount <= 0) {
        doneHappened
          ? (cfgDone && cfgDone())
          : (cfgAborted && cfgAborted())
      }
    }
    const abortedCb = function () {
      finishCount--
      if (finishCount <= 0) {
        doneHappened
          ? (cfgDone && cfgDone())
          : (cfgAborted && cfgAborted())
      }
    }
    if (!finishCount) {
      cfgDone && cfgDone()
    }
    if (animators.length > 0 && cfg.during) {
      animators[0].during(function (target, percent) {
        cfg.during(percent)
      })
    }
    for (let i = 0; i < animators.length; i++) {
      const animator = animators[i]
      if (doneCb) {
        animator.done(doneCb)
      }
      if (abortedCb) {
        animator.aborted(abortedCb)
      }
      if (cfg.force) {
        animator.duration(cfg.duration)
      }
      animator.start(cfg.easing)
    }
    return animators
  }
  function copyArrShallow (source, target, len) {
    for (let i = 0; i < len; i++) {
      source[i] = target[i]
    }
  }
  function is2DArray (value) {
    return isArrayLike(value[0])
  }
  function copyValue (target, source, key) {
    if (isArrayLike(source[key])) {
      if (!isArrayLike(target[key])) {
        target[key] = []
      }
      if (isTypedArray(source[key])) {
        const len = source[key].length
        if (target[key].length !== len) {
          target[key] = new (source[key].constructor)(len)
          copyArrShallow(target[key], source[key], len)
        }
      } else {
        const sourceArr = source[key]
        const targetArr = target[key]
        const len0 = sourceArr.length
        if (is2DArray(sourceArr)) {
          const len1 = sourceArr[0].length
          for (let i = 0; i < len0; i++) {
            if (!targetArr[i]) {
              targetArr[i] = Array.prototype.slice.call(sourceArr[i])
            } else {
              copyArrShallow(targetArr[i], sourceArr[i], len1)
            }
          }
        } else {
          copyArrShallow(targetArr, sourceArr, len0)
        }
        targetArr.length = sourceArr.length
      }
    } else {
      target[key] = source[key]
    }
  }
  function isValueSame (val1, val2) {
    return val1 === val2 ||
            isArrayLike(val1) && isArrayLike(val2) && is1DArraySame(val1, val2)
  }
  function is1DArraySame (arr0, arr1) {
    const len = arr0.length
    if (len !== arr1.length) {
      return false
    }
    for (let i = 0; i < len; i++) {
      if (arr0[i] !== arr1[i]) {
        return false
      }
    }
    return true
  }
  function animateToShallow (animatable, topKey, animateObj, target, cfg, animationProps, animators, reverse) {
    const targetKeys = keys(target)
    const duration = cfg.duration
    const delay = cfg.delay
    const additive = cfg.additive
    const setToFinal = cfg.setToFinal
    const animateAll = !isObject(animationProps)
    const existsAnimators = animatable.animators
    let animationKeys = []
    for (let k = 0; k < targetKeys.length; k++) {
      var innerKey = targetKeys[k]
      const targetVal = target[innerKey]
      if (targetVal != null && animateObj[innerKey] != null &&
                (animateAll || animationProps[innerKey])) {
        if (isObject(targetVal) &&
                    !isArrayLike(targetVal) &&
                    !isGradientObject(targetVal)) {
          if (topKey) {
            if (!reverse) {
              animateObj[innerKey] = targetVal
              animatable.updateDuringAnimation(topKey)
            }
            continue
          }
          animateToShallow(animatable, innerKey, animateObj[innerKey], targetVal, cfg, animationProps && animationProps[innerKey], animators, reverse)
        } else {
          animationKeys.push(innerKey)
        }
      } else if (!reverse) {
        animateObj[innerKey] = targetVal
        animatable.updateDuringAnimation(topKey)
        animationKeys.push(innerKey)
      }
    }
    let keyLen = animationKeys.length
    if (!additive && keyLen) {
      for (var i = 0; i < existsAnimators.length; i++) {
        var animator = existsAnimators[i]
        if (animator.targetName === topKey) {
          const allAborted = animator.stopTracks(animationKeys)
          if (allAborted) {
            const idx = indexOf(existsAnimators, animator)
            existsAnimators.splice(idx, 1)
          }
        }
      }
    }
    if (!cfg.force) {
      animationKeys = filter(animationKeys, function (key) { return !isValueSame(target[key], animateObj[key]) })
      keyLen = animationKeys.length
    }
    if (keyLen > 0 ||
            (cfg.force && !animators.length)) {
      let revertedSource = void 0
      let reversedTarget = void 0
      let sourceClone = void 0
      if (reverse) {
        reversedTarget = {}
        if (setToFinal) {
          revertedSource = {}
        }
        for (var i = 0; i < keyLen; i++) {
          var innerKey = animationKeys[i]
          reversedTarget[innerKey] = animateObj[innerKey]
          if (setToFinal) {
            revertedSource[innerKey] = target[innerKey]
          } else {
            animateObj[innerKey] = target[innerKey]
          }
        }
      } else if (setToFinal) {
        sourceClone = {}
        for (var i = 0; i < keyLen; i++) {
          var innerKey = animationKeys[i]
          sourceClone[innerKey] = cloneValue(animateObj[innerKey])
          copyValue(animateObj, target, innerKey)
        }
      }
      var animator = new Animator(animateObj, false, false, additive ? filter(existsAnimators, function (animator) { return animator.targetName === topKey }) : null)
      animator.targetName = topKey
      if (cfg.scope) {
        animator.scope = cfg.scope
      }
      if (setToFinal && revertedSource) {
        animator.whenWithKeys(0, revertedSource, animationKeys)
      }
      if (sourceClone) {
        animator.whenWithKeys(0, sourceClone, animationKeys)
      }
      animator.whenWithKeys(duration == null ? 500 : duration, reverse ? reversedTarget : target, animationKeys).delay(delay || 0)
      animatable.addAnimator(animator, topKey)
      animators.push(animator)
    }
  }

  const Group = (function (_super) {
    __extends(Group, _super)
    function Group (opts) {
      const _this = _super.call(this) || this
      _this.isGroup = true
      _this._children = []
      _this.attr(opts)
      return _this
    }
    Group.prototype.childrenRef = function () {
      return this._children
    }
    Group.prototype.children = function () {
      return this._children.slice()
    }
    Group.prototype.childAt = function (idx) {
      return this._children[idx]
    }
    Group.prototype.childOfName = function (name) {
      const children = this._children
      for (let i = 0; i < children.length; i++) {
        if (children[i].name === name) {
          return children[i]
        }
      }
    }
    Group.prototype.childCount = function () {
      return this._children.length
    }
    Group.prototype.add = function (child) {
      if (child) {
        if (child !== this && child.parent !== this) {
          this._children.push(child)
          this._doAdd(child)
        }
        if ('development' !== 'production') {
          if (child.__hostTarget) {
            throw 'This elemenet has been used as an attachment'
          }
        }
      }
      return this
    }
    Group.prototype.addBefore = function (child, nextSibling) {
      if (child && child !== this && child.parent !== this &&
                nextSibling && nextSibling.parent === this) {
        const children = this._children
        const idx = children.indexOf(nextSibling)
        if (idx >= 0) {
          children.splice(idx, 0, child)
          this._doAdd(child)
        }
      }
      return this
    }
    Group.prototype.replace = function (oldChild, newChild) {
      const idx = indexOf(this._children, oldChild)
      if (idx >= 0) {
        this.replaceAt(newChild, idx)
      }
      return this
    }
    Group.prototype.replaceAt = function (child, index) {
      const children = this._children
      const old = children[index]
      if (child && child !== this && child.parent !== this && child !== old) {
        children[index] = child
        old.parent = null
        const zr = this.__zr
        if (zr) {
          old.removeSelfFromZr(zr)
        }
        this._doAdd(child)
      }
      return this
    }
    Group.prototype._doAdd = function (child) {
      if (child.parent) {
        child.parent.remove(child)
      }
      child.parent = this
      const zr = this.__zr
      if (zr && zr !== child.__zr) {
        child.addSelfToZr(zr)
      }
      zr && zr.refresh()
    }
    Group.prototype.remove = function (child) {
      const zr = this.__zr
      const children = this._children
      const idx = indexOf(children, child)
      if (idx < 0) {
        return this
      }
      children.splice(idx, 1)
      child.parent = null
      if (zr) {
        child.removeSelfFromZr(zr)
      }
      zr && zr.refresh()
      return this
    }
    Group.prototype.removeAll = function () {
      const children = this._children
      const zr = this.__zr
      for (let i = 0; i < children.length; i++) {
        const child = children[i]
        if (zr) {
          child.removeSelfFromZr(zr)
        }
        child.parent = null
      }
      children.length = 0
      return this
    }
    Group.prototype.eachChild = function (cb, context) {
      const children = this._children
      for (let i = 0; i < children.length; i++) {
        const child = children[i]
        cb.call(context, child, i)
      }
      return this
    }
    Group.prototype.traverse = function (cb, context) {
      for (let i = 0; i < this._children.length; i++) {
        const child = this._children[i]
        const stopped = cb.call(context, child)
        if (child.isGroup && !stopped) {
          child.traverse(cb, context)
        }
      }
      return this
    }
    Group.prototype.addSelfToZr = function (zr) {
      _super.prototype.addSelfToZr.call(this, zr)
      for (let i = 0; i < this._children.length; i++) {
        const child = this._children[i]
        child.addSelfToZr(zr)
      }
    }
    Group.prototype.removeSelfFromZr = function (zr) {
      _super.prototype.removeSelfFromZr.call(this, zr)
      for (let i = 0; i < this._children.length; i++) {
        const child = this._children[i]
        child.removeSelfFromZr(zr)
      }
    }
    Group.prototype.getBoundingRect = function (includeChildren) {
      const tmpRect = new BoundingRect(0, 0, 0, 0)
      const children = includeChildren || this._children
      const tmpMat = []
      let rect = null
      for (let i = 0; i < children.length; i++) {
        const child = children[i]
        if (child.ignore || child.invisible) {
          continue
        }
        const childRect = child.getBoundingRect()
        const transform = child.getLocalTransform(tmpMat)
        if (transform) {
          BoundingRect.applyTransform(tmpRect, childRect, transform)
          rect = rect || tmpRect.clone()
          rect.union(tmpRect)
        } else {
          rect = rect || childRect.clone()
          rect.union(childRect)
        }
      }
      return rect || tmpRect
    }
    return Group
  }(Element))
  Group.prototype.type = 'group'

  /*!
    * ZRender, a high performance 2d drawing library.
    *
    * Copyright (c) 2013, Baidu Inc.
    * All rights reserved.
    *
    * LICENSE
    * https://github.com/ecomfe/zrender/blob/master/LICENSE.txt
    */
  const painterCtors = {}
  let instances = {}
  function delInstance (id) {
    delete instances[id]
  }
  function isDarkMode (backgroundColor) {
    if (!backgroundColor) {
      return false
    }
    if (typeof backgroundColor === 'string') {
      return lum(backgroundColor, 1) < DARK_MODE_THRESHOLD
    } else if (backgroundColor.colorStops) {
      const colorStops = backgroundColor.colorStops
      let totalLum = 0
      const len = colorStops.length
      for (let i = 0; i < len; i++) {
        totalLum += lum(colorStops[i].color, 1)
      }
      totalLum /= len
      return totalLum < DARK_MODE_THRESHOLD
    }
    return false
  }
  const ZRender = (function () {
    function ZRender (id, dom, opts) {
      const _this = this
      this._sleepAfterStill = 10
      this._stillFrameAccum = 0
      this._needsRefresh = true
      this._needsRefreshHover = true
      this._darkMode = false
      opts = opts || {}
      this.dom = dom
      this.id = id
      const storage = new Storage()
      let rendererType = opts.renderer || 'canvas'
      if (!painterCtors[rendererType]) {
        rendererType = keys(painterCtors)[0]
      }
      if ('development' !== 'production') {
        if (!painterCtors[rendererType]) {
          throw new Error("Renderer '" + rendererType + "' is not imported. Please import it first.")
        }
      }
      opts.useDirtyRect = opts.useDirtyRect == null
        ? false
        : opts.useDirtyRect
      const painter = new painterCtors[rendererType](dom, storage, opts, id)
      const ssrMode = opts.ssr || painter.ssrOnly
      this.storage = storage
      this.painter = painter
      const handerProxy = (!env.node && !env.worker && !ssrMode)
        ? new HandlerDomProxy(painter.getViewportRoot(), painter.root)
        : null
      this.handler = new Handler(storage, painter, handerProxy, painter.root)
      this.animation = new Animation({
        stage: {
          update: ssrMode ? null : function () { return _this._flush(true) }
        }
      })
      if (!ssrMode) {
        this.animation.start()
      }
    }
    ZRender.prototype.add = function (el) {
      if (!el) {
        return
      }
      this.storage.addRoot(el)
      el.addSelfToZr(this)
      this.refresh()
    }
    ZRender.prototype.remove = function (el) {
      if (!el) {
        return
      }
      this.storage.delRoot(el)
      el.removeSelfFromZr(this)
      this.refresh()
    }
    ZRender.prototype.configLayer = function (zLevel, config) {
      if (this.painter.configLayer) {
        this.painter.configLayer(zLevel, config)
      }
      this.refresh()
    }
    ZRender.prototype.setBackgroundColor = function (backgroundColor) {
      if (this.painter.setBackgroundColor) {
        this.painter.setBackgroundColor(backgroundColor)
      }
      this.refresh()
      this._backgroundColor = backgroundColor
      this._darkMode = isDarkMode(backgroundColor)
    }
    ZRender.prototype.getBackgroundColor = function () {
      return this._backgroundColor
    }
    ZRender.prototype.setDarkMode = function (darkMode) {
      this._darkMode = darkMode
    }
    ZRender.prototype.isDarkMode = function () {
      return this._darkMode
    }
    ZRender.prototype.refreshImmediately = function (fromInside) {
      if (!fromInside) {
        this.animation.update(true)
      }
      this._needsRefresh = false
      this.painter.refresh()
      this._needsRefresh = false
    }
    ZRender.prototype.refresh = function () {
      this._needsRefresh = true
      this.animation.start()
    }
    ZRender.prototype.flush = function () {
      this._flush(false)
    }
    ZRender.prototype._flush = function (fromInside) {
      let triggerRendered
      const start = getTime()
      if (this._needsRefresh) {
        triggerRendered = true
        this.refreshImmediately(fromInside)
      }
      if (this._needsRefreshHover) {
        triggerRendered = true
        this.refreshHoverImmediately()
      }
      const end = getTime()
      if (triggerRendered) {
        this._stillFrameAccum = 0
        this.trigger('rendered', {
          elapsedTime: end - start
        })
      } else if (this._sleepAfterStill > 0) {
        this._stillFrameAccum++
        if (this._stillFrameAccum > this._sleepAfterStill) {
          this.animation.stop()
        }
      }
    }
    ZRender.prototype.setSleepAfterStill = function (stillFramesCount) {
      this._sleepAfterStill = stillFramesCount
    }
    ZRender.prototype.wakeUp = function () {
      this.animation.start()
      this._stillFrameAccum = 0
    }
    ZRender.prototype.refreshHover = function () {
      this._needsRefreshHover = true
    }
    ZRender.prototype.refreshHoverImmediately = function () {
      this._needsRefreshHover = false
      if (this.painter.refreshHover && this.painter.getType() === 'canvas') {
        this.painter.refreshHover()
      }
    }
    ZRender.prototype.resize = function (opts) {
      opts = opts || {}
      this.painter.resize(opts.width, opts.height)
      this.handler.resize()
    }
    ZRender.prototype.clearAnimation = function () {
      this.animation.clear()
    }
    ZRender.prototype.getWidth = function () {
      return this.painter.getWidth()
    }
    ZRender.prototype.getHeight = function () {
      return this.painter.getHeight()
    }
    ZRender.prototype.setCursorStyle = function (cursorStyle) {
      this.handler.setCursorStyle(cursorStyle)
    }
    ZRender.prototype.findHover = function (x, y) {
      return this.handler.findHover(x, y)
    }
    ZRender.prototype.on = function (eventName, eventHandler, context) {
      this.handler.on(eventName, eventHandler, context)
      return this
    }
    ZRender.prototype.off = function (eventName, eventHandler) {
      this.handler.off(eventName, eventHandler)
    }
    ZRender.prototype.trigger = function (eventName, event) {
      this.handler.trigger(eventName, event)
    }
    ZRender.prototype.clear = function () {
      const roots = this.storage.getRoots()
      for (let i = 0; i < roots.length; i++) {
        if (roots[i] instanceof Group) {
          roots[i].removeSelfFromZr(this)
        }
      }
      this.storage.delAllRoots()
      this.painter.clear()
    }
    ZRender.prototype.dispose = function () {
      this.animation.stop()
      this.clear()
      this.storage.dispose()
      this.painter.dispose()
      this.handler.dispose()
      this.animation =
                this.storage =
                    this.painter =
                        this.handler = null
      delInstance(this.id)
    }
    return ZRender
  }())
  function init (dom, opts) {
    const zr = new ZRender(guid(), dom, opts)
    instances[zr.id] = zr
    return zr
  }
  function dispose (zr) {
    zr.dispose()
  }
  function disposeAll () {
    for (const key in instances) {
      if (instances.hasOwnProperty(key)) {
        instances[key].dispose()
      }
    }
    instances = {}
  }
  function getInstance (id) {
    return instances[id]
  }
  function registerPainter (name, Ctor) {
    painterCtors[name] = Ctor
  }
  const version = '5.3.2'

  const zrender = /* #__PURE__ */Object.freeze({
    __proto__: null,
    init: init,
    dispose: dispose,
    disposeAll: disposeAll,
    getInstance: getInstance,
    registerPainter: registerPainter,
    version: version
  })

  const RADIAN_EPSILON = 1e-4 // Although chrome already enlarge this number to 100 for `toFixed`, but
  // we sill follow the spec for compatibility.

  const ROUND_SUPPORTED_PRECISION_MAX = 20

  function _trim (str) {
    return str.replace(/^\s+|\s+$/g, '')
  }
  /**
     * Linear mapping a value from domain to range
     * @param  val
     * @param  domain Domain extent domain[0] can be bigger than domain[1]
     * @param  range  Range extent range[0] can be bigger than range[1]
     * @param  clamp Default to be false
     */

  function linearMap (val, domain, range, clamp) {
    const d0 = domain[0]
    const d1 = domain[1]
    const r0 = range[0]
    const r1 = range[1]
    const subDomain = d1 - d0
    const subRange = r1 - r0

    if (subDomain === 0) {
      return subRange === 0 ? r0 : (r0 + r1) / 2
    } // Avoid accuracy problem in edge, such as
    // 146.39 - 62.83 === 83.55999999999999.
    // See echarts/test/ut/spec/util/number.js#linearMap#accuracyError
    // It is a little verbose for efficiency considering this method
    // is a hotspot.

    if (clamp) {
      if (subDomain > 0) {
        if (val <= d0) {
          return r0
        } else if (val >= d1) {
          return r1
        }
      } else {
        if (val >= d0) {
          return r0
        } else if (val <= d1) {
          return r1
        }
      }
    } else {
      if (val === d0) {
        return r0
      }

      if (val === d1) {
        return r1
      }
    }

    return (val - d0) / subDomain * subRange + r0
  }
  /**
     * Convert a percent string to absolute number.
     * Returns NaN if percent is not a valid string or number
     */

  function parsePercent$1 (percent, all) {
    switch (percent) {
      case 'center':
      case 'middle':
        percent = '50%'
        break

      case 'left':
      case 'top':
        percent = '0%'
        break

      case 'right':
      case 'bottom':
        percent = '100%'
        break
    }

    if (isString(percent)) {
      if (_trim(percent).match(/%$/)) {
        return parseFloat(percent) / 100 * all
      }

      return parseFloat(percent)
    }

    return percent == null ? NaN : +percent
  }
  function round (x, precision, returnStr) {
    if (precision == null) {
      precision = 10
    } // Avoid range error

    precision = Math.min(Math.max(0, precision), ROUND_SUPPORTED_PRECISION_MAX) // PENDING: 1.005.toFixed(2) is '1.00' rather than '1.01'

    x = (+x).toFixed(precision)
    return returnStr ? x : +x
  }
  /**
     * Inplacd asc sort arr.
     * The input arr will be modified.
     */

  function asc (arr) {
    arr.sort(function (a, b) {
      return a - b
    })
    return arr
  }
  /**
     * Get precision.
     */

  function getPrecision (val) {
    val = +val

    if (isNaN(val)) {
      return 0
    } // It is much faster than methods converting number to string as follows
    //      let tmp = val.toString();
    //      return tmp.length - 1 - tmp.indexOf('.');
    // especially when precision is low
    // Notice:
    // (1) If the loop count is over about 20, it is slower than `getPrecisionSafe`.
    //     (see https://jsbench.me/2vkpcekkvw/1)
    // (2) If the val is less than for example 1e-15, the result may be incorrect.
    //     (see test/ut/spec/util/number.test.ts `getPrecision_equal_random`)

    if (val > 1e-14) {
      let e = 1

      for (let i = 0; i < 15; i++, e *= 10) {
        if (Math.round(val * e) / e === val) {
          return i
        }
      }
    }

    return getPrecisionSafe(val)
  }
  /**
     * Get precision with slow but safe method
     */

  function getPrecisionSafe (val) {
    // toLowerCase for: '3.4E-12'
    const str = val.toString().toLowerCase() // Consider scientific notation: '3.4e-12' '3.4e+12'

    const eIndex = str.indexOf('e')
    const exp = eIndex > 0 ? +str.slice(eIndex + 1) : 0
    const significandPartLen = eIndex > 0 ? eIndex : str.length
    const dotIndex = str.indexOf('.')
    const decimalPartLen = dotIndex < 0 ? 0 : significandPartLen - 1 - dotIndex
    return Math.max(0, decimalPartLen - exp)
  }
  /**
     * Minimal dicernible data precisioin according to a single pixel.
     */

  function getPixelPrecision (dataExtent, pixelExtent) {
    const log = Math.log
    const LN10 = Math.LN10
    const dataQuantity = Math.floor(log(dataExtent[1] - dataExtent[0]) / LN10)
    const sizeQuantity = Math.round(log(Math.abs(pixelExtent[1] - pixelExtent[0])) / LN10) // toFixed() digits argument must be between 0 and 20.

    const precision = Math.min(Math.max(-dataQuantity + sizeQuantity, 0), 20)
    return !isFinite(precision) ? 20 : precision
  }
  /**
     * Get a data of given precision, assuring the sum of percentages
     * in valueList is 1.
     * The largest remainer method is used.
     * https://en.wikipedia.org/wiki/Largest_remainder_method
     *
     * @param valueList a list of all data
     * @param idx index of the data to be processed in valueList
     * @param precision integer number showing digits of precision
     * @return percent ranging from 0 to 100
     */

  function getPercentWithPrecision (valueList, idx, precision) {
    if (!valueList[idx]) {
      return 0
    }

    const sum = reduce(valueList, function (acc, val) {
      return acc + (isNaN(val) ? 0 : val)
    }, 0)

    if (sum === 0) {
      return 0
    }

    const digits = Math.pow(10, precision)
    const votesPerQuota = map(valueList, function (val) {
      return (isNaN(val) ? 0 : val) / sum * digits * 100
    })
    const targetSeats = digits * 100
    const seats = map(votesPerQuota, function (votes) {
      // Assign automatic seats.
      return Math.floor(votes)
    })
    let currentSum = reduce(seats, function (acc, val) {
      return acc + val
    }, 0)
    const remainder = map(votesPerQuota, function (votes, idx) {
      return votes - seats[idx]
    }) // Has remainding votes.

    while (currentSum < targetSeats) {
      // Find next largest remainder.
      let max = Number.NEGATIVE_INFINITY
      let maxId = null

      for (let i = 0, len = remainder.length; i < len; ++i) {
        if (remainder[i] > max) {
          max = remainder[i]
          maxId = i
        }
      } // Add a vote to max remainder.

      ++seats[maxId]
      remainder[maxId] = 0
      ++currentSum
    }

    return seats[idx] / digits
  }
  /**
     * Solve the floating point adding problem like 0.1 + 0.2 === 0.30000000000000004
     * See <http://0.30000000000000004.com/>
     */

  function addSafe (val0, val1) {
    const maxPrecision = Math.max(getPrecision(val0), getPrecision(val1)) // const multiplier = Math.pow(10, maxPrecision);
    // return (Math.round(val0 * multiplier) + Math.round(val1 * multiplier)) / multiplier;

    const sum = val0 + val1 // // PENDING: support more?

    return maxPrecision > ROUND_SUPPORTED_PRECISION_MAX ? sum : round(sum, maxPrecision)
  } // Number.MAX_SAFE_INTEGER, ie do not support.

  const MAX_SAFE_INTEGER = 9007199254740991
  /**
     * To 0 - 2 * PI, considering negative radian.
     */

  function remRadian (radian) {
    const pi2 = Math.PI * 2
    return (radian % pi2 + pi2) % pi2
  }
  /**
     * @param {type} radian
     * @return {boolean}
     */

  function isRadianAroundZero (val) {
    return val > -RADIAN_EPSILON && val < RADIAN_EPSILON
  } // eslint-disable-next-line

  const TIME_REG = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d{1,2})(?::(\d{1,2})(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/ // jshint ignore:line

  /**
     * @param value valid type: number | string | Date, otherwise return `new Date(NaN)`
     *   These values can be accepted:
     *   + An instance of Date, represent a time in its own time zone.
     *   + Or string in a subset of ISO 8601, only including:
     *     + only year, month, date: '2012-03', '2012-03-01', '2012-03-01 05', '2012-03-01 05:06',
     *     + separated with T or space: '2012-03-01T12:22:33.123', '2012-03-01 12:22:33.123',
     *     + time zone: '2012-03-01T12:22:33Z', '2012-03-01T12:22:33+8000', '2012-03-01T12:22:33-05:00',
     *     all of which will be treated as local time if time zone is not specified
     *     (see <https://momentjs.com/>).
     *   + Or other string format, including (all of which will be treated as loacal time):
     *     '2012', '2012-3-1', '2012/3/1', '2012/03/01',
     *     '2009/6/12 2:00', '2009/6/12 2:05:08', '2009/6/12 2:05:08.123'
     *   + a timestamp, which represent a time in UTC.
     * @return date Never be null/undefined. If invalid, return `new Date(NaN)`.
     */

  function parseDate (value) {
    if (value instanceof Date) {
      return value
    } else if (isString(value)) {
      // Different browsers parse date in different way, so we parse it manually.
      // Some other issues:
      // new Date('1970-01-01') is UTC,
      // new Date('1970/01/01') and new Date('1970-1-01') is local.
      // See issue #3623
      const match = TIME_REG.exec(value)

      if (!match) {
        // return Invalid Date.
        return new Date(NaN)
      } // Use local time when no timezone offset specifed.

      if (!match[8]) {
        // match[n] can only be string or undefined.
        // But take care of '12' + 1 => '121'.
        return new Date(+match[1], +(match[2] || 1) - 1, +match[3] || 1, +match[4] || 0, +(match[5] || 0), +match[6] || 0, match[7] ? +match[7].substring(0, 3) : 0)
      } // Timezoneoffset of Javascript Date has considered DST (Daylight Saving Time,
      // https://tc39.github.io/ecma262/#sec-daylight-saving-time-adjustment).
      // For example, system timezone is set as "Time Zone: America/Toronto",
      // then these code will get different result:
      // `new Date(1478411999999).getTimezoneOffset();  // get 240`
      // `new Date(1478412000000).getTimezoneOffset();  // get 300`
      // So we should not use `new Date`, but use `Date.UTC`.
      else {
        let hour = +match[4] || 0

        if (match[8].toUpperCase() !== 'Z') {
          hour -= +match[8].slice(0, 3)
        }

        return new Date(Date.UTC(+match[1], +(match[2] || 1) - 1, +match[3] || 1, hour, +(match[5] || 0), +match[6] || 0, match[7] ? +match[7].substring(0, 3) : 0))
      }
    } else if (value == null) {
      return new Date(NaN)
    }

    return new Date(Math.round(value))
  }
  /**
     * Quantity of a number. e.g. 0.1, 1, 10, 100
     *
     * @param val
     * @return
     */

  function quantity (val) {
    return Math.pow(10, quantityExponent(val))
  }
  /**
     * Exponent of the quantity of a number
     * e.g., 1234 equals to 1.234*10^3, so quantityExponent(1234) is 3
     *
     * @param val non-negative value
     * @return
     */

  function quantityExponent (val) {
    if (val === 0) {
      return 0
    }

    let exp = Math.floor(Math.log(val) / Math.LN10)
    /**
       * exp is expected to be the rounded-down result of the base-10 log of val.
       * But due to the precision loss with Math.log(val), we need to restore it
       * using 10^exp to make sure we can get val back from exp. #11249
       */

    if (val / Math.pow(10, exp) >= 10) {
      exp++
    }

    return exp
  }
  /**
     * find a “nice” number approximately equal to x. Round the number if round = true,
     * take ceiling if round = false. The primary observation is that the “nicest”
     * numbers in decimal are 1, 2, and 5, and all power-of-ten multiples of these numbers.
     *
     * See "Nice Numbers for Graph Labels" of Graphic Gems.
     *
     * @param  val Non-negative value.
     * @param  round
     * @return Niced number
     */

  function nice (val, round) {
    const exponent = quantityExponent(val)
    const exp10 = Math.pow(10, exponent)
    const f = val / exp10 // 1 <= f < 10

    let nf

    if (round) {
      if (f < 1.5) {
        nf = 1
      } else if (f < 2.5) {
        nf = 2
      } else if (f < 4) {
        nf = 3
      } else if (f < 7) {
        nf = 5
      } else {
        nf = 10
      }
    } else {
      if (f < 1) {
        nf = 1
      } else if (f < 2) {
        nf = 2
      } else if (f < 3) {
        nf = 3
      } else if (f < 5) {
        nf = 5
      } else {
        nf = 10
      }
    }

    val = nf * exp10 // Fix 3 * 0.1 === 0.30000000000000004 issue (see IEEE 754).
    // 20 is the uppper bound of toFixed.

    return exponent >= -20 ? +val.toFixed(exponent < 0 ? -exponent : 0) : val
  }
  /**
     * This code was copied from "d3.js"
     * <https://github.com/d3/d3/blob/9cc9a875e636a1dcf36cc1e07bdf77e1ad6e2c74/src/arrays/quantile.js>.
     * See the license statement at the head of this file.
     * @param ascArr
     */

  function quantile (ascArr, p) {
    const H = (ascArr.length - 1) * p + 1
    const h = Math.floor(H)
    const v = +ascArr[h - 1]
    const e = H - h
    return e ? v + e * (ascArr[h] - v) : v
  }
  /**
     * Order intervals asc, and split them when overlap.
     * expect(numberUtil.reformIntervals([
     *     {interval: [18, 62], close: [1, 1]},
     *     {interval: [-Infinity, -70], close: [0, 0]},
     *     {interval: [-70, -26], close: [1, 1]},
     *     {interval: [-26, 18], close: [1, 1]},
     *     {interval: [62, 150], close: [1, 1]},
     *     {interval: [106, 150], close: [1, 1]},
     *     {interval: [150, Infinity], close: [0, 0]}
     * ])).toEqual([
     *     {interval: [-Infinity, -70], close: [0, 0]},
     *     {interval: [-70, -26], close: [1, 1]},
     *     {interval: [-26, 18], close: [0, 1]},
     *     {interval: [18, 62], close: [0, 1]},
     *     {interval: [62, 150], close: [0, 1]},
     *     {interval: [150, Infinity], close: [0, 0]}
     * ]);
     * @param list, where `close` mean open or close
     *        of the interval, and Infinity can be used.
     * @return The origin list, which has been reformed.
     */

  function reformIntervals (list) {
    list.sort(function (a, b) {
      return littleThan(a, b, 0) ? -1 : 1
    })
    let curr = -Infinity
    let currClose = 1

    for (let i = 0; i < list.length;) {
      const interval = list[i].interval
      const close_1 = list[i].close

      for (let lg = 0; lg < 2; lg++) {
        if (interval[lg] <= curr) {
          interval[lg] = curr
          close_1[lg] = !lg ? 1 - currClose : 1
        }

        curr = interval[lg]
        currClose = close_1[lg]
      }

      if (interval[0] === interval[1] && close_1[0] * close_1[1] !== 1) {
        list.splice(i, 1)
      } else {
        i++
      }
    }

    return list

    function littleThan (a, b, lg) {
      return a.interval[lg] < b.interval[lg] || a.interval[lg] === b.interval[lg] && (a.close[lg] - b.close[lg] === (!lg ? 1 : -1) || !lg && littleThan(a, b, 1))
    }
  }
  /**
     * [Numberic is defined as]:
     *     `parseFloat(val) == val`
     * For example:
     * numeric:
     *     typeof number except NaN, '-123', '123', '2e3', '-2e3', '011', 'Infinity', Infinity,
     *     and they rounded by white-spaces or line-terminal like ' -123 \n ' (see es spec)
     * not-numeric:
     *     null, undefined, [], {}, true, false, 'NaN', NaN, '123ab',
     *     empty string, string with only white-spaces or line-terminal (see es spec),
     *     0x12, '0x12', '-0x12', 012, '012', '-012',
     *     non-string, ...
     *
     * @test See full test cases in `test/ut/spec/util/number.js`.
     * @return Must be a typeof number. If not numeric, return NaN.
     */

  function numericToNumber (val) {
    const valFloat = parseFloat(val)
    return valFloat == val && // eslint-disable-line eqeqeq
      (valFloat !== 0 || !isString(val) || val.indexOf('x') <= 0) // For case ' 0x0 '.
      ? valFloat : NaN
  }
  /**
     * Definition of "numeric": see `numericToNumber`.
     */

  function isNumeric (val) {
    return !isNaN(numericToNumber(val))
  }
  /**
     * Use random base to prevent users hard code depending on
     * this auto generated marker id.
     * @return An positive integer.
     */

  function getRandomIdBase () {
    return Math.round(Math.random() * 9)
  }
  /**
     * Get the greatest common dividor
     *
     * @param {number} a one number
     * @param {number} b the other number
     */

  function getGreatestCommonDividor (a, b) {
    if (b === 0) {
      return a
    }

    return getGreatestCommonDividor(b, a % b)
  }
  /**
     * Get the least common multiple
     *
     * @param {number} a one number
     * @param {number} b the other number
     */

  function getLeastCommonMultiple (a, b) {
    if (a == null) {
      return b
    }

    if (b == null) {
      return a
    }

    return a * b / getGreatestCommonDividor(a, b)
  }

  const ECHARTS_PREFIX = '[ECharts] '
  const storedLogs = {}
  const hasConsole = typeof console !== 'undefined' // eslint-disable-next-line
    && console.warn && console.log;

  function outputLog (type, str, onlyOnce) {
    if (hasConsole) {
      if (onlyOnce) {
        if (storedLogs[str]) {
          return
        }

        storedLogs[str] = true
      } // eslint-disable-next-line

      console[type](ECHARTS_PREFIX + str)
    }
  }

  function log (str, onlyOnce) {
    outputLog('log', str, onlyOnce)
  }
  function warn (str, onlyOnce) {
    outputLog('warn', str, onlyOnce)
  }
  function error (str, onlyOnce) {
    outputLog('error', str, onlyOnce)
  }
  function deprecateLog (str) {
    if ('development' !== 'production') {
      // Not display duplicate message.
      outputLog('warn', 'DEPRECATED: ' + str, true)
    }
  }
  function deprecateReplaceLog (oldOpt, newOpt, scope) {
    if ('development' !== 'production') {
      deprecateLog((scope ? '[' + scope + ']' : '') + (oldOpt + ' is deprecated, use ' + newOpt + ' instead.'))
    }
  }
  /**
     * If in __DEV__ environment, get console printable message for users hint.
     * Parameters are separated by ' '.
     * @usuage
     * makePrintable('This is an error on', someVar, someObj);
     *
     * @param hintInfo anything about the current execution context to hint users.
     * @throws Error
     */

  function makePrintable () {
    const hintInfo = []

    for (let _i = 0; _i < arguments.length; _i++) {
      hintInfo[_i] = arguments[_i]
    }

    let msg = ''

    if ('development' !== 'production') {
      // Fuzzy stringify for print.
      // This code only exist in dev environment.
      const makePrintableStringIfPossible_1 = function (val) {
        return val === void 0 ? 'undefined' : val === Infinity ? 'Infinity' : val === -Infinity ? '-Infinity' : eqNaN(val) ? 'NaN' : val instanceof Date ? 'Date(' + val.toISOString() + ')' : isFunction(val) ? 'function () { ... }' : isRegExp(val) ? val + '' : null
      }

      msg = map(hintInfo, function (arg) {
        if (isString(arg)) {
          // Print without quotation mark for some statement.
          return arg
        } else {
          const printableStr = makePrintableStringIfPossible_1(arg)

          if (printableStr != null) {
            return printableStr
          } else if (typeof JSON !== 'undefined' && JSON.stringify) {
            try {
              return JSON.stringify(arg, function (n, val) {
                const printableStr = makePrintableStringIfPossible_1(val)
                return printableStr == null ? val : printableStr
              }) // In most cases the info object is small, so do not line break.
            } catch (err) {
              return '?'
            }
          } else {
            return '?'
          }
        }
      }).join(' ')
    }

    return msg
  }
  /**
     * @throws Error
     */

  function throwError (msg) {
    throw new Error(msg)
  }

  function interpolateNumber$1 (p0, p1, percent) {
    return (p1 - p0) * percent + p0
  }
  /**
     * Make the name displayable. But we should
     * make sure it is not duplicated with user
     * specified name, so use '\0';
     */

  const DUMMY_COMPONENT_NAME_PREFIX = 'series\0'
  const INTERNAL_COMPONENT_ID_PREFIX = '\0_ec_\0'
  /**
     * If value is not array, then translate it to array.
     * @param  {*} value
     * @return {Array} [value] or value
     */

  function normalizeToArray (value) {
    return value instanceof Array ? value : value == null ? [] : [value]
  }
  /**
     * Sync default option between normal and emphasis like `position` and `show`
     * In case some one will write code like
     *     label: {
     *          show: false,
     *          position: 'outside',
     *          fontSize: 18
     *     },
     *     emphasis: {
     *          label: { show: true }
     *     }
     */

  function defaultEmphasis (opt, key, subOpts) {
    // Caution: performance sensitive.
    if (opt) {
      opt[key] = opt[key] || {}
      opt.emphasis = opt.emphasis || {}
      opt.emphasis[key] = opt.emphasis[key] || {} // Default emphasis option from normal

      for (let i = 0, len = subOpts.length; i < len; i++) {
        const subOptName = subOpts[i]

        if (!opt.emphasis[key].hasOwnProperty(subOptName) && opt[key].hasOwnProperty(subOptName)) {
          opt.emphasis[key][subOptName] = opt[key][subOptName]
        }
      }
    }
  }
  const TEXT_STYLE_OPTIONS = ['fontStyle', 'fontWeight', 'fontSize', 'fontFamily', 'rich', 'tag', 'color', 'textBorderColor', 'textBorderWidth', 'width', 'height', 'lineHeight', 'align', 'verticalAlign', 'baseline', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY', 'textShadowColor', 'textShadowBlur', 'textShadowOffsetX', 'textShadowOffsetY', 'backgroundColor', 'borderColor', 'borderWidth', 'borderRadius', 'padding'] // modelUtil.LABEL_OPTIONS = modelUtil.TEXT_STYLE_OPTIONS.concat([
  //     'position', 'offset', 'rotate', 'origin', 'show', 'distance', 'formatter',
  //     'fontStyle', 'fontWeight', 'fontSize', 'fontFamily',
  //     // FIXME: deprecated, check and remove it.
  //     'textStyle'
  // ]);

  /**
     * The method do not ensure performance.
     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]
     * This helper method retieves value from data.
     */

  function getDataItemValue (dataItem) {
    return isObject(dataItem) && !isArray(dataItem) && !(dataItem instanceof Date) ? dataItem.value : dataItem
  }
  /**
     * data could be [12, 2323, {value: 223}, [1221, 23], {value: [2, 23]}]
     * This helper method determine if dataItem has extra option besides value
     */

  function isDataItemOption (dataItem) {
    return isObject(dataItem) && !(dataItem instanceof Array) // // markLine data can be array
    // && !(dataItem[0] && isObject(dataItem[0]) && !(dataItem[0] instanceof Array));
  }
  /**
     * Mapping to existings for merge.
     *
     * Mode "normalMege":
     *     The mapping result (merge result) will keep the order of the existing
     *     component, rather than the order of new option. Because we should ensure
     *     some specified index reference (like xAxisIndex) keep work.
     *     And in most cases, "merge option" is used to update partial option but not
     *     be expected to change the order.
     *
     * Mode "replaceMege":
     *     (1) Only the id mapped components will be merged.
     *     (2) Other existing components (except internal compoonets) will be removed.
     *     (3) Other new options will be used to create new component.
     *     (4) The index of the existing compoents will not be modified.
     *     That means their might be "hole" after the removal.
     *     The new components are created first at those available index.
     *
     * Mode "replaceAll":
     *     This mode try to support that reproduce an echarts instance from another
     *     echarts instance (via `getOption`) in some simple cases.
     *     In this senario, the `result` index are exactly the consistent with the `newCmptOptions`,
     *     which ensures the compoennt index referring (like `xAxisIndex: ?`) corrent. That is,
     *     the "hole" in `newCmptOptions` will also be kept.
     *     On the contrary, other modes try best to eliminate holes.
     *     PENDING: This is an experimental mode yet.
     *
     * @return See the comment of <MappingResult>.
     */

  function mappingToExists (existings, newCmptOptions, mode) {
    const isNormalMergeMode = mode === 'normalMerge'
    const isReplaceMergeMode = mode === 'replaceMerge'
    const isReplaceAllMode = mode === 'replaceAll'
    existings = existings || []
    newCmptOptions = (newCmptOptions || []).slice()
    const existingIdIdxMap = createHashMap() // Validate id and name on user input option.

    each(newCmptOptions, function (cmptOption, index) {
      if (!isObject(cmptOption)) {
        newCmptOptions[index] = null
        return
      }

      if ('development' !== 'production') {
        // There is some legacy case that name is set as `false`.
        // But should work normally rather than throw error.
        if (cmptOption.id != null && !isValidIdOrName(cmptOption.id)) {
          warnInvalidateIdOrName(cmptOption.id)
        }

        if (cmptOption.name != null && !isValidIdOrName(cmptOption.name)) {
          warnInvalidateIdOrName(cmptOption.name)
        }
      }
    })
    const result = prepareResult(existings, existingIdIdxMap, mode)

    if (isNormalMergeMode || isReplaceMergeMode) {
      mappingById(result, existings, existingIdIdxMap, newCmptOptions)
    }

    if (isNormalMergeMode) {
      mappingByName(result, newCmptOptions)
    }

    if (isNormalMergeMode || isReplaceMergeMode) {
      mappingByIndex(result, newCmptOptions, isReplaceMergeMode)
    } else if (isReplaceAllMode) {
      mappingInReplaceAllMode(result, newCmptOptions)
    }

    makeIdAndName(result) // The array `result` MUST NOT contain elided items, otherwise the
    // forEach will ommit those items and result in incorrect result.

    return result
  }

  function prepareResult (existings, existingIdIdxMap, mode) {
    const result = []

    if (mode === 'replaceAll') {
      return result
    } // Do not use native `map` to in case that the array `existings`
    // contains elided items, which will be ommited.

    for (let index = 0; index < existings.length; index++) {
      const existing = existings[index] // Because of replaceMerge, `existing` may be null/undefined.

      if (existing && existing.id != null) {
        existingIdIdxMap.set(existing.id, index)
      } // For non-internal-componnets:
      //     Mode "normalMerge": all existings kept.
      //     Mode "replaceMerge": all existing removed unless mapped by id.
      // For internal-components:
      //     go with "replaceMerge" approach in both mode.

      result.push({
        existing: mode === 'replaceMerge' || isComponentIdInternal(existing) ? null : existing,
        newOption: null,
        keyInfo: null,
        brandNew: null
      })
    }

    return result
  }

  function mappingById (result, existings, existingIdIdxMap, newCmptOptions) {
    // Mapping by id if specified.
    each(newCmptOptions, function (cmptOption, index) {
      if (!cmptOption || cmptOption.id == null) {
        return
      }

      const optionId = makeComparableKey(cmptOption.id)
      const existingIdx = existingIdIdxMap.get(optionId)

      if (existingIdx != null) {
        const resultItem = result[existingIdx]
        assert(!resultItem.newOption, 'Duplicated option on id "' + optionId + '".')
        resultItem.newOption = cmptOption // In both mode, if id matched, new option will be merged to
        // the existings rather than creating new component model.

        resultItem.existing = existings[existingIdx]
        newCmptOptions[index] = null
      }
    })
  }

  function mappingByName (result, newCmptOptions) {
    // Mapping by name if specified.
    each(newCmptOptions, function (cmptOption, index) {
      if (!cmptOption || cmptOption.name == null) {
        return
      }

      for (let i = 0; i < result.length; i++) {
        const existing = result[i].existing

        if (!result[i].newOption && // Consider name: two map to one.
          // Can not match when both ids existing but different.
          existing && (existing.id == null || cmptOption.id == null) && !isComponentIdInternal(cmptOption) && !isComponentIdInternal(existing) && keyExistAndEqual('name', existing, cmptOption)) {
          result[i].newOption = cmptOption
          newCmptOptions[index] = null
          return
        }
      }
    })
  }

  function mappingByIndex (result, newCmptOptions, brandNew) {
    each(newCmptOptions, function (cmptOption) {
      if (!cmptOption) {
        return
      } // Find the first place that not mapped by id and not internal component (consider the "hole").

      let resultItem
      let nextIdx = 0

      while ( // Be `!resultItem` only when `nextIdx >= result.length`.
        (resultItem = result[nextIdx]) && ( // (1) Existing models that already have id should be able to mapped to. Because
        // after mapping performed, model will always be assigned with an id if user not given.
        // After that all models have id.
        // (2) If new option has id, it can only set to a hole or append to the last. It should
        // not be merged to the existings with different id. Because id should not be overwritten.
        // (3) Name can be overwritten, because axis use name as 'show label text'.
          resultItem.newOption || isComponentIdInternal(resultItem.existing) || // In mode "replaceMerge", here no not-mapped-non-internal-existing.
        resultItem.existing && cmptOption.id != null && !keyExistAndEqual('id', cmptOption, resultItem.existing))) {
        nextIdx++
      }

      if (resultItem) {
        resultItem.newOption = cmptOption
        resultItem.brandNew = brandNew
      } else {
        result.push({
          newOption: cmptOption,
          brandNew: brandNew,
          existing: null,
          keyInfo: null
        })
      }

      nextIdx++
    })
  }

  function mappingInReplaceAllMode (result, newCmptOptions) {
    each(newCmptOptions, function (cmptOption) {
      // The feature "reproduce" requires "hole" will also reproduced
      // in case that compoennt index referring are broken.
      result.push({
        newOption: cmptOption,
        brandNew: true,
        existing: null,
        keyInfo: null
      })
    })
  }
  /**
     * Make id and name for mapping result (result of mappingToExists)
     * into `keyInfo` field.
     */

  function makeIdAndName (mapResult) {
    // We use this id to hash component models and view instances
    // in echarts. id can be specified by user, or auto generated.
    // The id generation rule ensures new view instance are able
    // to mapped to old instance when setOption are called in
    // no-merge mode. So we generate model id by name and plus
    // type in view id.
    // name can be duplicated among components, which is convenient
    // to specify multi components (like series) by one name.
    // Ensure that each id is distinct.
    const idMap = createHashMap()
    each(mapResult, function (item) {
      const existing = item.existing
      existing && idMap.set(existing.id, item)
    })
    each(mapResult, function (item) {
      const opt = item.newOption // Force ensure id not duplicated.

      assert(!opt || opt.id == null || !idMap.get(opt.id) || idMap.get(opt.id) === item, 'id duplicates: ' + (opt && opt.id))
      opt && opt.id != null && idMap.set(opt.id, item)
      !item.keyInfo && (item.keyInfo = {})
    }) // Make name and id.

    each(mapResult, function (item, index) {
      const existing = item.existing
      const opt = item.newOption
      const keyInfo = item.keyInfo

      if (!isObject(opt)) {
        return
      } // name can be overwitten. Consider case: axis.name = '20km'.
      // But id generated by name will not be changed, which affect
      // only in that case: setOption with 'not merge mode' and view
      // instance will be recreated, which can be accepted.

      keyInfo.name = opt.name != null ? makeComparableKey(opt.name) : existing ? existing.name // Avoid diffferent series has the same name,
        // because name may be used like in color pallet.
        : DUMMY_COMPONENT_NAME_PREFIX + index

      if (existing) {
        keyInfo.id = makeComparableKey(existing.id)
      } else if (opt.id != null) {
        keyInfo.id = makeComparableKey(opt.id)
      } else {
        // Consider this situatoin:
        //  optionA: [{name: 'a'}, {name: 'a'}, {..}]
        //  optionB [{..}, {name: 'a'}, {name: 'a'}]
        // Series with the same name between optionA and optionB
        // should be mapped.
        let idNum = 0

        do {
          keyInfo.id = '\0' + keyInfo.name + '\0' + idNum++
        } while (idMap.get(keyInfo.id))
      }

      idMap.set(keyInfo.id, item)
    })
  }

  function keyExistAndEqual (attr, obj1, obj2) {
    const key1 = convertOptionIdName(obj1[attr], null)
    const key2 = convertOptionIdName(obj2[attr], null) // See `MappingExistingItem`. `id` and `name` trade string equals to number.

    return key1 != null && key2 != null && key1 === key2
  }
  /**
     * @return return null if not exist.
     */

  function makeComparableKey (val) {
    if ('development' !== 'production') {
      if (val == null) {
        throw new Error()
      }
    }

    return convertOptionIdName(val, '')
  }

  function convertOptionIdName (idOrName, defaultValue) {
    if (idOrName == null) {
      return defaultValue
    }

    return isString(idOrName) ? idOrName : isNumber(idOrName) || isStringSafe(idOrName) ? idOrName + '' : defaultValue
  }

  function warnInvalidateIdOrName (idOrName) {
    if ('development' !== 'production') {
      warn('`' + idOrName + '` is invalid id or name. Must be a string or number.')
    }
  }

  function isValidIdOrName (idOrName) {
    return isStringSafe(idOrName) || isNumeric(idOrName)
  }

  function isNameSpecified (componentModel) {
    const name = componentModel.name // Is specified when `indexOf` get -1 or > 0.

    return !!(name && name.indexOf(DUMMY_COMPONENT_NAME_PREFIX))
  }
  /**
     * @public
     * @param {Object} cmptOption
     * @return {boolean}
     */

  function isComponentIdInternal (cmptOption) {
    return cmptOption && cmptOption.id != null && makeComparableKey(cmptOption.id).indexOf(INTERNAL_COMPONENT_ID_PREFIX) === 0
  }
  function makeInternalComponentId (idSuffix) {
    return INTERNAL_COMPONENT_ID_PREFIX + idSuffix
  }
  function setComponentTypeToKeyInfo (mappingResult, mainType, componentModelCtor) {
    // Set mainType and complete subType.
    each(mappingResult, function (item) {
      const newOption = item.newOption

      if (isObject(newOption)) {
        item.keyInfo.mainType = mainType
        item.keyInfo.subType = determineSubType(mainType, newOption, item.existing, componentModelCtor)
      }
    })
  }

  function determineSubType (mainType, newCmptOption, existComponent, componentModelCtor) {
    const subType = newCmptOption.type ? newCmptOption.type : existComponent ? existComponent.subType // Use determineSubType only when there is no existComponent.
      : componentModelCtor.determineSubType(mainType, newCmptOption) // tooltip, markline, markpoint may always has no subType

    return subType
  }
  /**
     * A helper for removing duplicate items between batchA and batchB,
     * and in themselves, and categorize by series.
     *
     * @param batchA Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]
     * @param batchB Like: [{seriesId: 2, dataIndex: [32, 4, 5]}, ...]
     * @return result: [resultBatchA, resultBatchB]
     */

  function compressBatches (batchA, batchB) {
    const mapA = {}
    const mapB = {}
    makeMap(batchA || [], mapA)
    makeMap(batchB || [], mapB, mapA)
    return [mapToArray(mapA), mapToArray(mapB)]

    function makeMap (sourceBatch, map, otherMap) {
      for (let i = 0, len = sourceBatch.length; i < len; i++) {
        const seriesId = convertOptionIdName(sourceBatch[i].seriesId, null)

        if (seriesId == null) {
          return
        }

        const dataIndices = normalizeToArray(sourceBatch[i].dataIndex)
        const otherDataIndices = otherMap && otherMap[seriesId]

        for (let j = 0, lenj = dataIndices.length; j < lenj; j++) {
          const dataIndex = dataIndices[j]

          if (otherDataIndices && otherDataIndices[dataIndex]) {
            otherDataIndices[dataIndex] = null
          } else {
            (map[seriesId] || (map[seriesId] = {}))[dataIndex] = 1
          }
        }
      }
    }

    function mapToArray (map, isData) {
      const result = []

      for (const i in map) {
        if (map.hasOwnProperty(i) && map[i] != null) {
          if (isData) {
            result.push(+i)
          } else {
            const dataIndices = mapToArray(map[i], true)
            dataIndices.length && result.push({
              seriesId: i,
              dataIndex: dataIndices
            })
          }
        }
      }

      return result
    }
  }
  /**
     * @param payload Contains dataIndex (means rawIndex) / dataIndexInside / name
     *                         each of which can be Array or primary type.
     * @return dataIndex If not found, return undefined/null.
     */

  function queryDataIndex (data, payload) {
    if (payload.dataIndexInside != null) {
      return payload.dataIndexInside
    } else if (payload.dataIndex != null) {
      return isArray(payload.dataIndex)
        ? map(payload.dataIndex, function (value) {
          return data.indexOfRawIndex(value)
        })
        : data.indexOfRawIndex(payload.dataIndex)
    } else if (payload.name != null) {
      return isArray(payload.name)
        ? map(payload.name, function (value) {
          return data.indexOfName(value)
        })
        : data.indexOfName(payload.name)
    }
  }
  /**
     * Enable property storage to any host object.
     * Notice: Serialization is not supported.
     *
     * For example:
     * let inner = zrUitl.makeInner();
     *
     * function some1(hostObj) {
     *      inner(hostObj).someProperty = 1212;
     *      ...
     * }
     * function some2() {
     *      let fields = inner(this);
     *      fields.someProperty1 = 1212;
     *      fields.someProperty2 = 'xx';
     *      ...
     * }
     *
     * @return {Function}
     */

  function makeInner () {
    const key = '__ec_inner_' + innerUniqueIndex++
    return function (hostObj) {
      return hostObj[key] || (hostObj[key] = {})
    }
  }
  var innerUniqueIndex = getRandomIdBase()
  /**
     * The same behavior as `component.getReferringComponents`.
     */

  function parseFinder (ecModel, finderInput, opt) {
    const _a = preParseFinder(finderInput, opt)
    const mainTypeSpecified = _a.mainTypeSpecified
    const queryOptionMap = _a.queryOptionMap
    const others = _a.others

    const result = others
    const defaultMainType = opt ? opt.defaultMainType : null

    if (!mainTypeSpecified && defaultMainType) {
      queryOptionMap.set(defaultMainType, {})
    }

    queryOptionMap.each(function (queryOption, mainType) {
      const queryResult = queryReferringComponents(ecModel, mainType, queryOption, {
        useDefault: defaultMainType === mainType,
        enableAll: opt && opt.enableAll != null ? opt.enableAll : true,
        enableNone: opt && opt.enableNone != null ? opt.enableNone : true
      })
      result[mainType + 'Models'] = queryResult.models
      result[mainType + 'Model'] = queryResult.models[0]
    })
    return result
  }
  function preParseFinder (finderInput, opt) {
    let finder

    if (isString(finderInput)) {
      const obj = {}
      obj[finderInput + 'Index'] = 0
      finder = obj
    } else {
      finder = finderInput
    }

    const queryOptionMap = createHashMap()
    const others = {}
    let mainTypeSpecified = false
    each(finder, function (value, key) {
      // Exclude 'dataIndex' and other illgal keys.
      if (key === 'dataIndex' || key === 'dataIndexInside') {
        others[key] = value
        return
      }

      const parsedKey = key.match(/^(\w+)(Index|Id|Name)$/) || []
      const mainType = parsedKey[1]
      const queryType = (parsedKey[2] || '').toLowerCase()

      if (!mainType || !queryType || opt && opt.includeMainTypes && indexOf(opt.includeMainTypes, mainType) < 0) {
        return
      }

      mainTypeSpecified = mainTypeSpecified || !!mainType
      const queryOption = queryOptionMap.get(mainType) || queryOptionMap.set(mainType, {})
      queryOption[queryType] = value
    })
    return {
      mainTypeSpecified: mainTypeSpecified,
      queryOptionMap: queryOptionMap,
      others: others
    }
  }
  const SINGLE_REFERRING = {
    useDefault: true,
    enableAll: false,
    enableNone: false
  }
  const MULTIPLE_REFERRING = {
    useDefault: false,
    enableAll: true,
    enableNone: true
  }
  function queryReferringComponents (ecModel, mainType, userOption, opt) {
    opt = opt || SINGLE_REFERRING
    let indexOption = userOption.index
    let idOption = userOption.id
    let nameOption = userOption.name
    const result = {
      models: null,
      specified: indexOption != null || idOption != null || nameOption != null
    }

    if (!result.specified) {
      // Use the first as default if `useDefault`.
      let firstCmpt = void 0
      result.models = opt.useDefault && (firstCmpt = ecModel.getComponent(mainType)) ? [firstCmpt] : []
      return result
    }

    if (indexOption === 'none' || indexOption === false) {
      assert(opt.enableNone, '`"none"` or `false` is not a valid value on index option.')
      result.models = []
      return result
    } // `queryComponents` will return all components if
    // both all of index/id/name are null/undefined.

    if (indexOption === 'all') {
      assert(opt.enableAll, '`"all"` is not a valid value on index option.')
      indexOption = idOption = nameOption = null
    }

    result.models = ecModel.queryComponents({
      mainType: mainType,
      index: indexOption,
      id: idOption,
      name: nameOption
    })
    return result
  }
  function setAttribute (dom, key, value) {
    dom.setAttribute ? dom.setAttribute(key, value) : dom[key] = value
  }
  function getAttribute (dom, key) {
    return dom.getAttribute ? dom.getAttribute(key) : dom[key]
  }
  function getTooltipRenderMode (renderModeOption) {
    if (renderModeOption === 'auto') {
      // Using html when `document` exists, use richText otherwise
      return env.domSupported ? 'html' : 'richText'
    } else {
      return renderModeOption || 'html'
    }
  }
  /**
     * Group a list by key.
     */

  function groupData (array, getKey // return key
  ) {
    const buckets = createHashMap()
    const keys = []
    each(array, function (item) {
      const key = getKey(item);
      (buckets.get(key) || (keys.push(key), buckets.set(key, []))).push(item)
    })
    return {
      keys: keys,
      buckets: buckets
    }
  }
  /**
     * Interpolate raw values of a series with percent
     *
     * @param data         data
     * @param labelModel   label model of the text element
     * @param sourceValue  start value. May be null/undefined when init.
     * @param targetValue  end value
     * @param percent      0~1 percentage; 0 uses start value while 1 uses end value
     * @return             interpolated values
     *                     If `sourceValue` and `targetValue` are `number`, return `number`.
     *                     If `sourceValue` and `targetValue` are `string`, return `string`.
     *                     If `sourceValue` and `targetValue` are `(string | number)[]`, return `(string | number)[]`.
     *                     Other cases do not supported.
     */

  function interpolateRawValues (data, precision, sourceValue, targetValue, percent) {
    const isAutoPrecision = precision == null || precision === 'auto'

    if (targetValue == null) {
      return targetValue
    }

    if (isNumber(targetValue)) {
      var value = interpolateNumber$1(sourceValue || 0, targetValue, percent)
      return round(value, isAutoPrecision ? Math.max(getPrecision(sourceValue || 0), getPrecision(targetValue)) : precision)
    } else if (isString(targetValue)) {
      return percent < 1 ? sourceValue : targetValue
    } else {
      const interpolated = []
      const leftArr = sourceValue
      const rightArr = targetValue
      const length_1 = Math.max(leftArr ? leftArr.length : 0, rightArr.length)

      for (let i = 0; i < length_1; ++i) {
        const info = data.getDimensionInfo(i) // Don't interpolate ordinal dims

        if (info && info.type === 'ordinal') {
          // In init, there is no `sourceValue`, but should better not to get undefined result.
          interpolated[i] = (percent < 1 && leftArr ? leftArr : rightArr)[i]
        } else {
          const leftVal = leftArr && leftArr[i] ? leftArr[i] : 0
          const rightVal = rightArr[i]
          var value = interpolateNumber$1(leftVal, rightVal, percent)
          interpolated[i] = round(value, isAutoPrecision ? Math.max(getPrecision(leftVal), getPrecision(rightVal)) : precision)
        }
      }

      return interpolated
    }
  }

  const TYPE_DELIMITER = '.'
  const IS_CONTAINER = '___EC__COMPONENT__CONTAINER___'
  const IS_EXTENDED_CLASS = '___EC__EXTENDED_CLASS___'
  /**
     * Notice, parseClassType('') should returns {main: '', sub: ''}
     * @public
     */

  function parseClassType (componentType) {
    const ret = {
      main: '',
      sub: ''
    }

    if (componentType) {
      const typeArr = componentType.split(TYPE_DELIMITER)
      ret.main = typeArr[0] || ''
      ret.sub = typeArr[1] || ''
    }

    return ret
  }
  /**
     * @public
     */

  function checkClassType (componentType) {
    assert(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(componentType), 'componentType "' + componentType + '" illegal')
  }

  function isExtendedClass (clz) {
    return !!(clz && clz[IS_EXTENDED_CLASS])
  }
  /**
     * Implements `ExtendableConstructor` for `rootClz`.
     *
     * @usage
     * ```ts
     * class Xxx {}
     * type XxxConstructor = typeof Xxx & ExtendableConstructor
     * enableClassExtend(Xxx as XxxConstructor);
     * ```
     */

  function enableClassExtend (rootClz, mandatoryMethods) {
    rootClz.$constructor = rootClz // FIXME: not necessary?

    rootClz.extend = function (proto) {
      if ('development' !== 'production') {
        each(mandatoryMethods, function (method) {
          if (!proto[method]) {
            console.warn('Method `' + method + '` should be implemented' + (proto.type ? ' in ' + proto.type : '') + '.')
          }
        })
      }

      const superClass = this
      let ExtendedClass

      if (isESClass(superClass)) {
        ExtendedClass =
          /** @class */
          (function (_super) {
            __extends(class_1, _super)

            function class_1 () {
              return _super.apply(this, arguments) || this
            }

            return class_1
          }(superClass))
      } else {
        // For backward compat, we both support ts class inheritance and this
        // "extend" approach.
        // The constructor should keep the same behavior as ts class inheritance:
        // If this constructor/$constructor is not declared, auto invoke the super
        // constructor.
        // If this constructor/$constructor is declared, it is responsible for
        // calling the super constructor.
        ExtendedClass = function () {
          (proto.$constructor || superClass).apply(this, arguments)
        }

        inherits(ExtendedClass, this)
      }

      extend(ExtendedClass.prototype, proto)
      ExtendedClass[IS_EXTENDED_CLASS] = true
      ExtendedClass.extend = this.extend
      ExtendedClass.superCall = superCall
      ExtendedClass.superApply = superApply
      ExtendedClass.superClass = superClass
      return ExtendedClass
    }
  }

  function isESClass (fn) {
    return isFunction(fn) && /^class\s/.test(Function.prototype.toString.call(fn))
  }
  /**
     * A work around to both support ts extend and this extend mechanism.
     * on sub-class.
     * @usage
     * ```ts
     * class Component { ... }
     * classUtil.enableClassExtend(Component);
     * classUtil.enableClassManagement(Component, {registerWhenExtend: true});
     *
     * class Series extends Component { ... }
     * // Without calling `markExtend`, `registerWhenExtend` will not work.
     * Component.markExtend(Series);
     * ```
     */

  function mountExtend (SubClz, SupperClz) {
    SubClz.extend = SupperClz.extend
  } // A random offset.

  let classBase = Math.round(Math.random() * 10)
  /**
     * Implements `CheckableConstructor` for `target`.
     * Can not use instanceof, consider different scope by
     * cross domain or es module import in ec extensions.
     * Mount a method "isInstance()" to Clz.
     *
     * @usage
     * ```ts
     * class Xxx {}
     * type XxxConstructor = typeof Xxx & CheckableConstructor;
     * enableClassCheck(Xxx as XxxConstructor)
     * ```
     */

  function enableClassCheck (target) {
    const classAttr = ['__\0is_clz', classBase++].join('_')
    target.prototype[classAttr] = true

    if ('development' !== 'production') {
      assert(!target.isInstance, 'The method "is" can not be defined.')
    }

    target.isInstance = function (obj) {
      return !!(obj && obj[classAttr])
    }
  } // superCall should have class info, which can not be fetch from 'this'.
  // Consider this case:
  // class A has method f,
  // class B inherits class A, overrides method f, f call superApply('f'),
  // class C inherits class B, do not overrides method f,
  // then when method of class C is called, dead loop occured.

  function superCall (context, methodName) {
    const args = []

    for (let _i = 2; _i < arguments.length; _i++) {
      args[_i - 2] = arguments[_i]
    }

    return this.superClass.prototype[methodName].apply(context, args)
  }

  function superApply (context, methodName, args) {
    return this.superClass.prototype[methodName].apply(context, args)
  }
  /**
     * Implements `ClassManager` for `target`
     *
     * @usage
     * ```ts
     * class Xxx {}
     * type XxxConstructor = typeof Xxx & ClassManager
     * enableClassManagement(Xxx as XxxConstructor);
     * ```
     */

  function enableClassManagement (target) {
    /**
       * Component model classes
       * key: componentType,
       * value:
       *     componentClass, when componentType is 'a'
       *     or Object.<subKey, componentClass>, when componentType is 'a.b'
       */
    const storage = {}

    target.registerClass = function (clz) {
      // `type` should not be a "instance memeber".
      // If using TS class, should better declared as `static type = 'series.pie'`.
      // otherwise users have to mount `type` on prototype manually.
      // For backward compat and enable instance visit type via `this.type`,
      // we stil support fetch `type` from prototype.
      const componentFullType = clz.type || clz.prototype.type

      if (componentFullType) {
        checkClassType(componentFullType) // If only static type declared, we assign it to prototype mandatorily.

        clz.prototype.type = componentFullType
        const componentTypeInfo = parseClassType(componentFullType)

        if (!componentTypeInfo.sub) {
          if ('development' !== 'production') {
            if (storage[componentTypeInfo.main]) {
              console.warn(componentTypeInfo.main + ' exists.')
            }
          }

          storage[componentTypeInfo.main] = clz
        } else if (componentTypeInfo.sub !== IS_CONTAINER) {
          const container = makeContainer(componentTypeInfo)
          container[componentTypeInfo.sub] = clz
        }
      }

      return clz
    }

    target.getClass = function (mainType, subType, throwWhenNotFound) {
      let clz = storage[mainType]

      if (clz && clz[IS_CONTAINER]) {
        clz = subType ? clz[subType] : null
      }

      if (throwWhenNotFound && !clz) {
        throw new Error(!subType ? mainType + '.' + 'type should be specified.' : 'Component ' + mainType + '.' + (subType || '') + ' is used but not imported.')
      }

      return clz
    }

    target.getClassesByMainType = function (componentType) {
      const componentTypeInfo = parseClassType(componentType)
      const result = []
      const obj = storage[componentTypeInfo.main]

      if (obj && obj[IS_CONTAINER]) {
        each(obj, function (o, type) {
          type !== IS_CONTAINER && result.push(o)
        })
      } else {
        result.push(obj)
      }

      return result
    }

    target.hasClass = function (componentType) {
      // Just consider componentType.main.
      const componentTypeInfo = parseClassType(componentType)
      return !!storage[componentTypeInfo.main]
    }
    /**
       * @return Like ['aa', 'bb'], but can not be ['aa.xx']
       */

    target.getAllClassMainTypes = function () {
      const types = []
      each(storage, function (obj, type) {
        types.push(type)
      })
      return types
    }
    /**
       * If a main type is container and has sub types
       */

    target.hasSubTypes = function (componentType) {
      const componentTypeInfo = parseClassType(componentType)
      const obj = storage[componentTypeInfo.main]
      return obj && obj[IS_CONTAINER]
    }

    function makeContainer (componentTypeInfo) {
      let container = storage[componentTypeInfo.main]

      if (!container || !container[IS_CONTAINER]) {
        container = storage[componentTypeInfo.main] = {}
        container[IS_CONTAINER] = true
      }

      return container
    }
  } // /**
  //  * @param {string|Array.<string>} properties
  //  */
  // export function setReadOnly(obj, properties) {
  // FIXME It seems broken in IE8 simulation of IE11
  // if (!zrUtil.isArray(properties)) {
  //     properties = properties != null ? [properties] : [];
  // }
  // zrUtil.each(properties, function (prop) {
  //     let value = obj[prop];
  //     Object.defineProperty
  //         && Object.defineProperty(obj, prop, {
  //             value: value, writable: false
  //         });
  //     zrUtil.isArray(obj[prop])
  //         && Object.freeze
  //         && Object.freeze(obj[prop]);
  // });
  // }

  function makeStyleMapper (properties, ignoreParent) {
    // Normalize
    for (let i = 0; i < properties.length; i++) {
      if (!properties[i][1]) {
        properties[i][1] = properties[i][0]
      }
    }

    ignoreParent = ignoreParent || false
    return function (model, excludes, includes) {
      const style = {}

      for (let i = 0; i < properties.length; i++) {
        const propName = properties[i][1]

        if (excludes && indexOf(excludes, propName) >= 0 || includes && indexOf(includes, propName) < 0) {
          continue
        }

        const val = model.getShallow(propName, ignoreParent)

        if (val != null) {
          style[properties[i][0]] = val
        }
      } // TODO Text or image?

      return style
    }
  }

  const AREA_STYLE_KEY_MAP = [['fill', 'color'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['opacity'], ['shadowColor'] // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
    // So do not transfer decal directly.
  ]
  const getAreaStyle = makeStyleMapper(AREA_STYLE_KEY_MAP)

  const AreaStyleMixin =
    /** @class */
    (function () {
      function AreaStyleMixin () {}

      AreaStyleMixin.prototype.getAreaStyle = function (excludes, includes) {
        return getAreaStyle(this, excludes, includes)
      }

      return AreaStyleMixin
    }())

  const globalImageCache = new LRU(50)
  function findExistImage (newImageOrSrc) {
    if (typeof newImageOrSrc === 'string') {
      const cachedImgObj = globalImageCache.get(newImageOrSrc)
      return cachedImgObj && cachedImgObj.image
    } else {
      return newImageOrSrc
    }
  }
  function createOrUpdateImage (newImageOrSrc, image, hostEl, onload, cbPayload) {
    if (!newImageOrSrc) {
      return image
    } else if (typeof newImageOrSrc === 'string') {
      if ((image && image.__zrImageSrc === newImageOrSrc) || !hostEl) {
        return image
      }
      const cachedImgObj = globalImageCache.get(newImageOrSrc)
      const pendingWrap = { hostEl: hostEl, cb: onload, cbPayload: cbPayload }
      if (cachedImgObj) {
        image = cachedImgObj.image
        !isImageReady(image) && cachedImgObj.pending.push(pendingWrap)
      } else {
        image = platformApi.loadImage(newImageOrSrc, imageOnLoad, imageOnLoad)
        image.__zrImageSrc = newImageOrSrc
        globalImageCache.put(newImageOrSrc, image.__cachedImgObj = {
          image: image,
          pending: [pendingWrap]
        })
      }
      return image
    } else {
      return newImageOrSrc
    }
  }
  function imageOnLoad () {
    const cachedImgObj = this.__cachedImgObj
    this.onload = this.onerror = this.__cachedImgObj = null
    for (let i = 0; i < cachedImgObj.pending.length; i++) {
      const pendingWrap = cachedImgObj.pending[i]
      const cb = pendingWrap.cb
      cb && cb(this, pendingWrap.cbPayload)
      pendingWrap.hostEl.dirty()
    }
    cachedImgObj.pending.length = 0
  }
  function isImageReady (image) {
    return image && image.width && image.height
  }

  const STYLE_REG = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g
  function truncateText (text, containerWidth, font, ellipsis, options) {
    if (!containerWidth) {
      return ''
    }
    const textLines = (text + '').split('\n')
    options = prepareTruncateOptions(containerWidth, font, ellipsis, options)
    for (let i = 0, len = textLines.length; i < len; i++) {
      textLines[i] = truncateSingleLine(textLines[i], options)
    }
    return textLines.join('\n')
  }
  function prepareTruncateOptions (containerWidth, font, ellipsis, options) {
    options = options || {}
    const preparedOpts = extend({}, options)
    preparedOpts.font = font
    ellipsis = retrieve2(ellipsis, '...')
    preparedOpts.maxIterations = retrieve2(options.maxIterations, 2)
    const minChar = preparedOpts.minChar = retrieve2(options.minChar, 0)
    preparedOpts.cnCharWidth = getWidth('国', font)
    const ascCharWidth = preparedOpts.ascCharWidth = getWidth('a', font)
    preparedOpts.placeholder = retrieve2(options.placeholder, '')
    let contentWidth = containerWidth = Math.max(0, containerWidth - 1)
    for (let i = 0; i < minChar && contentWidth >= ascCharWidth; i++) {
      contentWidth -= ascCharWidth
    }
    let ellipsisWidth = getWidth(ellipsis, font)
    if (ellipsisWidth > contentWidth) {
      ellipsis = ''
      ellipsisWidth = 0
    }
    contentWidth = containerWidth - ellipsisWidth
    preparedOpts.ellipsis = ellipsis
    preparedOpts.ellipsisWidth = ellipsisWidth
    preparedOpts.contentWidth = contentWidth
    preparedOpts.containerWidth = containerWidth
    return preparedOpts
  }
  function truncateSingleLine (textLine, options) {
    const containerWidth = options.containerWidth
    const font = options.font
    const contentWidth = options.contentWidth
    if (!containerWidth) {
      return ''
    }
    let lineWidth = getWidth(textLine, font)
    if (lineWidth <= containerWidth) {
      return textLine
    }
    for (let j = 0; ; j++) {
      if (lineWidth <= contentWidth || j >= options.maxIterations) {
        textLine += options.ellipsis
        break
      }
      const subLength = j === 0
        ? estimateLength(textLine, contentWidth, options.ascCharWidth, options.cnCharWidth)
        : lineWidth > 0
          ? Math.floor(textLine.length * contentWidth / lineWidth)
          : 0
      textLine = textLine.substr(0, subLength)
      lineWidth = getWidth(textLine, font)
    }
    if (textLine === '') {
      textLine = options.placeholder
    }
    return textLine
  }
  function estimateLength (text, contentWidth, ascCharWidth, cnCharWidth) {
    let width = 0
    let i = 0
    for (let len = text.length; i < len && width < contentWidth; i++) {
      const charCode = text.charCodeAt(i)
      width += (charCode >= 0 && charCode <= 127) ? ascCharWidth : cnCharWidth
    }
    return i
  }
  function parsePlainText (text, style) {
    text != null && (text += '')
    const overflow = style.overflow
    const padding = style.padding
    const font = style.font
    const truncate = overflow === 'truncate'
    const calculatedLineHeight = getLineHeight(font)
    const lineHeight = retrieve2(style.lineHeight, calculatedLineHeight)
    const bgColorDrawn = !!(style.backgroundColor)
    const truncateLineOverflow = style.lineOverflow === 'truncate'
    let width = style.width
    let lines
    if (width != null && (overflow === 'break' || overflow === 'breakAll')) {
      lines = text ? wrapText(text, style.font, width, overflow === 'breakAll', 0).lines : []
    } else {
      lines = text ? text.split('\n') : []
    }
    const contentHeight = lines.length * lineHeight
    const height = retrieve2(style.height, contentHeight)
    if (contentHeight > height && truncateLineOverflow) {
      const lineCount = Math.floor(height / lineHeight)
      lines = lines.slice(0, lineCount)
    }
    if (text && truncate && width != null) {
      const options = prepareTruncateOptions(width, font, style.ellipsis, {
        minChar: style.truncateMinChar,
        placeholder: style.placeholder
      })
      for (var i = 0; i < lines.length; i++) {
        lines[i] = truncateSingleLine(lines[i], options)
      }
    }
    let outerHeight = height
    let contentWidth = 0
    for (var i = 0; i < lines.length; i++) {
      contentWidth = Math.max(getWidth(lines[i], font), contentWidth)
    }
    if (width == null) {
      width = contentWidth
    }
    let outerWidth = contentWidth
    if (padding) {
      outerHeight += padding[0] + padding[2]
      outerWidth += padding[1] + padding[3]
      width += padding[1] + padding[3]
    }
    if (bgColorDrawn) {
      outerWidth = width
    }
    return {
      lines: lines,
      height: height,
      outerWidth: outerWidth,
      outerHeight: outerHeight,
      lineHeight: lineHeight,
      calculatedLineHeight: calculatedLineHeight,
      contentWidth: contentWidth,
      contentHeight: contentHeight,
      width: width
    }
  }
  const RichTextToken = (function () {
    function RichTextToken () {
    }
    return RichTextToken
  }())
  const RichTextLine = (function () {
    function RichTextLine (tokens) {
      this.tokens = []
      if (tokens) {
        this.tokens = tokens
      }
    }
    return RichTextLine
  }())
  const RichTextContentBlock = (function () {
    function RichTextContentBlock () {
      this.width = 0
      this.height = 0
      this.contentWidth = 0
      this.contentHeight = 0
      this.outerWidth = 0
      this.outerHeight = 0
      this.lines = []
    }
    return RichTextContentBlock
  }())
  function parseRichText (text, style) {
    const contentBlock = new RichTextContentBlock()
    text != null && (text += '')
    if (!text) {
      return contentBlock
    }
    const topWidth = style.width
    const topHeight = style.height
    const overflow = style.overflow
    const wrapInfo = (overflow === 'break' || overflow === 'breakAll') && topWidth != null
      ? { width: topWidth, accumWidth: 0, breakAll: overflow === 'breakAll' }
      : null
    let lastIndex = STYLE_REG.lastIndex = 0
    let result
    while ((result = STYLE_REG.exec(text)) != null) {
      const matchedIndex = result.index
      if (matchedIndex > lastIndex) {
        pushTokens(contentBlock, text.substring(lastIndex, matchedIndex), style, wrapInfo)
      }
      pushTokens(contentBlock, result[2], style, wrapInfo, result[1])
      lastIndex = STYLE_REG.lastIndex
    }
    if (lastIndex < text.length) {
      pushTokens(contentBlock, text.substring(lastIndex, text.length), style, wrapInfo)
    }
    const pendingList = []
    let calculatedHeight = 0
    let calculatedWidth = 0
    const stlPadding = style.padding
    const truncate = overflow === 'truncate'
    const truncateLine = style.lineOverflow === 'truncate'
    function finishLine (line, lineWidth, lineHeight) {
      line.width = lineWidth
      line.lineHeight = lineHeight
      calculatedHeight += lineHeight
      calculatedWidth = Math.max(calculatedWidth, lineWidth)
    }
    outer: for (var i = 0; i < contentBlock.lines.length; i++) {
      const line = contentBlock.lines[i]
      let lineHeight = 0
      let lineWidth = 0
      for (let j = 0; j < line.tokens.length; j++) {
        var token = line.tokens[j]
        const tokenStyle = token.styleName && style.rich[token.styleName] || {}
        const textPadding = token.textPadding = tokenStyle.padding
        const paddingH = textPadding ? textPadding[1] + textPadding[3] : 0
        const font = token.font = tokenStyle.font || style.font
        token.contentHeight = getLineHeight(font)
        let tokenHeight = retrieve2(tokenStyle.height, token.contentHeight)
        token.innerHeight = tokenHeight
        textPadding && (tokenHeight += textPadding[0] + textPadding[2])
        token.height = tokenHeight
        token.lineHeight = retrieve3(tokenStyle.lineHeight, style.lineHeight, tokenHeight)
        token.align = tokenStyle && tokenStyle.align || style.align
        token.verticalAlign = tokenStyle && tokenStyle.verticalAlign || 'middle'
        if (truncateLine && topHeight != null && calculatedHeight + token.lineHeight > topHeight) {
          if (j > 0) {
            line.tokens = line.tokens.slice(0, j)
            finishLine(line, lineWidth, lineHeight)
            contentBlock.lines = contentBlock.lines.slice(0, i + 1)
          } else {
            contentBlock.lines = contentBlock.lines.slice(0, i)
          }
          break outer
        }
        const styleTokenWidth = tokenStyle.width
        const tokenWidthNotSpecified = styleTokenWidth == null || styleTokenWidth === 'auto'
        if (typeof styleTokenWidth === 'string' && styleTokenWidth.charAt(styleTokenWidth.length - 1) === '%') {
          token.percentWidth = styleTokenWidth
          pendingList.push(token)
          token.contentWidth = getWidth(token.text, font)
        } else {
          if (tokenWidthNotSpecified) {
            const textBackgroundColor = tokenStyle.backgroundColor
            let bgImg = textBackgroundColor && textBackgroundColor.image
            if (bgImg) {
              bgImg = findExistImage(bgImg)
              if (isImageReady(bgImg)) {
                token.width = Math.max(token.width, bgImg.width * tokenHeight / bgImg.height)
              }
            }
          }
          const remainTruncWidth = truncate && topWidth != null
            ? topWidth - lineWidth
            : null
          if (remainTruncWidth != null && remainTruncWidth < token.width) {
            if (!tokenWidthNotSpecified || remainTruncWidth < paddingH) {
              token.text = ''
              token.width = token.contentWidth = 0
            } else {
              token.text = truncateText(token.text, remainTruncWidth - paddingH, font, style.ellipsis, { minChar: style.truncateMinChar })
              token.width = token.contentWidth = getWidth(token.text, font)
            }
          } else {
            token.contentWidth = getWidth(token.text, font)
          }
        }
        token.width += paddingH
        lineWidth += token.width
        tokenStyle && (lineHeight = Math.max(lineHeight, token.lineHeight))
      }
      finishLine(line, lineWidth, lineHeight)
    }
    contentBlock.outerWidth = contentBlock.width = retrieve2(topWidth, calculatedWidth)
    contentBlock.outerHeight = contentBlock.height = retrieve2(topHeight, calculatedHeight)
    contentBlock.contentHeight = calculatedHeight
    contentBlock.contentWidth = calculatedWidth
    if (stlPadding) {
      contentBlock.outerWidth += stlPadding[1] + stlPadding[3]
      contentBlock.outerHeight += stlPadding[0] + stlPadding[2]
    }
    for (var i = 0; i < pendingList.length; i++) {
      var token = pendingList[i]
      const percentWidth = token.percentWidth
      token.width = parseInt(percentWidth, 10) / 100 * contentBlock.width
    }
    return contentBlock
  }
  function pushTokens (block, str, style, wrapInfo, styleName) {
    const isEmptyStr = str === ''
    const tokenStyle = styleName && style.rich[styleName] || {}
    const lines = block.lines
    const font = tokenStyle.font || style.font
    let newLine = false
    let strLines
    let linesWidths
    if (wrapInfo) {
      const tokenPadding = tokenStyle.padding
      const tokenPaddingH = tokenPadding ? tokenPadding[1] + tokenPadding[3] : 0
      if (tokenStyle.width != null && tokenStyle.width !== 'auto') {
        const outerWidth_1 = parsePercent(tokenStyle.width, wrapInfo.width) + tokenPaddingH
        if (lines.length > 0) {
          if (outerWidth_1 + wrapInfo.accumWidth > wrapInfo.width) {
            strLines = str.split('\n')
            newLine = true
          }
        }
        wrapInfo.accumWidth = outerWidth_1
      } else {
        const res = wrapText(str, font, wrapInfo.width, wrapInfo.breakAll, wrapInfo.accumWidth)
        wrapInfo.accumWidth = res.accumWidth + tokenPaddingH
        linesWidths = res.linesWidths
        strLines = res.lines
      }
    } else {
      strLines = str.split('\n')
    }
    for (let i = 0; i < strLines.length; i++) {
      const text = strLines[i]
      const token = new RichTextToken()
      token.styleName = styleName
      token.text = text
      token.isLineHolder = !text && !isEmptyStr
      if (typeof tokenStyle.width === 'number') {
        token.width = tokenStyle.width
      } else {
        token.width = linesWidths
          ? linesWidths[i]
          : getWidth(text, font)
      }
      if (!i && !newLine) {
        const tokens = (lines[lines.length - 1] || (lines[0] = new RichTextLine())).tokens
        const tokensLen = tokens.length;
        (tokensLen === 1 && tokens[0].isLineHolder)
          ? (tokens[0] = token)
          : ((text || !tokensLen || isEmptyStr) && tokens.push(token))
      } else {
        lines.push(new RichTextLine([token]))
      }
    }
  }
  function isLatin (ch) {
    const code = ch.charCodeAt(0)
    return code >= 0x21 && code <= 0x17F
  }
  const breakCharMap = reduce(',&?/;] '.split(''), function (obj, ch) {
    obj[ch] = true
    return obj
  }, {})
  function isWordBreakChar (ch) {
    if (isLatin(ch)) {
      if (breakCharMap[ch]) {
        return true
      }
      return false
    }
    return true
  }
  function wrapText (text, font, lineWidth, isBreakAll, lastAccumWidth) {
    const lines = []
    const linesWidths = []
    let line = ''
    let currentWord = ''
    let currentWordWidth = 0
    let accumWidth = 0
    for (let i = 0; i < text.length; i++) {
      const ch = text.charAt(i)
      if (ch === '\n') {
        if (currentWord) {
          line += currentWord
          accumWidth += currentWordWidth
        }
        lines.push(line)
        linesWidths.push(accumWidth)
        line = ''
        currentWord = ''
        currentWordWidth = 0
        accumWidth = 0
        continue
      }
      const chWidth = getWidth(ch, font)
      const inWord = isBreakAll ? false : !isWordBreakChar(ch)
      if (!lines.length
        ? lastAccumWidth + accumWidth + chWidth > lineWidth
        : accumWidth + chWidth > lineWidth) {
        if (!accumWidth) {
          if (inWord) {
            lines.push(currentWord)
            linesWidths.push(currentWordWidth)
            currentWord = ch
            currentWordWidth = chWidth
          } else {
            lines.push(ch)
            linesWidths.push(chWidth)
          }
        } else if (line || currentWord) {
          if (inWord) {
            if (!line) {
              line = currentWord
              currentWord = ''
              currentWordWidth = 0
              accumWidth = currentWordWidth
            }
            lines.push(line)
            linesWidths.push(accumWidth - currentWordWidth)
            currentWord += ch
            currentWordWidth += chWidth
            line = ''
            accumWidth = currentWordWidth
          } else {
            if (currentWord) {
              line += currentWord
              currentWord = ''
              currentWordWidth = 0
            }
            lines.push(line)
            linesWidths.push(accumWidth)
            line = ch
            accumWidth = chWidth
          }
        }
        continue
      }
      accumWidth += chWidth
      if (inWord) {
        currentWord += ch
        currentWordWidth += chWidth
      } else {
        if (currentWord) {
          line += currentWord
          currentWord = ''
          currentWordWidth = 0
        }
        line += ch
      }
    }
    if (!lines.length && !line) {
      line = text
      currentWord = ''
      currentWordWidth = 0
    }
    if (currentWord) {
      line += currentWord
    }
    if (line) {
      lines.push(line)
      linesWidths.push(accumWidth)
    }
    if (lines.length === 1) {
      accumWidth += lastAccumWidth
    }
    return {
      accumWidth: accumWidth,
      lines: lines,
      linesWidths: linesWidths
    }
  }

  const STYLE_MAGIC_KEY = '__zr_style_' + Math.round((Math.random() * 10))
  const DEFAULT_COMMON_STYLE = {
    shadowBlur: 0,
    shadowOffsetX: 0,
    shadowOffsetY: 0,
    shadowColor: '#000',
    opacity: 1,
    blend: 'source-over'
  }
  const DEFAULT_COMMON_ANIMATION_PROPS = {
    style: {
      shadowBlur: true,
      shadowOffsetX: true,
      shadowOffsetY: true,
      shadowColor: true,
      opacity: true
    }
  }
  DEFAULT_COMMON_STYLE[STYLE_MAGIC_KEY] = true
  const PRIMARY_STATES_KEYS$1 = ['z', 'z2', 'invisible']
  const PRIMARY_STATES_KEYS_IN_HOVER_LAYER = ['invisible']
  const Displayable = (function (_super) {
    __extends(Displayable, _super)
    function Displayable (props) {
      return _super.call(this, props) || this
    }
    Displayable.prototype._init = function (props) {
      const keysArr = keys(props)
      for (let i = 0; i < keysArr.length; i++) {
        const key = keysArr[i]
        if (key === 'style') {
          this.useStyle(props[key])
        } else {
          _super.prototype.attrKV.call(this, key, props[key])
        }
      }
      if (!this.style) {
        this.useStyle({})
      }
    }
    Displayable.prototype.beforeBrush = function () { }
    Displayable.prototype.afterBrush = function () { }
    Displayable.prototype.innerBeforeBrush = function () { }
    Displayable.prototype.innerAfterBrush = function () { }
    Displayable.prototype.shouldBePainted = function (viewWidth, viewHeight, considerClipPath, considerAncestors) {
      const m = this.transform
      if (this.ignore ||
                this.invisible ||
                this.style.opacity === 0 ||
                (this.culling &&
                    isDisplayableCulled(this, viewWidth, viewHeight)) ||
                (m && !m[0] && !m[3])) {
        return false
      }
      if (considerClipPath && this.__clipPaths) {
        for (let i = 0; i < this.__clipPaths.length; ++i) {
          if (this.__clipPaths[i].isZeroArea()) {
            return false
          }
        }
      }
      if (considerAncestors && this.parent) {
        let parent_1 = this.parent
        while (parent_1) {
          if (parent_1.ignore) {
            return false
          }
          parent_1 = parent_1.parent
        }
      }
      return true
    }
    Displayable.prototype.contain = function (x, y) {
      return this.rectContain(x, y)
    }
    Displayable.prototype.traverse = function (cb, context) {
      cb.call(context, this)
    }
    Displayable.prototype.rectContain = function (x, y) {
      const coord = this.transformCoordToLocal(x, y)
      const rect = this.getBoundingRect()
      return rect.contain(coord[0], coord[1])
    }
    Displayable.prototype.getPaintRect = function () {
      let rect = this._paintRect
      if (!this._paintRect || this.__dirty) {
        const transform = this.transform
        const elRect = this.getBoundingRect()
        const style = this.style
        const shadowSize = style.shadowBlur || 0
        const shadowOffsetX = style.shadowOffsetX || 0
        const shadowOffsetY = style.shadowOffsetY || 0
        rect = this._paintRect || (this._paintRect = new BoundingRect(0, 0, 0, 0))
        if (transform) {
          BoundingRect.applyTransform(rect, elRect, transform)
        } else {
          rect.copy(elRect)
        }
        if (shadowSize || shadowOffsetX || shadowOffsetY) {
          rect.width += shadowSize * 2 + Math.abs(shadowOffsetX)
          rect.height += shadowSize * 2 + Math.abs(shadowOffsetY)
          rect.x = Math.min(rect.x, rect.x + shadowOffsetX - shadowSize)
          rect.y = Math.min(rect.y, rect.y + shadowOffsetY - shadowSize)
        }
        const tolerance = this.dirtyRectTolerance
        if (!rect.isZero()) {
          rect.x = Math.floor(rect.x - tolerance)
          rect.y = Math.floor(rect.y - tolerance)
          rect.width = Math.ceil(rect.width + 1 + tolerance * 2)
          rect.height = Math.ceil(rect.height + 1 + tolerance * 2)
        }
      }
      return rect
    }
    Displayable.prototype.setPrevPaintRect = function (paintRect) {
      if (paintRect) {
        this._prevPaintRect = this._prevPaintRect || new BoundingRect(0, 0, 0, 0)
        this._prevPaintRect.copy(paintRect)
      } else {
        this._prevPaintRect = null
      }
    }
    Displayable.prototype.getPrevPaintRect = function () {
      return this._prevPaintRect
    }
    Displayable.prototype.animateStyle = function (loop) {
      return this.animate('style', loop)
    }
    Displayable.prototype.updateDuringAnimation = function (targetKey) {
      if (targetKey === 'style') {
        this.dirtyStyle()
      } else {
        this.markRedraw()
      }
    }
    Displayable.prototype.attrKV = function (key, value) {
      if (key !== 'style') {
        _super.prototype.attrKV.call(this, key, value)
      } else {
        if (!this.style) {
          this.useStyle(value)
        } else {
          this.setStyle(value)
        }
      }
    }
    Displayable.prototype.setStyle = function (keyOrObj, value) {
      if (typeof keyOrObj === 'string') {
        this.style[keyOrObj] = value
      } else {
        extend(this.style, keyOrObj)
      }
      this.dirtyStyle()
      return this
    }
    Displayable.prototype.dirtyStyle = function (notRedraw) {
      if (!notRedraw) {
        this.markRedraw()
      }
      this.__dirty |= STYLE_CHANGED_BIT
      if (this._rect) {
        this._rect = null
      }
    }
    Displayable.prototype.dirty = function () {
      this.dirtyStyle()
    }
    Displayable.prototype.styleChanged = function () {
      return !!(this.__dirty & STYLE_CHANGED_BIT)
    }
    Displayable.prototype.styleUpdated = function () {
      this.__dirty &= ~STYLE_CHANGED_BIT
    }
    Displayable.prototype.createStyle = function (obj) {
      return createObject(DEFAULT_COMMON_STYLE, obj)
    }
    Displayable.prototype.useStyle = function (obj) {
      if (!obj[STYLE_MAGIC_KEY]) {
        obj = this.createStyle(obj)
      }
      if (this.__inHover) {
        this.__hoverStyle = obj
      } else {
        this.style = obj
      }
      this.dirtyStyle()
    }
    Displayable.prototype.isStyleObject = function (obj) {
      return obj[STYLE_MAGIC_KEY]
    }
    Displayable.prototype._innerSaveToNormal = function (toState) {
      _super.prototype._innerSaveToNormal.call(this, toState)
      const normalState = this._normalState
      if (toState.style && !normalState.style) {
        normalState.style = this._mergeStyle(this.createStyle(), this.style)
      }
      this._savePrimaryToNormal(toState, normalState, PRIMARY_STATES_KEYS$1)
    }
    Displayable.prototype._applyStateObj = function (stateName, state, normalState, keepCurrentStates, transition, animationCfg) {
      _super.prototype._applyStateObj.call(this, stateName, state, normalState, keepCurrentStates, transition, animationCfg)
      const needsRestoreToNormal = !(state && keepCurrentStates)
      let targetStyle
      if (state && state.style) {
        if (transition) {
          if (keepCurrentStates) {
            targetStyle = state.style
          } else {
            targetStyle = this._mergeStyle(this.createStyle(), normalState.style)
            this._mergeStyle(targetStyle, state.style)
          }
        } else {
          targetStyle = this._mergeStyle(this.createStyle(), keepCurrentStates ? this.style : normalState.style)
          this._mergeStyle(targetStyle, state.style)
        }
      } else if (needsRestoreToNormal) {
        targetStyle = normalState.style
      }
      if (targetStyle) {
        if (transition) {
          const sourceStyle = this.style
          this.style = this.createStyle(needsRestoreToNormal ? {} : sourceStyle)
          if (needsRestoreToNormal) {
            const changedKeys = keys(sourceStyle)
            for (var i = 0; i < changedKeys.length; i++) {
              var key = changedKeys[i]
              if (key in targetStyle) {
                targetStyle[key] = targetStyle[key]
                this.style[key] = sourceStyle[key]
              }
            }
          }
          const targetKeys = keys(targetStyle)
          for (var i = 0; i < targetKeys.length; i++) {
            var key = targetKeys[i]
            this.style[key] = this.style[key]
          }
          this._transitionState(stateName, {
            style: targetStyle
          }, animationCfg, this.getAnimationStyleProps())
        } else {
          this.useStyle(targetStyle)
        }
      }
      const statesKeys = this.__inHover ? PRIMARY_STATES_KEYS_IN_HOVER_LAYER : PRIMARY_STATES_KEYS$1
      for (var i = 0; i < statesKeys.length; i++) {
        var key = statesKeys[i]
        if (state && state[key] != null) {
          this[key] = state[key]
        } else if (needsRestoreToNormal) {
          if (normalState[key] != null) {
            this[key] = normalState[key]
          }
        }
      }
    }
    Displayable.prototype._mergeStates = function (states) {
      const mergedState = _super.prototype._mergeStates.call(this, states)
      let mergedStyle
      for (let i = 0; i < states.length; i++) {
        const state = states[i]
        if (state.style) {
          mergedStyle = mergedStyle || {}
          this._mergeStyle(mergedStyle, state.style)
        }
      }
      if (mergedStyle) {
        mergedState.style = mergedStyle
      }
      return mergedState
    }
    Displayable.prototype._mergeStyle = function (targetStyle, sourceStyle) {
      extend(targetStyle, sourceStyle)
      return targetStyle
    }
    Displayable.prototype.getAnimationStyleProps = function () {
      return DEFAULT_COMMON_ANIMATION_PROPS
    }
    Displayable.initDefaultProps = (function () {
      const dispProto = Displayable.prototype
      dispProto.type = 'displayable'
      dispProto.invisible = false
      dispProto.z = 0
      dispProto.z2 = 0
      dispProto.zlevel = 0
      dispProto.culling = false
      dispProto.cursor = 'pointer'
      dispProto.rectHover = false
      dispProto.incremental = false
      dispProto._rect = null
      dispProto.dirtyRectTolerance = 0
      dispProto.__dirty = REDRAW_BIT | STYLE_CHANGED_BIT
    })()
    return Displayable
  }(Element))
  const tmpRect = new BoundingRect(0, 0, 0, 0)
  const viewRect = new BoundingRect(0, 0, 0, 0)
  function isDisplayableCulled (el, width, height) {
    tmpRect.copy(el.getBoundingRect())
    if (el.transform) {
      tmpRect.applyTransform(el.transform)
    }
    viewRect.width = width
    viewRect.height = height
    return !tmpRect.intersect(viewRect)
  }

  const mathMin$1 = Math.min
  const mathMax$1 = Math.max
  const mathSin = Math.sin
  const mathCos = Math.cos
  const PI2 = Math.PI * 2
  const start = create()
  const end = create()
  const extremity = create()
  function fromPoints (points, min, max) {
    if (points.length === 0) {
      return
    }
    let p = points[0]
    let left = p[0]
    let right = p[0]
    let top = p[1]
    let bottom = p[1]
    for (let i = 1; i < points.length; i++) {
      p = points[i]
      left = mathMin$1(left, p[0])
      right = mathMax$1(right, p[0])
      top = mathMin$1(top, p[1])
      bottom = mathMax$1(bottom, p[1])
    }
    min[0] = left
    min[1] = top
    max[0] = right
    max[1] = bottom
  }
  function fromLine (x0, y0, x1, y1, min, max) {
    min[0] = mathMin$1(x0, x1)
    min[1] = mathMin$1(y0, y1)
    max[0] = mathMax$1(x0, x1)
    max[1] = mathMax$1(y0, y1)
  }
  const xDim = []
  const yDim = []
  function fromCubic (x0, y0, x1, y1, x2, y2, x3, y3, min, max) {
    const cubicExtrema$1 = cubicExtrema
    const cubicAt$1 = cubicAt
    let n = cubicExtrema$1(x0, x1, x2, x3, xDim)
    min[0] = Infinity
    min[1] = Infinity
    max[0] = -Infinity
    max[1] = -Infinity
    for (var i = 0; i < n; i++) {
      const x = cubicAt$1(x0, x1, x2, x3, xDim[i])
      min[0] = mathMin$1(x, min[0])
      max[0] = mathMax$1(x, max[0])
    }
    n = cubicExtrema$1(y0, y1, y2, y3, yDim)
    for (var i = 0; i < n; i++) {
      const y = cubicAt$1(y0, y1, y2, y3, yDim[i])
      min[1] = mathMin$1(y, min[1])
      max[1] = mathMax$1(y, max[1])
    }
    min[0] = mathMin$1(x0, min[0])
    max[0] = mathMax$1(x0, max[0])
    min[0] = mathMin$1(x3, min[0])
    max[0] = mathMax$1(x3, max[0])
    min[1] = mathMin$1(y0, min[1])
    max[1] = mathMax$1(y0, max[1])
    min[1] = mathMin$1(y3, min[1])
    max[1] = mathMax$1(y3, max[1])
  }
  function fromQuadratic (x0, y0, x1, y1, x2, y2, min, max) {
    const quadraticExtremum$1 = quadraticExtremum
    const quadraticAt$1 = quadraticAt
    const tx = mathMax$1(mathMin$1(quadraticExtremum$1(x0, x1, x2), 1), 0)
    const ty = mathMax$1(mathMin$1(quadraticExtremum$1(y0, y1, y2), 1), 0)
    const x = quadraticAt$1(x0, x1, x2, tx)
    const y = quadraticAt$1(y0, y1, y2, ty)
    min[0] = mathMin$1(x0, x2, x)
    min[1] = mathMin$1(y0, y2, y)
    max[0] = mathMax$1(x0, x2, x)
    max[1] = mathMax$1(y0, y2, y)
  }
  function fromArc (x, y, rx, ry, startAngle, endAngle, anticlockwise, min$1, max$1) {
    const vec2Min = min
    const vec2Max = max
    const diff = Math.abs(startAngle - endAngle)
    if (diff % PI2 < 1e-4 && diff > 1e-4) {
      min$1[0] = x - rx
      min$1[1] = y - ry
      max$1[0] = x + rx
      max$1[1] = y + ry
      return
    }
    start[0] = mathCos(startAngle) * rx + x
    start[1] = mathSin(startAngle) * ry + y
    end[0] = mathCos(endAngle) * rx + x
    end[1] = mathSin(endAngle) * ry + y
    vec2Min(min$1, start, end)
    vec2Max(max$1, start, end)
    startAngle = startAngle % (PI2)
    if (startAngle < 0) {
      startAngle = startAngle + PI2
    }
    endAngle = endAngle % (PI2)
    if (endAngle < 0) {
      endAngle = endAngle + PI2
    }
    if (startAngle > endAngle && !anticlockwise) {
      endAngle += PI2
    } else if (startAngle < endAngle && anticlockwise) {
      startAngle += PI2
    }
    if (anticlockwise) {
      const tmp = endAngle
      endAngle = startAngle
      startAngle = tmp
    }
    for (let angle = 0; angle < endAngle; angle += Math.PI / 2) {
      if (angle > startAngle) {
        extremity[0] = mathCos(angle) * rx + x
        extremity[1] = mathSin(angle) * ry + y
        vec2Min(min$1, extremity, min$1)
        vec2Max(max$1, extremity, max$1)
      }
    }
  }

  const CMD = {
    M: 1,
    L: 2,
    C: 3,
    Q: 4,
    A: 5,
    Z: 6,
    R: 7
  }
  const tmpOutX = []
  const tmpOutY = []
  const min$1 = []
  const max$1 = []
  const min2 = []
  const max2 = []
  const mathMin$2 = Math.min
  const mathMax$2 = Math.max
  const mathCos$1 = Math.cos
  const mathSin$1 = Math.sin
  const mathAbs = Math.abs
  const PI = Math.PI
  const PI2$1 = PI * 2
  const hasTypedArray = typeof Float32Array !== 'undefined'
  const tmpAngles = []
  function modPI2 (radian) {
    const n = Math.round(radian / PI * 1e8) / 1e8
    return (n % 2) * PI
  }
  function normalizeArcAngles (angles, anticlockwise) {
    let newStartAngle = modPI2(angles[0])
    if (newStartAngle < 0) {
      newStartAngle += PI2$1
    }
    const delta = newStartAngle - angles[0]
    let newEndAngle = angles[1]
    newEndAngle += delta
    if (!anticlockwise && newEndAngle - newStartAngle >= PI2$1) {
      newEndAngle = newStartAngle + PI2$1
    } else if (anticlockwise && newStartAngle - newEndAngle >= PI2$1) {
      newEndAngle = newStartAngle - PI2$1
    } else if (!anticlockwise && newStartAngle > newEndAngle) {
      newEndAngle = newStartAngle + (PI2$1 - modPI2(newStartAngle - newEndAngle))
    } else if (anticlockwise && newStartAngle < newEndAngle) {
      newEndAngle = newStartAngle - (PI2$1 - modPI2(newEndAngle - newStartAngle))
    }
    angles[0] = newStartAngle
    angles[1] = newEndAngle
  }
  const PathProxy = (function () {
    function PathProxy (notSaveData) {
      this.dpr = 1
      this._xi = 0
      this._yi = 0
      this._x0 = 0
      this._y0 = 0
      this._len = 0
      if (notSaveData) {
        this._saveData = false
      }
      if (this._saveData) {
        this.data = []
      }
    }
    PathProxy.prototype.increaseVersion = function () {
      this._version++
    }
    PathProxy.prototype.getVersion = function () {
      return this._version
    }
    PathProxy.prototype.setScale = function (sx, sy, segmentIgnoreThreshold) {
      segmentIgnoreThreshold = segmentIgnoreThreshold || 0
      if (segmentIgnoreThreshold > 0) {
        this._ux = mathAbs(segmentIgnoreThreshold / devicePixelRatio / sx) || 0
        this._uy = mathAbs(segmentIgnoreThreshold / devicePixelRatio / sy) || 0
      }
    }
    PathProxy.prototype.setDPR = function (dpr) {
      this.dpr = dpr
    }
    PathProxy.prototype.setContext = function (ctx) {
      this._ctx = ctx
    }
    PathProxy.prototype.getContext = function () {
      return this._ctx
    }
    PathProxy.prototype.beginPath = function () {
      this._ctx && this._ctx.beginPath()
      this.reset()
      return this
    }
    PathProxy.prototype.reset = function () {
      if (this._saveData) {
        this._len = 0
      }
      if (this._pathSegLen) {
        this._pathSegLen = null
        this._pathLen = 0
      }
      this._version++
    }
    PathProxy.prototype.moveTo = function (x, y) {
      this._drawPendingPt()
      this.addData(CMD.M, x, y)
      this._ctx && this._ctx.moveTo(x, y)
      this._x0 = x
      this._y0 = y
      this._xi = x
      this._yi = y
      return this
    }
    PathProxy.prototype.lineTo = function (x, y) {
      const dx = mathAbs(x - this._xi)
      const dy = mathAbs(y - this._yi)
      const exceedUnit = dx > this._ux || dy > this._uy
      this.addData(CMD.L, x, y)
      if (this._ctx && exceedUnit) {
        this._ctx.lineTo(x, y)
      }
      if (exceedUnit) {
        this._xi = x
        this._yi = y
        this._pendingPtDist = 0
      } else {
        const d2 = dx * dx + dy * dy
        if (d2 > this._pendingPtDist) {
          this._pendingPtX = x
          this._pendingPtY = y
          this._pendingPtDist = d2
        }
      }
      return this
    }
    PathProxy.prototype.bezierCurveTo = function (x1, y1, x2, y2, x3, y3) {
      this._drawPendingPt()
      this.addData(CMD.C, x1, y1, x2, y2, x3, y3)
      if (this._ctx) {
        this._ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3)
      }
      this._xi = x3
      this._yi = y3
      return this
    }
    PathProxy.prototype.quadraticCurveTo = function (x1, y1, x2, y2) {
      this._drawPendingPt()
      this.addData(CMD.Q, x1, y1, x2, y2)
      if (this._ctx) {
        this._ctx.quadraticCurveTo(x1, y1, x2, y2)
      }
      this._xi = x2
      this._yi = y2
      return this
    }
    PathProxy.prototype.arc = function (cx, cy, r, startAngle, endAngle, anticlockwise) {
      this._drawPendingPt()
      tmpAngles[0] = startAngle
      tmpAngles[1] = endAngle
      normalizeArcAngles(tmpAngles, anticlockwise)
      startAngle = tmpAngles[0]
      endAngle = tmpAngles[1]
      const delta = endAngle - startAngle
      this.addData(CMD.A, cx, cy, r, r, startAngle, delta, 0, anticlockwise ? 0 : 1)
      this._ctx && this._ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise)
      this._xi = mathCos$1(endAngle) * r + cx
      this._yi = mathSin$1(endAngle) * r + cy
      return this
    }
    PathProxy.prototype.arcTo = function (x1, y1, x2, y2, radius) {
      this._drawPendingPt()
      if (this._ctx) {
        this._ctx.arcTo(x1, y1, x2, y2, radius)
      }
      return this
    }
    PathProxy.prototype.rect = function (x, y, w, h) {
      this._drawPendingPt()
      this._ctx && this._ctx.rect(x, y, w, h)
      this.addData(CMD.R, x, y, w, h)
      return this
    }
    PathProxy.prototype.closePath = function () {
      this._drawPendingPt()
      this.addData(CMD.Z)
      const ctx = this._ctx
      const x0 = this._x0
      const y0 = this._y0
      if (ctx) {
        ctx.closePath()
      }
      this._xi = x0
      this._yi = y0
      return this
    }
    PathProxy.prototype.fill = function (ctx) {
      ctx && ctx.fill()
      this.toStatic()
    }
    PathProxy.prototype.stroke = function (ctx) {
      ctx && ctx.stroke()
      this.toStatic()
    }
    PathProxy.prototype.len = function () {
      return this._len
    }
    PathProxy.prototype.setData = function (data) {
      const len = data.length
      if (!(this.data && this.data.length === len) && hasTypedArray) {
        this.data = new Float32Array(len)
      }
      for (let i = 0; i < len; i++) {
        this.data[i] = data[i]
      }
      this._len = len
    }
    PathProxy.prototype.appendPath = function (path) {
      if (!(path instanceof Array)) {
        path = [path]
      }
      const len = path.length
      let appendSize = 0
      let offset = this._len
      for (var i = 0; i < len; i++) {
        appendSize += path[i].len()
      }
      if (hasTypedArray && (this.data instanceof Float32Array)) {
        this.data = new Float32Array(offset + appendSize)
      }
      for (var i = 0; i < len; i++) {
        const appendPathData = path[i].data
        for (let k = 0; k < appendPathData.length; k++) {
          this.data[offset++] = appendPathData[k]
        }
      }
      this._len = offset
    }
    PathProxy.prototype.addData = function (cmd, a, b, c, d, e, f, g, h) {
      if (!this._saveData) {
        return
      }
      let data = this.data
      if (this._len + arguments.length > data.length) {
        this._expandData()
        data = this.data
      }
      for (let i = 0; i < arguments.length; i++) {
        data[this._len++] = arguments[i]
      }
    }
    PathProxy.prototype._drawPendingPt = function () {
      if (this._pendingPtDist > 0) {
        this._ctx && this._ctx.lineTo(this._pendingPtX, this._pendingPtY)
        this._pendingPtDist = 0
      }
    }
    PathProxy.prototype._expandData = function () {
      if (!(this.data instanceof Array)) {
        const newData = []
        for (let i = 0; i < this._len; i++) {
          newData[i] = this.data[i]
        }
        this.data = newData
      }
    }
    PathProxy.prototype.toStatic = function () {
      if (!this._saveData) {
        return
      }
      this._drawPendingPt()
      const data = this.data
      if (data instanceof Array) {
        data.length = this._len
        if (hasTypedArray && this._len > 11) {
          this.data = new Float32Array(data)
        }
      }
    }
    PathProxy.prototype.getBoundingRect = function () {
      min$1[0] = min$1[1] = min2[0] = min2[1] = Number.MAX_VALUE
      max$1[0] = max$1[1] = max2[0] = max2[1] = -Number.MAX_VALUE
      const data = this.data
      let xi = 0
      let yi = 0
      let x0 = 0
      let y0 = 0
      let i
      for (i = 0; i < this._len;) {
        const cmd = data[i++]
        const isFirst = i === 1
        if (isFirst) {
          xi = data[i]
          yi = data[i + 1]
          x0 = xi
          y0 = yi
        }
        switch (cmd) {
          case CMD.M:
            xi = x0 = data[i++]
            yi = y0 = data[i++]
            min2[0] = x0
            min2[1] = y0
            max2[0] = x0
            max2[1] = y0
            break
          case CMD.L:
            fromLine(xi, yi, data[i], data[i + 1], min2, max2)
            xi = data[i++]
            yi = data[i++]
            break
          case CMD.C:
            fromCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], min2, max2)
            xi = data[i++]
            yi = data[i++]
            break
          case CMD.Q:
            fromQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], min2, max2)
            xi = data[i++]
            yi = data[i++]
            break
          case CMD.A:
            var cx = data[i++]
            var cy = data[i++]
            var rx = data[i++]
            var ry = data[i++]
            var startAngle = data[i++]
            var endAngle = data[i++] + startAngle
            i += 1
            var anticlockwise = !data[i++]
            if (isFirst) {
              x0 = mathCos$1(startAngle) * rx + cx
              y0 = mathSin$1(startAngle) * ry + cy
            }
            fromArc(cx, cy, rx, ry, startAngle, endAngle, anticlockwise, min2, max2)
            xi = mathCos$1(endAngle) * rx + cx
            yi = mathSin$1(endAngle) * ry + cy
            break
          case CMD.R:
            x0 = xi = data[i++]
            y0 = yi = data[i++]
            var width = data[i++]
            var height = data[i++]
            fromLine(x0, y0, x0 + width, y0 + height, min2, max2)
            break
          case CMD.Z:
            xi = x0
            yi = y0
            break
        }
        min(min$1, min$1, min2)
        max(max$1, max$1, max2)
      }
      if (i === 0) {
        min$1[0] = min$1[1] = max$1[0] = max$1[1] = 0
      }
      return new BoundingRect(min$1[0], min$1[1], max$1[0] - min$1[0], max$1[1] - min$1[1])
    }
    PathProxy.prototype._calculateLength = function () {
      const data = this.data
      const len = this._len
      const ux = this._ux
      const uy = this._uy
      let xi = 0
      let yi = 0
      let x0 = 0
      let y0 = 0
      if (!this._pathSegLen) {
        this._pathSegLen = []
      }
      const pathSegLen = this._pathSegLen
      let pathTotalLen = 0
      let segCount = 0
      for (let i = 0; i < len;) {
        const cmd = data[i++]
        const isFirst = i === 1
        if (isFirst) {
          xi = data[i]
          yi = data[i + 1]
          x0 = xi
          y0 = yi
        }
        let l = -1
        switch (cmd) {
          case CMD.M:
            xi = x0 = data[i++]
            yi = y0 = data[i++]
            break
          case CMD.L: {
            var x2 = data[i++]
            var y2 = data[i++]
            var dx = x2 - xi
            var dy = y2 - yi
            if (mathAbs(dx) > ux || mathAbs(dy) > uy || i === len - 1) {
              l = Math.sqrt(dx * dx + dy * dy)
              xi = x2
              yi = y2
            }
            break
          }
          case CMD.C: {
            var x1 = data[i++]
            var y1 = data[i++]
            var x2 = data[i++]
            var y2 = data[i++]
            const x3 = data[i++]
            const y3 = data[i++]
            l = cubicLength(xi, yi, x1, y1, x2, y2, x3, y3, 10)
            xi = x3
            yi = y3
            break
          }
          case CMD.Q: {
            var x1 = data[i++]
            var y1 = data[i++]
            var x2 = data[i++]
            var y2 = data[i++]
            l = quadraticLength(xi, yi, x1, y1, x2, y2, 10)
            xi = x2
            yi = y2
            break
          }
          case CMD.A:
            var cx = data[i++]
            var cy = data[i++]
            var rx = data[i++]
            var ry = data[i++]
            var startAngle = data[i++]
            var delta = data[i++]
            var endAngle = delta + startAngle
            i += 1
            var anticlockwise = !data[i++]
            if (isFirst) {
              x0 = mathCos$1(startAngle) * rx + cx
              y0 = mathSin$1(startAngle) * ry + cy
            }
            l = mathMax$2(rx, ry) * mathMin$2(PI2$1, Math.abs(delta))
            xi = mathCos$1(endAngle) * rx + cx
            yi = mathSin$1(endAngle) * ry + cy
            break
          case CMD.R: {
            x0 = xi = data[i++]
            y0 = yi = data[i++]
            const width = data[i++]
            const height = data[i++]
            l = width * 2 + height * 2
            break
          }
          case CMD.Z: {
            var dx = x0 - xi
            var dy = y0 - yi
            l = Math.sqrt(dx * dx + dy * dy)
            xi = x0
            yi = y0
            break
          }
        }
        if (l >= 0) {
          pathSegLen[segCount++] = l
          pathTotalLen += l
        }
      }
      this._pathLen = pathTotalLen
      return pathTotalLen
    }
    PathProxy.prototype.rebuildPath = function (ctx, percent) {
      const d = this.data
      const ux = this._ux
      const uy = this._uy
      const len = this._len
      let x0
      let y0
      let xi
      let yi
      let x
      let y
      const drawPart = percent < 1
      let pathSegLen
      let pathTotalLen
      let accumLength = 0
      let segCount = 0
      let displayedLength
      let pendingPtDist = 0
      let pendingPtX
      let pendingPtY
      if (drawPart) {
        if (!this._pathSegLen) {
          this._calculateLength()
        }
        pathSegLen = this._pathSegLen
        pathTotalLen = this._pathLen
        displayedLength = percent * pathTotalLen
        if (!displayedLength) {
          return
        }
      }
      lo: for (let i = 0; i < len;) {
        const cmd = d[i++]
        const isFirst = i === 1
        if (isFirst) {
          xi = d[i]
          yi = d[i + 1]
          x0 = xi
          y0 = yi
        }
        if (cmd !== CMD.L && pendingPtDist > 0) {
          ctx.lineTo(pendingPtX, pendingPtY)
          pendingPtDist = 0
        }
        switch (cmd) {
          case CMD.M:
            x0 = xi = d[i++]
            y0 = yi = d[i++]
            ctx.moveTo(xi, yi)
            break
          case CMD.L: {
            x = d[i++]
            y = d[i++]
            const dx = mathAbs(x - xi)
            const dy = mathAbs(y - yi)
            if (dx > ux || dy > uy) {
              if (drawPart) {
                var l = pathSegLen[segCount++]
                if (accumLength + l > displayedLength) {
                  var t = (displayedLength - accumLength) / l
                  ctx.lineTo(xi * (1 - t) + x * t, yi * (1 - t) + y * t)
                  break lo
                }
                accumLength += l
              }
              ctx.lineTo(x, y)
              xi = x
              yi = y
              pendingPtDist = 0
            } else {
              const d2 = dx * dx + dy * dy
              if (d2 > pendingPtDist) {
                pendingPtX = x
                pendingPtY = y
                pendingPtDist = d2
              }
            }
            break
          }
          case CMD.C: {
            var x1 = d[i++]
            var y1 = d[i++]
            var x2 = d[i++]
            var y2 = d[i++]
            const x3 = d[i++]
            const y3 = d[i++]
            if (drawPart) {
              var l = pathSegLen[segCount++]
              if (accumLength + l > displayedLength) {
                var t = (displayedLength - accumLength) / l
                cubicSubdivide(xi, x1, x2, x3, t, tmpOutX)
                cubicSubdivide(yi, y1, y2, y3, t, tmpOutY)
                ctx.bezierCurveTo(tmpOutX[1], tmpOutY[1], tmpOutX[2], tmpOutY[2], tmpOutX[3], tmpOutY[3])
                break lo
              }
              accumLength += l
            }
            ctx.bezierCurveTo(x1, y1, x2, y2, x3, y3)
            xi = x3
            yi = y3
            break
          }
          case CMD.Q: {
            var x1 = d[i++]
            var y1 = d[i++]
            var x2 = d[i++]
            var y2 = d[i++]
            if (drawPart) {
              var l = pathSegLen[segCount++]
              if (accumLength + l > displayedLength) {
                var t = (displayedLength - accumLength) / l
                quadraticSubdivide(xi, x1, x2, t, tmpOutX)
                quadraticSubdivide(yi, y1, y2, t, tmpOutY)
                ctx.quadraticCurveTo(tmpOutX[1], tmpOutY[1], tmpOutX[2], tmpOutY[2])
                break lo
              }
              accumLength += l
            }
            ctx.quadraticCurveTo(x1, y1, x2, y2)
            xi = x2
            yi = y2
            break
          }
          case CMD.A:
            var cx = d[i++]
            var cy = d[i++]
            var rx = d[i++]
            var ry = d[i++]
            var startAngle = d[i++]
            var delta = d[i++]
            var psi = d[i++]
            var anticlockwise = !d[i++]
            var r = (rx > ry) ? rx : ry
            var isEllipse = mathAbs(rx - ry) > 1e-3
            var endAngle = startAngle + delta
            var breakBuild = false
            if (drawPart) {
              var l = pathSegLen[segCount++]
              if (accumLength + l > displayedLength) {
                endAngle = startAngle + delta * (displayedLength - accumLength) / l
                breakBuild = true
              }
              accumLength += l
            }
            if (isEllipse && ctx.ellipse) {
              ctx.ellipse(cx, cy, rx, ry, psi, startAngle, endAngle, anticlockwise)
            } else {
              ctx.arc(cx, cy, r, startAngle, endAngle, anticlockwise)
            }
            if (breakBuild) {
              break lo
            }
            if (isFirst) {
              x0 = mathCos$1(startAngle) * rx + cx
              y0 = mathSin$1(startAngle) * ry + cy
            }
            xi = mathCos$1(endAngle) * rx + cx
            yi = mathSin$1(endAngle) * ry + cy
            break
          case CMD.R:
            x0 = xi = d[i]
            y0 = yi = d[i + 1]
            x = d[i++]
            y = d[i++]
            var width = d[i++]
            var height = d[i++]
            if (drawPart) {
              var l = pathSegLen[segCount++]
              if (accumLength + l > displayedLength) {
                let d_1 = displayedLength - accumLength
                ctx.moveTo(x, y)
                ctx.lineTo(x + mathMin$2(d_1, width), y)
                d_1 -= width
                if (d_1 > 0) {
                  ctx.lineTo(x + width, y + mathMin$2(d_1, height))
                }
                d_1 -= height
                if (d_1 > 0) {
                  ctx.lineTo(x + mathMax$2(width - d_1, 0), y + height)
                }
                d_1 -= width
                if (d_1 > 0) {
                  ctx.lineTo(x, y + mathMax$2(height - d_1, 0))
                }
                break lo
              }
              accumLength += l
            }
            ctx.rect(x, y, width, height)
            break
          case CMD.Z:
            if (drawPart) {
              var l = pathSegLen[segCount++]
              if (accumLength + l > displayedLength) {
                var t = (displayedLength - accumLength) / l
                ctx.lineTo(xi * (1 - t) + x0 * t, yi * (1 - t) + y0 * t)
                break lo
              }
              accumLength += l
            }
            ctx.closePath()
            xi = x0
            yi = y0
        }
      }
    }
    PathProxy.prototype.clone = function () {
      const newProxy = new PathProxy()
      const data = this.data
      newProxy.data = data.slice
        ? data.slice()
        : Array.prototype.slice.call(data)
      newProxy._len = this._len
      return newProxy
    }
    PathProxy.CMD = CMD
    PathProxy.initDefaultProps = (function () {
      const proto = PathProxy.prototype
      proto._saveData = true
      proto._ux = 0
      proto._uy = 0
      proto._pendingPtDist = 0
      proto._version = 0
    })()
    return PathProxy
  }())

  function containStroke (x0, y0, x1, y1, lineWidth, x, y) {
    if (lineWidth === 0) {
      return false
    }
    const _l = lineWidth
    let _a = 0
    let _b = x0
    if ((y > y0 + _l && y > y1 + _l) ||
            (y < y0 - _l && y < y1 - _l) ||
            (x > x0 + _l && x > x1 + _l) ||
            (x < x0 - _l && x < x1 - _l)) {
      return false
    }
    if (x0 !== x1) {
      _a = (y0 - y1) / (x0 - x1)
      _b = (x0 * y1 - x1 * y0) / (x0 - x1)
    } else {
      return Math.abs(x - x0) <= _l / 2
    }
    const tmp = _a * x - y + _b
    const _s = tmp * tmp / (_a * _a + 1)
    return _s <= _l / 2 * _l / 2
  }

  function containStroke$1 (x0, y0, x1, y1, x2, y2, x3, y3, lineWidth, x, y) {
    if (lineWidth === 0) {
      return false
    }
    const _l = lineWidth
    if ((y > y0 + _l && y > y1 + _l && y > y2 + _l && y > y3 + _l) ||
            (y < y0 - _l && y < y1 - _l && y < y2 - _l && y < y3 - _l) ||
            (x > x0 + _l && x > x1 + _l && x > x2 + _l && x > x3 + _l) ||
            (x < x0 - _l && x < x1 - _l && x < x2 - _l && x < x3 - _l)) {
      return false
    }
    const d = cubicProjectPoint(x0, y0, x1, y1, x2, y2, x3, y3, x, y, null)
    return d <= _l / 2
  }

  function containStroke$2 (x0, y0, x1, y1, x2, y2, lineWidth, x, y) {
    if (lineWidth === 0) {
      return false
    }
    const _l = lineWidth
    if ((y > y0 + _l && y > y1 + _l && y > y2 + _l) ||
            (y < y0 - _l && y < y1 - _l && y < y2 - _l) ||
            (x > x0 + _l && x > x1 + _l && x > x2 + _l) ||
            (x < x0 - _l && x < x1 - _l && x < x2 - _l)) {
      return false
    }
    const d = quadraticProjectPoint(x0, y0, x1, y1, x2, y2, x, y, null)
    return d <= _l / 2
  }

  const PI2$2 = Math.PI * 2
  function normalizeRadian (angle) {
    angle %= PI2$2
    if (angle < 0) {
      angle += PI2$2
    }
    return angle
  }

  const PI2$3 = Math.PI * 2
  function containStroke$3 (cx, cy, r, startAngle, endAngle, anticlockwise, lineWidth, x, y) {
    if (lineWidth === 0) {
      return false
    }
    const _l = lineWidth
    x -= cx
    y -= cy
    const d = Math.sqrt(x * x + y * y)
    if ((d - _l > r) || (d + _l < r)) {
      return false
    }
    if (Math.abs(startAngle - endAngle) % PI2$3 < 1e-4) {
      return true
    }
    if (anticlockwise) {
      const tmp = startAngle
      startAngle = normalizeRadian(endAngle)
      endAngle = normalizeRadian(tmp)
    } else {
      startAngle = normalizeRadian(startAngle)
      endAngle = normalizeRadian(endAngle)
    }
    if (startAngle > endAngle) {
      endAngle += PI2$3
    }
    let angle = Math.atan2(y, x)
    if (angle < 0) {
      angle += PI2$3
    }
    return (angle >= startAngle && angle <= endAngle) ||
            (angle + PI2$3 >= startAngle && angle + PI2$3 <= endAngle)
  }

  function windingLine (x0, y0, x1, y1, x, y) {
    if ((y > y0 && y > y1) || (y < y0 && y < y1)) {
      return 0
    }
    if (y1 === y0) {
      return 0
    }
    const t = (y - y0) / (y1 - y0)
    let dir = y1 < y0 ? 1 : -1
    if (t === 1 || t === 0) {
      dir = y1 < y0 ? 0.5 : -0.5
    }
    const x_ = t * (x1 - x0) + x0
    return x_ === x ? Infinity : x_ > x ? dir : 0
  }

  const CMD$1 = PathProxy.CMD
  const PI2$4 = Math.PI * 2
  const EPSILON$3 = 1e-4
  function isAroundEqual (a, b) {
    return Math.abs(a - b) < EPSILON$3
  }
  const roots = [-1, -1, -1]
  const extrema = [-1, -1]
  function swapExtrema () {
    const tmp = extrema[0]
    extrema[0] = extrema[1]
    extrema[1] = tmp
  }
  function windingCubic (x0, y0, x1, y1, x2, y2, x3, y3, x, y) {
    if ((y > y0 && y > y1 && y > y2 && y > y3) ||
            (y < y0 && y < y1 && y < y2 && y < y3)) {
      return 0
    }
    const nRoots = cubicRootAt(y0, y1, y2, y3, y, roots)
    if (nRoots === 0) {
      return 0
    } else {
      let w = 0
      let nExtrema = -1
      let y0_ = void 0
      let y1_ = void 0
      for (let i = 0; i < nRoots; i++) {
        const t = roots[i]
        const unit = (t === 0 || t === 1) ? 0.5 : 1
        const x_ = cubicAt(x0, x1, x2, x3, t)
        if (x_ < x) {
          continue
        }
        if (nExtrema < 0) {
          nExtrema = cubicExtrema(y0, y1, y2, y3, extrema)
          if (extrema[1] < extrema[0] && nExtrema > 1) {
            swapExtrema()
          }
          y0_ = cubicAt(y0, y1, y2, y3, extrema[0])
          if (nExtrema > 1) {
            y1_ = cubicAt(y0, y1, y2, y3, extrema[1])
          }
        }
        if (nExtrema === 2) {
          if (t < extrema[0]) {
            w += y0_ < y0 ? unit : -unit
          } else if (t < extrema[1]) {
            w += y1_ < y0_ ? unit : -unit
          } else {
            w += y3 < y1_ ? unit : -unit
          }
        } else {
          if (t < extrema[0]) {
            w += y0_ < y0 ? unit : -unit
          } else {
            w += y3 < y0_ ? unit : -unit
          }
        }
      }
      return w
    }
  }
  function windingQuadratic (x0, y0, x1, y1, x2, y2, x, y) {
    if ((y > y0 && y > y1 && y > y2) ||
            (y < y0 && y < y1 && y < y2)) {
      return 0
    }
    const nRoots = quadraticRootAt(y0, y1, y2, y, roots)
    if (nRoots === 0) {
      return 0
    } else {
      const t = quadraticExtremum(y0, y1, y2)
      if (t >= 0 && t <= 1) {
        let w = 0
        const y_ = quadraticAt(y0, y1, y2, t)
        for (let i = 0; i < nRoots; i++) {
          var unit = (roots[i] === 0 || roots[i] === 1) ? 0.5 : 1
          var x_ = quadraticAt(x0, x1, x2, roots[i])
          if (x_ < x) {
            continue
          }
          if (roots[i] < t) {
            w += y_ < y0 ? unit : -unit
          } else {
            w += y2 < y_ ? unit : -unit
          }
        }
        return w
      } else {
        var unit = (roots[0] === 0 || roots[0] === 1) ? 0.5 : 1
        var x_ = quadraticAt(x0, x1, x2, roots[0])
        if (x_ < x) {
          return 0
        }
        return y2 < y0 ? unit : -unit
      }
    }
  }
  function windingArc (cx, cy, r, startAngle, endAngle, anticlockwise, x, y) {
    y -= cy
    if (y > r || y < -r) {
      return 0
    }
    const tmp = Math.sqrt(r * r - y * y)
    roots[0] = -tmp
    roots[1] = tmp
    const dTheta = Math.abs(startAngle - endAngle)
    if (dTheta < 1e-4) {
      return 0
    }
    if (dTheta >= PI2$4 - 1e-4) {
      startAngle = 0
      endAngle = PI2$4
      var dir = anticlockwise ? 1 : -1
      if (x >= roots[0] + cx && x <= roots[1] + cx) {
        return dir
      } else {
        return 0
      }
    }
    if (startAngle > endAngle) {
      const tmp_1 = startAngle
      startAngle = endAngle
      endAngle = tmp_1
    }
    if (startAngle < 0) {
      startAngle += PI2$4
      endAngle += PI2$4
    }
    let w = 0
    for (let i = 0; i < 2; i++) {
      const x_ = roots[i]
      if (x_ + cx > x) {
        let angle = Math.atan2(y, x_)
        var dir = anticlockwise ? 1 : -1
        if (angle < 0) {
          angle = PI2$4 + angle
        }
        if ((angle >= startAngle && angle <= endAngle) ||
                    (angle + PI2$4 >= startAngle && angle + PI2$4 <= endAngle)) {
          if (angle > Math.PI / 2 && angle < Math.PI * 1.5) {
            dir = -dir
          }
          w += dir
        }
      }
    }
    return w
  }
  function containPath (path, lineWidth, isStroke, x, y) {
    const data = path.data
    const len = path.len()
    let w = 0
    let xi = 0
    let yi = 0
    let x0 = 0
    let y0 = 0
    let x1
    let y1
    for (let i = 0; i < len;) {
      const cmd = data[i++]
      const isFirst = i === 1
      if (cmd === CMD$1.M && i > 1) {
        if (!isStroke) {
          w += windingLine(xi, yi, x0, y0, x, y)
        }
      }
      if (isFirst) {
        xi = data[i]
        yi = data[i + 1]
        x0 = xi
        y0 = yi
      }
      switch (cmd) {
        case CMD$1.M:
          x0 = data[i++]
          y0 = data[i++]
          xi = x0
          yi = y0
          break
        case CMD$1.L:
          if (isStroke) {
            if (containStroke(xi, yi, data[i], data[i + 1], lineWidth, x, y)) {
              return true
            }
          } else {
            w += windingLine(xi, yi, data[i], data[i + 1], x, y) || 0
          }
          xi = data[i++]
          yi = data[i++]
          break
        case CMD$1.C:
          if (isStroke) {
            if (containStroke$1(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {
              return true
            }
          } else {
            w += windingCubic(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y) || 0
          }
          xi = data[i++]
          yi = data[i++]
          break
        case CMD$1.Q:
          if (isStroke) {
            if (containStroke$2(xi, yi, data[i++], data[i++], data[i], data[i + 1], lineWidth, x, y)) {
              return true
            }
          } else {
            w += windingQuadratic(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y) || 0
          }
          xi = data[i++]
          yi = data[i++]
          break
        case CMD$1.A:
          var cx = data[i++]
          var cy = data[i++]
          var rx = data[i++]
          var ry = data[i++]
          var theta = data[i++]
          var dTheta = data[i++]
          i += 1
          var anticlockwise = !!(1 - data[i++])
          x1 = Math.cos(theta) * rx + cx
          y1 = Math.sin(theta) * ry + cy
          if (!isFirst) {
            w += windingLine(xi, yi, x1, y1, x, y)
          } else {
            x0 = x1
            y0 = y1
          }
          var _x = (x - cx) * ry / rx + cx
          if (isStroke) {
            if (containStroke$3(cx, cy, ry, theta, theta + dTheta, anticlockwise, lineWidth, _x, y)) {
              return true
            }
          } else {
            w += windingArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y)
          }
          xi = Math.cos(theta + dTheta) * rx + cx
          yi = Math.sin(theta + dTheta) * ry + cy
          break
        case CMD$1.R:
          x0 = xi = data[i++]
          y0 = yi = data[i++]
          var width = data[i++]
          var height = data[i++]
          x1 = x0 + width
          y1 = y0 + height
          if (isStroke) {
            if (containStroke(x0, y0, x1, y0, lineWidth, x, y) ||
                            containStroke(x1, y0, x1, y1, lineWidth, x, y) ||
                            containStroke(x1, y1, x0, y1, lineWidth, x, y) ||
                            containStroke(x0, y1, x0, y0, lineWidth, x, y)) {
              return true
            }
          } else {
            w += windingLine(x1, y0, x1, y1, x, y)
            w += windingLine(x0, y1, x0, y0, x, y)
          }
          break
        case CMD$1.Z:
          if (isStroke) {
            if (containStroke(xi, yi, x0, y0, lineWidth, x, y)) {
              return true
            }
          } else {
            w += windingLine(xi, yi, x0, y0, x, y)
          }
          xi = x0
          yi = y0
          break
      }
    }
    if (!isStroke && !isAroundEqual(yi, y0)) {
      w += windingLine(xi, yi, x0, y0, x, y) || 0
    }
    return w !== 0
  }
  function contain (pathProxy, x, y) {
    return containPath(pathProxy, 0, false, x, y)
  }
  function containStroke$4 (pathProxy, lineWidth, x, y) {
    return containPath(pathProxy, lineWidth, true, x, y)
  }

  const DEFAULT_PATH_STYLE = defaults({
    fill: '#000',
    stroke: null,
    strokePercent: 1,
    fillOpacity: 1,
    strokeOpacity: 1,
    lineDashOffset: 0,
    lineWidth: 1,
    lineCap: 'butt',
    miterLimit: 10,
    strokeNoScale: false,
    strokeFirst: false
  }, DEFAULT_COMMON_STYLE)
  const DEFAULT_PATH_ANIMATION_PROPS = {
    style: defaults({
      fill: true,
      stroke: true,
      strokePercent: true,
      fillOpacity: true,
      strokeOpacity: true,
      lineDashOffset: true,
      lineWidth: true,
      miterLimit: true
    }, DEFAULT_COMMON_ANIMATION_PROPS.style)
  }
  const pathCopyParams = TRANSFORMABLE_PROPS.concat(['invisible',
    'culling', 'z', 'z2', 'zlevel', 'parent'
  ])
  const Path = (function (_super) {
    __extends(Path, _super)
    function Path (opts) {
      return _super.call(this, opts) || this
    }
    Path.prototype.update = function () {
      const _this = this
      _super.prototype.update.call(this)
      const style = this.style
      if (style.decal) {
        const decalEl = this._decalEl = this._decalEl || new Path()
        if (decalEl.buildPath === Path.prototype.buildPath) {
          decalEl.buildPath = function (ctx) {
            _this.buildPath(ctx, _this.shape)
          }
        }
        decalEl.silent = true
        const decalElStyle = decalEl.style
        for (const key in style) {
          if (decalElStyle[key] !== style[key]) {
            decalElStyle[key] = style[key]
          }
        }
        decalElStyle.fill = style.fill ? style.decal : null
        decalElStyle.decal = null
        decalElStyle.shadowColor = null
        style.strokeFirst && (decalElStyle.stroke = null)
        for (let i = 0; i < pathCopyParams.length; ++i) {
          decalEl[pathCopyParams[i]] = this[pathCopyParams[i]]
        }
        decalEl.__dirty |= REDRAW_BIT
      } else if (this._decalEl) {
        this._decalEl = null
      }
    }
    Path.prototype.getDecalElement = function () {
      return this._decalEl
    }
    Path.prototype._init = function (props) {
      const keysArr = keys(props)
      this.shape = this.getDefaultShape()
      const defaultStyle = this.getDefaultStyle()
      if (defaultStyle) {
        this.useStyle(defaultStyle)
      }
      for (let i = 0; i < keysArr.length; i++) {
        const key = keysArr[i]
        const value = props[key]
        if (key === 'style') {
          if (!this.style) {
            this.useStyle(value)
          } else {
            extend(this.style, value)
          }
        } else if (key === 'shape') {
          extend(this.shape, value)
        } else {
          _super.prototype.attrKV.call(this, key, value)
        }
      }
      if (!this.style) {
        this.useStyle({})
      }
    }
    Path.prototype.getDefaultStyle = function () {
      return null
    }
    Path.prototype.getDefaultShape = function () {
      return {}
    }
    Path.prototype.canBeInsideText = function () {
      return this.hasFill()
    }
    Path.prototype.getInsideTextFill = function () {
      const pathFill = this.style.fill
      if (pathFill !== 'none') {
        if (isString(pathFill)) {
          const fillLum = lum(pathFill, 0)
          if (fillLum > 0.5) {
            return DARK_LABEL_COLOR
          } else if (fillLum > 0.2) {
            return LIGHTER_LABEL_COLOR
          }
          return LIGHT_LABEL_COLOR
        } else if (pathFill) {
          return LIGHT_LABEL_COLOR
        }
      }
      return DARK_LABEL_COLOR
    }
    Path.prototype.getInsideTextStroke = function (textFill) {
      const pathFill = this.style.fill
      if (isString(pathFill)) {
        const zr = this.__zr
        const isDarkMode = !!(zr && zr.isDarkMode())
        const isDarkLabel = lum(textFill, 0) < DARK_MODE_THRESHOLD
        if (isDarkMode === isDarkLabel) {
          return pathFill
        }
      }
    }
    Path.prototype.buildPath = function (ctx, shapeCfg, inBatch) { }
    Path.prototype.pathUpdated = function () {
      this.__dirty &= ~SHAPE_CHANGED_BIT
    }
    Path.prototype.getUpdatedPathProxy = function (inBatch) {
      !this.path && this.createPathProxy()
      this.path.beginPath()
      this.buildPath(this.path, this.shape, inBatch)
      return this.path
    }
    Path.prototype.createPathProxy = function () {
      this.path = new PathProxy(false)
    }
    Path.prototype.hasStroke = function () {
      const style = this.style
      const stroke = style.stroke
      return !(stroke == null || stroke === 'none' || !(style.lineWidth > 0))
    }
    Path.prototype.hasFill = function () {
      const style = this.style
      const fill = style.fill
      return fill != null && fill !== 'none'
    }
    Path.prototype.getBoundingRect = function () {
      let rect = this._rect
      const style = this.style
      const needsUpdateRect = !rect
      if (needsUpdateRect) {
        let firstInvoke = false
        if (!this.path) {
          firstInvoke = true
          this.createPathProxy()
        }
        const path = this.path
        if (firstInvoke || (this.__dirty & SHAPE_CHANGED_BIT)) {
          path.beginPath()
          this.buildPath(path, this.shape, false)
          this.pathUpdated()
        }
        rect = path.getBoundingRect()
      }
      this._rect = rect
      if (this.hasStroke() && this.path && this.path.len() > 0) {
        const rectStroke = this._rectStroke || (this._rectStroke = rect.clone())
        if (this.__dirty || needsUpdateRect) {
          rectStroke.copy(rect)
          const lineScale = style.strokeNoScale ? this.getLineScale() : 1
          let w = style.lineWidth
          if (!this.hasFill()) {
            const strokeContainThreshold = this.strokeContainThreshold
            w = Math.max(w, strokeContainThreshold == null ? 4 : strokeContainThreshold)
          }
          if (lineScale > 1e-10) {
            rectStroke.width += w / lineScale
            rectStroke.height += w / lineScale
            rectStroke.x -= w / lineScale / 2
            rectStroke.y -= w / lineScale / 2
          }
        }
        return rectStroke
      }
      return rect
    }
    Path.prototype.contain = function (x, y) {
      const localPos = this.transformCoordToLocal(x, y)
      const rect = this.getBoundingRect()
      const style = this.style
      x = localPos[0]
      y = localPos[1]
      if (rect.contain(x, y)) {
        const pathProxy = this.path
        if (this.hasStroke()) {
          let lineWidth = style.lineWidth
          const lineScale = style.strokeNoScale ? this.getLineScale() : 1
          if (lineScale > 1e-10) {
            if (!this.hasFill()) {
              lineWidth = Math.max(lineWidth, this.strokeContainThreshold)
            }
            if (containStroke$4(pathProxy, lineWidth / lineScale, x, y)) {
              return true
            }
          }
        }
        if (this.hasFill()) {
          return contain(pathProxy, x, y)
        }
      }
      return false
    }
    Path.prototype.dirtyShape = function () {
      this.__dirty |= SHAPE_CHANGED_BIT
      if (this._rect) {
        this._rect = null
      }
      if (this._decalEl) {
        this._decalEl.dirtyShape()
      }
      this.markRedraw()
    }
    Path.prototype.dirty = function () {
      this.dirtyStyle()
      this.dirtyShape()
    }
    Path.prototype.animateShape = function (loop) {
      return this.animate('shape', loop)
    }
    Path.prototype.updateDuringAnimation = function (targetKey) {
      if (targetKey === 'style') {
        this.dirtyStyle()
      } else if (targetKey === 'shape') {
        this.dirtyShape()
      } else {
        this.markRedraw()
      }
    }
    Path.prototype.attrKV = function (key, value) {
      if (key === 'shape') {
        this.setShape(value)
      } else {
        _super.prototype.attrKV.call(this, key, value)
      }
    }
    Path.prototype.setShape = function (keyOrObj, value) {
      let shape = this.shape
      if (!shape) {
        shape = this.shape = {}
      }
      if (typeof keyOrObj === 'string') {
        shape[keyOrObj] = value
      } else {
        extend(shape, keyOrObj)
      }
      this.dirtyShape()
      return this
    }
    Path.prototype.shapeChanged = function () {
      return !!(this.__dirty & SHAPE_CHANGED_BIT)
    }
    Path.prototype.createStyle = function (obj) {
      return createObject(DEFAULT_PATH_STYLE, obj)
    }
    Path.prototype._innerSaveToNormal = function (toState) {
      _super.prototype._innerSaveToNormal.call(this, toState)
      const normalState = this._normalState
      if (toState.shape && !normalState.shape) {
        normalState.shape = extend({}, this.shape)
      }
    }
    Path.prototype._applyStateObj = function (stateName, state, normalState, keepCurrentStates, transition, animationCfg) {
      _super.prototype._applyStateObj.call(this, stateName, state, normalState, keepCurrentStates, transition, animationCfg)
      const needsRestoreToNormal = !(state && keepCurrentStates)
      let targetShape
      if (state && state.shape) {
        if (transition) {
          if (keepCurrentStates) {
            targetShape = state.shape
          } else {
            targetShape = extend({}, normalState.shape)
            extend(targetShape, state.shape)
          }
        } else {
          targetShape = extend({}, keepCurrentStates ? this.shape : normalState.shape)
          extend(targetShape, state.shape)
        }
      } else if (needsRestoreToNormal) {
        targetShape = normalState.shape
      }
      if (targetShape) {
        if (transition) {
          this.shape = extend({}, this.shape)
          const targetShapePrimaryProps = {}
          const shapeKeys = keys(targetShape)
          for (let i = 0; i < shapeKeys.length; i++) {
            const key = shapeKeys[i]
            if (typeof targetShape[key] === 'object') {
              this.shape[key] = targetShape[key]
            } else {
              targetShapePrimaryProps[key] = targetShape[key]
            }
          }
          this._transitionState(stateName, {
            shape: targetShapePrimaryProps
          }, animationCfg)
        } else {
          this.shape = targetShape
          this.dirtyShape()
        }
      }
    }
    Path.prototype._mergeStates = function (states) {
      const mergedState = _super.prototype._mergeStates.call(this, states)
      let mergedShape
      for (let i = 0; i < states.length; i++) {
        const state = states[i]
        if (state.shape) {
          mergedShape = mergedShape || {}
          this._mergeStyle(mergedShape, state.shape)
        }
      }
      if (mergedShape) {
        mergedState.shape = mergedShape
      }
      return mergedState
    }
    Path.prototype.getAnimationStyleProps = function () {
      return DEFAULT_PATH_ANIMATION_PROPS
    }
    Path.prototype.isZeroArea = function () {
      return false
    }
    Path.extend = function (defaultProps) {
      const Sub = (function (_super) {
        __extends(Sub, _super)
        function Sub (opts) {
          const _this = _super.call(this, opts) || this
          defaultProps.init && defaultProps.init.call(_this, opts)
          return _this
        }
        Sub.prototype.getDefaultStyle = function () {
          return clone(defaultProps.style)
        }
        Sub.prototype.getDefaultShape = function () {
          return clone(defaultProps.shape)
        }
        return Sub
      }(Path))
      for (const key in defaultProps) {
        if (typeof defaultProps[key] === 'function') {
          Sub.prototype[key] = defaultProps[key]
        }
      }
      return Sub
    }
    Path.initDefaultProps = (function () {
      const pathProto = Path.prototype
      pathProto.type = 'path'
      pathProto.strokeContainThreshold = 5
      pathProto.segmentIgnoreThreshold = 0
      pathProto.subPixelOptimize = false
      pathProto.autoBatch = false
      pathProto.__dirty = REDRAW_BIT | STYLE_CHANGED_BIT | SHAPE_CHANGED_BIT
    })()
    return Path
  }(Displayable))

  const DEFAULT_TSPAN_STYLE = defaults({
    strokeFirst: true,
    font: DEFAULT_FONT,
    x: 0,
    y: 0,
    textAlign: 'left',
    textBaseline: 'top',
    miterLimit: 2
  }, DEFAULT_PATH_STYLE)
  const TSpan = (function (_super) {
    __extends(TSpan, _super)
    function TSpan () {
      return _super !== null && _super.apply(this, arguments) || this
    }
    TSpan.prototype.hasStroke = function () {
      const style = this.style
      const stroke = style.stroke
      return stroke != null && stroke !== 'none' && style.lineWidth > 0
    }
    TSpan.prototype.hasFill = function () {
      const style = this.style
      const fill = style.fill
      return fill != null && fill !== 'none'
    }
    TSpan.prototype.createStyle = function (obj) {
      return createObject(DEFAULT_TSPAN_STYLE, obj)
    }
    TSpan.prototype.setBoundingRect = function (rect) {
      this._rect = rect
    }
    TSpan.prototype.getBoundingRect = function () {
      const style = this.style
      if (!this._rect) {
        let text = style.text
        text != null ? (text += '') : (text = '')
        const rect = getBoundingRect(text, style.font, style.textAlign, style.textBaseline)
        rect.x += style.x || 0
        rect.y += style.y || 0
        if (this.hasStroke()) {
          const w = style.lineWidth
          rect.x -= w / 2
          rect.y -= w / 2
          rect.width += w
          rect.height += w
        }
        this._rect = rect
      }
      return this._rect
    }
    TSpan.initDefaultProps = (function () {
      const tspanProto = TSpan.prototype
      tspanProto.dirtyRectTolerance = 10
    })()
    return TSpan
  }(Displayable))
  TSpan.prototype.type = 'tspan'

  const DEFAULT_IMAGE_STYLE = defaults({
    x: 0,
    y: 0
  }, DEFAULT_COMMON_STYLE)
  const DEFAULT_IMAGE_ANIMATION_PROPS = {
    style: defaults({
      x: true,
      y: true,
      width: true,
      height: true,
      sx: true,
      sy: true,
      sWidth: true,
      sHeight: true
    }, DEFAULT_COMMON_ANIMATION_PROPS.style)
  }
  function isImageLike (source) {
    return !!(source &&
            typeof source !== 'string' &&
            source.width && source.height)
  }
  const ZRImage = (function (_super) {
    __extends(ZRImage, _super)
    function ZRImage () {
      return _super !== null && _super.apply(this, arguments) || this
    }
    ZRImage.prototype.createStyle = function (obj) {
      return createObject(DEFAULT_IMAGE_STYLE, obj)
    }
    ZRImage.prototype._getSize = function (dim) {
      const style = this.style
      const size = style[dim]
      if (size != null) {
        return size
      }
      const imageSource = isImageLike(style.image)
        ? style.image
        : this.__image
      if (!imageSource) {
        return 0
      }
      const otherDim = dim === 'width' ? 'height' : 'width'
      const otherDimSize = style[otherDim]
      if (otherDimSize == null) {
        return imageSource[dim]
      } else {
        return imageSource[dim] / imageSource[otherDim] * otherDimSize
      }
    }
    ZRImage.prototype.getWidth = function () {
      return this._getSize('width')
    }
    ZRImage.prototype.getHeight = function () {
      return this._getSize('height')
    }
    ZRImage.prototype.getAnimationStyleProps = function () {
      return DEFAULT_IMAGE_ANIMATION_PROPS
    }
    ZRImage.prototype.getBoundingRect = function () {
      const style = this.style
      if (!this._rect) {
        this._rect = new BoundingRect(style.x || 0, style.y || 0, this.getWidth(), this.getHeight())
      }
      return this._rect
    }
    return ZRImage
  }(Displayable))
  ZRImage.prototype.type = 'image'

  function buildPath (ctx, shape) {
    let x = shape.x
    let y = shape.y
    let width = shape.width
    let height = shape.height
    const r = shape.r
    let r1
    let r2
    let r3
    let r4
    if (width < 0) {
      x = x + width
      width = -width
    }
    if (height < 0) {
      y = y + height
      height = -height
    }
    if (typeof r === 'number') {
      r1 = r2 = r3 = r4 = r
    } else if (r instanceof Array) {
      if (r.length === 1) {
        r1 = r2 = r3 = r4 = r[0]
      } else if (r.length === 2) {
        r1 = r3 = r[0]
        r2 = r4 = r[1]
      } else if (r.length === 3) {
        r1 = r[0]
        r2 = r4 = r[1]
        r3 = r[2]
      } else {
        r1 = r[0]
        r2 = r[1]
        r3 = r[2]
        r4 = r[3]
      }
    } else {
      r1 = r2 = r3 = r4 = 0
    }
    let total
    if (r1 + r2 > width) {
      total = r1 + r2
      r1 *= width / total
      r2 *= width / total
    }
    if (r3 + r4 > width) {
      total = r3 + r4
      r3 *= width / total
      r4 *= width / total
    }
    if (r2 + r3 > height) {
      total = r2 + r3
      r2 *= height / total
      r3 *= height / total
    }
    if (r1 + r4 > height) {
      total = r1 + r4
      r1 *= height / total
      r4 *= height / total
    }
    ctx.moveTo(x + r1, y)
    ctx.lineTo(x + width - r2, y)
    r2 !== 0 && ctx.arc(x + width - r2, y + r2, r2, -Math.PI / 2, 0)
    ctx.lineTo(x + width, y + height - r3)
    r3 !== 0 && ctx.arc(x + width - r3, y + height - r3, r3, 0, Math.PI / 2)
    ctx.lineTo(x + r4, y + height)
    r4 !== 0 && ctx.arc(x + r4, y + height - r4, r4, Math.PI / 2, Math.PI)
    ctx.lineTo(x, y + r1)
    r1 !== 0 && ctx.arc(x + r1, y + r1, r1, Math.PI, Math.PI * 1.5)
  }

  const round$1 = Math.round
  function subPixelOptimizeLine (outputShape, inputShape, style) {
    if (!inputShape) {
      return
    }
    const x1 = inputShape.x1
    const x2 = inputShape.x2
    const y1 = inputShape.y1
    const y2 = inputShape.y2
    outputShape.x1 = x1
    outputShape.x2 = x2
    outputShape.y1 = y1
    outputShape.y2 = y2
    const lineWidth = style && style.lineWidth
    if (!lineWidth) {
      return outputShape
    }
    if (round$1(x1 * 2) === round$1(x2 * 2)) {
      outputShape.x1 = outputShape.x2 = subPixelOptimize(x1, lineWidth, true)
    }
    if (round$1(y1 * 2) === round$1(y2 * 2)) {
      outputShape.y1 = outputShape.y2 = subPixelOptimize(y1, lineWidth, true)
    }
    return outputShape
  }
  function subPixelOptimizeRect (outputShape, inputShape, style) {
    if (!inputShape) {
      return
    }
    const originX = inputShape.x
    const originY = inputShape.y
    const originWidth = inputShape.width
    const originHeight = inputShape.height
    outputShape.x = originX
    outputShape.y = originY
    outputShape.width = originWidth
    outputShape.height = originHeight
    const lineWidth = style && style.lineWidth
    if (!lineWidth) {
      return outputShape
    }
    outputShape.x = subPixelOptimize(originX, lineWidth, true)
    outputShape.y = subPixelOptimize(originY, lineWidth, true)
    outputShape.width = Math.max(subPixelOptimize(originX + originWidth, lineWidth, false) - outputShape.x, originWidth === 0 ? 0 : 1)
    outputShape.height = Math.max(subPixelOptimize(originY + originHeight, lineWidth, false) - outputShape.y, originHeight === 0 ? 0 : 1)
    return outputShape
  }
  function subPixelOptimize (position, lineWidth, positiveOrNegative) {
    if (!lineWidth) {
      return position
    }
    const doubledPosition = round$1(position * 2)
    return (doubledPosition + round$1(lineWidth)) % 2 === 0
      ? doubledPosition / 2
      : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2
  }

  const RectShape = (function () {
    function RectShape () {
      this.x = 0
      this.y = 0
      this.width = 0
      this.height = 0
    }
    return RectShape
  }())
  const subPixelOptimizeOutputShape = {}
  const Rect = (function (_super) {
    __extends(Rect, _super)
    function Rect (opts) {
      return _super.call(this, opts) || this
    }
    Rect.prototype.getDefaultShape = function () {
      return new RectShape()
    }
    Rect.prototype.buildPath = function (ctx, shape) {
      let x
      let y
      let width
      let height
      if (this.subPixelOptimize) {
        const optimizedShape = subPixelOptimizeRect(subPixelOptimizeOutputShape, shape, this.style)
        x = optimizedShape.x
        y = optimizedShape.y
        width = optimizedShape.width
        height = optimizedShape.height
        optimizedShape.r = shape.r
        shape = optimizedShape
      } else {
        x = shape.x
        y = shape.y
        width = shape.width
        height = shape.height
      }
      if (!shape.r) {
        ctx.rect(x, y, width, height)
      } else {
        buildPath(ctx, shape)
      }
    }
    Rect.prototype.isZeroArea = function () {
      return !this.shape.width || !this.shape.height
    }
    return Rect
  }(Path))
  Rect.prototype.type = 'rect'

  const DEFAULT_RICH_TEXT_COLOR = {
    fill: '#000'
  }
  const DEFAULT_STROKE_LINE_WIDTH = 2
  const DEFAULT_TEXT_ANIMATION_PROPS = {
    style: defaults({
      fill: true,
      stroke: true,
      fillOpacity: true,
      strokeOpacity: true,
      lineWidth: true,
      fontSize: true,
      lineHeight: true,
      width: true,
      height: true,
      textShadowColor: true,
      textShadowBlur: true,
      textShadowOffsetX: true,
      textShadowOffsetY: true,
      backgroundColor: true,
      padding: true,
      borderColor: true,
      borderWidth: true,
      borderRadius: true
    }, DEFAULT_COMMON_ANIMATION_PROPS.style)
  }
  const ZRText = (function (_super) {
    __extends(ZRText, _super)
    function ZRText (opts) {
      const _this = _super.call(this) || this
      _this.type = 'text'
      _this._children = []
      _this._defaultStyle = DEFAULT_RICH_TEXT_COLOR
      _this.attr(opts)
      return _this
    }
    ZRText.prototype.childrenRef = function () {
      return this._children
    }
    ZRText.prototype.update = function () {
      _super.prototype.update.call(this)
      if (this.styleChanged()) {
        this._updateSubTexts()
      }
      for (let i = 0; i < this._children.length; i++) {
        const child = this._children[i]
        child.zlevel = this.zlevel
        child.z = this.z
        child.z2 = this.z2
        child.culling = this.culling
        child.cursor = this.cursor
        child.invisible = this.invisible
      }
    }
    ZRText.prototype.updateTransform = function () {
      const innerTransformable = this.innerTransformable
      if (innerTransformable) {
        innerTransformable.updateTransform()
        if (innerTransformable.transform) {
          this.transform = innerTransformable.transform
        }
      } else {
        _super.prototype.updateTransform.call(this)
      }
    }
    ZRText.prototype.getLocalTransform = function (m) {
      const innerTransformable = this.innerTransformable
      return innerTransformable
        ? innerTransformable.getLocalTransform(m)
        : _super.prototype.getLocalTransform.call(this, m)
    }
    ZRText.prototype.getComputedTransform = function () {
      if (this.__hostTarget) {
        this.__hostTarget.getComputedTransform()
        this.__hostTarget.updateInnerText(true)
      }
      return _super.prototype.getComputedTransform.call(this)
    }
    ZRText.prototype._updateSubTexts = function () {
      this._childCursor = 0
      normalizeTextStyle(this.style)
      this.style.rich
        ? this._updateRichTexts()
        : this._updatePlainTexts()
      this._children.length = this._childCursor
      this.styleUpdated()
    }
    ZRText.prototype.addSelfToZr = function (zr) {
      _super.prototype.addSelfToZr.call(this, zr)
      for (let i = 0; i < this._children.length; i++) {
        this._children[i].__zr = zr
      }
    }
    ZRText.prototype.removeSelfFromZr = function (zr) {
      _super.prototype.removeSelfFromZr.call(this, zr)
      for (let i = 0; i < this._children.length; i++) {
        this._children[i].__zr = null
      }
    }
    ZRText.prototype.getBoundingRect = function () {
      if (this.styleChanged()) {
        this._updateSubTexts()
      }
      if (!this._rect) {
        const tmpRect = new BoundingRect(0, 0, 0, 0)
        const children = this._children
        const tmpMat = []
        let rect = null
        for (let i = 0; i < children.length; i++) {
          const child = children[i]
          const childRect = child.getBoundingRect()
          const transform = child.getLocalTransform(tmpMat)
          if (transform) {
            tmpRect.copy(childRect)
            tmpRect.applyTransform(transform)
            rect = rect || tmpRect.clone()
            rect.union(tmpRect)
          } else {
            rect = rect || childRect.clone()
            rect.union(childRect)
          }
        }
        this._rect = rect || tmpRect
      }
      return this._rect
    }
    ZRText.prototype.setDefaultTextStyle = function (defaultTextStyle) {
      this._defaultStyle = defaultTextStyle || DEFAULT_RICH_TEXT_COLOR
    }
    ZRText.prototype.setTextContent = function (textContent) {
      if ('development' !== 'production') {
        throw new Error('Can\'t attach text on another text')
      }
    }
    ZRText.prototype._mergeStyle = function (targetStyle, sourceStyle) {
      if (!sourceStyle) {
        return targetStyle
      }
      const sourceRich = sourceStyle.rich
      const targetRich = targetStyle.rich || (sourceRich && {})
      extend(targetStyle, sourceStyle)
      if (sourceRich && targetRich) {
        this._mergeRich(targetRich, sourceRich)
        targetStyle.rich = targetRich
      } else if (targetRich) {
        targetStyle.rich = targetRich
      }
      return targetStyle
    }
    ZRText.prototype._mergeRich = function (targetRich, sourceRich) {
      const richNames = keys(sourceRich)
      for (let i = 0; i < richNames.length; i++) {
        const richName = richNames[i]
        targetRich[richName] = targetRich[richName] || {}
        extend(targetRich[richName], sourceRich[richName])
      }
    }
    ZRText.prototype.getAnimationStyleProps = function () {
      return DEFAULT_TEXT_ANIMATION_PROPS
    }
    ZRText.prototype._getOrCreateChild = function (Ctor) {
      let child = this._children[this._childCursor]
      if (!child || !(child instanceof Ctor)) {
        child = new Ctor()
      }
      this._children[this._childCursor++] = child
      child.__zr = this.__zr
      child.parent = this
      return child
    }
    ZRText.prototype._updatePlainTexts = function () {
      const style = this.style
      const textFont = style.font || DEFAULT_FONT
      const textPadding = style.padding
      const text = getStyleText(style)
      const contentBlock = parsePlainText(text, style)
      const needDrawBg = needDrawBackground(style)
      const bgColorDrawn = !!(style.backgroundColor)
      const outerHeight = contentBlock.outerHeight
      const outerWidth = contentBlock.outerWidth
      const contentWidth = contentBlock.contentWidth
      const textLines = contentBlock.lines
      const lineHeight = contentBlock.lineHeight
      const defaultStyle = this._defaultStyle
      const baseX = style.x || 0
      const baseY = style.y || 0
      const textAlign = style.align || defaultStyle.align || 'left'
      const verticalAlign = style.verticalAlign || defaultStyle.verticalAlign || 'top'
      let textX = baseX
      let textY = adjustTextY$1(baseY, contentBlock.contentHeight, verticalAlign)
      if (needDrawBg || textPadding) {
        const boxX = adjustTextX(baseX, outerWidth, textAlign)
        const boxY = adjustTextY$1(baseY, outerHeight, verticalAlign)
        needDrawBg && this._renderBackground(style, style, boxX, boxY, outerWidth, outerHeight)
      }
      textY += lineHeight / 2
      if (textPadding) {
        textX = getTextXForPadding(baseX, textAlign, textPadding)
        if (verticalAlign === 'top') {
          textY += textPadding[0]
        } else if (verticalAlign === 'bottom') {
          textY -= textPadding[2]
        }
      }
      let defaultLineWidth = 0
      let useDefaultFill = false
      const textFill = getFill('fill' in style
        ? style.fill
        : (useDefaultFill = true, defaultStyle.fill))
      const textStroke = getStroke('stroke' in style
        ? style.stroke
        : (!bgColorDrawn &&
                    (!defaultStyle.autoStroke || useDefaultFill))
            ? (defaultLineWidth = DEFAULT_STROKE_LINE_WIDTH, defaultStyle.stroke)
            : null)
      const hasShadow = style.textShadowBlur > 0
      const fixedBoundingRect = style.width != null &&
                (style.overflow === 'truncate' || style.overflow === 'break' || style.overflow === 'breakAll')
      const calculatedLineHeight = contentBlock.calculatedLineHeight
      for (let i = 0; i < textLines.length; i++) {
        const el = this._getOrCreateChild(TSpan)
        const subElStyle = el.createStyle()
        el.useStyle(subElStyle)
        subElStyle.text = textLines[i]
        subElStyle.x = textX
        subElStyle.y = textY
        if (textAlign) {
          subElStyle.textAlign = textAlign
        }
        subElStyle.textBaseline = 'middle'
        subElStyle.opacity = style.opacity
        subElStyle.strokeFirst = true
        if (hasShadow) {
          subElStyle.shadowBlur = style.textShadowBlur || 0
          subElStyle.shadowColor = style.textShadowColor || 'transparent'
          subElStyle.shadowOffsetX = style.textShadowOffsetX || 0
          subElStyle.shadowOffsetY = style.textShadowOffsetY || 0
        }
        subElStyle.stroke = textStroke
        subElStyle.fill = textFill
        if (textStroke) {
          subElStyle.lineWidth = style.lineWidth || defaultLineWidth
          subElStyle.lineDash = style.lineDash
          subElStyle.lineDashOffset = style.lineDashOffset || 0
        }
        subElStyle.font = textFont
        setSeparateFont(subElStyle, style)
        textY += lineHeight
        if (fixedBoundingRect) {
          el.setBoundingRect(new BoundingRect(adjustTextX(subElStyle.x, style.width, subElStyle.textAlign), adjustTextY$1(subElStyle.y, calculatedLineHeight, subElStyle.textBaseline), contentWidth, calculatedLineHeight))
        }
      }
    }
    ZRText.prototype._updateRichTexts = function () {
      const style = this.style
      const text = getStyleText(style)
      const contentBlock = parseRichText(text, style)
      const contentWidth = contentBlock.width
      const outerWidth = contentBlock.outerWidth
      const outerHeight = contentBlock.outerHeight
      const textPadding = style.padding
      const baseX = style.x || 0
      const baseY = style.y || 0
      const defaultStyle = this._defaultStyle
      const textAlign = style.align || defaultStyle.align
      const verticalAlign = style.verticalAlign || defaultStyle.verticalAlign
      const boxX = adjustTextX(baseX, outerWidth, textAlign)
      const boxY = adjustTextY$1(baseY, outerHeight, verticalAlign)
      let xLeft = boxX
      let lineTop = boxY
      if (textPadding) {
        xLeft += textPadding[3]
        lineTop += textPadding[0]
      }
      const xRight = xLeft + contentWidth
      if (needDrawBackground(style)) {
        this._renderBackground(style, style, boxX, boxY, outerWidth, outerHeight)
      }
      const bgColorDrawn = !!(style.backgroundColor)
      for (let i = 0; i < contentBlock.lines.length; i++) {
        const line = contentBlock.lines[i]
        const tokens = line.tokens
        const tokenCount = tokens.length
        const lineHeight = line.lineHeight
        let remainedWidth = line.width
        let leftIndex = 0
        let lineXLeft = xLeft
        let lineXRight = xRight
        let rightIndex = tokenCount - 1
        let token = void 0
        while (leftIndex < tokenCount &&
                    (token = tokens[leftIndex], !token.align || token.align === 'left')) {
          this._placeToken(token, style, lineHeight, lineTop, lineXLeft, 'left', bgColorDrawn)
          remainedWidth -= token.width
          lineXLeft += token.width
          leftIndex++
        }
        while (rightIndex >= 0 &&
                    (token = tokens[rightIndex], token.align === 'right')) {
          this._placeToken(token, style, lineHeight, lineTop, lineXRight, 'right', bgColorDrawn)
          remainedWidth -= token.width
          lineXRight -= token.width
          rightIndex--
        }
        lineXLeft += (contentWidth - (lineXLeft - xLeft) - (xRight - lineXRight) - remainedWidth) / 2
        while (leftIndex <= rightIndex) {
          token = tokens[leftIndex]
          this._placeToken(token, style, lineHeight, lineTop, lineXLeft + token.width / 2, 'center', bgColorDrawn)
          lineXLeft += token.width
          leftIndex++
        }
        lineTop += lineHeight
      }
    }
    ZRText.prototype._placeToken = function (token, style, lineHeight, lineTop, x, textAlign, parentBgColorDrawn) {
      const tokenStyle = style.rich[token.styleName] || {}
      tokenStyle.text = token.text
      const verticalAlign = token.verticalAlign
      let y = lineTop + lineHeight / 2
      if (verticalAlign === 'top') {
        y = lineTop + token.height / 2
      } else if (verticalAlign === 'bottom') {
        y = lineTop + lineHeight - token.height / 2
      }
      const needDrawBg = !token.isLineHolder && needDrawBackground(tokenStyle)
      needDrawBg && this._renderBackground(tokenStyle, style, textAlign === 'right'
        ? x - token.width
        : textAlign === 'center'
          ? x - token.width / 2
          : x, y - token.height / 2, token.width, token.height)
      const bgColorDrawn = !!tokenStyle.backgroundColor
      const textPadding = token.textPadding
      if (textPadding) {
        x = getTextXForPadding(x, textAlign, textPadding)
        y -= token.height / 2 - textPadding[0] - token.innerHeight / 2
      }
      const el = this._getOrCreateChild(TSpan)
      const subElStyle = el.createStyle()
      el.useStyle(subElStyle)
      const defaultStyle = this._defaultStyle
      let useDefaultFill = false
      let defaultLineWidth = 0
      const textFill = getFill('fill' in tokenStyle
        ? tokenStyle.fill
        : 'fill' in style
          ? style.fill
          : (useDefaultFill = true, defaultStyle.fill))
      const textStroke = getStroke('stroke' in tokenStyle
        ? tokenStyle.stroke
        : 'stroke' in style
          ? style.stroke
          : (!bgColorDrawn &&
                        !parentBgColorDrawn &&
                        (!defaultStyle.autoStroke || useDefaultFill))
              ? (defaultLineWidth = DEFAULT_STROKE_LINE_WIDTH, defaultStyle.stroke)
              : null)
      const hasShadow = tokenStyle.textShadowBlur > 0 ||
                style.textShadowBlur > 0
      subElStyle.text = token.text
      subElStyle.x = x
      subElStyle.y = y
      if (hasShadow) {
        subElStyle.shadowBlur = tokenStyle.textShadowBlur || style.textShadowBlur || 0
        subElStyle.shadowColor = tokenStyle.textShadowColor || style.textShadowColor || 'transparent'
        subElStyle.shadowOffsetX = tokenStyle.textShadowOffsetX || style.textShadowOffsetX || 0
        subElStyle.shadowOffsetY = tokenStyle.textShadowOffsetY || style.textShadowOffsetY || 0
      }
      subElStyle.textAlign = textAlign
      subElStyle.textBaseline = 'middle'
      subElStyle.font = token.font || DEFAULT_FONT
      subElStyle.opacity = retrieve3(tokenStyle.opacity, style.opacity, 1)
      setSeparateFont(subElStyle, tokenStyle)
      if (textStroke) {
        subElStyle.lineWidth = retrieve3(tokenStyle.lineWidth, style.lineWidth, defaultLineWidth)
        subElStyle.lineDash = retrieve2(tokenStyle.lineDash, style.lineDash)
        subElStyle.lineDashOffset = style.lineDashOffset || 0
        subElStyle.stroke = textStroke
      }
      if (textFill) {
        subElStyle.fill = textFill
      }
      const textWidth = token.contentWidth
      const textHeight = token.contentHeight
      el.setBoundingRect(new BoundingRect(adjustTextX(subElStyle.x, textWidth, subElStyle.textAlign), adjustTextY$1(subElStyle.y, textHeight, subElStyle.textBaseline), textWidth, textHeight))
    }
    ZRText.prototype._renderBackground = function (style, topStyle, x, y, width, height) {
      const textBackgroundColor = style.backgroundColor
      const textBorderWidth = style.borderWidth
      const textBorderColor = style.borderColor
      const isImageBg = textBackgroundColor && textBackgroundColor.image
      const isPlainOrGradientBg = textBackgroundColor && !isImageBg
      const textBorderRadius = style.borderRadius
      const self = this
      let rectEl
      let imgEl
      if (isPlainOrGradientBg || style.lineHeight || (textBorderWidth && textBorderColor)) {
        rectEl = this._getOrCreateChild(Rect)
        rectEl.useStyle(rectEl.createStyle())
        rectEl.style.fill = null
        const rectShape = rectEl.shape
        rectShape.x = x
        rectShape.y = y
        rectShape.width = width
        rectShape.height = height
        rectShape.r = textBorderRadius
        rectEl.dirtyShape()
      }
      if (isPlainOrGradientBg) {
        var rectStyle = rectEl.style
        rectStyle.fill = textBackgroundColor || null
        rectStyle.fillOpacity = retrieve2(style.fillOpacity, 1)
      } else if (isImageBg) {
        imgEl = this._getOrCreateChild(ZRImage)
        imgEl.onload = function () {
          self.dirtyStyle()
        }
        const imgStyle = imgEl.style
        imgStyle.image = textBackgroundColor.image
        imgStyle.x = x
        imgStyle.y = y
        imgStyle.width = width
        imgStyle.height = height
      }
      if (textBorderWidth && textBorderColor) {
        var rectStyle = rectEl.style
        rectStyle.lineWidth = textBorderWidth
        rectStyle.stroke = textBorderColor
        rectStyle.strokeOpacity = retrieve2(style.strokeOpacity, 1)
        rectStyle.lineDash = style.borderDash
        rectStyle.lineDashOffset = style.borderDashOffset || 0
        rectEl.strokeContainThreshold = 0
        if (rectEl.hasFill() && rectEl.hasStroke()) {
          rectStyle.strokeFirst = true
          rectStyle.lineWidth *= 2
        }
      }
      const commonStyle = (rectEl || imgEl).style
      commonStyle.shadowBlur = style.shadowBlur || 0
      commonStyle.shadowColor = style.shadowColor || 'transparent'
      commonStyle.shadowOffsetX = style.shadowOffsetX || 0
      commonStyle.shadowOffsetY = style.shadowOffsetY || 0
      commonStyle.opacity = retrieve3(style.opacity, topStyle.opacity, 1)
    }
    ZRText.makeFont = function (style) {
      let font = ''
      if (hasSeparateFont(style)) {
        font = [
          style.fontStyle,
          style.fontWeight,
          parseFontSize(style.fontSize),
          style.fontFamily || 'sans-serif'
        ].join(' ')
      }
      return font && trim(font) || style.textFont || style.font
    }
    return ZRText
  }(Displayable))
  const VALID_TEXT_ALIGN = { left: true, right: 1, center: 1 }
  const VALID_TEXT_VERTICAL_ALIGN = { top: 1, bottom: 1, middle: 1 }
  const FONT_PARTS = ['fontStyle', 'fontWeight', 'fontSize', 'fontFamily']
  function parseFontSize (fontSize) {
    if (typeof fontSize === 'string' &&
            (fontSize.indexOf('px') !== -1 ||
                fontSize.indexOf('rem') !== -1 ||
                fontSize.indexOf('em') !== -1)) {
      return fontSize
    } else if (!isNaN(+fontSize)) {
      return fontSize + 'px'
    } else {
      return DEFAULT_FONT_SIZE + 'px'
    }
  }
  function setSeparateFont (targetStyle, sourceStyle) {
    for (let i = 0; i < FONT_PARTS.length; i++) {
      const fontProp = FONT_PARTS[i]
      const val = sourceStyle[fontProp]
      if (val != null) {
        targetStyle[fontProp] = val
      }
    }
  }
  function hasSeparateFont (style) {
    return style.fontSize != null || style.fontFamily || style.fontWeight
  }
  function normalizeTextStyle (style) {
    normalizeStyle(style)
    each(style.rich, normalizeStyle)
    return style
  }
  function normalizeStyle (style) {
    if (style) {
      style.font = ZRText.makeFont(style)
      let textAlign = style.align
      textAlign === 'middle' && (textAlign = 'center')
      style.align = (textAlign == null || VALID_TEXT_ALIGN[textAlign]) ? textAlign : 'left'
      let verticalAlign = style.verticalAlign
      verticalAlign === 'center' && (verticalAlign = 'middle')
      style.verticalAlign = (verticalAlign == null || VALID_TEXT_VERTICAL_ALIGN[verticalAlign]) ? verticalAlign : 'top'
      const textPadding = style.padding
      if (textPadding) {
        style.padding = normalizeCssArray(style.padding)
      }
    }
  }
  function getStroke (stroke, lineWidth) {
    return (stroke == null || lineWidth <= 0 || stroke === 'transparent' || stroke === 'none')
      ? null
      : (stroke.image || stroke.colorStops)
          ? '#000'
          : stroke
  }
  function getFill (fill) {
    return (fill == null || fill === 'none')
      ? null
      : (fill.image || fill.colorStops)
          ? '#000'
          : fill
  }
  function getTextXForPadding (x, textAlign, textPadding) {
    return textAlign === 'right'
      ? (x - textPadding[1])
      : textAlign === 'center'
        ? (x + textPadding[3] / 2 - textPadding[1] / 2)
        : (x + textPadding[3])
  }
  function getStyleText (style) {
    let text = style.text
    text != null && (text += '')
    return text
  }
  function needDrawBackground (style) {
    return !!(style.backgroundColor ||
            style.lineHeight ||
            (style.borderWidth && style.borderColor))
  }

  const getECData = makeInner()
  const setCommonECData = function (seriesIndex, dataType, dataIdx, el) {
    if (el) {
      const ecData = getECData(el) // Add data index and series index for indexing the data by element
      // Useful in tooltip

      ecData.dataIndex = dataIdx
      ecData.dataType = dataType
      ecData.seriesIndex = seriesIndex // TODO: not store dataIndex on children.

      if (el.type === 'group') {
        el.traverse(function (child) {
          const childECData = getECData(child)
          childECData.seriesIndex = seriesIndex
          childECData.dataIndex = dataIdx
          childECData.dataType = dataType
        })
      }
    }
  }

  let _highlightNextDigit = 1
  const _highlightKeyMap = {}
  const getSavedStates = makeInner()
  const getComponentStates = makeInner()
  const HOVER_STATE_NORMAL = 0
  const HOVER_STATE_BLUR = 1
  const HOVER_STATE_EMPHASIS = 2
  const SPECIAL_STATES = ['emphasis', 'blur', 'select']
  const DISPLAY_STATES = ['normal', 'emphasis', 'blur', 'select']
  const Z2_EMPHASIS_LIFT = 10
  const Z2_SELECT_LIFT = 9
  const HIGHLIGHT_ACTION_TYPE = 'highlight'
  const DOWNPLAY_ACTION_TYPE = 'downplay'
  const SELECT_ACTION_TYPE = 'select'
  const UNSELECT_ACTION_TYPE = 'unselect'
  const TOGGLE_SELECT_ACTION_TYPE = 'toggleSelect'

  function hasFillOrStroke (fillOrStroke) {
    return fillOrStroke != null && fillOrStroke !== 'none'
  } // Most lifted color are duplicated.

  const liftedColorCache = new LRU(100)

  function liftColor (color$1) {
    if (isString(color$1)) {
      let liftedColor = liftedColorCache.get(color$1)

      if (!liftedColor) {
        liftedColor = lift(color$1, -0.1)
        liftedColorCache.put(color$1, liftedColor)
      }

      return liftedColor
    } else if (isGradientObject(color$1)) {
      const ret = extend({}, color$1)
      ret.colorStops = map(color$1.colorStops, function (stop) {
        return {
          offset: stop.offset,
          color: lift(stop.color, -0.1)
        }
      })
      return ret
    } // Change nothing.

    return color$1
  }

  function doChangeHoverState (el, stateName, hoverStateEnum) {
    if (el.onHoverStateChange && (el.hoverState || 0) !== hoverStateEnum) {
      el.onHoverStateChange(stateName)
    }

    el.hoverState = hoverStateEnum
  }

  function singleEnterEmphasis (el) {
    // Only mark the flag.
    // States will be applied in the echarts.ts in next frame.
    doChangeHoverState(el, 'emphasis', HOVER_STATE_EMPHASIS)
  }

  function singleLeaveEmphasis (el) {
    // Only mark the flag.
    // States will be applied in the echarts.ts in next frame.
    if (el.hoverState === HOVER_STATE_EMPHASIS) {
      doChangeHoverState(el, 'normal', HOVER_STATE_NORMAL)
    }
  }

  function singleEnterBlur (el) {
    doChangeHoverState(el, 'blur', HOVER_STATE_BLUR)
  }

  function singleLeaveBlur (el) {
    if (el.hoverState === HOVER_STATE_BLUR) {
      doChangeHoverState(el, 'normal', HOVER_STATE_NORMAL)
    }
  }

  function singleEnterSelect (el) {
    el.selected = true
  }

  function singleLeaveSelect (el) {
    el.selected = false
  }

  function updateElementState (el, updater, commonParam) {
    updater(el, commonParam)
  }

  function traverseUpdateState (el, updater, commonParam) {
    updateElementState(el, updater, commonParam)
    el.isGroup && el.traverse(function (child) {
      updateElementState(child, updater, commonParam)
    })
  }

  function setStatesFlag (el, stateName) {
    switch (stateName) {
      case 'emphasis':
        el.hoverState = HOVER_STATE_EMPHASIS
        break

      case 'normal':
        el.hoverState = HOVER_STATE_NORMAL
        break

      case 'blur':
        el.hoverState = HOVER_STATE_BLUR
        break

      case 'select':
        el.selected = true
    }
  }

  function getFromStateStyle (el, props, toStateName, defaultValue) {
    const style = el.style
    const fromState = {}

    for (var i = 0; i < props.length; i++) {
      const propName = props[i]
      const val = style[propName]
      fromState[propName] = val == null ? defaultValue && defaultValue[propName] : val
    }

    for (var i = 0; i < el.animators.length; i++) {
      const animator = el.animators[i]

      if (animator.__fromStateTransition && // Dont consider the animation to emphasis state.
        animator.__fromStateTransition.indexOf(toStateName) < 0 && animator.targetName === 'style') {
        animator.saveTo(fromState, props)
      }
    }

    return fromState
  }

  function createEmphasisDefaultState (el, stateName, targetStates, state) {
    const hasSelect = targetStates && indexOf(targetStates, 'select') >= 0
    let cloned = false

    if (el instanceof Path) {
      const store = getSavedStates(el)
      const fromFill = hasSelect ? store.selectFill || store.normalFill : store.normalFill
      const fromStroke = hasSelect ? store.selectStroke || store.normalStroke : store.normalStroke

      if (hasFillOrStroke(fromFill) || hasFillOrStroke(fromStroke)) {
        state = state || {}
        let emphasisStyle = state.style || {} // inherit case

        if (emphasisStyle.fill === 'inherit') {
          cloned = true
          state = extend({}, state)
          emphasisStyle = extend({}, emphasisStyle)
          emphasisStyle.fill = fromFill
        } // Apply default color lift
        else if (!hasFillOrStroke(emphasisStyle.fill) && hasFillOrStroke(fromFill)) {
          cloned = true // Not modify the original value.

          state = extend({}, state)
          emphasisStyle = extend({}, emphasisStyle) // Already being applied 'emphasis'. DON'T lift color multiple times.

          emphasisStyle.fill = liftColor(fromFill)
        } // Not highlight stroke if fill has been highlighted.
        else if (!hasFillOrStroke(emphasisStyle.stroke) && hasFillOrStroke(fromStroke)) {
          if (!cloned) {
            state = extend({}, state)
            emphasisStyle = extend({}, emphasisStyle)
          }

          emphasisStyle.stroke = liftColor(fromStroke)
        }

        state.style = emphasisStyle
      }
    }

    if (state) {
      // TODO Share with textContent?
      if (state.z2 == null) {
        if (!cloned) {
          state = extend({}, state)
        }

        const z2EmphasisLift = el.z2EmphasisLift
        state.z2 = el.z2 + (z2EmphasisLift != null ? z2EmphasisLift : Z2_EMPHASIS_LIFT)
      }
    }

    return state
  }

  function createSelectDefaultState (el, stateName, state) {
    // const hasSelect = indexOf(el.currentStates, stateName) >= 0;
    if (state) {
      // TODO Share with textContent?
      if (state.z2 == null) {
        state = extend({}, state)
        const z2SelectLift = el.z2SelectLift
        state.z2 = el.z2 + (z2SelectLift != null ? z2SelectLift : Z2_SELECT_LIFT)
      }
    }

    return state
  }

  function createBlurDefaultState (el, stateName, state) {
    const hasBlur = indexOf(el.currentStates, stateName) >= 0
    const currentOpacity = el.style.opacity
    const fromState = !hasBlur
      ? getFromStateStyle(el, ['opacity'], stateName, {
        opacity: 1
      })
      : null
    state = state || {}
    let blurStyle = state.style || {}

    if (blurStyle.opacity == null) {
      // clone state
      state = extend({}, state)
      blurStyle = extend({
        // Already being applied 'emphasis'. DON'T mul opacity multiple times.
        opacity: hasBlur ? currentOpacity : fromState.opacity * 0.1
      }, blurStyle)
      state.style = blurStyle
    }

    return state
  }

  function elementStateProxy (stateName, targetStates) {
    const state = this.states[stateName]

    if (this.style) {
      if (stateName === 'emphasis') {
        return createEmphasisDefaultState(this, stateName, targetStates, state)
      } else if (stateName === 'blur') {
        return createBlurDefaultState(this, stateName, state)
      } else if (stateName === 'select') {
        return createSelectDefaultState(this, stateName, state)
      }
    }

    return state
  }
  /** FI
     * Set hover style (namely "emphasis style") of element.
     * @param el Should not be `zrender/graphic/Group`.
     * @param focus 'self' | 'selfInSeries' | 'series'
     */

  function setDefaultStateProxy (el) {
    el.stateProxy = elementStateProxy
    const textContent = el.getTextContent()
    const textGuide = el.getTextGuideLine()

    if (textContent) {
      textContent.stateProxy = elementStateProxy
    }

    if (textGuide) {
      textGuide.stateProxy = elementStateProxy
    }
  }
  function enterEmphasisWhenMouseOver (el, e) {
    !shouldSilent(el, e) && // "emphasis" event highlight has higher priority than mouse highlight.
      !el.__highByOuter && traverseUpdateState(el, singleEnterEmphasis)
  }
  function leaveEmphasisWhenMouseOut (el, e) {
    !shouldSilent(el, e) && // "emphasis" event highlight has higher priority than mouse highlight.
      !el.__highByOuter && traverseUpdateState(el, singleLeaveEmphasis)
  }
  function enterEmphasis (el, highlightDigit) {
    el.__highByOuter |= 1 << (highlightDigit || 0)
    traverseUpdateState(el, singleEnterEmphasis)
  }
  function leaveEmphasis (el, highlightDigit) {
    !(el.__highByOuter &= ~(1 << (highlightDigit || 0))) && traverseUpdateState(el, singleLeaveEmphasis)
  }
  function enterBlur (el) {
    traverseUpdateState(el, singleEnterBlur)
  }
  function leaveBlur (el) {
    traverseUpdateState(el, singleLeaveBlur)
  }
  function enterSelect (el) {
    traverseUpdateState(el, singleEnterSelect)
  }
  function leaveSelect (el) {
    traverseUpdateState(el, singleLeaveSelect)
  }

  function shouldSilent (el, e) {
    return el.__highDownSilentOnTouch && e.zrByTouch
  }

  function allLeaveBlur (api) {
    const model = api.getModel()
    const leaveBlurredSeries = []
    const allComponentViews = []
    model.eachComponent(function (componentType, componentModel) {
      const componentStates = getComponentStates(componentModel)
      const isSeries = componentType === 'series'
      const view = isSeries ? api.getViewOfSeriesModel(componentModel) : api.getViewOfComponentModel(componentModel)
      !isSeries && allComponentViews.push(view)

      if (componentStates.isBlured) {
        // Leave blur anyway
        view.group.traverse(function (child) {
          singleLeaveBlur(child)
        })
        isSeries && leaveBlurredSeries.push(componentModel)
      }

      componentStates.isBlured = false
    })
    each(allComponentViews, function (view) {
      if (view && view.toggleBlurSeries) {
        view.toggleBlurSeries(leaveBlurredSeries, false, model)
      }
    })
  }
  function blurSeries (targetSeriesIndex, focus, blurScope, api) {
    const ecModel = api.getModel()
    blurScope = blurScope || 'coordinateSystem'

    function leaveBlurOfIndices (data, dataIndices) {
      for (let i = 0; i < dataIndices.length; i++) {
        const itemEl = data.getItemGraphicEl(dataIndices[i])
        itemEl && leaveBlur(itemEl)
      }
    }

    if (targetSeriesIndex == null) {
      return
    }

    if (!focus || focus === 'none') {
      return
    }

    const targetSeriesModel = ecModel.getSeriesByIndex(targetSeriesIndex)
    let targetCoordSys = targetSeriesModel.coordinateSystem

    if (targetCoordSys && targetCoordSys.master) {
      targetCoordSys = targetCoordSys.master
    }

    const blurredSeries = []
    ecModel.eachSeries(function (seriesModel) {
      const sameSeries = targetSeriesModel === seriesModel
      let coordSys = seriesModel.coordinateSystem

      if (coordSys && coordSys.master) {
        coordSys = coordSys.master
      }

      const sameCoordSys = coordSys && targetCoordSys ? coordSys === targetCoordSys : sameSeries // If there is no coordinate system. use sameSeries instead.

      if (!( // Not blur other series if blurScope series
        blurScope === 'series' && !sameSeries || // Not blur other coordinate system if blurScope is coordinateSystem
        blurScope === 'coordinateSystem' && !sameCoordSys || // Not blur self series if focus is series.
        focus === 'series' && sameSeries // TODO blurScope: coordinate system
      )) {
        const view = api.getViewOfSeriesModel(seriesModel)
        view.group.traverse(function (child) {
          singleEnterBlur(child)
        })

        if (isArrayLike(focus)) {
          leaveBlurOfIndices(seriesModel.getData(), focus)
        } else if (isObject(focus)) {
          const dataTypes = keys(focus)

          for (let d = 0; d < dataTypes.length; d++) {
            leaveBlurOfIndices(seriesModel.getData(dataTypes[d]), focus[dataTypes[d]])
          }
        }

        blurredSeries.push(seriesModel)
        getComponentStates(seriesModel).isBlured = true
      }
    })
    ecModel.eachComponent(function (componentType, componentModel) {
      if (componentType === 'series') {
        return
      }

      const view = api.getViewOfComponentModel(componentModel)

      if (view && view.toggleBlurSeries) {
        view.toggleBlurSeries(blurredSeries, true, ecModel)
      }
    })
  }
  function blurComponent (componentMainType, componentIndex, api) {
    if (componentMainType == null || componentIndex == null) {
      return
    }

    const componentModel = api.getModel().getComponent(componentMainType, componentIndex)

    if (!componentModel) {
      return
    }

    getComponentStates(componentModel).isBlured = true
    const view = api.getViewOfComponentModel(componentModel)

    if (!view || !view.focusBlurEnabled) {
      return
    }

    view.group.traverse(function (child) {
      singleEnterBlur(child)
    })
  }
  function blurSeriesFromHighlightPayload (seriesModel, payload, api) {
    const seriesIndex = seriesModel.seriesIndex
    const data = seriesModel.getData(payload.dataType)

    if (!data) {
      if ('development' !== 'production') {
        error('Unknown dataType ' + payload.dataType)
      }

      return
    }

    let dataIndex = queryDataIndex(data, payload) // Pick the first one if there is multiple/none exists.

    dataIndex = (isArray(dataIndex) ? dataIndex[0] : dataIndex) || 0
    let el = data.getItemGraphicEl(dataIndex)

    if (!el) {
      const count = data.count()
      let current = 0 // If data on dataIndex is NaN.

      while (!el && current < count) {
        el = data.getItemGraphicEl(current++)
      }
    }

    if (el) {
      const ecData = getECData(el)
      blurSeries(seriesIndex, ecData.focus, ecData.blurScope, api)
    } else {
      // If there is no element put on the data. Try getting it from raw option
      // TODO Should put it on seriesModel?
      const focus_1 = seriesModel.get(['emphasis', 'focus'])
      const blurScope = seriesModel.get(['emphasis', 'blurScope'])

      if (focus_1 != null) {
        blurSeries(seriesIndex, focus_1, blurScope, api)
      }
    }
  }
  function findComponentHighDownDispatchers (componentMainType, componentIndex, name, api) {
    const ret = {
      focusSelf: false,
      dispatchers: null
    }

    if (componentMainType == null || componentMainType === 'series' || componentIndex == null || name == null) {
      return ret
    }

    const componentModel = api.getModel().getComponent(componentMainType, componentIndex)

    if (!componentModel) {
      return ret
    }

    const view = api.getViewOfComponentModel(componentModel)

    if (!view || !view.findHighDownDispatchers) {
      return ret
    }

    const dispatchers = view.findHighDownDispatchers(name) // At presnet, the component (like Geo) only blur inside itself.
    // So we do not use `blurScope` in component.

    let focusSelf

    for (let i = 0; i < dispatchers.length; i++) {
      if ('development' !== 'production' && !isHighDownDispatcher(dispatchers[i])) {
        error('param should be highDownDispatcher')
      }

      if (getECData(dispatchers[i]).focus === 'self') {
        focusSelf = true
        break
      }
    }

    return {
      focusSelf: focusSelf,
      dispatchers: dispatchers
    }
  }
  function handleGlobalMouseOverForHighDown (dispatcher, e, api) {
    if ('development' !== 'production' && !isHighDownDispatcher(dispatcher)) {
      error('param should be highDownDispatcher')
    }

    const ecData = getECData(dispatcher)

    const _a = findComponentHighDownDispatchers(ecData.componentMainType, ecData.componentIndex, ecData.componentHighDownName, api)
    const dispatchers = _a.dispatchers
    const focusSelf = _a.focusSelf // If `findHighDownDispatchers` is supported on the component,
    // highlight/downplay elements with the same name.

    if (dispatchers) {
      if (focusSelf) {
        blurComponent(ecData.componentMainType, ecData.componentIndex, api)
      }

      each(dispatchers, function (dispatcher) {
        return enterEmphasisWhenMouseOver(dispatcher, e)
      })
    } else {
      // Try blur all in the related series. Then emphasis the hoverred.
      // TODO. progressive mode.
      blurSeries(ecData.seriesIndex, ecData.focus, ecData.blurScope, api)

      if (ecData.focus === 'self') {
        blurComponent(ecData.componentMainType, ecData.componentIndex, api)
      } // Other than series, component that not support `findHighDownDispatcher` will
      // also use it. But in this case, highlight/downplay are only supported in
      // mouse hover but not in dispatchAction.

      enterEmphasisWhenMouseOver(dispatcher, e)
    }
  }
  function handleGlobalMouseOutForHighDown (dispatcher, e, api) {
    if ('development' !== 'production' && !isHighDownDispatcher(dispatcher)) {
      error('param should be highDownDispatcher')
    }

    allLeaveBlur(api)
    const ecData = getECData(dispatcher)
    const dispatchers = findComponentHighDownDispatchers(ecData.componentMainType, ecData.componentIndex, ecData.componentHighDownName, api).dispatchers

    if (dispatchers) {
      each(dispatchers, function (dispatcher) {
        return leaveEmphasisWhenMouseOut(dispatcher, e)
      })
    } else {
      leaveEmphasisWhenMouseOut(dispatcher, e)
    }
  }
  function toggleSelectionFromPayload (seriesModel, payload, api) {
    if (!isSelectChangePayload(payload)) {
      return
    }

    const dataType = payload.dataType
    const data = seriesModel.getData(dataType)
    let dataIndex = queryDataIndex(data, payload)

    if (!isArray(dataIndex)) {
      dataIndex = [dataIndex]
    }

    seriesModel[payload.type === TOGGLE_SELECT_ACTION_TYPE ? 'toggleSelect' : payload.type === SELECT_ACTION_TYPE ? 'select' : 'unselect'](dataIndex, dataType)
  }
  function updateSeriesElementSelection (seriesModel) {
    const allData = seriesModel.getAllData()
    each(allData, function (_a) {
      const data = _a.data
      const type = _a.type
      data.eachItemGraphicEl(function (el, idx) {
        seriesModel.isSelected(idx, type) ? enterSelect(el) : leaveSelect(el)
      })
    })
  }
  function getAllSelectedIndices (ecModel) {
    const ret = []
    ecModel.eachSeries(function (seriesModel) {
      const allData = seriesModel.getAllData()
      each(allData, function (_a) {
        const data = _a.data
        const type = _a.type
        const dataIndices = seriesModel.getSelectedDataIndices()

        if (dataIndices.length > 0) {
          const item = {
            dataIndex: dataIndices,
            seriesIndex: seriesModel.seriesIndex
          }

          if (type != null) {
            item.dataType = type
          }

          ret.push(item)
        }
      })
    })
    return ret
  }
  /**
     * Enable the function that mouseover will trigger the emphasis state.
     *
     * NOTE:
     * This function should be used on the element with dataIndex, seriesIndex.
     *
     */

  function enableHoverEmphasis (el, focus, blurScope) {
    setAsHighDownDispatcher(el, true)
    traverseUpdateState(el, setDefaultStateProxy)
    enableHoverFocus(el, focus, blurScope)
  }
  function disableHoverEmphasis (el) {
    setAsHighDownDispatcher(el, false)
  }
  function toggleHoverEmphasis (el, focus, blurScope, isDisabled) {
    isDisabled ? disableHoverEmphasis(el) : enableHoverEmphasis(el, focus, blurScope)
  }
  function enableHoverFocus (el, focus, blurScope) {
    const ecData = getECData(el)

    if (focus != null) {
      // TODO dataIndex may be set after this function. This check is not useful.
      // if (ecData.dataIndex == null) {
      //     if (__DEV__) {
      //         console.warn('focus can only been set on element with dataIndex');
      //     }
      // }
      // else {
      ecData.focus = focus
      ecData.blurScope = blurScope // }
    } else if (ecData.focus) {
      ecData.focus = null
    }
  }
  const OTHER_STATES = ['emphasis', 'blur', 'select']
  const defaultStyleGetterMap = {
    itemStyle: 'getItemStyle',
    lineStyle: 'getLineStyle',
    areaStyle: 'getAreaStyle'
  }
  /**
     * Set emphasis/blur/selected states of element.
     */

  function setStatesStylesFromModel (el, itemModel, styleType, // default itemStyle
    getter) {
    styleType = styleType || 'itemStyle'

    for (let i = 0; i < OTHER_STATES.length; i++) {
      const stateName = OTHER_STATES[i]
      const model = itemModel.getModel([stateName, styleType])
      const state = el.ensureState(stateName) // Let it throw error if getterType is not found.

      state.style = getter ? getter(model) : model[defaultStyleGetterMap[styleType]]()
    }
  }
  /**
     *
     * Set element as highlight / downplay dispatcher.
     * It will be checked when element recieved mouseover event or from highlight action.
     * It's in change of all highlight/downplay behavior of it's children.
     *
     * @param el
     * @param el.highDownSilentOnTouch
     *        In touch device, mouseover event will be trigger on touchstart event
     *        (see module:zrender/dom/HandlerProxy). By this mechanism, we can
     *        conveniently use hoverStyle when tap on touch screen without additional
     *        code for compatibility.
     *        But if the chart/component has select feature, which usually also use
     *        hoverStyle, there might be conflict between 'select-highlight' and
     *        'hover-highlight' especially when roam is enabled (see geo for example).
     *        In this case, `highDownSilentOnTouch` should be used to disable
     *        hover-highlight on touch device.
     * @param asDispatcher If `false`, do not set as "highDownDispatcher".
     */

  function setAsHighDownDispatcher (el, asDispatcher) {
    const disable = asDispatcher === false
    const extendedEl = el // Make `highDownSilentOnTouch` and `onStateChange` only work after
    // `setAsHighDownDispatcher` called. Avoid it is modified by user unexpectedly.

    if (el.highDownSilentOnTouch) {
      extendedEl.__highDownSilentOnTouch = el.highDownSilentOnTouch
    } // Simple optimize, since this method might be
    // called for each elements of a group in some cases.

    if (!disable || extendedEl.__highDownDispatcher) {
      // Emphasis, normal can be triggered manually by API or other components like hover link.
      // el[method]('emphasis', onElementEmphasisEvent)[method]('normal', onElementNormalEvent);
      // Also keep previous record.
      extendedEl.__highByOuter = extendedEl.__highByOuter || 0
      extendedEl.__highDownDispatcher = !disable
    }
  }
  function isHighDownDispatcher (el) {
    return !!(el && el.__highDownDispatcher)
  }
  /**
     * Enable component highlight/downplay features:
     * + hover link (within the same name)
     * + focus blur in component
     */

  function enableComponentHighDownFeatures (el, componentModel, componentHighDownName) {
    const ecData = getECData(el)
    ecData.componentMainType = componentModel.mainType
    ecData.componentIndex = componentModel.componentIndex
    ecData.componentHighDownName = componentHighDownName
  }
  /**
     * Support hightlight/downplay record on each elements.
     * For the case: hover highlight/downplay (legend, visualMap, ...) and
     * user triggerred hightlight/downplay should not conflict.
     * Only all of the highlightDigit cleared, return to normal.
     * @param {string} highlightKey
     * @return {number} highlightDigit
     */

  function getHighlightDigit (highlightKey) {
    let highlightDigit = _highlightKeyMap[highlightKey]

    if (highlightDigit == null && _highlightNextDigit <= 32) {
      highlightDigit = _highlightKeyMap[highlightKey] = _highlightNextDigit++
    }

    return highlightDigit
  }
  function isSelectChangePayload (payload) {
    const payloadType = payload.type
    return payloadType === SELECT_ACTION_TYPE || payloadType === UNSELECT_ACTION_TYPE || payloadType === TOGGLE_SELECT_ACTION_TYPE
  }
  function isHighDownPayload (payload) {
    const payloadType = payload.type
    return payloadType === HIGHLIGHT_ACTION_TYPE || payloadType === DOWNPLAY_ACTION_TYPE
  }
  function savePathStates (el) {
    const store = getSavedStates(el)
    store.normalFill = el.style.fill
    store.normalStroke = el.style.stroke
    const selectState = el.states.select || {}
    store.selectFill = selectState.style && selectState.style.fill || null
    store.selectStroke = selectState.style && selectState.style.stroke || null
  }

  const CMD$2 = PathProxy.CMD
  const points = [[], [], []]
  const mathSqrt$1 = Math.sqrt
  const mathAtan2 = Math.atan2
  function transformPath (path, m) {
    if (!m) {
      return
    }
    const data = path.data
    const len = path.len()
    let cmd
    let nPoint
    let i
    let j
    let k
    let p
    const M = CMD$2.M
    const C = CMD$2.C
    const L = CMD$2.L
    const R = CMD$2.R
    const A = CMD$2.A
    const Q = CMD$2.Q
    for (i = 0, j = 0; i < len;) {
      cmd = data[i++]
      j = i
      nPoint = 0
      switch (cmd) {
        case M:
          nPoint = 1
          break
        case L:
          nPoint = 1
          break
        case C:
          nPoint = 3
          break
        case Q:
          nPoint = 2
          break
        case A:
          var x = m[4]
          var y = m[5]
          var sx = mathSqrt$1(m[0] * m[0] + m[1] * m[1])
          var sy = mathSqrt$1(m[2] * m[2] + m[3] * m[3])
          var angle = mathAtan2(-m[1] / sy, m[0] / sx)
          data[i] *= sx
          data[i++] += x
          data[i] *= sy
          data[i++] += y
          data[i++] *= sx
          data[i++] *= sy
          data[i++] += angle
          data[i++] += angle
          i += 2
          j = i
          break
        case R:
          p[0] = data[i++]
          p[1] = data[i++]
          applyTransform(p, p, m)
          data[j++] = p[0]
          data[j++] = p[1]
          p[0] += data[i++]
          p[1] += data[i++]
          applyTransform(p, p, m)
          data[j++] = p[0]
          data[j++] = p[1]
      }
      for (k = 0; k < nPoint; k++) {
        const p_1 = points[k]
        p_1[0] = data[i++]
        p_1[1] = data[i++]
        applyTransform(p_1, p_1, m)
        data[j++] = p_1[0]
        data[j++] = p_1[1]
      }
    }
    path.increaseVersion()
  }

  const mathSqrt$2 = Math.sqrt
  const mathSin$2 = Math.sin
  const mathCos$2 = Math.cos
  const PI$1 = Math.PI
  function vMag (v) {
    return Math.sqrt(v[0] * v[0] + v[1] * v[1])
  }
  function vRatio (u, v) {
    return (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v))
  }
  function vAngle (u, v) {
    return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) *
            Math.acos(vRatio(u, v))
  }
  function processArc (x1, y1, x2, y2, fa, fs, rx, ry, psiDeg, cmd, path) {
    const psi = psiDeg * (PI$1 / 180.0)
    const xp = mathCos$2(psi) * (x1 - x2) / 2.0 +
            mathSin$2(psi) * (y1 - y2) / 2.0
    const yp = -1 * mathSin$2(psi) * (x1 - x2) / 2.0 +
            mathCos$2(psi) * (y1 - y2) / 2.0
    const lambda = (xp * xp) / (rx * rx) + (yp * yp) / (ry * ry)
    if (lambda > 1) {
      rx *= mathSqrt$2(lambda)
      ry *= mathSqrt$2(lambda)
    }
    const f = (fa === fs ? -1 : 1) *
            mathSqrt$2((((rx * rx) * (ry * ry)) -
                ((rx * rx) * (yp * yp)) -
                ((ry * ry) * (xp * xp))) / ((rx * rx) * (yp * yp) +
                (ry * ry) * (xp * xp))) || 0
    const cxp = f * rx * yp / ry
    const cyp = f * -ry * xp / rx
    const cx = (x1 + x2) / 2.0 +
            mathCos$2(psi) * cxp -
            mathSin$2(psi) * cyp
    const cy = (y1 + y2) / 2.0 +
            mathSin$2(psi) * cxp +
            mathCos$2(psi) * cyp
    const theta = vAngle([1, 0], [(xp - cxp) / rx, (yp - cyp) / ry])
    const u = [(xp - cxp) / rx, (yp - cyp) / ry]
    const v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry]
    let dTheta = vAngle(u, v)
    if (vRatio(u, v) <= -1) {
      dTheta = PI$1
    }
    if (vRatio(u, v) >= 1) {
      dTheta = 0
    }
    if (dTheta < 0) {
      const n = Math.round(dTheta / PI$1 * 1e6) / 1e6
      dTheta = PI$1 * 2 + (n % 2) * PI$1
    }
    path.addData(cmd, cx, cy, rx, ry, theta, dTheta, psi, fs)
  }
  const commandReg = /([mlvhzcqtsa])([^mlvhzcqtsa]*)/ig
  const numberReg = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g
  function createPathProxyFromString (data) {
    const path = new PathProxy()
    if (!data) {
      return path
    }
    let cpx = 0
    let cpy = 0
    let subpathX = cpx
    let subpathY = cpy
    let prevCmd
    const CMD = PathProxy.CMD
    const cmdList = data.match(commandReg)
    if (!cmdList) {
      return path
    }
    for (let l = 0; l < cmdList.length; l++) {
      const cmdText = cmdList[l]
      let cmdStr = cmdText.charAt(0)
      let cmd = void 0
      const p = cmdText.match(numberReg) || []
      const pLen = p.length
      for (let i = 0; i < pLen; i++) {
        p[i] = parseFloat(p[i])
      }
      let off = 0
      while (off < pLen) {
        let ctlPtx = void 0
        let ctlPty = void 0
        let rx = void 0
        let ry = void 0
        let psi = void 0
        let fa = void 0
        let fs = void 0
        let x1 = cpx
        let y1 = cpy
        let len = void 0
        let pathData = void 0
        switch (cmdStr) {
          case 'l':
            cpx += p[off++]
            cpy += p[off++]
            cmd = CMD.L
            path.addData(cmd, cpx, cpy)
            break
          case 'L':
            cpx = p[off++]
            cpy = p[off++]
            cmd = CMD.L
            path.addData(cmd, cpx, cpy)
            break
          case 'm':
            cpx += p[off++]
            cpy += p[off++]
            cmd = CMD.M
            path.addData(cmd, cpx, cpy)
            subpathX = cpx
            subpathY = cpy
            cmdStr = 'l'
            break
          case 'M':
            cpx = p[off++]
            cpy = p[off++]
            cmd = CMD.M
            path.addData(cmd, cpx, cpy)
            subpathX = cpx
            subpathY = cpy
            cmdStr = 'L'
            break
          case 'h':
            cpx += p[off++]
            cmd = CMD.L
            path.addData(cmd, cpx, cpy)
            break
          case 'H':
            cpx = p[off++]
            cmd = CMD.L
            path.addData(cmd, cpx, cpy)
            break
          case 'v':
            cpy += p[off++]
            cmd = CMD.L
            path.addData(cmd, cpx, cpy)
            break
          case 'V':
            cpy = p[off++]
            cmd = CMD.L
            path.addData(cmd, cpx, cpy)
            break
          case 'C':
            cmd = CMD.C
            path.addData(cmd, p[off++], p[off++], p[off++], p[off++], p[off++], p[off++])
            cpx = p[off - 2]
            cpy = p[off - 1]
            break
          case 'c':
            cmd = CMD.C
            path.addData(cmd, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy, p[off++] + cpx, p[off++] + cpy)
            cpx += p[off - 2]
            cpy += p[off - 1]
            break
          case 'S':
            ctlPtx = cpx
            ctlPty = cpy
            len = path.len()
            pathData = path.data
            if (prevCmd === CMD.C) {
              ctlPtx += cpx - pathData[len - 4]
              ctlPty += cpy - pathData[len - 3]
            }
            cmd = CMD.C
            x1 = p[off++]
            y1 = p[off++]
            cpx = p[off++]
            cpy = p[off++]
            path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy)
            break
          case 's':
            ctlPtx = cpx
            ctlPty = cpy
            len = path.len()
            pathData = path.data
            if (prevCmd === CMD.C) {
              ctlPtx += cpx - pathData[len - 4]
              ctlPty += cpy - pathData[len - 3]
            }
            cmd = CMD.C
            x1 = cpx + p[off++]
            y1 = cpy + p[off++]
            cpx += p[off++]
            cpy += p[off++]
            path.addData(cmd, ctlPtx, ctlPty, x1, y1, cpx, cpy)
            break
          case 'Q':
            x1 = p[off++]
            y1 = p[off++]
            cpx = p[off++]
            cpy = p[off++]
            cmd = CMD.Q
            path.addData(cmd, x1, y1, cpx, cpy)
            break
          case 'q':
            x1 = p[off++] + cpx
            y1 = p[off++] + cpy
            cpx += p[off++]
            cpy += p[off++]
            cmd = CMD.Q
            path.addData(cmd, x1, y1, cpx, cpy)
            break
          case 'T':
            ctlPtx = cpx
            ctlPty = cpy
            len = path.len()
            pathData = path.data
            if (prevCmd === CMD.Q) {
              ctlPtx += cpx - pathData[len - 4]
              ctlPty += cpy - pathData[len - 3]
            }
            cpx = p[off++]
            cpy = p[off++]
            cmd = CMD.Q
            path.addData(cmd, ctlPtx, ctlPty, cpx, cpy)
            break
          case 't':
            ctlPtx = cpx
            ctlPty = cpy
            len = path.len()
            pathData = path.data
            if (prevCmd === CMD.Q) {
              ctlPtx += cpx - pathData[len - 4]
              ctlPty += cpy - pathData[len - 3]
            }
            cpx += p[off++]
            cpy += p[off++]
            cmd = CMD.Q
            path.addData(cmd, ctlPtx, ctlPty, cpx, cpy)
            break
          case 'A':
            rx = p[off++]
            ry = p[off++]
            psi = p[off++]
            fa = p[off++]
            fs = p[off++]
            x1 = cpx, y1 = cpy
            cpx = p[off++]
            cpy = p[off++]
            cmd = CMD.A
            processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path)
            break
          case 'a':
            rx = p[off++]
            ry = p[off++]
            psi = p[off++]
            fa = p[off++]
            fs = p[off++]
            x1 = cpx, y1 = cpy
            cpx += p[off++]
            cpy += p[off++]
            cmd = CMD.A
            processArc(x1, y1, cpx, cpy, fa, fs, rx, ry, psi, cmd, path)
            break
        }
      }
      if (cmdStr === 'z' || cmdStr === 'Z') {
        cmd = CMD.Z
        path.addData(cmd)
        cpx = subpathX
        cpy = subpathY
      }
      prevCmd = cmd
    }
    path.toStatic()
    return path
  }
  const SVGPath = (function (_super) {
    __extends(SVGPath, _super)
    function SVGPath () {
      return _super !== null && _super.apply(this, arguments) || this
    }
    SVGPath.prototype.applyTransform = function (m) { }
    return SVGPath
  }(Path))
  function isPathProxy (path) {
    return path.setData != null
  }
  function createPathOptions (str, opts) {
    const pathProxy = createPathProxyFromString(str)
    const innerOpts = extend({}, opts)
    innerOpts.buildPath = function (path) {
      if (isPathProxy(path)) {
        path.setData(pathProxy.data)
        var ctx = path.getContext()
        if (ctx) {
          path.rebuildPath(ctx, 1)
        }
      } else {
        var ctx = path
        pathProxy.rebuildPath(ctx, 1)
      }
    }
    innerOpts.applyTransform = function (m) {
      transformPath(pathProxy, m)
      this.dirtyShape()
    }
    return innerOpts
  }
  function createFromString (str, opts) {
    return new SVGPath(createPathOptions(str, opts))
  }
  function extendFromString (str, defaultOpts) {
    const innerOpts = createPathOptions(str, defaultOpts)
    const Sub = (function (_super) {
      __extends(Sub, _super)
      function Sub (opts) {
        const _this = _super.call(this, opts) || this
        _this.applyTransform = innerOpts.applyTransform
        _this.buildPath = innerOpts.buildPath
        return _this
      }
      return Sub
    }(SVGPath))
    return Sub
  }
  function mergePath (pathEls, opts) {
    const pathList = []
    const len = pathEls.length
    for (let i = 0; i < len; i++) {
      const pathEl = pathEls[i]
      pathList.push(pathEl.getUpdatedPathProxy(true))
    }
    const pathBundle = new Path(opts)
    pathBundle.createPathProxy()
    pathBundle.buildPath = function (path) {
      if (isPathProxy(path)) {
        path.appendPath(pathList)
        const ctx = path.getContext()
        if (ctx) {
          path.rebuildPath(ctx, 1)
        }
      }
    }
    return pathBundle
  }
  function clonePath (sourcePath, opts) {
    opts = opts || {}
    const path = new Path()
    if (sourcePath.shape) {
      path.setShape(sourcePath.shape)
    }
    path.setStyle(sourcePath.style)
    if (opts.bakeTransform) {
      transformPath(path.path, sourcePath.getComputedTransform())
    } else {
      if (opts.toLocal) {
        path.setLocalTransform(sourcePath.getComputedTransform())
      } else {
        path.copyTransform(sourcePath)
      }
    }
    path.buildPath = sourcePath.buildPath
    path.applyTransform = path.applyTransform
    path.z = sourcePath.z
    path.z2 = sourcePath.z2
    path.zlevel = sourcePath.zlevel
    return path
  }

  const CircleShape = (function () {
    function CircleShape () {
      this.cx = 0
      this.cy = 0
      this.r = 0
    }
    return CircleShape
  }())
  const Circle = (function (_super) {
    __extends(Circle, _super)
    function Circle (opts) {
      return _super.call(this, opts) || this
    }
    Circle.prototype.getDefaultShape = function () {
      return new CircleShape()
    }
    Circle.prototype.buildPath = function (ctx, shape) {
      ctx.moveTo(shape.cx + shape.r, shape.cy)
      ctx.arc(shape.cx, shape.cy, shape.r, 0, Math.PI * 2)
    }
    return Circle
  }(Path))
  Circle.prototype.type = 'circle'

  const EllipseShape = (function () {
    function EllipseShape () {
      this.cx = 0
      this.cy = 0
      this.rx = 0
      this.ry = 0
    }
    return EllipseShape
  }())
  const Ellipse = (function (_super) {
    __extends(Ellipse, _super)
    function Ellipse (opts) {
      return _super.call(this, opts) || this
    }
    Ellipse.prototype.getDefaultShape = function () {
      return new EllipseShape()
    }
    Ellipse.prototype.buildPath = function (ctx, shape) {
      const k = 0.5522848
      const x = shape.cx
      const y = shape.cy
      const a = shape.rx
      const b = shape.ry
      const ox = a * k
      const oy = b * k
      ctx.moveTo(x - a, y)
      ctx.bezierCurveTo(x - a, y - oy, x - ox, y - b, x, y - b)
      ctx.bezierCurveTo(x + ox, y - b, x + a, y - oy, x + a, y)
      ctx.bezierCurveTo(x + a, y + oy, x + ox, y + b, x, y + b)
      ctx.bezierCurveTo(x - ox, y + b, x - a, y + oy, x - a, y)
      ctx.closePath()
    }
    return Ellipse
  }(Path))
  Ellipse.prototype.type = 'ellipse'

  const PI$2 = Math.PI
  const PI2$5 = PI$2 * 2
  const mathSin$3 = Math.sin
  const mathCos$3 = Math.cos
  const mathACos = Math.acos
  const mathATan2 = Math.atan2
  const mathAbs$1 = Math.abs
  const mathSqrt$3 = Math.sqrt
  const mathMax$3 = Math.max
  const mathMin$3 = Math.min
  const e = 1e-4
  function intersect (x0, y0, x1, y1, x2, y2, x3, y3) {
    const dx10 = x1 - x0
    const dy10 = y1 - y0
    const dx32 = x3 - x2
    const dy32 = y3 - y2
    let t = dy32 * dx10 - dx32 * dy10
    if (t * t < e) {
      return
    }
    t = (dx32 * (y0 - y2) - dy32 * (x0 - x2)) / t
    return [x0 + t * dx10, y0 + t * dy10]
  }
  function computeCornerTangents (x0, y0, x1, y1, radius, cr, clockwise) {
    const x01 = x0 - x1
    const y01 = y0 - y1
    const lo = (clockwise ? cr : -cr) / mathSqrt$3(x01 * x01 + y01 * y01)
    const ox = lo * y01
    const oy = -lo * x01
    const x11 = x0 + ox
    const y11 = y0 + oy
    const x10 = x1 + ox
    const y10 = y1 + oy
    const x00 = (x11 + x10) / 2
    const y00 = (y11 + y10) / 2
    const dx = x10 - x11
    const dy = y10 - y11
    const d2 = dx * dx + dy * dy
    const r = radius - cr
    const s = x11 * y10 - x10 * y11
    const d = (dy < 0 ? -1 : 1) * mathSqrt$3(mathMax$3(0, r * r * d2 - s * s))
    let cx0 = (s * dy - dx * d) / d2
    let cy0 = (-s * dx - dy * d) / d2
    const cx1 = (s * dy + dx * d) / d2
    const cy1 = (-s * dx + dy * d) / d2
    const dx0 = cx0 - x00
    const dy0 = cy0 - y00
    const dx1 = cx1 - x00
    const dy1 = cy1 - y00
    if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) {
      cx0 = cx1
      cy0 = cy1
    }
    return {
      cx: cx0,
      cy: cy0,
      x0: -ox,
      y0: -oy,
      x1: cx0 * (radius / r - 1),
      y1: cy0 * (radius / r - 1)
    }
  }
  function normalizeCornerRadius (cr) {
    let arr
    if (isArray(cr)) {
      const len = cr.length
      if (!len) {
        return cr
      }
      if (len === 1) {
        arr = [cr[0], cr[0], 0, 0]
      } else if (len === 2) {
        arr = [cr[0], cr[0], cr[1], cr[1]]
      } else if (len === 3) {
        arr = cr.concat(cr[2])
      } else {
        arr = cr
      }
    } else {
      arr = [cr, cr, cr, cr]
    }
    return arr
  }
  function buildPath$1 (ctx, shape) {
    let _a
    let radius = mathMax$3(shape.r, 0)
    let innerRadius = mathMax$3(shape.r0 || 0, 0)
    const hasRadius = radius > 0
    const hasInnerRadius = innerRadius > 0
    if (!hasRadius && !hasInnerRadius) {
      return
    }
    if (!hasRadius) {
      radius = innerRadius
      innerRadius = 0
    }
    if (innerRadius > radius) {
      const tmp = radius
      radius = innerRadius
      innerRadius = tmp
    }
    const startAngle = shape.startAngle; const endAngle = shape.endAngle
    if (isNaN(startAngle) || isNaN(endAngle)) {
      return
    }
    const cx = shape.cx; const cy = shape.cy
    const clockwise = !!shape.clockwise
    let arc = mathAbs$1(endAngle - startAngle)
    const mod = arc > PI2$5 && arc % PI2$5
    mod > e && (arc = mod)
    if (!(radius > e)) {
      ctx.moveTo(cx, cy)
    } else if (arc > PI2$5 - e) {
      ctx.moveTo(cx + radius * mathCos$3(startAngle), cy + radius * mathSin$3(startAngle))
      ctx.arc(cx, cy, radius, startAngle, endAngle, !clockwise)
      if (innerRadius > e) {
        ctx.moveTo(cx + innerRadius * mathCos$3(endAngle), cy + innerRadius * mathSin$3(endAngle))
        ctx.arc(cx, cy, innerRadius, endAngle, startAngle, clockwise)
      }
    } else {
      let icrStart = void 0
      let icrEnd = void 0
      let ocrStart = void 0
      let ocrEnd = void 0
      let ocrs = void 0
      let ocre = void 0
      let icrs = void 0
      let icre = void 0
      let ocrMax = void 0
      let icrMax = void 0
      let limitedOcrMax = void 0
      let limitedIcrMax = void 0
      let xre = void 0
      let yre = void 0
      let xirs = void 0
      let yirs = void 0
      const xrs = radius * mathCos$3(startAngle)
      const yrs = radius * mathSin$3(startAngle)
      const xire = innerRadius * mathCos$3(endAngle)
      const yire = innerRadius * mathSin$3(endAngle)
      const hasArc = arc > e
      if (hasArc) {
        const cornerRadius = shape.cornerRadius
        if (cornerRadius) {
          _a = normalizeCornerRadius(cornerRadius), icrStart = _a[0], icrEnd = _a[1], ocrStart = _a[2], ocrEnd = _a[3]
        }
        const halfRd = mathAbs$1(radius - innerRadius) / 2
        ocrs = mathMin$3(halfRd, ocrStart)
        ocre = mathMin$3(halfRd, ocrEnd)
        icrs = mathMin$3(halfRd, icrStart)
        icre = mathMin$3(halfRd, icrEnd)
        limitedOcrMax = ocrMax = mathMax$3(ocrs, ocre)
        limitedIcrMax = icrMax = mathMax$3(icrs, icre)
        if (ocrMax > e || icrMax > e) {
          xre = radius * mathCos$3(endAngle)
          yre = radius * mathSin$3(endAngle)
          xirs = innerRadius * mathCos$3(startAngle)
          yirs = innerRadius * mathSin$3(startAngle)
          if (arc < PI$2) {
            const it_1 = intersect(xrs, yrs, xirs, yirs, xre, yre, xire, yire)
            if (it_1) {
              const x0 = xrs - it_1[0]
              const y0 = yrs - it_1[1]
              const x1 = xre - it_1[0]
              const y1 = yre - it_1[1]
              const a = 1 / mathSin$3(mathACos((x0 * x1 + y0 * y1) / (mathSqrt$3(x0 * x0 + y0 * y0) * mathSqrt$3(x1 * x1 + y1 * y1))) / 2)
              const b = mathSqrt$3(it_1[0] * it_1[0] + it_1[1] * it_1[1])
              limitedOcrMax = mathMin$3(ocrMax, (radius - b) / (a + 1))
              limitedIcrMax = mathMin$3(icrMax, (innerRadius - b) / (a - 1))
            }
          }
        }
      }
      if (!hasArc) {
        ctx.moveTo(cx + xrs, cy + yrs)
      } else if (limitedOcrMax > e) {
        var crStart = mathMin$3(ocrStart, limitedOcrMax)
        var crEnd = mathMin$3(ocrEnd, limitedOcrMax)
        var ct0 = computeCornerTangents(xirs, yirs, xrs, yrs, radius, crStart, clockwise)
        var ct1 = computeCornerTangents(xre, yre, xire, yire, radius, crEnd, clockwise)
        ctx.moveTo(cx + ct0.cx + ct0.x0, cy + ct0.cy + ct0.y0)
        if (limitedOcrMax < ocrMax && crStart === crEnd) {
          ctx.arc(cx + ct0.cx, cy + ct0.cy, limitedOcrMax, mathATan2(ct0.y0, ct0.x0), mathATan2(ct1.y0, ct1.x0), !clockwise)
        } else {
          crStart > 0 && ctx.arc(cx + ct0.cx, cy + ct0.cy, crStart, mathATan2(ct0.y0, ct0.x0), mathATan2(ct0.y1, ct0.x1), !clockwise)
          ctx.arc(cx, cy, radius, mathATan2(ct0.cy + ct0.y1, ct0.cx + ct0.x1), mathATan2(ct1.cy + ct1.y1, ct1.cx + ct1.x1), !clockwise)
          crEnd > 0 && ctx.arc(cx + ct1.cx, cy + ct1.cy, crEnd, mathATan2(ct1.y1, ct1.x1), mathATan2(ct1.y0, ct1.x0), !clockwise)
        }
      } else {
        ctx.moveTo(cx + xrs, cy + yrs)
        ctx.arc(cx, cy, radius, startAngle, endAngle, !clockwise)
      }
      if (!(innerRadius > e) || !hasArc) {
        ctx.lineTo(cx + xire, cy + yire)
      } else if (limitedIcrMax > e) {
        var crStart = mathMin$3(icrStart, limitedIcrMax)
        var crEnd = mathMin$3(icrEnd, limitedIcrMax)
        var ct0 = computeCornerTangents(xire, yire, xre, yre, innerRadius, -crEnd, clockwise)
        var ct1 = computeCornerTangents(xrs, yrs, xirs, yirs, innerRadius, -crStart, clockwise)
        ctx.lineTo(cx + ct0.cx + ct0.x0, cy + ct0.cy + ct0.y0)
        if (limitedIcrMax < icrMax && crStart === crEnd) {
          ctx.arc(cx + ct0.cx, cy + ct0.cy, limitedIcrMax, mathATan2(ct0.y0, ct0.x0), mathATan2(ct1.y0, ct1.x0), !clockwise)
        } else {
          crEnd > 0 && ctx.arc(cx + ct0.cx, cy + ct0.cy, crEnd, mathATan2(ct0.y0, ct0.x0), mathATan2(ct0.y1, ct0.x1), !clockwise)
          ctx.arc(cx, cy, innerRadius, mathATan2(ct0.cy + ct0.y1, ct0.cx + ct0.x1), mathATan2(ct1.cy + ct1.y1, ct1.cx + ct1.x1), clockwise)
          crStart > 0 && ctx.arc(cx + ct1.cx, cy + ct1.cy, crStart, mathATan2(ct1.y1, ct1.x1), mathATan2(ct1.y0, ct1.x0), !clockwise)
        }
      } else {
        ctx.lineTo(cx + xire, cy + yire)
        ctx.arc(cx, cy, innerRadius, endAngle, startAngle, clockwise)
      }
    }
    ctx.closePath()
  }

  const SectorShape = (function () {
    function SectorShape () {
      this.cx = 0
      this.cy = 0
      this.r0 = 0
      this.r = 0
      this.startAngle = 0
      this.endAngle = Math.PI * 2
      this.clockwise = true
      this.cornerRadius = 0
    }
    return SectorShape
  }())
  const Sector = (function (_super) {
    __extends(Sector, _super)
    function Sector (opts) {
      return _super.call(this, opts) || this
    }
    Sector.prototype.getDefaultShape = function () {
      return new SectorShape()
    }
    Sector.prototype.buildPath = function (ctx, shape) {
      buildPath$1(ctx, shape)
    }
    Sector.prototype.isZeroArea = function () {
      return this.shape.startAngle === this.shape.endAngle ||
                this.shape.r === this.shape.r0
    }
    return Sector
  }(Path))
  Sector.prototype.type = 'sector'

  const RingShape = (function () {
    function RingShape () {
      this.cx = 0
      this.cy = 0
      this.r = 0
      this.r0 = 0
    }
    return RingShape
  }())
  const Ring = (function (_super) {
    __extends(Ring, _super)
    function Ring (opts) {
      return _super.call(this, opts) || this
    }
    Ring.prototype.getDefaultShape = function () {
      return new RingShape()
    }
    Ring.prototype.buildPath = function (ctx, shape) {
      const x = shape.cx
      const y = shape.cy
      const PI2 = Math.PI * 2
      ctx.moveTo(x + shape.r, y)
      ctx.arc(x, y, shape.r, 0, PI2, false)
      ctx.moveTo(x + shape.r0, y)
      ctx.arc(x, y, shape.r0, 0, PI2, true)
    }
    return Ring
  }(Path))
  Ring.prototype.type = 'ring'

  function smoothBezier (points, smooth, isLoop, constraint) {
    const cps = []
    const v = []
    const v1 = []
    const v2 = []
    let prevPoint
    let nextPoint
    let min$1
    let max$1
    if (constraint) {
      min$1 = [Infinity, Infinity]
      max$1 = [-Infinity, -Infinity]
      for (var i = 0, len = points.length; i < len; i++) {
        min(min$1, min$1, points[i])
        max(max$1, max$1, points[i])
      }
      min(min$1, min$1, constraint[0])
      max(max$1, max$1, constraint[1])
    }
    for (var i = 0, len = points.length; i < len; i++) {
      const point = points[i]
      if (isLoop) {
        prevPoint = points[i ? i - 1 : len - 1]
        nextPoint = points[(i + 1) % len]
      } else {
        if (i === 0 || i === len - 1) {
          cps.push(clone$1(points[i]))
          continue
        } else {
          prevPoint = points[i - 1]
          nextPoint = points[i + 1]
        }
      }
      sub(v, nextPoint, prevPoint)
      scale(v, v, smooth)
      let d0 = distance(point, prevPoint)
      let d1 = distance(point, nextPoint)
      const sum = d0 + d1
      if (sum !== 0) {
        d0 /= sum
        d1 /= sum
      }
      scale(v1, v, -d0)
      scale(v2, v, d1)
      const cp0 = add([], point, v1)
      const cp1 = add([], point, v2)
      if (constraint) {
        max(cp0, cp0, min$1)
        min(cp0, cp0, max$1)
        max(cp1, cp1, min$1)
        min(cp1, cp1, max$1)
      }
      cps.push(cp0)
      cps.push(cp1)
    }
    if (isLoop) {
      cps.push(cps.shift())
    }
    return cps
  }

  function buildPath$2 (ctx, shape, closePath) {
    const smooth = shape.smooth
    const points = shape.points
    if (points && points.length >= 2) {
      if (smooth) {
        const controlPoints = smoothBezier(points, smooth, closePath, shape.smoothConstraint)
        ctx.moveTo(points[0][0], points[0][1])
        const len = points.length
        for (var i = 0; i < (closePath ? len : len - 1); i++) {
          const cp1 = controlPoints[i * 2]
          const cp2 = controlPoints[i * 2 + 1]
          const p = points[(i + 1) % len]
          ctx.bezierCurveTo(cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1])
        }
      } else {
        ctx.moveTo(points[0][0], points[0][1])
        for (var i = 1, l = points.length; i < l; i++) {
          ctx.lineTo(points[i][0], points[i][1])
        }
      }
      closePath && ctx.closePath()
    }
  }

  const PolygonShape = (function () {
    function PolygonShape () {
      this.points = null
      this.smooth = 0
      this.smoothConstraint = null
    }
    return PolygonShape
  }())
  const Polygon = (function (_super) {
    __extends(Polygon, _super)
    function Polygon (opts) {
      return _super.call(this, opts) || this
    }
    Polygon.prototype.getDefaultShape = function () {
      return new PolygonShape()
    }
    Polygon.prototype.buildPath = function (ctx, shape) {
      buildPath$2(ctx, shape, true)
    }
    return Polygon
  }(Path))
  Polygon.prototype.type = 'polygon'

  const PolylineShape = (function () {
    function PolylineShape () {
      this.points = null
      this.percent = 1
      this.smooth = 0
      this.smoothConstraint = null
    }
    return PolylineShape
  }())
  const Polyline = (function (_super) {
    __extends(Polyline, _super)
    function Polyline (opts) {
      return _super.call(this, opts) || this
    }
    Polyline.prototype.getDefaultStyle = function () {
      return {
        stroke: '#000',
        fill: null
      }
    }
    Polyline.prototype.getDefaultShape = function () {
      return new PolylineShape()
    }
    Polyline.prototype.buildPath = function (ctx, shape) {
      buildPath$2(ctx, shape, false)
    }
    return Polyline
  }(Path))
  Polyline.prototype.type = 'polyline'

  const subPixelOptimizeOutputShape$1 = {}
  const LineShape = (function () {
    function LineShape () {
      this.x1 = 0
      this.y1 = 0
      this.x2 = 0
      this.y2 = 0
      this.percent = 1
    }
    return LineShape
  }())
  const Line = (function (_super) {
    __extends(Line, _super)
    function Line (opts) {
      return _super.call(this, opts) || this
    }
    Line.prototype.getDefaultStyle = function () {
      return {
        stroke: '#000',
        fill: null
      }
    }
    Line.prototype.getDefaultShape = function () {
      return new LineShape()
    }
    Line.prototype.buildPath = function (ctx, shape) {
      let x1
      let y1
      let x2
      let y2
      if (this.subPixelOptimize) {
        const optimizedShape = subPixelOptimizeLine(subPixelOptimizeOutputShape$1, shape, this.style)
        x1 = optimizedShape.x1
        y1 = optimizedShape.y1
        x2 = optimizedShape.x2
        y2 = optimizedShape.y2
      } else {
        x1 = shape.x1
        y1 = shape.y1
        x2 = shape.x2
        y2 = shape.y2
      }
      const percent = shape.percent
      if (percent === 0) {
        return
      }
      ctx.moveTo(x1, y1)
      if (percent < 1) {
        x2 = x1 * (1 - percent) + x2 * percent
        y2 = y1 * (1 - percent) + y2 * percent
      }
      ctx.lineTo(x2, y2)
    }
    Line.prototype.pointAt = function (p) {
      const shape = this.shape
      return [
        shape.x1 * (1 - p) + shape.x2 * p,
        shape.y1 * (1 - p) + shape.y2 * p
      ]
    }
    return Line
  }(Path))
  Line.prototype.type = 'line'

  const out = []
  const BezierCurveShape = (function () {
    function BezierCurveShape () {
      this.x1 = 0
      this.y1 = 0
      this.x2 = 0
      this.y2 = 0
      this.cpx1 = 0
      this.cpy1 = 0
      this.percent = 1
    }
    return BezierCurveShape
  }())
  function someVectorAt (shape, t, isTangent) {
    const cpx2 = shape.cpx2
    const cpy2 = shape.cpy2
    if (cpx2 != null || cpy2 != null) {
      return [
        (isTangent ? cubicDerivativeAt : cubicAt)(shape.x1, shape.cpx1, shape.cpx2, shape.x2, t),
        (isTangent ? cubicDerivativeAt : cubicAt)(shape.y1, shape.cpy1, shape.cpy2, shape.y2, t)
      ]
    } else {
      return [
        (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.x1, shape.cpx1, shape.x2, t),
        (isTangent ? quadraticDerivativeAt : quadraticAt)(shape.y1, shape.cpy1, shape.y2, t)
      ]
    }
  }
  const BezierCurve = (function (_super) {
    __extends(BezierCurve, _super)
    function BezierCurve (opts) {
      return _super.call(this, opts) || this
    }
    BezierCurve.prototype.getDefaultStyle = function () {
      return {
        stroke: '#000',
        fill: null
      }
    }
    BezierCurve.prototype.getDefaultShape = function () {
      return new BezierCurveShape()
    }
    BezierCurve.prototype.buildPath = function (ctx, shape) {
      const x1 = shape.x1
      const y1 = shape.y1
      let x2 = shape.x2
      let y2 = shape.y2
      let cpx1 = shape.cpx1
      let cpy1 = shape.cpy1
      let cpx2 = shape.cpx2
      let cpy2 = shape.cpy2
      const percent = shape.percent
      if (percent === 0) {
        return
      }
      ctx.moveTo(x1, y1)
      if (cpx2 == null || cpy2 == null) {
        if (percent < 1) {
          quadraticSubdivide(x1, cpx1, x2, percent, out)
          cpx1 = out[1]
          x2 = out[2]
          quadraticSubdivide(y1, cpy1, y2, percent, out)
          cpy1 = out[1]
          y2 = out[2]
        }
        ctx.quadraticCurveTo(cpx1, cpy1, x2, y2)
      } else {
        if (percent < 1) {
          cubicSubdivide(x1, cpx1, cpx2, x2, percent, out)
          cpx1 = out[1]
          cpx2 = out[2]
          x2 = out[3]
          cubicSubdivide(y1, cpy1, cpy2, y2, percent, out)
          cpy1 = out[1]
          cpy2 = out[2]
          y2 = out[3]
        }
        ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2)
      }
    }
    BezierCurve.prototype.pointAt = function (t) {
      return someVectorAt(this.shape, t, false)
    }
    BezierCurve.prototype.tangentAt = function (t) {
      const p = someVectorAt(this.shape, t, true)
      return normalize(p, p)
    }
    return BezierCurve
  }(Path))
  BezierCurve.prototype.type = 'bezier-curve'

  const ArcShape = (function () {
    function ArcShape () {
      this.cx = 0
      this.cy = 0
      this.r = 0
      this.startAngle = 0
      this.endAngle = Math.PI * 2
      this.clockwise = true
    }
    return ArcShape
  }())
  const Arc = (function (_super) {
    __extends(Arc, _super)
    function Arc (opts) {
      return _super.call(this, opts) || this
    }
    Arc.prototype.getDefaultStyle = function () {
      return {
        stroke: '#000',
        fill: null
      }
    }
    Arc.prototype.getDefaultShape = function () {
      return new ArcShape()
    }
    Arc.prototype.buildPath = function (ctx, shape) {
      const x = shape.cx
      const y = shape.cy
      const r = Math.max(shape.r, 0)
      const startAngle = shape.startAngle
      const endAngle = shape.endAngle
      const clockwise = shape.clockwise
      const unitX = Math.cos(startAngle)
      const unitY = Math.sin(startAngle)
      ctx.moveTo(unitX * r + x, unitY * r + y)
      ctx.arc(x, y, r, startAngle, endAngle, !clockwise)
    }
    return Arc
  }(Path))
  Arc.prototype.type = 'arc'

  const CompoundPath = (function (_super) {
    __extends(CompoundPath, _super)
    function CompoundPath () {
      const _this = _super !== null && _super.apply(this, arguments) || this
      _this.type = 'compound'
      return _this
    }
    CompoundPath.prototype._updatePathDirty = function () {
      const paths = this.shape.paths
      let dirtyPath = this.shapeChanged()
      for (let i = 0; i < paths.length; i++) {
        dirtyPath = dirtyPath || paths[i].shapeChanged()
      }
      if (dirtyPath) {
        this.dirtyShape()
      }
    }
    CompoundPath.prototype.beforeBrush = function () {
      this._updatePathDirty()
      const paths = this.shape.paths || []
      const scale = this.getGlobalScale()
      for (let i = 0; i < paths.length; i++) {
        if (!paths[i].path) {
          paths[i].createPathProxy()
        }
        paths[i].path.setScale(scale[0], scale[1], paths[i].segmentIgnoreThreshold)
      }
    }
    CompoundPath.prototype.buildPath = function (ctx, shape) {
      const paths = shape.paths || []
      for (let i = 0; i < paths.length; i++) {
        paths[i].buildPath(ctx, paths[i].shape, true)
      }
    }
    CompoundPath.prototype.afterBrush = function () {
      const paths = this.shape.paths || []
      for (let i = 0; i < paths.length; i++) {
        paths[i].pathUpdated()
      }
    }
    CompoundPath.prototype.getBoundingRect = function () {
      this._updatePathDirty.call(this)
      return Path.prototype.getBoundingRect.call(this)
    }
    return CompoundPath
  }(Path))

  const Gradient = (function () {
    function Gradient (colorStops) {
      this.colorStops = colorStops || []
    }
    Gradient.prototype.addColorStop = function (offset, color) {
      this.colorStops.push({
        offset: offset,
        color: color
      })
    }
    return Gradient
  }())

  const LinearGradient = (function (_super) {
    __extends(LinearGradient, _super)
    function LinearGradient (x, y, x2, y2, colorStops, globalCoord) {
      const _this = _super.call(this, colorStops) || this
      _this.x = x == null ? 0 : x
      _this.y = y == null ? 0 : y
      _this.x2 = x2 == null ? 1 : x2
      _this.y2 = y2 == null ? 0 : y2
      _this.type = 'linear'
      _this.global = globalCoord || false
      return _this
    }
    return LinearGradient
  }(Gradient))

  const RadialGradient = (function (_super) {
    __extends(RadialGradient, _super)
    function RadialGradient (x, y, r, colorStops, globalCoord) {
      const _this = _super.call(this, colorStops) || this
      _this.x = x == null ? 0.5 : x
      _this.y = y == null ? 0.5 : y
      _this.r = r == null ? 0.5 : r
      _this.type = 'radial'
      _this.global = globalCoord || false
      return _this
    }
    return RadialGradient
  }(Gradient))

  const extent = [0, 0]
  const extent2 = [0, 0]
  const minTv$1 = new Point()
  const maxTv$1 = new Point()
  const OrientedBoundingRect = (function () {
    function OrientedBoundingRect (rect, transform) {
      this._corners = []
      this._axes = []
      this._origin = [0, 0]
      for (var i = 0; i < 4; i++) {
        this._corners[i] = new Point()
      }
      for (var i = 0; i < 2; i++) {
        this._axes[i] = new Point()
      }
      if (rect) {
        this.fromBoundingRect(rect, transform)
      }
    }
    OrientedBoundingRect.prototype.fromBoundingRect = function (rect, transform) {
      const corners = this._corners
      const axes = this._axes
      const x = rect.x
      const y = rect.y
      const x2 = x + rect.width
      const y2 = y + rect.height
      corners[0].set(x, y)
      corners[1].set(x2, y)
      corners[2].set(x2, y2)
      corners[3].set(x, y2)
      if (transform) {
        for (var i = 0; i < 4; i++) {
          corners[i].transform(transform)
        }
      }
      Point.sub(axes[0], corners[1], corners[0])
      Point.sub(axes[1], corners[3], corners[0])
      axes[0].normalize()
      axes[1].normalize()
      for (var i = 0; i < 2; i++) {
        this._origin[i] = axes[i].dot(corners[0])
      }
    }
    OrientedBoundingRect.prototype.intersect = function (other, mtv) {
      let overlapped = true
      const noMtv = !mtv
      minTv$1.set(Infinity, Infinity)
      maxTv$1.set(0, 0)
      if (!this._intersectCheckOneSide(this, other, minTv$1, maxTv$1, noMtv, 1)) {
        overlapped = false
        if (noMtv) {
          return overlapped
        }
      }
      if (!this._intersectCheckOneSide(other, this, minTv$1, maxTv$1, noMtv, -1)) {
        overlapped = false
        if (noMtv) {
          return overlapped
        }
      }
      if (!noMtv) {
        Point.copy(mtv, overlapped ? minTv$1 : maxTv$1)
      }
      return overlapped
    }
    OrientedBoundingRect.prototype._intersectCheckOneSide = function (self, other, minTv, maxTv, noMtv, inverse) {
      let overlapped = true
      for (let i = 0; i < 2; i++) {
        const axis = this._axes[i]
        this._getProjMinMaxOnAxis(i, self._corners, extent)
        this._getProjMinMaxOnAxis(i, other._corners, extent2)
        if (extent[1] < extent2[0] || extent[0] > extent2[1]) {
          overlapped = false
          if (noMtv) {
            return overlapped
          }
          var dist0 = Math.abs(extent2[0] - extent[1])
          var dist1 = Math.abs(extent[0] - extent2[1])
          if (Math.min(dist0, dist1) > maxTv.len()) {
            if (dist0 < dist1) {
              Point.scale(maxTv, axis, -dist0 * inverse)
            } else {
              Point.scale(maxTv, axis, dist1 * inverse)
            }
          }
        } else if (minTv) {
          var dist0 = Math.abs(extent2[0] - extent[1])
          var dist1 = Math.abs(extent[0] - extent2[1])
          if (Math.min(dist0, dist1) < minTv.len()) {
            if (dist0 < dist1) {
              Point.scale(minTv, axis, dist0 * inverse)
            } else {
              Point.scale(minTv, axis, -dist1 * inverse)
            }
          }
        }
      }
      return overlapped
    }
    OrientedBoundingRect.prototype._getProjMinMaxOnAxis = function (dim, corners, out) {
      const axis = this._axes[dim]
      const origin = this._origin
      const proj = corners[0].dot(axis) + origin[dim]
      let min = proj
      let max = proj
      for (let i = 1; i < corners.length; i++) {
        const proj_1 = corners[i].dot(axis) + origin[dim]
        min = Math.min(proj_1, min)
        max = Math.max(proj_1, max)
      }
      out[0] = min
      out[1] = max
    }
    return OrientedBoundingRect
  }())

  const m = []
  const IncrementalDisplayable = (function (_super) {
    __extends(IncrementalDisplayable, _super)
    function IncrementalDisplayable () {
      const _this = _super !== null && _super.apply(this, arguments) || this
      _this.notClear = true
      _this.incremental = true
      _this._displayables = []
      _this._temporaryDisplayables = []
      _this._cursor = 0
      return _this
    }
    IncrementalDisplayable.prototype.traverse = function (cb, context) {
      cb.call(context, this)
    }
    IncrementalDisplayable.prototype.useStyle = function () {
      this.style = {}
    }
    IncrementalDisplayable.prototype.getCursor = function () {
      return this._cursor
    }
    IncrementalDisplayable.prototype.innerAfterBrush = function () {
      this._cursor = this._displayables.length
    }
    IncrementalDisplayable.prototype.clearDisplaybles = function () {
      this._displayables = []
      this._temporaryDisplayables = []
      this._cursor = 0
      this.markRedraw()
      this.notClear = false
    }
    IncrementalDisplayable.prototype.clearTemporalDisplayables = function () {
      this._temporaryDisplayables = []
    }
    IncrementalDisplayable.prototype.addDisplayable = function (displayable, notPersistent) {
      if (notPersistent) {
        this._temporaryDisplayables.push(displayable)
      } else {
        this._displayables.push(displayable)
      }
      this.markRedraw()
    }
    IncrementalDisplayable.prototype.addDisplayables = function (displayables, notPersistent) {
      notPersistent = notPersistent || false
      for (let i = 0; i < displayables.length; i++) {
        this.addDisplayable(displayables[i], notPersistent)
      }
    }
    IncrementalDisplayable.prototype.getDisplayables = function () {
      return this._displayables
    }
    IncrementalDisplayable.prototype.getTemporalDisplayables = function () {
      return this._temporaryDisplayables
    }
    IncrementalDisplayable.prototype.eachPendingDisplayable = function (cb) {
      for (var i = this._cursor; i < this._displayables.length; i++) {
        cb && cb(this._displayables[i])
      }
      for (var i = 0; i < this._temporaryDisplayables.length; i++) {
        cb && cb(this._temporaryDisplayables[i])
      }
    }
    IncrementalDisplayable.prototype.update = function () {
      this.updateTransform()
      for (var i = this._cursor; i < this._displayables.length; i++) {
        var displayable = this._displayables[i]
        displayable.parent = this
        displayable.update()
        displayable.parent = null
      }
      for (var i = 0; i < this._temporaryDisplayables.length; i++) {
        var displayable = this._temporaryDisplayables[i]
        displayable.parent = this
        displayable.update()
        displayable.parent = null
      }
    }
    IncrementalDisplayable.prototype.getBoundingRect = function () {
      if (!this._rect) {
        const rect = new BoundingRect(Infinity, Infinity, -Infinity, -Infinity)
        for (let i = 0; i < this._displayables.length; i++) {
          const displayable = this._displayables[i]
          const childRect = displayable.getBoundingRect().clone()
          if (displayable.needLocalTransform()) {
            childRect.applyTransform(displayable.getLocalTransform(m))
          }
          rect.union(childRect)
        }
        this._rect = rect
      }
      return this._rect
    }
    IncrementalDisplayable.prototype.contain = function (x, y) {
      const localPos = this.transformCoordToLocal(x, y)
      const rect = this.getBoundingRect()
      if (rect.contain(localPos[0], localPos[1])) {
        for (let i = 0; i < this._displayables.length; i++) {
          const displayable = this._displayables[i]
          if (displayable.contain(x, y)) {
            return true
          }
        }
      }
      return false
    }
    return IncrementalDisplayable
  }(Displayable))

  const transitionStore = makeInner()
  /**
     * Return null if animation is disabled.
     */

  function getAnimationConfig (animationType, animatableModel, dataIndex, // Extra opts can override the option in animatable model.
    extraOpts, // TODO It's only for pictorial bar now.
    extraDelayParams) {
    let animationPayload // Check if there is global animation configuration from dataZoom/resize can override the config in option.
    // If animation is enabled. Will use this animation config in payload.
    // If animation is disabled. Just ignore it.

    if (animatableModel && animatableModel.ecModel) {
      const updatePayload = animatableModel.ecModel.getUpdatePayload()
      animationPayload = updatePayload && updatePayload.animation
    }

    const animationEnabled = animatableModel && animatableModel.isAnimationEnabled()
    const isUpdate = animationType === 'update'

    if (animationEnabled) {
      let duration = void 0
      let easing = void 0
      let delay = void 0

      if (extraOpts) {
        duration = retrieve2(extraOpts.duration, 200)
        easing = retrieve2(extraOpts.easing, 'cubicOut')
        delay = 0
      } else {
        duration = animatableModel.getShallow(isUpdate ? 'animationDurationUpdate' : 'animationDuration')
        easing = animatableModel.getShallow(isUpdate ? 'animationEasingUpdate' : 'animationEasing')
        delay = animatableModel.getShallow(isUpdate ? 'animationDelayUpdate' : 'animationDelay')
      } // animation from payload has highest priority.

      if (animationPayload) {
        animationPayload.duration != null && (duration = animationPayload.duration)
        animationPayload.easing != null && (easing = animationPayload.easing)
        animationPayload.delay != null && (delay = animationPayload.delay)
      }

      if (isFunction(delay)) {
        delay = delay(dataIndex, extraDelayParams)
      }

      if (isFunction(duration)) {
        duration = duration(dataIndex)
      }

      const config = {
        duration: duration || 0,
        delay: delay,
        easing: easing
      }
      return config
    } else {
      return null
    }
  }

  function animateOrSetProps (animationType, el, props, animatableModel, dataIndex, cb, during) {
    let isFrom = false
    let removeOpt

    if (isFunction(dataIndex)) {
      during = cb
      cb = dataIndex
      dataIndex = null
    } else if (isObject(dataIndex)) {
      cb = dataIndex.cb
      during = dataIndex.during
      isFrom = dataIndex.isFrom
      removeOpt = dataIndex.removeOpt
      dataIndex = dataIndex.dataIndex
    }

    const isRemove = animationType === 'leave'

    if (!isRemove) {
      // Must stop the remove animation.
      el.stopAnimation('leave')
    }

    const animationConfig = getAnimationConfig(animationType, animatableModel, dataIndex, isRemove ? removeOpt || {} : null, animatableModel && animatableModel.getAnimationDelayParams ? animatableModel.getAnimationDelayParams(el, dataIndex) : null)

    if (animationConfig && animationConfig.duration > 0) {
      const duration = animationConfig.duration
      const animationDelay = animationConfig.delay
      const animationEasing = animationConfig.easing
      const animateConfig = {
        duration: duration,
        delay: animationDelay || 0,
        easing: animationEasing,
        done: cb,
        force: !!cb || !!during,
        // Set to final state in update/init animation.
        // So the post processing based on the path shape can be done correctly.
        setToFinal: !isRemove,
        scope: animationType,
        during: during
      }
      isFrom ? el.animateFrom(props, animateConfig) : el.animateTo(props, animateConfig)
    } else {
      el.stopAnimation() // If `isFrom`, the props is the "from" props.

      !isFrom && el.attr(props) // Call during at least once.

      during && during(1)
      cb && cb()
    }
  }
  /**
     * Update graphic element properties with or without animation according to the
     * configuration in series.
     *
     * Caution: this method will stop previous animation.
     * So do not use this method to one element twice before
     * animation starts, unless you know what you are doing.
     * @example
     *     graphic.updateProps(el, {
     *         position: [100, 100]
     *     }, seriesModel, dataIndex, function () { console.log('Animation done!'); });
     *     // Or
     *     graphic.updateProps(el, {
     *         position: [100, 100]
     *     }, seriesModel, function () { console.log('Animation done!'); });
     */

  function updateProps (el, props, // TODO: TYPE AnimatableModel
    animatableModel, dataIndex, cb, during) {
    animateOrSetProps('update', el, props, animatableModel, dataIndex, cb, during)
  }
  /**
     * Init graphic element properties with or without animation according to the
     * configuration in series.
     *
     * Caution: this method will stop previous animation.
     * So do not use this method to one element twice before
     * animation starts, unless you know what you are doing.
     */

  function initProps (el, props, animatableModel, dataIndex, cb, during) {
    animateOrSetProps('enter', el, props, animatableModel, dataIndex, cb, during)
  }
  /**
     * If element is removed.
     * It can determine if element is having remove animation.
     */

  function isElementRemoved (el) {
    if (!el.__zr) {
      return true
    }

    for (let i = 0; i < el.animators.length; i++) {
      const animator = el.animators[i]

      if (animator.scope === 'leave') {
        return true
      }
    }

    return false
  }
  /**
     * Remove graphic element
     */

  function removeElement (el, props, animatableModel, dataIndex, cb, during) {
    // Don't do remove animation twice.
    if (isElementRemoved(el)) {
      return
    }

    animateOrSetProps('leave', el, props, animatableModel, dataIndex, cb, during)
  }

  function fadeOutDisplayable (el, animatableModel, dataIndex, done) {
    el.removeTextContent()
    el.removeTextGuideLine()
    removeElement(el, {
      style: {
        opacity: 0
      }
    }, animatableModel, dataIndex, done)
  }

  function removeElementWithFadeOut (el, animatableModel, dataIndex) {
    function doRemove () {
      el.parent && el.parent.remove(el)
    } // Hide label and labelLine first
    // TODO Also use fade out animation?

    if (!el.isGroup) {
      fadeOutDisplayable(el, animatableModel, dataIndex, doRemove)
    } else {
      el.traverse(function (disp) {
        if (!disp.isGroup) {
          // Can invoke doRemove multiple times.
          fadeOutDisplayable(disp, animatableModel, dataIndex, doRemove)
        }
      })
    }
  }
  /**
     * Save old style for style transition in universalTransition module.
     * It's used when element will be reused in each render.
     * For chart like map, heatmap, which will always create new element.
     * We don't need to save this because universalTransition can get old style from the old element
     */

  function saveOldStyle (el) {
    transitionStore(el).oldStyle = el.style
  }
  function getOldStyle (el) {
    return transitionStore(el).oldStyle
  }

  const mathMax$4 = Math.max
  const mathMin$4 = Math.min
  const _customShapeMap = {}
  /**
     * Extend shape with parameters
     */

  function extendShape (opts) {
    return Path.extend(opts)
  }
  const extendPathFromString = extendFromString
  /**
     * Extend path
     */

  function extendPath (pathData, opts) {
    return extendPathFromString(pathData, opts)
  }
  /**
     * Register a user defined shape.
     * The shape class can be fetched by `getShapeClass`
     * This method will overwrite the registered shapes, including
     * the registered built-in shapes, if using the same `name`.
     * The shape can be used in `custom series` and
     * `graphic component` by declaring `{type: name}`.
     *
     * @param name
     * @param ShapeClass Can be generated by `extendShape`.
     */

  function registerShape (name, ShapeClass) {
    _customShapeMap[name] = ShapeClass
  }
  /**
     * Find shape class registered by `registerShape`. Usually used in
     * fetching user defined shape.
     *
     * [Caution]:
     * (1) This method **MUST NOT be used inside echarts !!!**, unless it is prepared
     * to use user registered shapes.
     * Because the built-in shape (see `getBuiltInShape`) will be registered by
     * `registerShape` by default. That enables users to get both built-in
     * shapes as well as the shapes belonging to themsleves. But users can overwrite
     * the built-in shapes by using names like 'circle', 'rect' via calling
     * `registerShape`. So the echarts inner featrues should not fetch shapes from here
     * in case that it is overwritten by users, except that some features, like
     * `custom series`, `graphic component`, do it deliberately.
     *
     * (2) In the features like `custom series`, `graphic component`, the user input
     * `{tpye: 'xxx'}` does not only specify shapes but also specify other graphic
     * elements like `'group'`, `'text'`, `'image'` or event `'path'`. Those names
     * are reserved names, that is, if some user register a shape named `'image'`,
     * the shape will not be used. If we intending to add some more reserved names
     * in feature, that might bring break changes (disable some existing user shape
     * names). But that case probably rearly happen. So we dont make more mechanism
     * to resolve this issue here.
     *
     * @param name
     * @return The shape class. If not found, return nothing.
     */

  function getShapeClass (name) {
    if (_customShapeMap.hasOwnProperty(name)) {
      return _customShapeMap[name]
    }
  }
  /**
     * Create a path element from path data string
     * @param pathData
     * @param opts
     * @param rect
     * @param layout 'center' or 'cover' default to be cover
     */

  function makePath (pathData, opts, rect, layout) {
    const path = createFromString(pathData, opts)

    if (rect) {
      if (layout === 'center') {
        rect = centerGraphic(rect, path.getBoundingRect())
      }

      resizePath(path, rect)
    }

    return path
  }
  /**
     * Create a image element from image url
     * @param imageUrl image url
     * @param opts options
     * @param rect constrain rect
     * @param layout 'center' or 'cover'. Default to be 'cover'
     */

  function makeImage (imageUrl, rect, layout) {
    var zrImg = new ZRImage({
      style: {
        image: imageUrl,
        x: rect.x,
        y: rect.y,
        width: rect.width,
        height: rect.height
      },
      onload: function (img) {
        if (layout === 'center') {
          const boundingRect = {
            width: img.width,
            height: img.height
          }
          zrImg.setStyle(centerGraphic(rect, boundingRect))
        }
      }
    })
    return zrImg
  }
  /**
     * Get position of centered element in bounding box.
     *
     * @param  rect         element local bounding box
     * @param  boundingRect constraint bounding box
     * @return element position containing x, y, width, and height
     */

  function centerGraphic (rect, boundingRect) {
    // Set rect to center, keep width / height ratio.
    const aspect = boundingRect.width / boundingRect.height
    let width = rect.height * aspect
    let height

    if (width <= rect.width) {
      height = rect.height
    } else {
      width = rect.width
      height = width / aspect
    }

    const cx = rect.x + rect.width / 2
    const cy = rect.y + rect.height / 2
    return {
      x: cx - width / 2,
      y: cy - height / 2,
      width: width,
      height: height
    }
  }

  const mergePath$1 = mergePath
  /**
     * Resize a path to fit the rect
     * @param path
     * @param rect
     */

  function resizePath (path, rect) {
    if (!path.applyTransform) {
      return
    }

    const pathRect = path.getBoundingRect()
    const m = pathRect.calculateTransform(rect)
    path.applyTransform(m)
  }
  /**
     * Sub pixel optimize line for canvas
     */

  function subPixelOptimizeLine$1 (param) {
    subPixelOptimizeLine(param.shape, param.shape, param.style)
    return param
  }
  /**
     * Sub pixel optimize rect for canvas
     */

  function subPixelOptimizeRect$1 (param) {
    subPixelOptimizeRect(param.shape, param.shape, param.style)
    return param
  }
  /**
     * Sub pixel optimize for canvas
     *
     * @param position Coordinate, such as x, y
     * @param lineWidth Should be nonnegative integer.
     * @param positiveOrNegative Default false (negative).
     * @return Optimized position.
     */

  const subPixelOptimize$1 = subPixelOptimize
  /**
     * Get transform matrix of target (param target),
     * in coordinate of its ancestor (param ancestor)
     *
     * @param target
     * @param [ancestor]
     */

  function getTransform (target, ancestor) {
    const mat = identity([])

    while (target && target !== ancestor) {
      mul$1(mat, target.getLocalTransform(), mat)
      target = target.parent
    }

    return mat
  }
  /**
     * Apply transform to an vertex.
     * @param target [x, y]
     * @param transform Can be:
     *      + Transform matrix: like [1, 0, 0, 1, 0, 0]
     *      + {position, rotation, scale}, the same as `zrender/Transformable`.
     * @param invert Whether use invert matrix.
     * @return [x, y]
     */

  function applyTransform$1 (target, transform, invert$1) {
    if (transform && !isArrayLike(transform)) {
      transform = Transformable.getLocalTransform(transform)
    }

    if (invert$1) {
      transform = invert([], transform)
    }

    return applyTransform([], target, transform)
  }
  /**
     * @param direction 'left' 'right' 'top' 'bottom'
     * @param transform Transform matrix: like [1, 0, 0, 1, 0, 0]
     * @param invert Whether use invert matrix.
     * @return Transformed direction. 'left' 'right' 'top' 'bottom'
     */

  function transformDirection (direction, transform, invert) {
    // Pick a base, ensure that transform result will not be (0, 0).
    const hBase = transform[4] === 0 || transform[5] === 0 || transform[0] === 0 ? 1 : Math.abs(2 * transform[4] / transform[0])
    const vBase = transform[4] === 0 || transform[5] === 0 || transform[2] === 0 ? 1 : Math.abs(2 * transform[4] / transform[2])
    let vertex = [direction === 'left' ? -hBase : direction === 'right' ? hBase : 0, direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0]
    vertex = applyTransform$1(vertex, transform, invert)
    return Math.abs(vertex[0]) > Math.abs(vertex[1]) ? vertex[0] > 0 ? 'right' : 'left' : vertex[1] > 0 ? 'bottom' : 'top'
  }

  function isNotGroup (el) {
    return !el.isGroup
  }

  function isPath (el) {
    return el.shape != null
  }
  /**
     * Apply group transition animation from g1 to g2.
     * If no animatableModel, no animation.
     */

  function groupTransition (g1, g2, animatableModel) {
    if (!g1 || !g2) {
      return
    }

    function getElMap (g) {
      const elMap = {}
      g.traverse(function (el) {
        if (isNotGroup(el) && el.anid) {
          elMap[el.anid] = el
        }
      })
      return elMap
    }

    function getAnimatableProps (el) {
      const obj = {
        x: el.x,
        y: el.y,
        rotation: el.rotation
      }

      if (isPath(el)) {
        obj.shape = extend({}, el.shape)
      }

      return obj
    }

    const elMap1 = getElMap(g1)
    g2.traverse(function (el) {
      if (isNotGroup(el) && el.anid) {
        const oldEl = elMap1[el.anid]

        if (oldEl) {
          const newProp = getAnimatableProps(el)
          el.attr(getAnimatableProps(oldEl))
          updateProps(el, newProp, animatableModel, getECData(el).dataIndex)
        }
      }
    })
  }
  function clipPointsByRect (points, rect) {
    // FIXME: this way migth be incorrect when grpahic clipped by a corner.
    // and when element have border.
    return map(points, function (point) {
      let x = point[0]
      x = mathMax$4(x, rect.x)
      x = mathMin$4(x, rect.x + rect.width)
      let y = point[1]
      y = mathMax$4(y, rect.y)
      y = mathMin$4(y, rect.y + rect.height)
      return [x, y]
    })
  }
  /**
     * Return a new clipped rect. If rect size are negative, return undefined.
     */

  function clipRectByRect (targetRect, rect) {
    const x = mathMax$4(targetRect.x, rect.x)
    const x2 = mathMin$4(targetRect.x + targetRect.width, rect.x + rect.width)
    const y = mathMax$4(targetRect.y, rect.y)
    const y2 = mathMin$4(targetRect.y + targetRect.height, rect.y + rect.height) // If the total rect is cliped, nothing, including the border,
    // should be painted. So return undefined.

    if (x2 >= x && y2 >= y) {
      return {
        x: x,
        y: y,
        width: x2 - x,
        height: y2 - y
      }
    }
  }
  function createIcon (iconStr, // Support 'image://' or 'path://' or direct svg path.
    opt, rect) {
    const innerOpts = extend({
      rectHover: true
    }, opt)
    const style = innerOpts.style = {
      strokeNoScale: true
    }
    rect = rect || {
      x: -1,
      y: -1,
      width: 2,
      height: 2
    }

    if (iconStr) {
      return iconStr.indexOf('image://') === 0 ? (style.image = iconStr.slice(8), defaults(style, rect), new ZRImage(innerOpts)) : makePath(iconStr.replace('path://', ''), innerOpts, rect, 'center')
    }
  }
  /**
     * Return `true` if the given line (line `a`) and the given polygon
     * are intersect.
     * Note that we do not count colinear as intersect here because no
     * requirement for that. We could do that if required in future.
     */

  function linePolygonIntersect (a1x, a1y, a2x, a2y, points) {
    for (let i = 0, p2 = points[points.length - 1]; i < points.length; i++) {
      const p = points[i]

      if (lineLineIntersect(a1x, a1y, a2x, a2y, p[0], p[1], p2[0], p2[1])) {
        return true
      }

      p2 = p
    }
  }
  /**
     * Return `true` if the given two lines (line `a` and line `b`)
     * are intersect.
     * Note that we do not count colinear as intersect here because no
     * requirement for that. We could do that if required in future.
     */

  function lineLineIntersect (a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y) {
    // let `vec_m` to be `vec_a2 - vec_a1` and `vec_n` to be `vec_b2 - vec_b1`.
    const mx = a2x - a1x
    const my = a2y - a1y
    const nx = b2x - b1x
    const ny = b2y - b1y // `vec_m` and `vec_n` are parallel iff
    //     exising `k` such that `vec_m = k · vec_n`, equivalent to `vec_m X vec_n = 0`.

    const nmCrossProduct = crossProduct2d(nx, ny, mx, my)

    if (nearZero(nmCrossProduct)) {
      return false
    } // `vec_m` and `vec_n` are intersect iff
    //     existing `p` and `q` in [0, 1] such that `vec_a1 + p * vec_m = vec_b1 + q * vec_n`,
    //     such that `q = ((vec_a1 - vec_b1) X vec_m) / (vec_n X vec_m)`
    //           and `p = ((vec_a1 - vec_b1) X vec_n) / (vec_n X vec_m)`.

    const b1a1x = a1x - b1x
    const b1a1y = a1y - b1y
    const q = crossProduct2d(b1a1x, b1a1y, mx, my) / nmCrossProduct

    if (q < 0 || q > 1) {
      return false
    }

    const p = crossProduct2d(b1a1x, b1a1y, nx, ny) / nmCrossProduct

    if (p < 0 || p > 1) {
      return false
    }

    return true
  }
  /**
     * Cross product of 2-dimension vector.
     */

  function crossProduct2d (x1, y1, x2, y2) {
    return x1 * y2 - x2 * y1
  }

  function nearZero (val) {
    return val <= 1e-6 && val >= -1e-6
  }

  function setTooltipConfig (opt) {
    const itemTooltipOption = opt.itemTooltipOption
    const componentModel = opt.componentModel
    const itemName = opt.itemName
    const itemTooltipOptionObj = isString(itemTooltipOption)
      ? {
          formatter: itemTooltipOption
        }
      : itemTooltipOption
    const mainType = componentModel.mainType
    const componentIndex = componentModel.componentIndex
    const formatterParams = {
      componentType: mainType,
      name: itemName,
      $vars: ['name']
    }
    formatterParams[mainType + 'Index'] = componentIndex
    const formatterParamsExtra = opt.formatterParamsExtra

    if (formatterParamsExtra) {
      each(keys(formatterParamsExtra), function (key) {
        if (!hasOwn(formatterParams, key)) {
          formatterParams[key] = formatterParamsExtra[key]
          formatterParams.$vars.push(key)
        }
      })
    }

    const ecData = getECData(opt.el)
    ecData.componentMainType = mainType
    ecData.componentIndex = componentIndex
    ecData.tooltipConfig = {
      name: itemName,
      option: defaults({
        content: itemName,
        formatterParams: formatterParams
      }, itemTooltipOptionObj)
    }
  }

  function traverseElement (el, cb) {
    let stopped // TODO
    // Polyfill for fixing zrender group traverse don't visit it's root issue.

    if (el.isGroup) {
      stopped = cb(el)
    }

    if (!stopped) {
      el.traverse(cb)
    }
  }

  function traverseElements (els, cb) {
    if (els) {
      if (isArray(els)) {
        for (let i = 0; i < els.length; i++) {
          traverseElement(els[i], cb)
        }
      } else {
        traverseElement(els, cb)
      }
    }
  } // Register built-in shapes. These shapes might be overwirtten
  // by users, although we do not recommend that.

  registerShape('circle', Circle)
  registerShape('ellipse', Ellipse)
  registerShape('sector', Sector)
  registerShape('ring', Ring)
  registerShape('polygon', Polygon)
  registerShape('polyline', Polyline)
  registerShape('rect', Rect)
  registerShape('line', Line)
  registerShape('bezierCurve', BezierCurve)
  registerShape('arc', Arc)

  const graphic = /* #__PURE__ */Object.freeze({
    __proto__: null,
    updateProps: updateProps,
    initProps: initProps,
    removeElement: removeElement,
    removeElementWithFadeOut: removeElementWithFadeOut,
    isElementRemoved: isElementRemoved,
    extendShape: extendShape,
    extendPath: extendPath,
    registerShape: registerShape,
    getShapeClass: getShapeClass,
    makePath: makePath,
    makeImage: makeImage,
    mergePath: mergePath$1,
    resizePath: resizePath,
    subPixelOptimizeLine: subPixelOptimizeLine$1,
    subPixelOptimizeRect: subPixelOptimizeRect$1,
    subPixelOptimize: subPixelOptimize$1,
    getTransform: getTransform,
    applyTransform: applyTransform$1,
    transformDirection: transformDirection,
    groupTransition: groupTransition,
    clipPointsByRect: clipPointsByRect,
    clipRectByRect: clipRectByRect,
    createIcon: createIcon,
    linePolygonIntersect: linePolygonIntersect,
    lineLineIntersect: lineLineIntersect,
    setTooltipConfig: setTooltipConfig,
    traverseElements: traverseElements,
    Group: Group,
    Image: ZRImage,
    Text: ZRText,
    Circle: Circle,
    Ellipse: Ellipse,
    Sector: Sector,
    Ring: Ring,
    Polygon: Polygon,
    Polyline: Polyline,
    Rect: Rect,
    Line: Line,
    BezierCurve: BezierCurve,
    Arc: Arc,
    IncrementalDisplayable: IncrementalDisplayable,
    CompoundPath: CompoundPath,
    LinearGradient: LinearGradient,
    RadialGradient: RadialGradient,
    BoundingRect: BoundingRect,
    OrientedBoundingRect: OrientedBoundingRect,
    Point: Point,
    Path: Path
  })

  const EMPTY_OBJ = {}
  function setLabelText (label, labelTexts) {
    for (let i = 0; i < SPECIAL_STATES.length; i++) {
      const stateName = SPECIAL_STATES[i]
      const text = labelTexts[stateName]
      const state = label.ensureState(stateName)
      state.style = state.style || {}
      state.style.text = text
    }

    const oldStates = label.currentStates.slice()
    label.clearStates(true)
    label.setStyle({
      text: labelTexts.normal
    })
    label.useStates(oldStates, true)
  }

  function getLabelText (opt, stateModels, interpolatedValue) {
    const labelFetcher = opt.labelFetcher
    const labelDataIndex = opt.labelDataIndex
    const labelDimIndex = opt.labelDimIndex
    const normalModel = stateModels.normal
    let baseText

    if (labelFetcher) {
      baseText = labelFetcher.getFormattedLabel(labelDataIndex, 'normal', null, labelDimIndex, normalModel && normalModel.get('formatter'), interpolatedValue != null
        ? {
            interpolatedValue: interpolatedValue
          }
        : null)
    }

    if (baseText == null) {
      baseText = isFunction(opt.defaultText) ? opt.defaultText(labelDataIndex, opt, interpolatedValue) : opt.defaultText
    }

    const statesText = {
      normal: baseText
    }

    for (let i = 0; i < SPECIAL_STATES.length; i++) {
      const stateName = SPECIAL_STATES[i]
      const stateModel = stateModels[stateName]
      statesText[stateName] = retrieve2(labelFetcher ? labelFetcher.getFormattedLabel(labelDataIndex, stateName, null, labelDimIndex, stateModel && stateModel.get('formatter')) : null, baseText)
    }

    return statesText
  }

  function setLabelStyle (targetEl, labelStatesModels, opt, stateSpecified // TODO specified position?
  ) {
    opt = opt || EMPTY_OBJ
    const isSetOnText = targetEl instanceof ZRText
    let needsCreateText = false

    for (var i = 0; i < DISPLAY_STATES.length; i++) {
      var stateModel = labelStatesModels[DISPLAY_STATES[i]]

      if (stateModel && stateModel.getShallow('show')) {
        needsCreateText = true
        break
      }
    }

    let textContent = isSetOnText ? targetEl : targetEl.getTextContent()

    if (needsCreateText) {
      if (!isSetOnText) {
        // Reuse the previous
        if (!textContent) {
          textContent = new ZRText()
          targetEl.setTextContent(textContent)
        } // Use same state proxy

        if (targetEl.stateProxy) {
          textContent.stateProxy = targetEl.stateProxy
        }
      }

      const labelStatesTexts = getLabelText(opt, labelStatesModels)
      const normalModel = labelStatesModels.normal
      const showNormal = !!normalModel.getShallow('show')
      const normalStyle = createTextStyle(normalModel, stateSpecified && stateSpecified.normal, opt, false, !isSetOnText)
      normalStyle.text = labelStatesTexts.normal

      if (!isSetOnText) {
        // Always create new
        targetEl.setTextConfig(createTextConfig(normalModel, opt, false))
      }

      for (var i = 0; i < SPECIAL_STATES.length; i++) {
        const stateName = SPECIAL_STATES[i]
        var stateModel = labelStatesModels[stateName]

        if (stateModel) {
          const stateObj = textContent.ensureState(stateName)
          const stateShow = !!retrieve2(stateModel.getShallow('show'), showNormal)

          if (stateShow !== showNormal) {
            stateObj.ignore = !stateShow
          }

          stateObj.style = createTextStyle(stateModel, stateSpecified && stateSpecified[stateName], opt, true, !isSetOnText)
          stateObj.style.text = labelStatesTexts[stateName]

          if (!isSetOnText) {
            const targetElEmphasisState = targetEl.ensureState(stateName)
            targetElEmphasisState.textConfig = createTextConfig(stateModel, opt, true)
          }
        }
      } // PENDING: if there is many requirements that emphasis position
      // need to be different from normal position, we might consider
      // auto slient is those cases.

      textContent.silent = !!normalModel.getShallow('silent') // Keep x and y

      if (textContent.style.x != null) {
        normalStyle.x = textContent.style.x
      }

      if (textContent.style.y != null) {
        normalStyle.y = textContent.style.y
      }

      textContent.ignore = !showNormal // Always create new style.

      textContent.useStyle(normalStyle)
      textContent.dirty()

      if (opt.enableTextSetter) {
        labelInner(textContent).setLabelText = function (interpolatedValue) {
          const labelStatesTexts = getLabelText(opt, labelStatesModels, interpolatedValue)
          setLabelText(textContent, labelStatesTexts)
        }
      }
    } else if (textContent) {
      // Not display rich text.
      textContent.ignore = true
    }

    targetEl.dirty()
  }
  function getLabelStatesModels (itemModel, labelName) {
    labelName = labelName || 'label'
    const statesModels = {
      normal: itemModel.getModel(labelName)
    }

    for (let i = 0; i < SPECIAL_STATES.length; i++) {
      const stateName = SPECIAL_STATES[i]
      statesModels[stateName] = itemModel.getModel([stateName, labelName])
    }

    return statesModels
  }
  /**
     * Set basic textStyle properties.
     */

  function createTextStyle (textStyleModel, specifiedTextStyle, // Fixed style in the code. Can't be set by model.
    opt, isNotNormal, isAttached // If text is attached on an element. If so, auto color will handling in zrender.
  ) {
    const textStyle = {}
    setTextStyleCommon(textStyle, textStyleModel, opt, isNotNormal, isAttached)
    specifiedTextStyle && extend(textStyle, specifiedTextStyle) // textStyle.host && textStyle.host.dirty && textStyle.host.dirty(false);

    return textStyle
  }
  function createTextConfig (textStyleModel, opt, isNotNormal) {
    opt = opt || {}
    const textConfig = {}
    let labelPosition
    let labelRotate = textStyleModel.getShallow('rotate')
    const labelDistance = retrieve2(textStyleModel.getShallow('distance'), isNotNormal ? null : 5)
    const labelOffset = textStyleModel.getShallow('offset')
    labelPosition = textStyleModel.getShallow('position') || (isNotNormal ? null : 'inside') // 'outside' is not a valid zr textPostion value, but used
    // in bar series, and magric type should be considered.

    labelPosition === 'outside' && (labelPosition = opt.defaultOutsidePosition || 'top')

    if (labelPosition != null) {
      textConfig.position = labelPosition
    }

    if (labelOffset != null) {
      textConfig.offset = labelOffset
    }

    if (labelRotate != null) {
      labelRotate *= Math.PI / 180
      textConfig.rotation = labelRotate
    }

    if (labelDistance != null) {
      textConfig.distance = labelDistance
    } // fill and auto is determined by the color of path fill if it's not specified by developers.

    textConfig.outsideFill = textStyleModel.get('color') === 'inherit' ? opt.inheritColor || null : 'auto'
    return textConfig
  }
  /**
     * The uniform entry of set text style, that is, retrieve style definitions
     * from `model` and set to `textStyle` object.
     *
     * Never in merge mode, but in overwrite mode, that is, all of the text style
     * properties will be set. (Consider the states of normal and emphasis and
     * default value can be adopted, merge would make the logic too complicated
     * to manage.)
     */

  function setTextStyleCommon (textStyle, textStyleModel, opt, isNotNormal, isAttached) {
    // Consider there will be abnormal when merge hover style to normal style if given default value.
    opt = opt || EMPTY_OBJ
    const ecModel = textStyleModel.ecModel
    const globalTextStyle = ecModel && ecModel.option.textStyle // Consider case:
    // {
    //     data: [{
    //         value: 12,
    //         label: {
    //             rich: {
    //                 // no 'a' here but using parent 'a'.
    //             }
    //         }
    //     }],
    //     rich: {
    //         a: { ... }
    //     }
    // }

    const richItemNames = getRichItemNames(textStyleModel)
    let richResult

    if (richItemNames) {
      richResult = {}

      for (const name_1 in richItemNames) {
        if (richItemNames.hasOwnProperty(name_1)) {
          // Cascade is supported in rich.
          const richTextStyle = textStyleModel.getModel(['rich', name_1]) // In rich, never `disableBox`.
          // FIXME: consider `label: {formatter: '{a|xx}', color: 'blue', rich: {a: {}}}`,
          // the default color `'blue'` will not be adopted if no color declared in `rich`.
          // That might confuses users. So probably we should put `textStyleModel` as the
          // root ancestor of the `richTextStyle`. But that would be a break change.

          setTokenTextStyle(richResult[name_1] = {}, richTextStyle, globalTextStyle, opt, isNotNormal, isAttached, false, true)
        }
      }
    }

    if (richResult) {
      textStyle.rich = richResult
    }

    const overflow = textStyleModel.get('overflow')

    if (overflow) {
      textStyle.overflow = overflow
    }

    const margin = textStyleModel.get('minMargin')

    if (margin != null) {
      textStyle.margin = margin
    }

    setTokenTextStyle(textStyle, textStyleModel, globalTextStyle, opt, isNotNormal, isAttached, true, false)
  } // Consider case:
  // {
  //     data: [{
  //         value: 12,
  //         label: {
  //             rich: {
  //                 // no 'a' here but using parent 'a'.
  //             }
  //         }
  //     }],
  //     rich: {
  //         a: { ... }
  //     }
  // }
  // TODO TextStyleModel

  function getRichItemNames (textStyleModel) {
    // Use object to remove duplicated names.
    let richItemNameMap

    while (textStyleModel && textStyleModel !== textStyleModel.ecModel) {
      const rich = (textStyleModel.option || EMPTY_OBJ).rich

      if (rich) {
        richItemNameMap = richItemNameMap || {}
        const richKeys = keys(rich)

        for (let i = 0; i < richKeys.length; i++) {
          const richKey = richKeys[i]
          richItemNameMap[richKey] = 1
        }
      }

      textStyleModel = textStyleModel.parentModel
    }

    return richItemNameMap
  }

  const TEXT_PROPS_WITH_GLOBAL = ['fontStyle', 'fontWeight', 'fontSize', 'fontFamily', 'textShadowColor', 'textShadowBlur', 'textShadowOffsetX', 'textShadowOffsetY']
  const TEXT_PROPS_SELF = ['align', 'lineHeight', 'width', 'height', 'tag', 'verticalAlign']
  const TEXT_PROPS_BOX = ['padding', 'borderWidth', 'borderRadius', 'borderDashOffset', 'backgroundColor', 'borderColor', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY']

  function setTokenTextStyle (textStyle, textStyleModel, globalTextStyle, opt, isNotNormal, isAttached, isBlock, inRich) {
    // In merge mode, default value should not be given.
    globalTextStyle = !isNotNormal && globalTextStyle || EMPTY_OBJ
    const inheritColor = opt && opt.inheritColor
    let fillColor = textStyleModel.getShallow('color')
    let strokeColor = textStyleModel.getShallow('textBorderColor')
    let opacity = retrieve2(textStyleModel.getShallow('opacity'), globalTextStyle.opacity)

    if (fillColor === 'inherit' || fillColor === 'auto') {
      if ('development' !== 'production') {
        if (fillColor === 'auto') {
          deprecateReplaceLog('color: \'auto\'', 'color: \'inherit\'')
        }
      }

      if (inheritColor) {
        fillColor = inheritColor
      } else {
        fillColor = null
      }
    }

    if (strokeColor === 'inherit' || strokeColor === 'auto') {
      if ('development' !== 'production') {
        if (strokeColor === 'auto') {
          deprecateReplaceLog('color: \'auto\'', 'color: \'inherit\'')
        }
      }

      if (inheritColor) {
        strokeColor = inheritColor
      } else {
        strokeColor = null
      }
    }

    if (!isAttached) {
      // Only use default global textStyle.color if text is individual.
      // Otherwise it will use the strategy of attached text color because text may be on a path.
      fillColor = fillColor || globalTextStyle.color
      strokeColor = strokeColor || globalTextStyle.textBorderColor
    }

    if (fillColor != null) {
      textStyle.fill = fillColor
    }

    if (strokeColor != null) {
      textStyle.stroke = strokeColor
    }

    const textBorderWidth = retrieve2(textStyleModel.getShallow('textBorderWidth'), globalTextStyle.textBorderWidth)

    if (textBorderWidth != null) {
      textStyle.lineWidth = textBorderWidth
    }

    const textBorderType = retrieve2(textStyleModel.getShallow('textBorderType'), globalTextStyle.textBorderType)

    if (textBorderType != null) {
      textStyle.lineDash = textBorderType
    }

    const textBorderDashOffset = retrieve2(textStyleModel.getShallow('textBorderDashOffset'), globalTextStyle.textBorderDashOffset)

    if (textBorderDashOffset != null) {
      textStyle.lineDashOffset = textBorderDashOffset
    }

    if (!isNotNormal && opacity == null && !inRich) {
      opacity = opt && opt.defaultOpacity
    }

    if (opacity != null) {
      textStyle.opacity = opacity
    } // TODO

    if (!isNotNormal && !isAttached) {
      // Set default finally.
      if (textStyle.fill == null && opt.inheritColor) {
        textStyle.fill = opt.inheritColor
      }
    } // Do not use `getFont` here, because merge should be supported, where
    // part of these properties may be changed in emphasis style, and the
    // others should remain their original value got from normal style.

    for (var i = 0; i < TEXT_PROPS_WITH_GLOBAL.length; i++) {
      var key = TEXT_PROPS_WITH_GLOBAL[i]
      var val = retrieve2(textStyleModel.getShallow(key), globalTextStyle[key])

      if (val != null) {
        textStyle[key] = val
      }
    }

    for (var i = 0; i < TEXT_PROPS_SELF.length; i++) {
      var key = TEXT_PROPS_SELF[i]
      var val = textStyleModel.getShallow(key)

      if (val != null) {
        textStyle[key] = val
      }
    }

    if (textStyle.verticalAlign == null) {
      const baseline = textStyleModel.getShallow('baseline')

      if (baseline != null) {
        textStyle.verticalAlign = baseline
      }
    }

    if (!isBlock || !opt.disableBox) {
      for (var i = 0; i < TEXT_PROPS_BOX.length; i++) {
        var key = TEXT_PROPS_BOX[i]
        var val = textStyleModel.getShallow(key)

        if (val != null) {
          textStyle[key] = val
        }
      }

      const borderType = textStyleModel.getShallow('borderType')

      if (borderType != null) {
        textStyle.borderDash = borderType
      }

      if ((textStyle.backgroundColor === 'auto' || textStyle.backgroundColor === 'inherit') && inheritColor) {
        if ('development' !== 'production') {
          if (textStyle.backgroundColor === 'auto') {
            deprecateReplaceLog('backgroundColor: \'auto\'', 'backgroundColor: \'inherit\'')
          }
        }

        textStyle.backgroundColor = inheritColor
      }

      if ((textStyle.borderColor === 'auto' || textStyle.borderColor === 'inherit') && inheritColor) {
        if ('development' !== 'production') {
          if (textStyle.borderColor === 'auto') {
            deprecateReplaceLog('borderColor: \'auto\'', 'borderColor: \'inherit\'')
          }
        }

        textStyle.borderColor = inheritColor
      }
    }
  }

  function getFont (opt, ecModel) {
    const gTextStyleModel = ecModel && ecModel.getModel('textStyle')
    return trim([// FIXME in node-canvas fontWeight is before fontStyle
      opt.fontStyle || gTextStyleModel && gTextStyleModel.getShallow('fontStyle') || '', opt.fontWeight || gTextStyleModel && gTextStyleModel.getShallow('fontWeight') || '', (opt.fontSize || gTextStyleModel && gTextStyleModel.getShallow('fontSize') || 12) + 'px', opt.fontFamily || gTextStyleModel && gTextStyleModel.getShallow('fontFamily') || 'sans-serif'].join(' '))
  }
  var labelInner = makeInner()
  function setLabelValueAnimation (label, labelStatesModels, value, getDefaultText) {
    if (!label) {
      return
    }

    const obj = labelInner(label)
    obj.prevValue = obj.value
    obj.value = value
    const normalLabelModel = labelStatesModels.normal
    obj.valueAnimation = normalLabelModel.get('valueAnimation')

    if (obj.valueAnimation) {
      obj.precision = normalLabelModel.get('precision')
      obj.defaultInterpolatedText = getDefaultText
      obj.statesModels = labelStatesModels
    }
  }
  function animateLabelValue (textEl, dataIndex, data, animatableModel, labelFetcher) {
    const labelInnerStore = labelInner(textEl)

    if (!labelInnerStore.valueAnimation || labelInnerStore.prevValue === labelInnerStore.value) {
      // Value not changed, no new label animation
      return
    }

    const defaultInterpolatedText = labelInnerStore.defaultInterpolatedText // Consider the case that being animating, do not use the `obj.value`,
    // Otherwise it will jump to the `obj.value` when this new animation started.

    const currValue = retrieve2(labelInnerStore.interpolatedValue, labelInnerStore.prevValue)
    const targetValue = labelInnerStore.value

    function during (percent) {
      const interpolated = interpolateRawValues(data, labelInnerStore.precision, currValue, targetValue, percent)
      labelInnerStore.interpolatedValue = percent === 1 ? null : interpolated
      const labelText = getLabelText({
        labelDataIndex: dataIndex,
        labelFetcher: labelFetcher,
        defaultText: defaultInterpolatedText ? defaultInterpolatedText(interpolated) : interpolated + ''
      }, labelInnerStore.statesModels, interpolated)
      setLabelText(textEl, labelText)
    }

    textEl.percent = 0;
    (labelInnerStore.prevValue == null ? initProps : updateProps)(textEl, {
      // percent is used to prevent animation from being aborted #15916
      percent: 1
    }, animatableModel, dataIndex, null, during)
  }

  const PATH_COLOR = ['textStyle', 'color']
  const textStyleParams = ['fontStyle', 'fontWeight', 'fontSize', 'fontFamily', 'padding', 'lineHeight', 'rich', 'width', 'height', 'overflow'] // TODO Performance improvement?

  const tmpText = new ZRText()

  const TextStyleMixin =
    /** @class */
    (function () {
      function TextStyleMixin () {}
      /**
       * Get color property or get color from option.textStyle.color
       */
      // TODO Callback

      TextStyleMixin.prototype.getTextColor = function (isEmphasis) {
        const ecModel = this.ecModel
        return this.getShallow('color') || (!isEmphasis && ecModel ? ecModel.get(PATH_COLOR) : null)
      }
      /**
       * Create font string from fontStyle, fontWeight, fontSize, fontFamily
       * @return {string}
       */

      TextStyleMixin.prototype.getFont = function () {
        return getFont({
          fontStyle: this.getShallow('fontStyle'),
          fontWeight: this.getShallow('fontWeight'),
          fontSize: this.getShallow('fontSize'),
          fontFamily: this.getShallow('fontFamily')
        }, this.ecModel)
      }

      TextStyleMixin.prototype.getTextRect = function (text) {
        const style = {
          text: text,
          verticalAlign: this.getShallow('verticalAlign') || this.getShallow('baseline')
        }

        for (let i = 0; i < textStyleParams.length; i++) {
          style[textStyleParams[i]] = this.getShallow(textStyleParams[i])
        }

        tmpText.useStyle(style)
        tmpText.update()
        return tmpText.getBoundingRect()
      }

      return TextStyleMixin
    }())

  const LINE_STYLE_KEY_MAP = [['lineWidth', 'width'], ['stroke', 'color'], ['opacity'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor'], ['lineDash', 'type'], ['lineDashOffset', 'dashOffset'], ['lineCap', 'cap'], ['lineJoin', 'join'], ['miterLimit'] // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
    // So do not transfer decal directly.
  ]
  const getLineStyle = makeStyleMapper(LINE_STYLE_KEY_MAP)

  const LineStyleMixin =
    /** @class */
    (function () {
      function LineStyleMixin () {}

      LineStyleMixin.prototype.getLineStyle = function (excludes) {
        return getLineStyle(this, excludes)
      }

      return LineStyleMixin
    }())

  const ITEM_STYLE_KEY_MAP = [['fill', 'color'], ['stroke', 'borderColor'], ['lineWidth', 'borderWidth'], ['opacity'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor'], ['lineDash', 'borderType'], ['lineDashOffset', 'borderDashOffset'], ['lineCap', 'borderCap'], ['lineJoin', 'borderJoin'], ['miterLimit', 'borderMiterLimit'] // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
    // So do not transfer decal directly.
  ]
  const getItemStyle = makeStyleMapper(ITEM_STYLE_KEY_MAP)

  const ItemStyleMixin =
    /** @class */
    (function () {
      function ItemStyleMixin () {}

      ItemStyleMixin.prototype.getItemStyle = function (excludes, includes) {
        return getItemStyle(this, excludes, includes)
      }

      return ItemStyleMixin
    }())

  const Model =
    /** @class */
    (function () {
      function Model (option, parentModel, ecModel) {
        this.parentModel = parentModel
        this.ecModel = ecModel
        this.option = option // Simple optimization
        // if (this.init) {
        //     if (arguments.length <= 4) {
        //         this.init(option, parentModel, ecModel, extraOpt);
        //     }
        //     else {
        //         this.init.apply(this, arguments);
        //     }
        // }
      }

      Model.prototype.init = function (option, parentModel, ecModel) {
        const rest = []

        for (let _i = 3; _i < arguments.length; _i++) {
          rest[_i - 3] = arguments[_i]
        }
      }
      /**
       * Merge the input option to me.
       */

      Model.prototype.mergeOption = function (option, ecModel) {
        merge(this.option, option, true)
      } // `path` can be 'a.b.c', so the return value type have to be `ModelOption`
      // TODO: TYPE strict key check?
      // get(path: string | string[], ignoreParent?: boolean): ModelOption;

      Model.prototype.get = function (path, ignoreParent) {
        if (path == null) {
          return this.option
        }

        return this._doGet(this.parsePath(path), !ignoreParent && this.parentModel)
      }

      Model.prototype.getShallow = function (key, ignoreParent) {
        const option = this.option
        let val = option == null ? option : option[key]

        if (val == null && !ignoreParent) {
          const parentModel = this.parentModel

          if (parentModel) {
            // FIXME:TS do not know how to make it works
            val = parentModel.getShallow(key)
          }
        }

        return val
      } // `path` can be 'a.b.c', so the return value type have to be `Model<ModelOption>`
      // getModel(path: string | string[], parentModel?: Model): Model;
      // TODO 'a.b.c' is deprecated

      Model.prototype.getModel = function (path, parentModel) {
        const hasPath = path != null
        const pathFinal = hasPath ? this.parsePath(path) : null
        const obj = hasPath ? this._doGet(pathFinal) : this.option
        parentModel = parentModel || this.parentModel && this.parentModel.getModel(this.resolveParentPath(pathFinal))
        return new Model(obj, parentModel, this.ecModel)
      }
      /**
       * If model has option
       */

      Model.prototype.isEmpty = function () {
        return this.option == null
      }

      Model.prototype.restoreData = function () {} // Pending

      Model.prototype.clone = function () {
        const Ctor = this.constructor
        return new Ctor(clone(this.option))
      } // setReadOnly(properties): void {
      // clazzUtil.setReadOnly(this, properties);
      // }
      // If path is null/undefined, return null/undefined.

      Model.prototype.parsePath = function (path) {
        if (typeof path === 'string') {
          return path.split('.')
        }

        return path
      } // Resolve path for parent. Perhaps useful when parent use a different property.
      // Default to be a identity resolver.
      // Can be modified to a different resolver.

      Model.prototype.resolveParentPath = function (path) {
        return path
      } // FIXME:TS check whether put this method here

      Model.prototype.isAnimationEnabled = function () {
        if (!env.node && this.option) {
          if (this.option.animation != null) {
            return !!this.option.animation
          } else if (this.parentModel) {
            return this.parentModel.isAnimationEnabled()
          }
        }
      }

      Model.prototype._doGet = function (pathArr, parentModel) {
        let obj = this.option

        if (!pathArr) {
          return obj
        }

        for (let i = 0; i < pathArr.length; i++) {
          // Ignore empty
          if (!pathArr[i]) {
            continue
          } // obj could be number/string/... (like 0)

          obj = obj && typeof obj === 'object' ? obj[pathArr[i]] : null

          if (obj == null) {
            break
          }
        }

        if (obj == null && parentModel) {
          obj = parentModel._doGet(this.resolveParentPath(pathArr), parentModel.parentModel)
        }

        return obj
      }

      return Model
    }())

  enableClassExtend(Model)
  enableClassCheck(Model)
  mixin(Model, LineStyleMixin)
  mixin(Model, ItemStyleMixin)
  mixin(Model, AreaStyleMixin)
  mixin(Model, TextStyleMixin)

  let base = Math.round(Math.random() * 10)
  /**
     * @public
     * @param {string} type
     * @return {string}
     */

  function getUID (type) {
    // Considering the case of crossing js context,
    // use Math.random to make id as unique as possible.
    return [type || '', base++].join('_')
  }
  /**
     * Implements `SubTypeDefaulterManager` for `target`.
     */

  function enableSubTypeDefaulter (target) {
    const subTypeDefaulters = {}

    target.registerSubTypeDefaulter = function (componentType, defaulter) {
      const componentTypeInfo = parseClassType(componentType)
      subTypeDefaulters[componentTypeInfo.main] = defaulter
    }

    target.determineSubType = function (componentType, option) {
      let type = option.type

      if (!type) {
        const componentTypeMain = parseClassType(componentType).main

        if (target.hasSubTypes(componentType) && subTypeDefaulters[componentTypeMain]) {
          type = subTypeDefaulters[componentTypeMain](option)
        }
      }

      return type
    }
  }
  /**
     * Implements `TopologicalTravelable<any>` for `entity`.
     *
     * Topological travel on Activity Network (Activity On Vertices).
     * Dependencies is defined in Model.prototype.dependencies, like ['xAxis', 'yAxis'].
     * If 'xAxis' or 'yAxis' is absent in componentTypeList, just ignore it in topology.
     * If there is circular dependencey, Error will be thrown.
     */

  function enableTopologicalTravel (entity, dependencyGetter) {
    /**
       * @param targetNameList Target Component type list.
       *                       Can be ['aa', 'bb', 'aa.xx']
       * @param fullNameList By which we can build dependency graph.
       * @param callback Params: componentType, dependencies.
       * @param context Scope of callback.
       */
    entity.topologicalTravel = function (targetNameList, fullNameList, callback, context) {
      if (!targetNameList.length) {
        return
      }

      const result = makeDepndencyGraph(fullNameList)
      const graph = result.graph
      const noEntryList = result.noEntryList
      const targetNameSet = {}
      each(targetNameList, function (name) {
        targetNameSet[name] = true
      })

      while (noEntryList.length) {
        const currComponentType = noEntryList.pop()
        const currVertex = graph[currComponentType]
        const isInTargetNameSet = !!targetNameSet[currComponentType]

        if (isInTargetNameSet) {
          callback.call(context, currComponentType, currVertex.originalDeps.slice())
          delete targetNameSet[currComponentType]
        }

        each(currVertex.successor, isInTargetNameSet ? removeEdgeAndAdd : removeEdge)
      }

      each(targetNameSet, function () {
        let errMsg = ''

        if ('development' !== 'production') {
          errMsg = makePrintable('Circular dependency may exists: ', targetNameSet, targetNameList, fullNameList)
        }

        throw new Error(errMsg)
      })

      function removeEdge (succComponentType) {
        graph[succComponentType].entryCount--

        if (graph[succComponentType].entryCount === 0) {
          noEntryList.push(succComponentType)
        }
      } // Consider this case: legend depends on series, and we call
      // chart.setOption({series: [...]}), where only series is in option.
      // If we do not have 'removeEdgeAndAdd', legendModel.mergeOption will
      // not be called, but only sereis.mergeOption is called. Thus legend
      // have no chance to update its local record about series (like which
      // name of series is available in legend).

      function removeEdgeAndAdd (succComponentType) {
        targetNameSet[succComponentType] = true
        removeEdge(succComponentType)
      }
    }

    function makeDepndencyGraph (fullNameList) {
      const graph = {}
      const noEntryList = []
      each(fullNameList, function (name) {
        const thisItem = createDependencyGraphItem(graph, name)
        const originalDeps = thisItem.originalDeps = dependencyGetter(name)
        const availableDeps = getAvailableDependencies(originalDeps, fullNameList)
        thisItem.entryCount = availableDeps.length

        if (thisItem.entryCount === 0) {
          noEntryList.push(name)
        }

        each(availableDeps, function (dependentName) {
          if (indexOf(thisItem.predecessor, dependentName) < 0) {
            thisItem.predecessor.push(dependentName)
          }

          const thatItem = createDependencyGraphItem(graph, dependentName)

          if (indexOf(thatItem.successor, dependentName) < 0) {
            thatItem.successor.push(name)
          }
        })
      })
      return {
        graph: graph,
        noEntryList: noEntryList
      }
    }

    function createDependencyGraphItem (graph, name) {
      if (!graph[name]) {
        graph[name] = {
          predecessor: [],
          successor: []
        }
      }

      return graph[name]
    }

    function getAvailableDependencies (originalDeps, fullNameList) {
      const availableDeps = []
      each(originalDeps, function (dep) {
        indexOf(fullNameList, dep) >= 0 && availableDeps.push(dep)
      })
      return availableDeps
    }
  }
  function inheritDefaultOption (superOption, subOption) {
    // See also `model/Component.ts#getDefaultOption`
    return merge(merge({}, superOption, true), subOption, true)
  }

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

  /**
     * AUTO-GENERATED FILE. DO NOT MODIFY.
     */

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

  /**
     * Language: English.
     */
  const langEN = {
    time: {
      month: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],
      monthAbbr: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
      dayOfWeek: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],
      dayOfWeekAbbr: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']
    },
    legend: {
      selector: {
        all: 'All',
        inverse: 'Inv'
      }
    },
    toolbox: {
      brush: {
        title: {
          rect: 'Box Select',
          polygon: 'Lasso Select',
          lineX: 'Horizontally Select',
          lineY: 'Vertically Select',
          keep: 'Keep Selections',
          clear: 'Clear Selections'
        }
      },
      dataView: {
        title: 'Data View',
        lang: ['Data View', 'Close', 'Refresh']
      },
      dataZoom: {
        title: {
          zoom: 'Zoom',
          back: 'Zoom Reset'
        }
      },
      magicType: {
        title: {
          line: 'Switch to Line Chart',
          bar: 'Switch to Bar Chart',
          stack: 'Stack',
          tiled: 'Tile'
        }
      },
      restore: {
        title: 'Restore'
      },
      saveAsImage: {
        title: 'Save as Image',
        lang: ['Right Click to Save Image']
      }
    },
    series: {
      typeNames: {
        pie: 'Pie chart',
        bar: 'Bar chart',
        line: 'Line chart',
        scatter: 'Scatter plot',
        effectScatter: 'Ripple scatter plot',
        radar: 'Radar chart',
        tree: 'Tree',
        treemap: 'Treemap',
        boxplot: 'Boxplot',
        candlestick: 'Candlestick',
        k: 'K line chart',
        heatmap: 'Heat map',
        map: 'Map',
        parallel: 'Parallel coordinate map',
        lines: 'Line graph',
        graph: 'Relationship graph',
        sankey: 'Sankey diagram',
        funnel: 'Funnel chart',
        gauge: 'Gauge',
        pictorialBar: 'Pictorial bar',
        themeRiver: 'Theme River Map',
        sunburst: 'Sunburst'
      }
    },
    aria: {
      general: {
        withTitle: 'This is a chart about "{title}"',
        withoutTitle: 'This is a chart'
      },
      series: {
        single: {
          prefix: '',
          withName: ' with type {seriesType} named {seriesName}.',
          withoutName: ' with type {seriesType}.'
        },
        multiple: {
          prefix: '. It consists of {seriesCount} series count.',
          withName: ' The {seriesId} series is a {seriesType} representing {seriesName}.',
          withoutName: ' The {seriesId} series is a {seriesType}.',
          separator: {
            middle: '',
            end: ''
          }
        }
      },
      data: {
        allData: 'The data is as follows: ',
        partialData: 'The first {displayCnt} items are: ',
        withName: 'the data for {name} is {value}',
        withoutName: '{value}',
        separator: {
          middle: ', ',
          end: '. '
        }
      }
    }
  }

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

  /**
     * AUTO-GENERATED FILE. DO NOT MODIFY.
     */

  /*
     * Licensed to the Apache Software Foundation (ASF) under one
     * or more contributor license agreements.  See the NOTICE file
     * distributed with this work for additional information
     * regarding copyright ownership.  The ASF licenses this file
     * to you under the Apache License, Version 2.0 (the
     * "License"); you may not use this file except in compliance
     * with the License.  You may obtain a copy of the License at
     *
     *   http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing,
     * software distributed under the License is distributed on an
     * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
     * KIND, either express or implied.  See the License for the
     * specific language governing permissions and limitations
     * under the License.
     */
  const langZH = {
    time: {
      month: ['一月', '二月', '三月', '四月', '五月', '六月', '七月', '八月', '九月', '十月', '十一月', '十二月'],
      monthAbbr: ['1月', '2月', '3月', '4月', '5月', '6月', '7月', '8月', '9月', '10月', '11月', '12月'],
      dayOfWeek: ['星期日', '星期一', '星期二', '星期三', '星期四', '星期五', '星期六'],
      dayOfWeekAbbr: ['日', '一', '二', '三', '四', '五', '六']
    },
    legend: {
      selector: {
        all: '全选',
        inverse: '反选'
      }
    },
    toolbox: {
      brush: {
        title: {
          rect: '矩形选择',
          polygon: '圈选',
          lineX: '横向选择',
          lineY: '纵向选择',
          keep: '保持选择',
          clear: '清除选择'
        }
      },
      dataView: {
        title: '数据视图',
        lang: ['数据视图', '关闭', '刷新']
      },
      dataZoom: {
        title: {
          zoom: '区域缩放',
          back: '区域缩放还原'
        }
      },
      magicType: {
        title: {
          line: '切换为折线图',
          bar: '切换为柱状图',
          stack: '切换为堆叠',
          tiled: '切换为平铺'
        }
      },
      restore: {
        title: '还原'
      },
      saveAsImage: {
        title: '保存为图片',
        lang: ['右键另存为图片']
      }
    },
    series: {
      typeNames: {
        pie: '饼图',
        bar: '柱状图',
        line: '折线图',
        scatter: '散点图',
        effectScatter: '涟漪散点图',
        radar: '雷达图',
        tree: '树图',
        treemap: '矩形树图',
        boxplot: '箱型图',
        candlestick: 'K线图',
        k: 'K线图',
        heatmap: '热力图',
        map: '地图',
        parallel: '平行坐标图',
        lines: '线图',
        graph: '关系图',
        sankey: '桑基图',
        funnel: '漏斗图',
        gauge: '仪表盘图',
        pictorialBar: '象形柱图',
        themeRiver: '主题河流图',
        sunburst: '旭日图'
      }
    },
    aria: {
      general: {
        withTitle: '这是一个关于“{title}”的图表。',
        withoutTitle: '这是一个图表，'
      },
      series: {
        single: {
          prefix: '',
          withName: '图表类型是{seriesType}，表示{seriesName}。',
          withoutName: '图表类型是{seriesType}。'
        },
        multiple: {
          prefix: '它由{seriesCount}个图表系列组成。',
          withName: '第{seriesId}个系列是一个表示{seriesName}的{seriesType}，',
          withoutName: '第{seriesId}个系列是一个{seriesType}，',
          separator: {
            middle: '；',
            end: '。'
          }
        }
      },
      data: {
        allData: '其数据是——',
        partialData: '其中，前{displayCnt}项是——',
        withName: '{name}的数据是{value}',
        withoutName: '{value}',
        separator: {
          middle: '，',
          end: ''
        }
      }
    }
  }

  const LOCALE_ZH = 'ZH'
  const LOCALE_EN = 'EN'
  const DEFAULT_LOCALE = LOCALE_EN
  const localeStorage = {}
  const localeModels = {}
  const SYSTEM_LANG = !env.domSupported ? DEFAULT_LOCALE : (function () {
    const langStr = (
      /* eslint-disable-next-line */
      document.documentElement.lang || navigator.language || navigator.browserLanguage).toUpperCase();
    return langStr.indexOf(LOCALE_ZH) > -1 ? LOCALE_ZH : DEFAULT_LOCALE
  }())
  function registerLocale (locale, localeObj) {
    locale = locale.toUpperCase()
    localeModels[locale] = new Model(localeObj)
    localeStorage[locale] = localeObj
  } // export function getLocale(locale: string) {
  //     return localeStorage[locale];
  // }

  function createLocaleObject (locale) {
    if (isString(locale)) {
      const localeObj = localeStorage[locale.toUpperCase()] || {}

      if (locale === LOCALE_ZH || locale === LOCALE_EN) {
        return clone(localeObj)
      } else {
        return merge(clone(localeObj), clone(localeStorage[DEFAULT_LOCALE]), false)
      }
    } else {
      return merge(clone(locale), clone(localeStorage[DEFAULT_LOCALE]), false)
    }
  }
  function getLocaleModel (lang) {
    return localeModels[lang]
  }
  function getDefaultLocaleModel () {
    return localeModels[DEFAULT_LOCALE]
  } // Default locale

  registerLocale(LOCALE_EN, langEN)
  registerLocale(LOCALE_ZH, langZH)

  const ONE_SECOND = 1000
  const ONE_MINUTE = ONE_SECOND * 60
  const ONE_HOUR = ONE_MINUTE * 60
  const ONE_DAY = ONE_HOUR * 24
  const ONE_YEAR = ONE_DAY * 365
  const defaultLeveledFormatter = {
    year: '{yyyy}',
    month: '{MMM}',
    day: '{d}',
    hour: '{HH}:{mm}',
    minute: '{HH}:{mm}',
    second: '{HH}:{mm}:{ss}',
    millisecond: '{HH}:{mm}:{ss} {SSS}',
    none: '{yyyy}-{MM}-{dd} {HH}:{mm}:{ss} {SSS}'
  }
  const fullDayFormatter = '{yyyy}-{MM}-{dd}'
  const fullLeveledFormatter = {
    year: '{yyyy}',
    month: '{yyyy}-{MM}',
    day: fullDayFormatter,
    hour: fullDayFormatter + ' ' + defaultLeveledFormatter.hour,
    minute: fullDayFormatter + ' ' + defaultLeveledFormatter.minute,
    second: fullDayFormatter + ' ' + defaultLeveledFormatter.second,
    millisecond: defaultLeveledFormatter.none
  }
  const primaryTimeUnits = ['year', 'month', 'day', 'hour', 'minute', 'second', 'millisecond']
  const timeUnits = ['year', 'half-year', 'quarter', 'month', 'week', 'half-week', 'day', 'half-day', 'quarter-day', 'hour', 'minute', 'second', 'millisecond']
  function pad (str, len) {
    str += ''
    return '0000'.substr(0, len - str.length) + str
  }
  function getPrimaryTimeUnit (timeUnit) {
    switch (timeUnit) {
      case 'half-year':
      case 'quarter':
        return 'month'

      case 'week':
      case 'half-week':
        return 'day'

      case 'half-day':
      case 'quarter-day':
        return 'hour'

      default:
        // year, minutes, second, milliseconds
        return timeUnit
    }
  }
  function isPrimaryTimeUnit (timeUnit) {
    return timeUnit === getPrimaryTimeUnit(timeUnit)
  }
  function getDefaultFormatPrecisionOfInterval (timeUnit) {
    switch (timeUnit) {
      case 'year':
      case 'month':
        return 'day'

      case 'millisecond':
        return 'millisecond'

      default:
        // Also for day, hour, minute, second
        return 'second'
    }
  }
  function format ( // Note: The result based on `isUTC` are totally different, which can not be just simply
    // substituted by the result without `isUTC`. So we make the param `isUTC` mandatory.
    time, template, isUTC, lang) {
    const date = parseDate(time)
    const y = date[fullYearGetterName(isUTC)]()
    const M = date[monthGetterName(isUTC)]() + 1
    const q = Math.floor((M - 1) / 3) + 1
    const d = date[dateGetterName(isUTC)]()
    const e = date['get' + (isUTC ? 'UTC' : '') + 'Day']()
    const H = date[hoursGetterName(isUTC)]()
    const h = (H - 1) % 12 + 1
    const m = date[minutesGetterName(isUTC)]()
    const s = date[secondsGetterName(isUTC)]()
    const S = date[millisecondsGetterName(isUTC)]()
    const localeModel = lang instanceof Model ? lang : getLocaleModel(lang || SYSTEM_LANG) || getDefaultLocaleModel()
    const timeModel = localeModel.getModel('time')
    const month = timeModel.get('month')
    const monthAbbr = timeModel.get('monthAbbr')
    const dayOfWeek = timeModel.get('dayOfWeek')
    const dayOfWeekAbbr = timeModel.get('dayOfWeekAbbr')
    return (template || '').replace(/{yyyy}/g, y + '').replace(/{yy}/g, y % 100 + '').replace(/{Q}/g, q + '').replace(/{MMMM}/g, month[M - 1]).replace(/{MMM}/g, monthAbbr[M - 1]).replace(/{MM}/g, pad(M, 2)).replace(/{M}/g, M + '').replace(/{dd}/g, pad(d, 2)).replace(/{d}/g, d + '').replace(/{eeee}/g, dayOfWeek[e]).replace(/{ee}/g, dayOfWeekAbbr[e]).replace(/{e}/g, e + '').replace(/{HH}/g, pad(H, 2)).replace(/{H}/g, H + '').replace(/{hh}/g, pad(h + '', 2)).replace(/{h}/g, h + '').replace(/{mm}/g, pad(m, 2)).replace(/{m}/g, m + '').replace(/{ss}/g, pad(s, 2)).replace(/{s}/g, s + '').replace(/{SSS}/g, pad(S, 3)).replace(/{S}/g, S + '')
  }
  function leveledFormat (tick, idx, formatter, lang, isUTC) {
    let template = null

    if (isString(formatter)) {
      // Single formatter for all units at all levels
      template = formatter
    } else if (isFunction(formatter)) {
      // Callback formatter
      template = formatter(tick.value, idx, {
        level: tick.level
      })
    } else {
      const defaults$1 = extend({}, defaultLeveledFormatter)

      if (tick.level > 0) {
        for (var i = 0; i < primaryTimeUnits.length; ++i) {
          defaults$1[primaryTimeUnits[i]] = '{primary|' + defaults$1[primaryTimeUnits[i]] + '}'
        }
      }

      const mergedFormatter = formatter ? formatter.inherit === false ? formatter // Use formatter with bigger units
        : defaults(formatter, defaults$1) : defaults$1
      const unit = getUnitFromValue(tick.value, isUTC)

      if (mergedFormatter[unit]) {
        template = mergedFormatter[unit]
      } else if (mergedFormatter.inherit) {
        // Unit formatter is not defined and should inherit from bigger units
        const targetId = timeUnits.indexOf(unit)

        for (var i = targetId - 1; i >= 0; --i) {
          if (mergedFormatter[unit]) {
            template = mergedFormatter[unit]
            break
          }
        }

        template = template || defaults$1.none
      }

      if (isArray(template)) {
        let levelId = tick.level == null ? 0 : tick.level >= 0 ? tick.level : template.length + tick.level
        levelId = Math.min(levelId, template.length - 1)
        template = template[levelId]
      }
    }

    return format(new Date(tick.value), template, isUTC, lang)
  }
  function getUnitFromValue (value, isUTC) {
    const date = parseDate(value)
    const M = date[monthGetterName(isUTC)]() + 1
    const d = date[dateGetterName(isUTC)]()
    const h = date[hoursGetterName(isUTC)]()
    const m = date[minutesGetterName(isUTC)]()
    const s = date[secondsGetterName(isUTC)]()
    const S = date[millisecondsGetterName(isUTC)]()
    const isSecond = S === 0
    const isMinute = isSecond && s === 0
    const isHour = isMinute && m === 0
    const isDay = isHour && h === 0
    const isMonth = isDay && d === 1
    const isYear = isMonth && M === 1

    if (isYear) {
      return 'year'
    } else if (isMonth) {
      return 'month'
    } else if (isDay) {
      return 'day'
    } else if (isHour) {
      return 'hour'
    } else if (isMinute) {
      return 'minute'
    } else if (isSecond) {
      return 'second'
    } else {
      return 'millisecond'
    }
  }
  function getUnitValue (value, unit, isUTC) {
    const date = isNumber(value) ? parseDate(value) : value
    unit = unit || getUnitFromValue(value, isUTC)

    switch (unit) {
      case 'year':
        return date[fullYearGetterName(isUTC)]()

      case 'half-year':
        return date[monthGetterName(isUTC)]() >= 6 ? 1 : 0

      case 'quarter':
        return Math.floor((date[monthGetterName(isUTC)]() + 1) / 4)

      case 'month':
        return date[monthGetterName(isUTC)]()

      case 'day':
        return date[dateGetterName(isUTC)]()

      case 'half-day':
        return date[hoursGetterName(isUTC)]() / 24

      case 'hour':
        return date[hoursGetterName(isUTC)]()

      case 'minute':
        return date[minutesGetterName(isUTC)]()

      case 'second':
        return date[secondsGetterName(isUTC)]()

      case 'millisecond':
        return date[millisecondsGetterName(isUTC)]()
    }
  }
  function fullYearGetterName (isUTC) {
    return isUTC ? 'getUTCFullYear' : 'getFullYear'
  }
  function monthGetterName (isUTC) {
    return isUTC ? 'getUTCMonth' : 'getMonth'
  }
  function dateGetterName (isUTC) {
    return isUTC ? 'getUTCDate' : 'getDate'
  }
  function hoursGetterName (isUTC) {
    return isUTC ? 'getUTCHours' : 'getHours'
  }
  function minutesGetterName (isUTC) {
    return isUTC ? 'getUTCMinutes' : 'getMinutes'
  }
  function secondsGetterName (isUTC) {
    return isUTC ? 'getUTCSeconds' : 'getSeconds'
  }
  function millisecondsGetterName (isUTC) {
    return isUTC ? 'getUTCMilliseconds' : 'getMilliseconds'
  }
  function fullYearSetterName (isUTC) {
    return isUTC ? 'setUTCFullYear' : 'setFullYear'
  }
  function monthSetterName (isUTC) {
    return isUTC ? 'setUTCMonth' : 'setMonth'
  }
  function dateSetterName (isUTC) {
    return isUTC ? 'setUTCDate' : 'setDate'
  }
  function hoursSetterName (isUTC) {
    return isUTC ? 'setUTCHours' : 'setHours'
  }
  function minutesSetterName (isUTC) {
    return isUTC ? 'setUTCMinutes' : 'setMinutes'
  }
  function secondsSetterName (isUTC) {
    return isUTC ? 'setUTCSeconds' : 'setSeconds'
  }
  function millisecondsSetterName (isUTC) {
    return isUTC ? 'setUTCMilliseconds' : 'setMilliseconds'
  }

  function getTextRect (text, font, align, verticalAlign, padding, rich, truncate, lineHeight) {
    const textEl = new ZRText({
      style: {
        text: text,
        font: font,
        align: align,
        verticalAlign: verticalAlign,
        padding: padding,
        rich: rich,
        overflow: truncate ? 'truncate' : null,
        lineHeight: lineHeight
      }
    })
    return textEl.getBoundingRect()
  }

  /**
     * Add a comma each three digit.
     */

  function addCommas (x) {
    if (!isNumeric(x)) {
      return isString(x) ? x : '-'
    }

    const parts = (x + '').split('.')
    return parts[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, '$1,') + (parts.length > 1 ? '.' + parts[1] : '')
  }
  function toCamelCase (str, upperCaseFirst) {
    str = (str || '').toLowerCase().replace(/-(.)/g, function (match, group1) {
      return group1.toUpperCase()
    })

    if (upperCaseFirst && str) {
      str = str.charAt(0).toUpperCase() + str.slice(1)
    }

    return str
  }
  const normalizeCssArray$1 = normalizeCssArray
  const replaceReg = /([&<>"'])/g
  const replaceMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    '\'': '&#39;'
  }
  function encodeHTML (source) {
    return source == null
      ? ''
      : (source + '').replace(replaceReg, function (str, c) {
          return replaceMap[c]
        })
  }
  /**
     * Make value user readable for tooltip and label.
     * "User readable":
     *     Try to not print programmer-specific text like NaN, Infinity, null, undefined.
     *     Avoid to display an empty string, which users can not recognize there is
     *     a value and it might look like a bug.
     */

  function makeValueReadable (value, valueType, useUTC) {
    const USER_READABLE_DEFUALT_TIME_PATTERN = '{yyyy}-{MM}-{dd} {HH}:{mm}:{ss}'

    function stringToUserReadable (str) {
      return str && trim(str) ? str : '-'
    }

    function isNumberUserReadable (num) {
      return !!(num != null && !isNaN(num) && isFinite(num))
    }

    const isTypeTime = valueType === 'time'
    const isValueDate = value instanceof Date

    if (isTypeTime || isValueDate) {
      const date = isTypeTime ? parseDate(value) : value

      if (!isNaN(+date)) {
        return format(date, USER_READABLE_DEFUALT_TIME_PATTERN, useUTC)
      } else if (isValueDate) {
        return '-'
      } // In other cases, continue to try to display the value in the following code.
    }

    if (valueType === 'ordinal') {
      return isStringSafe(value) ? stringToUserReadable(value) : isNumber(value) ? isNumberUserReadable(value) ? value + '' : '-' : '-'
    } // By default.

    const numericResult = numericToNumber(value)
    return isNumberUserReadable(numericResult) ? addCommas(numericResult) : isStringSafe(value) ? stringToUserReadable(value) : typeof value === 'boolean' ? value + '' : '-'
  }
  const TPL_VAR_ALIAS = ['a', 'b', 'c', 'd', 'e', 'f', 'g']

  const wrapVar = function (varName, seriesIdx) {
    return '{' + varName + (seriesIdx == null ? '' : seriesIdx) + '}'
  }
  /**
     * Template formatter
     * @param {Array.<Object>|Object} paramsList
     */

  function formatTpl (tpl, paramsList, encode) {
    if (!isArray(paramsList)) {
      paramsList = [paramsList]
    }

    const seriesLen = paramsList.length

    if (!seriesLen) {
      return ''
    }

    const $vars = paramsList[0].$vars || []

    for (let i = 0; i < $vars.length; i++) {
      const alias = TPL_VAR_ALIAS[i]
      tpl = tpl.replace(wrapVar(alias), wrapVar(alias, 0))
    }

    for (let seriesIdx = 0; seriesIdx < seriesLen; seriesIdx++) {
      for (let k = 0; k < $vars.length; k++) {
        const val = paramsList[seriesIdx][$vars[k]]
        tpl = tpl.replace(wrapVar(TPL_VAR_ALIAS[k], seriesIdx), encode ? encodeHTML(val) : val)
      }
    }

    return tpl
  }
  /**
     * simple Template formatter
     */

  function formatTplSimple (tpl, param, encode) {
    each(param, function (value, key) {
      tpl = tpl.replace('{' + key + '}', encode ? encodeHTML(value) : value)
    })
    return tpl
  }
  function getTooltipMarker (inOpt, extraCssText) {
    const opt = isString(inOpt)
      ? {
          color: inOpt,
          extraCssText: extraCssText
        }
      : inOpt || {}
    const color = opt.color
    const type = opt.type
    extraCssText = opt.extraCssText
    const renderMode = opt.renderMode || 'html'

    if (!color) {
      return ''
    }

    if (renderMode === 'html') {
      return type === 'subItem' ? '<span style="display:inline-block;vertical-align:middle;margin-right:8px;margin-left:3px;' + 'border-radius:4px;width:4px;height:4px;background-color:' + // Only support string
        encodeHTML(color) + ';' + (extraCssText || '') + '"></span>' : '<span style="display:inline-block;margin-right:4px;' + 'border-radius:10px;width:10px;height:10px;background-color:' + encodeHTML(color) + ';' + (extraCssText || '') + '"></span>'
    } else {
      // Should better not to auto generate style name by auto-increment number here.
      // Because this util is usually called in tooltip formatter, which is probably
      // called repeatly when mouse move and the auto-increment number increases fast.
      // Users can make their own style name by theirselves, make it unique and readable.
      const markerId = opt.markerId || 'markerX'
      return {
        renderMode: renderMode,
        content: '{' + markerId + '|}  ',
        style: type === 'subItem'
          ? {
              width: 4,
              height: 4,
              borderRadius: 2,
              backgroundColor: color
            }
          : {
              width: 10,
              height: 10,
              borderRadius: 5,
              backgroundColor: color
            }
      }
    }
  }
  /**
     * @deprecated Use `time/format` instead.
     * ISO Date format
     * @param {string} tpl
     * @param {number} value
     * @param {boolean} [isUTC=false] Default in local time.
     *           see `module:echarts/scale/Time`
     *           and `module:echarts/util/number#parseDate`.
     * @inner
     */

  function formatTime (tpl, value, isUTC) {
    if ('development' !== 'production') {
      deprecateReplaceLog('echarts.format.formatTime', 'echarts.time.format')
    }

    if (tpl === 'week' || tpl === 'month' || tpl === 'quarter' || tpl === 'half-year' || tpl === 'year') {
      tpl = 'MM-dd\nyyyy'
    }

    const date = parseDate(value)
    const getUTC = isUTC ? 'getUTC' : 'get'
    const y = date[getUTC + 'FullYear']()
    const M = date[getUTC + 'Month']() + 1
    const d = date[getUTC + 'Date']()
    const h = date[getUTC + 'Hours']()
    const m = date[getUTC + 'Minutes']()
    const s = date[getUTC + 'Seconds']()
    const S = date[getUTC + 'Milliseconds']()
    tpl = tpl.replace('MM', pad(M, 2)).replace('M', M).replace('yyyy', y).replace('yy', pad(y % 100 + '', 2)).replace('dd', pad(d, 2)).replace('d', d).replace('hh', pad(h, 2)).replace('h', h).replace('mm', pad(m, 2)).replace('m', m).replace('ss', pad(s, 2)).replace('s', s).replace('SSS', pad(S, 3))
    return tpl
  }
  /**
     * Capital first
     * @param {string} str
     * @return {string}
     */

  function capitalFirst (str) {
    return str ? str.charAt(0).toUpperCase() + str.substr(1) : str
  }
  /**
     * @return Never be null/undefined.
     */

  function convertToColorString (color, defaultColor) {
    defaultColor = defaultColor || 'transparent'
    return isString(color) ? color : isObject(color) ? color.colorStops && (color.colorStops[0] || {}).color || defaultColor : defaultColor
  }
  /**
     * open new tab
     * @param link url
     * @param target blank or self
     */

  function windowOpen (link, target) {
    /* global window */
    if (target === '_blank' || target === 'blank') {
      const blank = window.open()
      blank.opener = null
      blank.location.href = link
    } else {
      window.open(link, target)
    }
  }

  const each$1 = each
  /**
     * @public
     */

  const LOCATION_PARAMS = ['left', 'right', 'top', 'bottom', 'width', 'height']
  /**
     * @public
     */

  const HV_NAMES = [['width', 'left', 'right'], ['height', 'top', 'bottom']]

  function boxLayout (orient, group, gap, maxWidth, maxHeight) {
    let x = 0
    let y = 0

    if (maxWidth == null) {
      maxWidth = Infinity
    }

    if (maxHeight == null) {
      maxHeight = Infinity
    }

    let currentLineMaxSize = 0
    group.eachChild(function (child, idx) {
      const rect = child.getBoundingRect()
      const nextChild = group.childAt(idx + 1)
      const nextChildRect = nextChild && nextChild.getBoundingRect()
      let nextX
      let nextY

      if (orient === 'horizontal') {
        const moveX = rect.width + (nextChildRect ? -nextChildRect.x + rect.x : 0)
        nextX = x + moveX // Wrap when width exceeds maxWidth or meet a `newline` group
        // FIXME compare before adding gap?

        if (nextX > maxWidth || child.newline) {
          x = 0
          nextX = moveX
          y += currentLineMaxSize + gap
          currentLineMaxSize = rect.height
        } else {
          // FIXME: consider rect.y is not `0`?
          currentLineMaxSize = Math.max(currentLineMaxSize, rect.height)
        }
      } else {
        const moveY = rect.height + (nextChildRect ? -nextChildRect.y + rect.y : 0)
        nextY = y + moveY // Wrap when width exceeds maxHeight or meet a `newline` group

        if (nextY > maxHeight || child.newline) {
          x += currentLineMaxSize + gap
          y = 0
          nextY = moveY
          currentLineMaxSize = rect.width
        } else {
          currentLineMaxSize = Math.max(currentLineMaxSize, rect.width)
        }
      }

      if (child.newline) {
        return
      }

      child.x = x
      child.y = y
      child.markRedraw()
      orient === 'horizontal' ? x = nextX + gap : y = nextY + gap
    })
  }
  /**
     * VBox or HBox layouting
     * @param {string} orient
     * @param {module:zrender/graphic/Group} group
     * @param {number} gap
     * @param {number} [width=Infinity]
     * @param {number} [height=Infinity]
     */

  const box = boxLayout
  /**
     * VBox layouting
     * @param {module:zrender/graphic/Group} group
     * @param {number} gap
     * @param {number} [width=Infinity]
     * @param {number} [height=Infinity]
     */

  const vbox = curry(boxLayout, 'vertical')
  /**
     * HBox layouting
     * @param {module:zrender/graphic/Group} group
     * @param {number} gap
     * @param {number} [width=Infinity]
     * @param {number} [height=Infinity]
     */

  const hbox = curry(boxLayout, 'horizontal')
  /**
     * If x or x2 is not specified or 'center' 'left' 'right',
     * the width would be as long as possible.
     * If y or y2 is not specified or 'middle' 'top' 'bottom',
     * the height would be as long as possible.
     */

  function getAvailableSize (positionInfo, containerRect, margin) {
    const containerWidth = containerRect.width
    const containerHeight = containerRect.height
    let x = parsePercent$1(positionInfo.left, containerWidth)
    let y = parsePercent$1(positionInfo.top, containerHeight)
    let x2 = parsePercent$1(positionInfo.right, containerWidth)
    let y2 = parsePercent$1(positionInfo.bottom, containerHeight);
    (isNaN(x) || isNaN(parseFloat(positionInfo.left))) && (x = 0);
    (isNaN(x2) || isNaN(parseFloat(positionInfo.right))) && (x2 = containerWidth);
    (isNaN(y) || isNaN(parseFloat(positionInfo.top))) && (y = 0);
    (isNaN(y2) || isNaN(parseFloat(positionInfo.bottom))) && (y2 = containerHeight)
    margin = normalizeCssArray$1(margin || 0)
    return {
      width: Math.max(x2 - x - margin[1] - margin[3], 0),
      height: Math.max(y2 - y - margin[0] - margin[2], 0)
    }
  }
  /**
     * Parse position info.
     */

  function getLayoutRect (positionInfo, containerRect, margin) {
    margin = normalizeCssArray$1(margin || 0)
    const containerWidth = containerRect.width
    const containerHeight = containerRect.height
    let left = parsePercent$1(positionInfo.left, containerWidth)
    let top = parsePercent$1(positionInfo.top, containerHeight)
    const right = parsePercent$1(positionInfo.right, containerWidth)
    const bottom = parsePercent$1(positionInfo.bottom, containerHeight)
    let width = parsePercent$1(positionInfo.width, containerWidth)
    let height = parsePercent$1(positionInfo.height, containerHeight)
    const verticalMargin = margin[2] + margin[0]
    const horizontalMargin = margin[1] + margin[3]
    const aspect = positionInfo.aspect // If width is not specified, calculate width from left and right

    if (isNaN(width)) {
      width = containerWidth - right - horizontalMargin - left
    }

    if (isNaN(height)) {
      height = containerHeight - bottom - verticalMargin - top
    }

    if (aspect != null) {
      // If width and height are not given
      // 1. Graph should not exceeds the container
      // 2. Aspect must be keeped
      // 3. Graph should take the space as more as possible
      // FIXME
      // Margin is not considered, because there is no case that both
      // using margin and aspect so far.
      if (isNaN(width) && isNaN(height)) {
        if (aspect > containerWidth / containerHeight) {
          width = containerWidth * 0.8
        } else {
          height = containerHeight * 0.8
        }
      } // Calculate width or height with given aspect

      if (isNaN(width)) {
        width = aspect * height
      }

      if (isNaN(height)) {
        height = width / aspect
      }
    } // If left is not specified, calculate left from right and width

    if (isNaN(left)) {
      left = containerWidth - right - width - horizontalMargin
    }

    if (isNaN(top)) {
      top = containerHeight - bottom - height - verticalMargin
    } // Align left and top

    switch (positionInfo.left || positionInfo.right) {
      case 'center':
        left = containerWidth / 2 - width / 2 - margin[3]
        break

      case 'right':
        left = containerWidth - width - horizontalMargin
        break
    }

    switch (positionInfo.top || positionInfo.bottom) {
      case 'middle':
      case 'center':
        top = containerHeight / 2 - height / 2 - margin[0]
        break

      case 'bottom':
        top = containerHeight - height - verticalMargin
        break
    } // If something is wrong and left, top, width, height are calculated as NaN

    left = left || 0
    top = top || 0

    if (isNaN(width)) {
      // Width may be NaN if only one value is given except width
      width = containerWidth - horizontalMargin - left - (right || 0)
    }

    if (isNaN(height)) {
      // Height may be NaN if only one value is given except height
      height = containerHeight - verticalMargin - top - (bottom || 0)
    }

    const rect = new BoundingRect(left + margin[3], top + margin[0], width, height)
    rect.margin = margin
    return rect
  }
  /**
     * Position a zr element in viewport
     *  Group position is specified by either
     *  {left, top}, {right, bottom}
     *  If all properties exists, right and bottom will be igonred.
     *
     * Logic:
     *     1. Scale (against origin point in parent coord)
     *     2. Rotate (against origin point in parent coord)
     *     3. Traslate (with el.position by this method)
     * So this method only fixes the last step 'Traslate', which does not affect
     * scaling and rotating.
     *
     * If be called repeatly with the same input el, the same result will be gotten.
     *
     * Return true if the layout happend.
     *
     * @param el Should have `getBoundingRect` method.
     * @param positionInfo
     * @param positionInfo.left
     * @param positionInfo.top
     * @param positionInfo.right
     * @param positionInfo.bottom
     * @param positionInfo.width Only for opt.boundingModel: 'raw'
     * @param positionInfo.height Only for opt.boundingModel: 'raw'
     * @param containerRect
     * @param margin
     * @param opt
     * @param opt.hv Only horizontal or only vertical. Default to be [1, 1]
     * @param opt.boundingMode
     *        Specify how to calculate boundingRect when locating.
     *        'all': Position the boundingRect that is transformed and uioned
     *               both itself and its descendants.
     *               This mode simplies confine the elements in the bounding
     *               of their container (e.g., using 'right: 0').
     *        'raw': Position the boundingRect that is not transformed and only itself.
     *               This mode is useful when you want a element can overflow its
     *               container. (Consider a rotated circle needs to be located in a corner.)
     *               In this mode positionInfo.width/height can only be number.
     */

  function positionElement (el, positionInfo, containerRect, margin, opt, out) {
    const h = !opt || !opt.hv || opt.hv[0]
    const v = !opt || !opt.hv || opt.hv[1]
    const boundingMode = opt && opt.boundingMode || 'all'
    out = out || el
    out.x = el.x
    out.y = el.y

    if (!h && !v) {
      return false
    }

    let rect

    if (boundingMode === 'raw') {
      rect = el.type === 'group' ? new BoundingRect(0, 0, +positionInfo.width || 0, +positionInfo.height || 0) : el.getBoundingRect()
    } else {
      rect = el.getBoundingRect()

      if (el.needLocalTransform()) {
        const transform = el.getLocalTransform() // Notice: raw rect may be inner object of el,
        // which should not be modified.

        rect = rect.clone()
        rect.applyTransform(transform)
      }
    } // The real width and height can not be specified but calculated by the given el.

    const layoutRect = getLayoutRect(defaults({
      width: rect.width,
      height: rect.height
    }, positionInfo), containerRect, margin) // Because 'tranlate' is the last step in transform
    // (see zrender/core/Transformable#getLocalTransform),
    // we can just only modify el.position to get final result.

    const dx = h ? layoutRect.x - rect.x : 0
    const dy = v ? layoutRect.y - rect.y : 0

    if (boundingMode === 'raw') {
      out.x = dx
      out.y = dy
    } else {
      out.x += dx
      out.y += dy
    }

    if (out === el) {
      el.markRedraw()
    }

    return true
  }
  /**
     * @param option Contains some of the properties in HV_NAMES.
     * @param hvIdx 0: horizontal; 1: vertical.
     */

  function sizeCalculable (option, hvIdx) {
    return option[HV_NAMES[hvIdx][0]] != null || option[HV_NAMES[hvIdx][1]] != null && option[HV_NAMES[hvIdx][2]] != null
  }
  function fetchLayoutMode (ins) {
    const layoutMode = ins.layoutMode || ins.constructor.layoutMode
    return isObject(layoutMode)
      ? layoutMode
      : layoutMode
        ? {
            type: layoutMode
          }
        : null
  }
  /**
     * Consider Case:
     * When default option has {left: 0, width: 100}, and we set {right: 0}
     * through setOption or media query, using normal zrUtil.merge will cause
     * {right: 0} does not take effect.
     *
     * @example
     * ComponentModel.extend({
     *     init: function () {
     *         ...
     *         let inputPositionParams = layout.getLayoutParams(option);
     *         this.mergeOption(inputPositionParams);
     *     },
     *     mergeOption: function (newOption) {
     *         newOption && zrUtil.merge(thisOption, newOption, true);
     *         layout.mergeLayoutParam(thisOption, newOption);
     *     }
     * });
     *
     * @param targetOption
     * @param newOption
     * @param opt
     */

  function mergeLayoutParam (targetOption, newOption, opt) {
    let ignoreSize = opt && opt.ignoreSize
    !isArray(ignoreSize) && (ignoreSize = [ignoreSize, ignoreSize])
    const hResult = merge(HV_NAMES[0], 0)
    const vResult = merge(HV_NAMES[1], 1)
    copy(HV_NAMES[0], targetOption, hResult)
    copy(HV_NAMES[1], targetOption, vResult)

    function merge (names, hvIdx) {
      const newParams = {}
      let newValueCount = 0
      const merged = {}
      let mergedValueCount = 0
      const enoughParamNumber = 2
      each$1(names, function (name) {
        merged[name] = targetOption[name]
      })
      each$1(names, function (name) {
        // Consider case: newOption.width is null, which is
        // set by user for removing width setting.
        hasProp(newOption, name) && (newParams[name] = merged[name] = newOption[name])
        hasValue(newParams, name) && newValueCount++
        hasValue(merged, name) && mergedValueCount++
      })

      if (ignoreSize[hvIdx]) {
        // Only one of left/right is premitted to exist.
        if (hasValue(newOption, names[1])) {
          merged[names[2]] = null
        } else if (hasValue(newOption, names[2])) {
          merged[names[1]] = null
        }

        return merged
      } // Case: newOption: {width: ..., right: ...},
      // or targetOption: {right: ...} and newOption: {width: ...},
      // There is no conflict when merged only has params count
      // little than enoughParamNumber.

      if (mergedValueCount === enoughParamNumber || !newValueCount) {
        return merged
      } // Case: newOption: {width: ..., right: ...},
      // Than we can make sure user only want those two, and ignore
      // all origin params in targetOption.
      else if (newValueCount >= enoughParamNumber) {
        return newParams
      } else {
        // Chose another param from targetOption by priority.
        for (let i = 0; i < names.length; i++) {
          const name_1 = names[i]

          if (!hasProp(newParams, name_1) && hasProp(targetOption, name_1)) {
            newParams[name_1] = targetOption[name_1]
            break
          }
        }

        return newParams
      }
    }

    function hasProp (obj, name) {
      return obj.hasOwnProperty(name)
    }

    function hasValue (obj, name) {
      return obj[name] != null && obj[name] !== 'auto'
    }

    function copy (names, target, source) {
      each$1(names, function (name) {
        target[name] = source[name]
      })
    }
  }
  /**
     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.
     */

  function getLayoutParams (source) {
    return copyLayoutParams({}, source)
  }
  /**
     * Retrieve 'left', 'right', 'top', 'bottom', 'width', 'height' from object.
     * @param {Object} source
     * @return {Object} Result contains those props.
     */

  function copyLayoutParams (target, source) {
    source && target && each$1(LOCATION_PARAMS, function (name) {
      source.hasOwnProperty(name) && (target[name] = source[name])
    })
    return target
  }

  const inner = makeInner()

  const ComponentModel =
    /** @class */
    (function (_super) {
      __extends(ComponentModel, _super)

      function ComponentModel (option, parentModel, ecModel) {
        const _this = _super.call(this, option, parentModel, ecModel) || this

        _this.uid = getUID('ec_cpt_model')
        return _this
      }

      ComponentModel.prototype.init = function (option, parentModel, ecModel) {
        this.mergeDefaultAndTheme(option, ecModel)
      }

      ComponentModel.prototype.mergeDefaultAndTheme = function (option, ecModel) {
        const layoutMode = fetchLayoutMode(this)
        const inputPositionParams = layoutMode ? getLayoutParams(option) : {}
        const themeModel = ecModel.getTheme()
        merge(option, themeModel.get(this.mainType))
        merge(option, this.getDefaultOption())

        if (layoutMode) {
          mergeLayoutParam(option, inputPositionParams, layoutMode)
        }
      }

      ComponentModel.prototype.mergeOption = function (option, ecModel) {
        merge(this.option, option, true)
        const layoutMode = fetchLayoutMode(this)

        if (layoutMode) {
          mergeLayoutParam(this.option, option, layoutMode)
        }
      }
      /**
       * Called immediately after `init` or `mergeOption` of this instance called.
       */

      ComponentModel.prototype.optionUpdated = function (newCptOption, isInit) {}
      /**
       * [How to declare defaultOption]:
       *
       * (A) If using class declaration in typescript (since echarts 5):
       * ```ts
       * import {ComponentOption} from '../model/option.js';
       * export interface XxxOption extends ComponentOption {
       *     aaa: number
       * }
       * export class XxxModel extends Component {
       *     static type = 'xxx';
       *     static defaultOption: XxxOption = {
       *         aaa: 123
       *     }
       * }
       * Component.registerClass(XxxModel);
       * ```
       * ```ts
       * import {inheritDefaultOption} from '../util/component.js';
       * import {XxxModel, XxxOption} from './XxxModel.js';
       * export interface XxxSubOption extends XxxOption {
       *     bbb: number
       * }
       * class XxxSubModel extends XxxModel {
       *     static defaultOption: XxxSubOption = inheritDefaultOption(XxxModel.defaultOption, {
       *         bbb: 456
       *     })
       *     fn() {
       *         let opt = this.getDefaultOption();
       *         // opt is {aaa: 123, bbb: 456}
       *     }
       * }
       * ```
       *
       * (B) If using class extend (previous approach in echarts 3 & 4):
       * ```js
       * let XxxComponent = Component.extend({
       *     defaultOption: {
       *         xx: 123
       *     }
       * })
       * ```
       * ```js
       * let XxxSubComponent = XxxComponent.extend({
       *     defaultOption: {
       *         yy: 456
       *     },
       *     fn: function () {
       *         let opt = this.getDefaultOption();
       *         // opt is {xx: 123, yy: 456}
       *     }
       * })
       * ```
       */

      ComponentModel.prototype.getDefaultOption = function () {
        const ctor = this.constructor // If using class declaration, it is different to travel super class
        // in legacy env and auto merge defaultOption. So if using class
        // declaration, defaultOption should be merged manually.

        if (!isExtendedClass(ctor)) {
          // When using ts class, defaultOption must be declared as static.
          return ctor.defaultOption
        } // FIXME: remove this approach?

        const fields = inner(this)

        if (!fields.defaultOption) {
          const optList = []
          let clz = ctor

          while (clz) {
            const opt = clz.prototype.defaultOption
            opt && optList.push(opt)
            clz = clz.superClass
          }

          let defaultOption = {}

          for (let i = optList.length - 1; i >= 0; i--) {
            defaultOption = merge(defaultOption, optList[i], true)
          }

          fields.defaultOption = defaultOption
        }

        return fields.defaultOption
      }
      /**
       * Notice: always force to input param `useDefault` in case that forget to consider it.
       * The same behavior as `modelUtil.parseFinder`.
       *
       * @param useDefault In many cases like series refer axis and axis refer grid,
       *        If axis index / axis id not specified, use the first target as default.
       *        In other cases like dataZoom refer axis, if not specified, measn no refer.
       */

      ComponentModel.prototype.getReferringComponents = function (mainType, opt) {
        const indexKey = mainType + 'Index'
        const idKey = mainType + 'Id'
        return queryReferringComponents(this.ecModel, mainType, {
          index: this.get(indexKey, true),
          id: this.get(idKey, true)
        }, opt)
      }

      ComponentModel.prototype.getBoxLayoutParams = function () {
        // Consider itself having box layout configs.
        const boxLayoutModel = this
        return {
          left: boxLayoutModel.get('left'),
          top: boxLayoutModel.get('top'),
          right: boxLayoutModel.get('right'),
          bottom: boxLayoutModel.get('bottom'),
          width: boxLayoutModel.get('width'),
          height: boxLayoutModel.get('height')
        }
      }
      /**
       * Get key for zlevel.
       * If developers don't configure zlevel. We will assign zlevel to series based on the key.
       * For example, lines with trail effect and progressive series will in an individual zlevel.
       */

      ComponentModel.prototype.getZLevelKey = function () {
        return ''
      }

      ComponentModel.prototype.setZLevel = function (zlevel) {
        this.option.zlevel = zlevel
      }

      ComponentModel.protoInitialize = (function () {
        const proto = ComponentModel.prototype
        proto.type = 'component'
        proto.id = ''
        proto.name = ''
        proto.mainType = ''
        proto.subType = ''
        proto.componentIndex = 0
      }())

      return ComponentModel
    }(Model))

  mountExtend(ComponentModel, Model)
  enableClassManagement(ComponentModel)
  enableSubTypeDefaulter(ComponentModel)
  enableTopologicalTravel(ComponentModel, getDependencies)

  function getDependencies (componentType) {
    let deps = []
    each(ComponentModel.getClassesByMainType(componentType), function (clz) {
      deps = deps.concat(clz.dependencies || clz.prototype.dependencies || [])
    }) // Ensure main type.

    deps = map(deps, function (type) {
      return parseClassType(type).main
    }) // Hack dataset for convenience.

    if (componentType !== 'dataset' && indexOf(deps, 'dataset') <= 0) {
      deps.unshift('dataset')
    }

    return deps
  }

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

  /**
     * AUTO-GENERATED FILE. DO NOT MODIFY.
     */

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
  let platform = '' // Navigator not exists in node

  if (typeof navigator !== 'undefined') {
    /* global navigator */
    platform = navigator.platform || ''
  }

  const decalColor = 'rgba(0, 0, 0, 0.2)'
  const globalDefault = {
    darkMode: 'auto',
    // backgroundColor: 'rgba(0,0,0,0)',
    colorBy: 'series',
    color: ['#5470c6', '#91cc75', '#fac858', '#ee6666', '#73c0de', '#3ba272', '#fc8452', '#9a60b4', '#ea7ccc'],
    gradientColor: ['#f6efa6', '#d88273', '#bf444c'],
    aria: {
      decal: {
        decals: [{
          color: decalColor,
          dashArrayX: [1, 0],
          dashArrayY: [2, 5],
          symbolSize: 1,
          rotation: Math.PI / 6
        }, {
          color: decalColor,
          symbol: 'circle',
          dashArrayX: [[8, 8], [0, 8, 8, 0]],
          dashArrayY: [6, 0],
          symbolSize: 0.8
        }, {
          color: decalColor,
          dashArrayX: [1, 0],
          dashArrayY: [4, 3],
          rotation: -Math.PI / 4
        }, {
          color: decalColor,
          dashArrayX: [[6, 6], [0, 6, 6, 0]],
          dashArrayY: [6, 0]
        }, {
          color: decalColor,
          dashArrayX: [[1, 0], [1, 6]],
          dashArrayY: [1, 0, 6, 0],
          rotation: Math.PI / 4
        }, {
          color: decalColor,
          symbol: 'triangle',
          dashArrayX: [[9, 9], [0, 9, 9, 0]],
          dashArrayY: [7, 2],
          symbolSize: 0.75
        }]
      }
    },
    // If xAxis and yAxis declared, grid is created by default.
    // grid: {},
    textStyle: {
      // color: '#000',
      // decoration: 'none',
      // PENDING
      fontFamily: platform.match(/^Win/) ? 'Microsoft YaHei' : 'sans-serif',
      // fontFamily: 'Arial, Verdana, sans-serif',
      fontSize: 12,
      fontStyle: 'normal',
      fontWeight: 'normal'
    },
    // http://blogs.adobe.com/webplatform/2014/02/24/using-blend-modes-in-html-canvas/
    // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
    // Default is source-over
    blendMode: null,
    stateAnimation: {
      duration: 300,
      easing: 'cubicOut'
    },
    animation: 'auto',
    animationDuration: 1000,
    animationDurationUpdate: 500,
    animationEasing: 'cubicInOut',
    animationEasingUpdate: 'cubicInOut',
    animationThreshold: 2000,
    // Configuration for progressive/incremental rendering
    progressiveThreshold: 3000,
    progressive: 400,
    // Threshold of if use single hover layer to optimize.
    // It is recommended that `hoverLayerThreshold` is equivalent to or less than
    // `progressiveThreshold`, otherwise hover will cause restart of progressive,
    // which is unexpected.
    // see example <echarts/test/heatmap-large.html>.
    hoverLayerThreshold: 3000,
    // See: module:echarts/scale/Time
    useUTC: false
  }

  const VISUAL_DIMENSIONS = createHashMap(['tooltip', 'label', 'itemName', 'itemId', 'itemGroupId', 'seriesName'])
  const SOURCE_FORMAT_ORIGINAL = 'original'
  const SOURCE_FORMAT_ARRAY_ROWS = 'arrayRows'
  const SOURCE_FORMAT_OBJECT_ROWS = 'objectRows'
  const SOURCE_FORMAT_KEYED_COLUMNS = 'keyedColumns'
  const SOURCE_FORMAT_TYPED_ARRAY = 'typedArray'
  const SOURCE_FORMAT_UNKNOWN = 'unknown'
  const SERIES_LAYOUT_BY_COLUMN = 'column'
  const SERIES_LAYOUT_BY_ROW = 'row'

  const BE_ORDINAL = {
    Must: 1,
    Might: 2,
    Not: 3 // Other cases

  }
  const innerGlobalModel = makeInner()
  /**
     * MUST be called before mergeOption of all series.
     */

  function resetSourceDefaulter (ecModel) {
    // `datasetMap` is used to make default encode.
    innerGlobalModel(ecModel).datasetMap = createHashMap()
  }
  /**
     * [The strategy of the arrengment of data dimensions for dataset]:
     * "value way": all axes are non-category axes. So series one by one take
     *     several (the number is coordSysDims.length) dimensions from dataset.
     *     The result of data arrengment of data dimensions like:
     *     | ser0_x | ser0_y | ser1_x | ser1_y | ser2_x | ser2_y |
     * "category way": at least one axis is category axis. So the the first data
     *     dimension is always mapped to the first category axis and shared by
     *     all of the series. The other data dimensions are taken by series like
     *     "value way" does.
     *     The result of data arrengment of data dimensions like:
     *     | ser_shared_x | ser0_y | ser1_y | ser2_y |
     *
     * @return encode Never be `null/undefined`.
     */

  function makeSeriesEncodeForAxisCoordSys (coordDimensions, seriesModel, source) {
    const encode = {}
    const datasetModel = querySeriesUpstreamDatasetModel(seriesModel) // Currently only make default when using dataset, util more reqirements occur.

    if (!datasetModel || !coordDimensions) {
      return encode
    }

    const encodeItemName = []
    const encodeSeriesName = []
    const ecModel = seriesModel.ecModel
    const datasetMap = innerGlobalModel(ecModel).datasetMap
    const key = datasetModel.uid + '_' + source.seriesLayoutBy
    let baseCategoryDimIndex
    let categoryWayValueDimStart
    coordDimensions = coordDimensions.slice()
    each(coordDimensions, function (coordDimInfoLoose, coordDimIdx) {
      const coordDimInfo = isObject(coordDimInfoLoose)
        ? coordDimInfoLoose
        : coordDimensions[coordDimIdx] = {
          name: coordDimInfoLoose
        }

      if (coordDimInfo.type === 'ordinal' && baseCategoryDimIndex == null) {
        baseCategoryDimIndex = coordDimIdx
        categoryWayValueDimStart = getDataDimCountOnCoordDim(coordDimInfo)
      }

      encode[coordDimInfo.name] = []
    })
    const datasetRecord = datasetMap.get(key) || datasetMap.set(key, {
      categoryWayDim: categoryWayValueDimStart,
      valueWayDim: 0
    }) // TODO
    // Auto detect first time axis and do arrangement.

    each(coordDimensions, function (coordDimInfo, coordDimIdx) {
      const coordDimName = coordDimInfo.name
      const count = getDataDimCountOnCoordDim(coordDimInfo) // In value way.

      if (baseCategoryDimIndex == null) {
        var start = datasetRecord.valueWayDim
        pushDim(encode[coordDimName], start, count)
        pushDim(encodeSeriesName, start, count)
        datasetRecord.valueWayDim += count // ??? TODO give a better default series name rule?
        // especially when encode x y specified.
        // consider: when mutiple series share one dimension
        // category axis, series name should better use
        // the other dimsion name. On the other hand, use
        // both dimensions name.
      } // In category way, the first category axis.
      else if (baseCategoryDimIndex === coordDimIdx) {
        pushDim(encode[coordDimName], 0, count)
        pushDim(encodeItemName, 0, count)
      } // In category way, the other axis.
      else {
        var start = datasetRecord.categoryWayDim
        pushDim(encode[coordDimName], start, count)
        pushDim(encodeSeriesName, start, count)
        datasetRecord.categoryWayDim += count
      }
    })

    function pushDim (dimIdxArr, idxFrom, idxCount) {
      for (let i = 0; i < idxCount; i++) {
        dimIdxArr.push(idxFrom + i)
      }
    }

    function getDataDimCountOnCoordDim (coordDimInfo) {
      const dimsDef = coordDimInfo.dimsDef
      return dimsDef ? dimsDef.length : 1
    }

    encodeItemName.length && (encode.itemName = encodeItemName)
    encodeSeriesName.length && (encode.seriesName = encodeSeriesName)
    return encode
  }
  /**
     * Work for data like [{name: ..., value: ...}, ...].
     *
     * @return encode Never be `null/undefined`.
     */

  function makeSeriesEncodeForNameBased (seriesModel, source, dimCount) {
    const encode = {}
    const datasetModel = querySeriesUpstreamDatasetModel(seriesModel) // Currently only make default when using dataset, util more reqirements occur.

    if (!datasetModel) {
      return encode
    }

    const sourceFormat = source.sourceFormat
    const dimensionsDefine = source.dimensionsDefine
    let potentialNameDimIndex

    if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS || sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {
      each(dimensionsDefine, function (dim, idx) {
        if ((isObject(dim) ? dim.name : dim) === 'name') {
          potentialNameDimIndex = idx
        }
      })
    }

    const idxResult = (function () {
      const idxRes0 = {}
      const idxRes1 = {}
      const guessRecords = [] // 5 is an experience value.

      for (let i = 0, len = Math.min(5, dimCount); i < len; i++) {
        const guessResult = doGuessOrdinal(source.data, sourceFormat, source.seriesLayoutBy, dimensionsDefine, source.startIndex, i)
        guessRecords.push(guessResult)
        const isPureNumber = guessResult === BE_ORDINAL.Not // [Strategy of idxRes0]: find the first BE_ORDINAL.Not as the value dim,
        // and then find a name dim with the priority:
        // "BE_ORDINAL.Might|BE_ORDINAL.Must" > "other dim" > "the value dim itself".

        if (isPureNumber && idxRes0.v == null && i !== potentialNameDimIndex) {
          idxRes0.v = i
        }

        if (idxRes0.n == null || idxRes0.n === idxRes0.v || !isPureNumber && guessRecords[idxRes0.n] === BE_ORDINAL.Not) {
          idxRes0.n = i
        }

        if (fulfilled(idxRes0) && guessRecords[idxRes0.n] !== BE_ORDINAL.Not) {
          return idxRes0
        } // [Strategy of idxRes1]: if idxRes0 not satisfied (that is, no BE_ORDINAL.Not),
        // find the first BE_ORDINAL.Might as the value dim,
        // and then find a name dim with the priority:
        // "other dim" > "the value dim itself".
        // That is for backward compat: number-like (e.g., `'3'`, `'55'`) can be
        // treated as number.

        if (!isPureNumber) {
          if (guessResult === BE_ORDINAL.Might && idxRes1.v == null && i !== potentialNameDimIndex) {
            idxRes1.v = i
          }

          if (idxRes1.n == null || idxRes1.n === idxRes1.v) {
            idxRes1.n = i
          }
        }
      }

      function fulfilled (idxResult) {
        return idxResult.v != null && idxResult.n != null
      }

      return fulfilled(idxRes0) ? idxRes0 : fulfilled(idxRes1) ? idxRes1 : null
    }())

    if (idxResult) {
      encode.value = [idxResult.v] // `potentialNameDimIndex` has highest priority.

      const nameDimIndex = potentialNameDimIndex != null ? potentialNameDimIndex : idxResult.n // By default, label use itemName in charts.
      // So we dont set encodeLabel here.

      encode.itemName = [nameDimIndex]
      encode.seriesName = [nameDimIndex]
    }

    return encode
  }
  /**
     * @return If return null/undefined, indicate that should not use datasetModel.
     */

  function querySeriesUpstreamDatasetModel (seriesModel) {
    // Caution: consider the scenario:
    // A dataset is declared and a series is not expected to use the dataset,
    // and at the beginning `setOption({series: { noData })` (just prepare other
    // option but no data), then `setOption({series: {data: [...]}); In this case,
    // the user should set an empty array to avoid that dataset is used by default.
    const thisData = seriesModel.get('data', true)

    if (!thisData) {
      return queryReferringComponents(seriesModel.ecModel, 'dataset', {
        index: seriesModel.get('datasetIndex', true),
        id: seriesModel.get('datasetId', true)
      }, SINGLE_REFERRING).models[0]
    }
  }
  /**
     * @return Always return an array event empty.
     */

  function queryDatasetUpstreamDatasetModels (datasetModel) {
    // Only these attributes declared, we by defualt reference to `datasetIndex: 0`.
    // Otherwise, no reference.
    if (!datasetModel.get('transform', true) && !datasetModel.get('fromTransformResult', true)) {
      return []
    }

    return queryReferringComponents(datasetModel.ecModel, 'dataset', {
      index: datasetModel.get('fromDatasetIndex', true),
      id: datasetModel.get('fromDatasetId', true)
    }, SINGLE_REFERRING).models
  }
  /**
     * The rule should not be complex, otherwise user might not
     * be able to known where the data is wrong.
     * The code is ugly, but how to make it neat?
     */

  function guessOrdinal (source, dimIndex) {
    return doGuessOrdinal(source.data, source.sourceFormat, source.seriesLayoutBy, source.dimensionsDefine, source.startIndex, dimIndex)
  } // dimIndex may be overflow source data.
  // return {BE_ORDINAL}

  function doGuessOrdinal (data, sourceFormat, seriesLayoutBy, dimensionsDefine, startIndex, dimIndex) {
    let result // Experience value.

    const maxLoop = 5

    if (isTypedArray(data)) {
      return BE_ORDINAL.Not
    } // When sourceType is 'objectRows' or 'keyedColumns', dimensionsDefine
    // always exists in source.

    let dimName
    let dimType

    if (dimensionsDefine) {
      const dimDefItem = dimensionsDefine[dimIndex]

      if (isObject(dimDefItem)) {
        dimName = dimDefItem.name
        dimType = dimDefItem.type
      } else if (isString(dimDefItem)) {
        dimName = dimDefItem
      }
    }

    if (dimType != null) {
      return dimType === 'ordinal' ? BE_ORDINAL.Must : BE_ORDINAL.Not
    }

    if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {
      const dataArrayRows = data

      if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW) {
        var sample = dataArrayRows[dimIndex]

        for (var i = 0; i < (sample || []).length && i < maxLoop; i++) {
          if ((result = detectValue(sample[startIndex + i])) != null) {
            return result
          }
        }
      } else {
        for (var i = 0; i < dataArrayRows.length && i < maxLoop; i++) {
          const row = dataArrayRows[startIndex + i]

          if (row && (result = detectValue(row[dimIndex])) != null) {
            return result
          }
        }
      }
    } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {
      const dataObjectRows = data

      if (!dimName) {
        return BE_ORDINAL.Not
      }

      for (var i = 0; i < dataObjectRows.length && i < maxLoop; i++) {
        var item = dataObjectRows[i]

        if (item && (result = detectValue(item[dimName])) != null) {
          return result
        }
      }
    } else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {
      const dataKeyedColumns = data

      if (!dimName) {
        return BE_ORDINAL.Not
      }

      var sample = dataKeyedColumns[dimName]

      if (!sample || isTypedArray(sample)) {
        return BE_ORDINAL.Not
      }

      for (var i = 0; i < sample.length && i < maxLoop; i++) {
        if ((result = detectValue(sample[i])) != null) {
          return result
        }
      }
    } else if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {
      const dataOriginal = data

      for (var i = 0; i < dataOriginal.length && i < maxLoop; i++) {
        var item = dataOriginal[i]
        const val = getDataItemValue(item)

        if (!isArray(val)) {
          return BE_ORDINAL.Not
        }

        if ((result = detectValue(val[dimIndex])) != null) {
          return result
        }
      }
    }

    function detectValue (val) {
      const beStr = isString(val) // Consider usage convenience, '1', '2' will be treated as "number".
      // `isFinit('')` get `true`.

      if (val != null && isFinite(val) && val !== '') {
        return beStr ? BE_ORDINAL.Might : BE_ORDINAL.Not
      } else if (beStr && val !== '-') {
        return BE_ORDINAL.Must
      }
    }

    return BE_ORDINAL.Not
  }

  const internalOptionCreatorMap = createHashMap()
  function registerInternalOptionCreator (mainType, creator) {
    assert(internalOptionCreatorMap.get(mainType) == null && creator)
    internalOptionCreatorMap.set(mainType, creator)
  }
  function concatInternalOptions (ecModel, mainType, newCmptOptionList) {
    const internalOptionCreator = internalOptionCreatorMap.get(mainType)

    if (!internalOptionCreator) {
      return newCmptOptionList
    }

    const internalOptions = internalOptionCreator(ecModel)

    if (!internalOptions) {
      return newCmptOptionList
    }

    if ('development' !== 'production') {
      for (let i = 0; i < internalOptions.length; i++) {
        assert(isComponentIdInternal(internalOptions[i]))
      }
    }

    return newCmptOptionList.concat(internalOptions)
  }

  const innerColor = makeInner()
  const innerDecal = makeInner()

  const PaletteMixin =
    /** @class */
    (function () {
      function PaletteMixin () {}

      PaletteMixin.prototype.getColorFromPalette = function (name, scope, requestNum) {
        const defaultPalette = normalizeToArray(this.get('color', true))
        const layeredPalette = this.get('colorLayer', true)
        return getFromPalette(this, innerColor, defaultPalette, layeredPalette, name, scope, requestNum)
      }

      PaletteMixin.prototype.clearColorPalette = function () {
        clearPalette(this, innerColor)
      }

      return PaletteMixin
    }())

  function getDecalFromPalette (ecModel, name, scope, requestNum) {
    const defaultDecals = normalizeToArray(ecModel.get(['aria', 'decal', 'decals']))
    return getFromPalette(ecModel, innerDecal, defaultDecals, null, name, scope, requestNum)
  }

  function getNearestPalette (palettes, requestColorNum) {
    const paletteNum = palettes.length // TODO palettes must be in order

    for (let i = 0; i < paletteNum; i++) {
      if (palettes[i].length > requestColorNum) {
        return palettes[i]
      }
    }

    return palettes[paletteNum - 1]
  }
  /**
     * @param name MUST NOT be null/undefined. Otherwise call this function
     *             twise with the same parameters will get different result.
     * @param scope default this.
     * @return Can be null/undefined
     */

  function getFromPalette (that, inner, defaultPalette, layeredPalette, name, scope, requestNum) {
    scope = scope || that
    const scopeFields = inner(scope)
    const paletteIdx = scopeFields.paletteIdx || 0
    const paletteNameMap = scopeFields.paletteNameMap = scopeFields.paletteNameMap || {} // Use `hasOwnProperty` to avoid conflict with Object.prototype.

    if (paletteNameMap.hasOwnProperty(name)) {
      return paletteNameMap[name]
    }

    let palette = requestNum == null || !layeredPalette ? defaultPalette : getNearestPalette(layeredPalette, requestNum) // In case can't find in layered color palette.

    palette = palette || defaultPalette

    if (!palette || !palette.length) {
      return
    }

    const pickedPaletteItem = palette[paletteIdx]

    if (name) {
      paletteNameMap[name] = pickedPaletteItem
    }

    scopeFields.paletteIdx = (paletteIdx + 1) % palette.length
    return pickedPaletteItem
  }

  function clearPalette (that, inner) {
    inner(that).paletteIdx = 0
    inner(that).paletteNameMap = {}
  }

  // Internal method names:
  // -----------------------

  let reCreateSeriesIndices
  let assertSeriesInitialized
  let initBase
  const OPTION_INNER_KEY = '\0_ec_inner'
  const OPTION_INNER_VALUE = 1
  const BUITIN_COMPONENTS_MAP = {
    grid: 'GridComponent',
    polar: 'PolarComponent',
    geo: 'GeoComponent',
    singleAxis: 'SingleAxisComponent',
    parallel: 'ParallelComponent',
    calendar: 'CalendarComponent',
    graphic: 'GraphicComponent',
    toolbox: 'ToolboxComponent',
    tooltip: 'TooltipComponent',
    axisPointer: 'AxisPointerComponent',
    brush: 'BrushComponent',
    title: 'TitleComponent',
    timeline: 'TimelineComponent',
    markPoint: 'MarkPointComponent',
    markLine: 'MarkLineComponent',
    markArea: 'MarkAreaComponent',
    legend: 'LegendComponent',
    dataZoom: 'DataZoomComponent',
    visualMap: 'VisualMapComponent',
    // aria: 'AriaComponent',
    // dataset: 'DatasetComponent',
    // Dependencies
    xAxis: 'GridComponent',
    yAxis: 'GridComponent',
    angleAxis: 'PolarComponent',
    radiusAxis: 'PolarComponent'
  }
  const BUILTIN_CHARTS_MAP = {
    line: 'LineChart',
    bar: 'BarChart',
    pie: 'PieChart',
    scatter: 'ScatterChart',
    radar: 'RadarChart',
    map: 'MapChart',
    tree: 'TreeChart',
    treemap: 'TreemapChart',
    graph: 'GraphChart',
    gauge: 'GaugeChart',
    funnel: 'FunnelChart',
    parallel: 'ParallelChart',
    sankey: 'SankeyChart',
    boxplot: 'BoxplotChart',
    candlestick: 'CandlestickChart',
    effectScatter: 'EffectScatterChart',
    lines: 'LinesChart',
    heatmap: 'HeatmapChart',
    pictorialBar: 'PictorialBarChart',
    themeRiver: 'ThemeRiverChart',
    sunburst: 'SunburstChart',
    custom: 'CustomChart'
  }
  const componetsMissingLogPrinted = {}

  function checkMissingComponents (option) {
    each(option, function (componentOption, mainType) {
      if (!ComponentModel.hasClass(mainType)) {
        const componentImportName = BUITIN_COMPONENTS_MAP[mainType]

        if (componentImportName && !componetsMissingLogPrinted[componentImportName]) {
          error('Component ' + mainType + ' is used but not imported.\nimport { ' + componentImportName + " } from 'echarts/components';\necharts.use([" + componentImportName + ']);')
          componetsMissingLogPrinted[componentImportName] = true
        }
      }
    })
  }

  const GlobalModel =
    /** @class */
    (function (_super) {
      __extends(GlobalModel, _super)

      function GlobalModel () {
        return _super !== null && _super.apply(this, arguments) || this
      }

      GlobalModel.prototype.init = function (option, parentModel, ecModel, theme, locale, optionManager) {
        theme = theme || {}
        this.option = null // Mark as not initialized.

        this._theme = new Model(theme)
        this._locale = new Model(locale)
        this._optionManager = optionManager
      }

      GlobalModel.prototype.setOption = function (option, opts, optionPreprocessorFuncs) {
        if ('development' !== 'production') {
          assert(option != null, 'option is null/undefined')
          assert(option[OPTION_INNER_KEY] !== OPTION_INNER_VALUE, 'please use chart.getOption()')
        }

        const innerOpt = normalizeSetOptionInput(opts)

        this._optionManager.setOption(option, optionPreprocessorFuncs, innerOpt)

        this._resetOption(null, innerOpt)
      }
      /**
       * @param type null/undefined: reset all.
       *        'recreate': force recreate all.
       *        'timeline': only reset timeline option
       *        'media': only reset media query option
       * @return Whether option changed.
       */

      GlobalModel.prototype.resetOption = function (type, opt) {
        return this._resetOption(type, normalizeSetOptionInput(opt))
      }

      GlobalModel.prototype._resetOption = function (type, opt) {
        let optionChanged = false
        const optionManager = this._optionManager

        if (!type || type === 'recreate') {
          const baseOption = optionManager.mountOption(type === 'recreate')

          if ('development' !== 'production') {
            checkMissingComponents(baseOption)
          }

          if (!this.option || type === 'recreate') {
            initBase(this, baseOption)
          } else {
            this.restoreData()

            this._mergeOption(baseOption, opt)
          }

          optionChanged = true
        }

        if (type === 'timeline' || type === 'media') {
          this.restoreData()
        } // By design, if `setOption(option2)` at the second time, and `option2` is a `ECUnitOption`,
        // it should better not have the same props with `MediaUnit['option']`.
        // Becuase either `option2` or `MediaUnit['option']` will be always merged to "current option"
        // rather than original "baseOption". If they both override a prop, the result might be
        // unexpected when media state changed after `setOption` called.
        // If we really need to modify a props in each `MediaUnit['option']`, use the full version
        // (`{baseOption, media}`) in `setOption`.
        // For `timeline`, the case is the same.

        if (!type || type === 'recreate' || type === 'timeline') {
          const timelineOption = optionManager.getTimelineOption(this)

          if (timelineOption) {
            optionChanged = true

            this._mergeOption(timelineOption, opt)
          }
        }

        if (!type || type === 'recreate' || type === 'media') {
          const mediaOptions = optionManager.getMediaOption(this)

          if (mediaOptions.length) {
            each(mediaOptions, function (mediaOption) {
              optionChanged = true

              this._mergeOption(mediaOption, opt)
            }, this)
          }
        }

        return optionChanged
      }

      GlobalModel.prototype.mergeOption = function (option) {
        this._mergeOption(option, null)
      }

      GlobalModel.prototype._mergeOption = function (newOption, opt) {
        const option = this.option
        const componentsMap = this._componentsMap
        const componentsCount = this._componentsCount
        const newCmptTypes = []
        const newCmptTypeMap = createHashMap()
        const replaceMergeMainTypeMap = opt && opt.replaceMergeMainTypeMap
        resetSourceDefaulter(this) // If no component class, merge directly.
        // For example: color, animaiton options, etc.

        each(newOption, function (componentOption, mainType) {
          if (componentOption == null) {
            return
          }

          if (!ComponentModel.hasClass(mainType)) {
            // globalSettingTask.dirty();
            option[mainType] = option[mainType] == null ? clone(componentOption) : merge(option[mainType], componentOption, true)
          } else if (mainType) {
            newCmptTypes.push(mainType)
            newCmptTypeMap.set(mainType, true)
          }
        })

        if (replaceMergeMainTypeMap) {
          // If there is a mainType `xxx` in `replaceMerge` but not declared in option,
          // we trade it as it is declared in option as `{xxx: []}`. Because:
          // (1) for normal merge, `{xxx: null/undefined}` are the same meaning as `{xxx: []}`.
          // (2) some preprocessor may convert some of `{xxx: null/undefined}` to `{xxx: []}`.
          replaceMergeMainTypeMap.each(function (val, mainTypeInReplaceMerge) {
            if (ComponentModel.hasClass(mainTypeInReplaceMerge) && !newCmptTypeMap.get(mainTypeInReplaceMerge)) {
              newCmptTypes.push(mainTypeInReplaceMerge)
              newCmptTypeMap.set(mainTypeInReplaceMerge, true)
            }
          })
        }

        ComponentModel.topologicalTravel(newCmptTypes, ComponentModel.getAllClassMainTypes(), visitComponent, this)

        function visitComponent (mainType) {
          const newCmptOptionList = concatInternalOptions(this, mainType, normalizeToArray(newOption[mainType]))
          const oldCmptList = componentsMap.get(mainType)
          const mergeMode = // `!oldCmptList` means init. See the comment in `mappingToExists`
          !oldCmptList ? 'replaceAll' : replaceMergeMainTypeMap && replaceMergeMainTypeMap.get(mainType) ? 'replaceMerge' : 'normalMerge'
          const mappingResult = mappingToExists(oldCmptList, newCmptOptionList, mergeMode) // Set mainType and complete subType.

          setComponentTypeToKeyInfo(mappingResult, mainType, ComponentModel) // Empty it before the travel, in order to prevent `this._componentsMap`
          // from being used in the `init`/`mergeOption`/`optionUpdated` of some
          // components, which is probably incorrect logic.

          option[mainType] = null
          componentsMap.set(mainType, null)
          componentsCount.set(mainType, 0)
          const optionsByMainType = []
          const cmptsByMainType = []
          let cmptsCountByMainType = 0
          let tooltipExists
          let tooltipWarningLogged
          each(mappingResult, function (resultItem, index) {
            let componentModel = resultItem.existing
            const newCmptOption = resultItem.newOption

            if (!newCmptOption) {
              if (componentModel) {
                // Consider where is no new option and should be merged using {},
                // see removeEdgeAndAdd in topologicalTravel and
                // ComponentModel.getAllClassMainTypes.
                componentModel.mergeOption({}, this)
                componentModel.optionUpdated({}, false)
              } // If no both `resultItem.exist` and `resultItem.option`,
              // either it is in `replaceMerge` and not matched by any id,
              // or it has been removed in previous `replaceMerge` and left a "hole" in this component index.
            } else {
              const isSeriesType = mainType === 'series'
              const ComponentModelClass = ComponentModel.getClass(mainType, resultItem.keyInfo.subType, !isSeriesType // Give a more detailed warn later if series don't exists
              )

              if (!ComponentModelClass) {
                if ('development' !== 'production') {
                  const subType = resultItem.keyInfo.subType
                  const seriesImportName = BUILTIN_CHARTS_MAP[subType]

                  if (!componetsMissingLogPrinted[subType]) {
                    componetsMissingLogPrinted[subType] = true

                    if (seriesImportName) {
                      error('Series ' + subType + ' is used but not imported.\nimport { ' + seriesImportName + " } from 'echarts/charts';\necharts.use([" + seriesImportName + ']);')
                    } else {
                      error('Unkown series ' + subType)
                    }
                  }
                }

                return
              } // TODO Before multiple tooltips get supported, we do this check to avoid unexpected exception.

              if (mainType === 'tooltip') {
                if (tooltipExists) {
                  if ('development' !== 'production') {
                    if (!tooltipWarningLogged) {
                      warn('Currently only one tooltip component is allowed.')
                      tooltipWarningLogged = true
                    }
                  }

                  return
                }

                tooltipExists = true
              }

              if (componentModel && componentModel.constructor === ComponentModelClass) {
                componentModel.name = resultItem.keyInfo.name // componentModel.settingTask && componentModel.settingTask.dirty();

                componentModel.mergeOption(newCmptOption, this)
                componentModel.optionUpdated(newCmptOption, false)
              } else {
                // PENDING Global as parent ?
                const extraOpt = extend({
                  componentIndex: index
                }, resultItem.keyInfo)
                componentModel = new ComponentModelClass(newCmptOption, this, this, extraOpt) // Assign `keyInfo`

                extend(componentModel, extraOpt)

                if (resultItem.brandNew) {
                  componentModel.__requireNewView = true
                }

                componentModel.init(newCmptOption, this, this) // Call optionUpdated after init.
                // newCmptOption has been used as componentModel.option
                // and may be merged with theme and default, so pass null
                // to avoid confusion.

                componentModel.optionUpdated(null, true)
              }
            }

            if (componentModel) {
              optionsByMainType.push(componentModel.option)
              cmptsByMainType.push(componentModel)
              cmptsCountByMainType++
            } else {
              // Always do assign to avoid elided item in array.
              optionsByMainType.push(void 0)
              cmptsByMainType.push(void 0)
            }
          }, this)
          option[mainType] = optionsByMainType
          componentsMap.set(mainType, cmptsByMainType)
          componentsCount.set(mainType, cmptsCountByMainType) // Backup series for filtering.

          if (mainType === 'series') {
            reCreateSeriesIndices(this)
          }
        } // If no series declared, ensure `_seriesIndices` initialized.

        if (!this._seriesIndices) {
          reCreateSeriesIndices(this)
        }
      }
      /**
       * Get option for output (cloned option and inner info removed)
       */

      GlobalModel.prototype.getOption = function () {
        const option = clone(this.option)
        each(option, function (optInMainType, mainType) {
          if (ComponentModel.hasClass(mainType)) {
            const opts = normalizeToArray(optInMainType) // Inner cmpts need to be removed.
            // Inner cmpts might not be at last since ec5.0, but still
            // compatible for users: if inner cmpt at last, splice the returned array.

            let realLen = opts.length
            let metNonInner = false

            for (let i = realLen - 1; i >= 0; i--) {
              // Remove options with inner id.
              if (opts[i] && !isComponentIdInternal(opts[i])) {
                metNonInner = true
              } else {
                opts[i] = null
                !metNonInner && realLen--
              }
            }

            opts.length = realLen
            option[mainType] = opts
          }
        })
        delete option[OPTION_INNER_KEY]
        return option
      }

      GlobalModel.prototype.getTheme = function () {
        return this._theme
      }

      GlobalModel.prototype.getLocaleModel = function () {
        return this._locale
      }

      GlobalModel.prototype.setUpdatePayload = function (payload) {
        this._payload = payload
      }

      GlobalModel.prototype.getUpdatePayload = function () {
        return this._payload
      }
      /**
       * @param idx If not specified, return the first one.
       */

      GlobalModel.prototype.getComponent = function (mainType, idx) {
        const list = this._componentsMap.get(mainType)

        if (list) {
          const cmpt = list[idx || 0]

          if (cmpt) {
            return cmpt
          } else if (idx == null) {
            for (let i = 0; i < list.length; i++) {
              if (list[i]) {
                return list[i]
              }
            }
          }
        }
      }
      /**
       * @return Never be null/undefined.
       */

      GlobalModel.prototype.queryComponents = function (condition) {
        const mainType = condition.mainType

        if (!mainType) {
          return []
        }

        const index = condition.index
        const id = condition.id
        const name = condition.name

        const cmpts = this._componentsMap.get(mainType)

        if (!cmpts || !cmpts.length) {
          return []
        }

        let result

        if (index != null) {
          result = []
          each(normalizeToArray(index), function (idx) {
            cmpts[idx] && result.push(cmpts[idx])
          })
        } else if (id != null) {
          result = queryByIdOrName('id', id, cmpts)
        } else if (name != null) {
          result = queryByIdOrName('name', name, cmpts)
        } else {
          // Return all non-empty components in that mainType
          result = filter(cmpts, function (cmpt) {
            return !!cmpt
          })
        }

        return filterBySubType(result, condition)
      }
      /**
       * The interface is different from queryComponents,
       * which is convenient for inner usage.
       *
       * @usage
       * let result = findComponents(
       *     {mainType: 'dataZoom', query: {dataZoomId: 'abc'}}
       * );
       * let result = findComponents(
       *     {mainType: 'series', subType: 'pie', query: {seriesName: 'uio'}}
       * );
       * let result = findComponents(
       *     {mainType: 'series',
       *     filter: function (model, index) {...}}
       * );
       * // result like [component0, componnet1, ...]
       */

      GlobalModel.prototype.findComponents = function (condition) {
        const query = condition.query
        const mainType = condition.mainType
        const queryCond = getQueryCond(query)
        const result = queryCond ? this.queryComponents(queryCond) // Retrieve all non-empty components.
          : filter(this._componentsMap.get(mainType), function (cmpt) {
            return !!cmpt
          })
        return doFilter(filterBySubType(result, condition))

        function getQueryCond (q) {
          const indexAttr = mainType + 'Index'
          const idAttr = mainType + 'Id'
          const nameAttr = mainType + 'Name'
          return q && (q[indexAttr] != null || q[idAttr] != null || q[nameAttr] != null) ? {
            mainType: mainType,
            // subType will be filtered finally.
            index: q[indexAttr],
            id: q[idAttr],
            name: q[nameAttr]
          } : null
        }

        function doFilter (res) {
          return condition.filter ? filter(res, condition.filter) : res
        }
      }

      GlobalModel.prototype.eachComponent = function (mainType, cb, context) {
        const componentsMap = this._componentsMap

        if (isFunction(mainType)) {
          const ctxForAll_1 = cb
          const cbForAll_1 = mainType
          componentsMap.each(function (cmpts, componentType) {
            for (let i = 0; cmpts && i < cmpts.length; i++) {
              const cmpt = cmpts[i]
              cmpt && cbForAll_1.call(ctxForAll_1, componentType, cmpt, cmpt.componentIndex)
            }
          })
        } else {
          const cmpts = isString(mainType) ? componentsMap.get(mainType) : isObject(mainType) ? this.findComponents(mainType) : null

          for (let i = 0; cmpts && i < cmpts.length; i++) {
            const cmpt = cmpts[i]
            cmpt && cb.call(context, cmpt, cmpt.componentIndex)
          }
        }
      }
      /**
       * Get series list before filtered by name.
       */

      GlobalModel.prototype.getSeriesByName = function (name) {
        const nameStr = convertOptionIdName(name, null)
        return filter(this._componentsMap.get('series'), function (oneSeries) {
          return !!oneSeries && nameStr != null && oneSeries.name === nameStr
        })
      }
      /**
       * Get series list before filtered by index.
       */

      GlobalModel.prototype.getSeriesByIndex = function (seriesIndex) {
        return this._componentsMap.get('series')[seriesIndex]
      }
      /**
       * Get series list before filtered by type.
       * FIXME: rename to getRawSeriesByType?
       */

      GlobalModel.prototype.getSeriesByType = function (subType) {
        return filter(this._componentsMap.get('series'), function (oneSeries) {
          return !!oneSeries && oneSeries.subType === subType
        })
      }
      /**
       * Get all series before filtered.
       */

      GlobalModel.prototype.getSeries = function () {
        return filter(this._componentsMap.get('series'), function (oneSeries) {
          return !!oneSeries
        })
      }
      /**
       * Count series before filtered.
       */

      GlobalModel.prototype.getSeriesCount = function () {
        return this._componentsCount.get('series')
      }
      /**
       * After filtering, series may be different
       * frome raw series.
       */

      GlobalModel.prototype.eachSeries = function (cb, context) {
        assertSeriesInitialized(this)
        each(this._seriesIndices, function (rawSeriesIndex) {
          const series = this._componentsMap.get('series')[rawSeriesIndex]

          cb.call(context, series, rawSeriesIndex)
        }, this)
      }
      /**
       * Iterate raw series before filtered.
       *
       * @param {Function} cb
       * @param {*} context
       */

      GlobalModel.prototype.eachRawSeries = function (cb, context) {
        each(this._componentsMap.get('series'), function (series) {
          series && cb.call(context, series, series.componentIndex)
        })
      }
      /**
       * After filtering, series may be different.
       * frome raw series.
       */

      GlobalModel.prototype.eachSeriesByType = function (subType, cb, context) {
        assertSeriesInitialized(this)
        each(this._seriesIndices, function (rawSeriesIndex) {
          const series = this._componentsMap.get('series')[rawSeriesIndex]

          if (series.subType === subType) {
            cb.call(context, series, rawSeriesIndex)
          }
        }, this)
      }
      /**
       * Iterate raw series before filtered of given type.
       */

      GlobalModel.prototype.eachRawSeriesByType = function (subType, cb, context) {
        return each(this.getSeriesByType(subType), cb, context)
      }

      GlobalModel.prototype.isSeriesFiltered = function (seriesModel) {
        assertSeriesInitialized(this)
        return this._seriesIndicesMap.get(seriesModel.componentIndex) == null
      }

      GlobalModel.prototype.getCurrentSeriesIndices = function () {
        return (this._seriesIndices || []).slice()
      }

      GlobalModel.prototype.filterSeries = function (cb, context) {
        assertSeriesInitialized(this)
        const newSeriesIndices = []
        each(this._seriesIndices, function (seriesRawIdx) {
          const series = this._componentsMap.get('series')[seriesRawIdx]

          cb.call(context, series, seriesRawIdx) && newSeriesIndices.push(seriesRawIdx)
        }, this)
        this._seriesIndices = newSeriesIndices
        this._seriesIndicesMap = createHashMap(newSeriesIndices)
      }

      GlobalModel.prototype.restoreData = function (payload) {
        reCreateSeriesIndices(this)
        const componentsMap = this._componentsMap
        const componentTypes = []
        componentsMap.each(function (components, componentType) {
          if (ComponentModel.hasClass(componentType)) {
            componentTypes.push(componentType)
          }
        })
        ComponentModel.topologicalTravel(componentTypes, ComponentModel.getAllClassMainTypes(), function (componentType) {
          each(componentsMap.get(componentType), function (component) {
            if (component && (componentType !== 'series' || !isNotTargetSeries(component, payload))) {
              component.restoreData()
            }
          })
        })
      }

      GlobalModel.internalField = (function () {
        reCreateSeriesIndices = function (ecModel) {
          const seriesIndices = ecModel._seriesIndices = []
          each(ecModel._componentsMap.get('series'), function (series) {
            // series may have been removed by `replaceMerge`.
            series && seriesIndices.push(series.componentIndex)
          })
          ecModel._seriesIndicesMap = createHashMap(seriesIndices)
        }

        assertSeriesInitialized = function (ecModel) {
          // Components that use _seriesIndices should depends on series component,
          // which make sure that their initialization is after series.
          if ('development' !== 'production') {
            if (!ecModel._seriesIndices) {
              throw new Error('Option should contains series.')
            }
          }
        }

        initBase = function (ecModel, baseOption) {
          // Using OPTION_INNER_KEY to mark that this option can not be used outside,
          // i.e. `chart.setOption(chart.getModel().option);` is forbiden.
          ecModel.option = {}
          ecModel.option[OPTION_INNER_KEY] = OPTION_INNER_VALUE // Init with series: [], in case of calling findSeries method
          // before series initialized.

          ecModel._componentsMap = createHashMap({
            series: []
          })
          ecModel._componentsCount = createHashMap() // If user spefied `option.aria`, aria will be enable. This detection should be
          // performed before theme and globalDefault merge.

          const airaOption = baseOption.aria

          if (isObject(airaOption) && airaOption.enabled == null) {
            airaOption.enabled = true
          }

          mergeTheme(baseOption, ecModel._theme.option) // TODO Needs clone when merging to the unexisted property

          merge(baseOption, globalDefault, false)

          ecModel._mergeOption(baseOption, null)
        }
      }())

      return GlobalModel
    }(Model))

  function isNotTargetSeries (seriesModel, payload) {
    if (payload) {
      const index = payload.seriesIndex
      const id = payload.seriesId
      const name_1 = payload.seriesName
      return index != null && seriesModel.componentIndex !== index || id != null && seriesModel.id !== id || name_1 != null && seriesModel.name !== name_1
    }
  }

  function mergeTheme (option, theme) {
    // PENDING
    // NOT use `colorLayer` in theme if option has `color`
    const notMergeColorLayer = option.color && !option.colorLayer
    each(theme, function (themeItem, name) {
      if (name === 'colorLayer' && notMergeColorLayer) {
        return
      } // If it is component model mainType, the model handles that merge later.
      // otherwise, merge them here.

      if (!ComponentModel.hasClass(name)) {
        if (typeof themeItem === 'object') {
          option[name] = !option[name] ? clone(themeItem) : merge(option[name], themeItem, false)
        } else {
          if (option[name] == null) {
            option[name] = themeItem
          }
        }
      }
    })
  }

  function queryByIdOrName (attr, idOrName, cmpts) {
    // Here is a break from echarts4: string and number are
    // treated as equal.
    if (isArray(idOrName)) {
      const keyMap_1 = createHashMap()
      each(idOrName, function (idOrNameItem) {
        if (idOrNameItem != null) {
          const idName = convertOptionIdName(idOrNameItem, null)
          idName != null && keyMap_1.set(idOrNameItem, true)
        }
      })
      return filter(cmpts, function (cmpt) {
        return cmpt && keyMap_1.get(cmpt[attr])
      })
    } else {
      const idName_1 = convertOptionIdName(idOrName, null)
      return filter(cmpts, function (cmpt) {
        return cmpt && idName_1 != null && cmpt[attr] === idName_1
      })
    }
  }

  function filterBySubType (components, condition) {
    // Using hasOwnProperty for restrict. Consider
    // subType is undefined in user payload.
    return condition.hasOwnProperty('subType')
      ? filter(components, function (cmpt) {
        return cmpt && cmpt.subType === condition.subType
      })
      : components
  }

  function normalizeSetOptionInput (opts) {
    const replaceMergeMainTypeMap = createHashMap()
    opts && each(normalizeToArray(opts.replaceMerge), function (mainType) {
      if ('development' !== 'production') {
        assert(ComponentModel.hasClass(mainType), '"' + mainType + '" is not valid component main type in "replaceMerge"')
      }

      replaceMergeMainTypeMap.set(mainType, true)
    })
    return {
      replaceMergeMainTypeMap: replaceMergeMainTypeMap
    }
  }

  mixin(GlobalModel, PaletteMixin)

  const availableMethods = ['getDom', 'getZr', 'getWidth', 'getHeight', 'getDevicePixelRatio', 'dispatchAction', 'isSSR', 'isDisposed', 'on', 'off', 'getDataURL', 'getConnectedDataURL', // 'getModel',
    'getOption', // 'getViewOfComponentModel',
    // 'getViewOfSeriesModel',
    'getId', 'updateLabelLayout']

  const ExtensionAPI =
    /** @class */
    (function () {
      function ExtensionAPI (ecInstance) {
        each(availableMethods, function (methodName) {
          this[methodName] = bind(ecInstance[methodName], ecInstance)
        }, this)
      }

      return ExtensionAPI
    }())

  const coordinateSystemCreators = {}

  const CoordinateSystemManager =
    /** @class */
    (function () {
      function CoordinateSystemManager () {
        this._coordinateSystems = []
      }

      CoordinateSystemManager.prototype.create = function (ecModel, api) {
        let coordinateSystems = []
        each(coordinateSystemCreators, function (creater, type) {
          const list = creater.create(ecModel, api)
          coordinateSystems = coordinateSystems.concat(list || [])
        })
        this._coordinateSystems = coordinateSystems
      }

      CoordinateSystemManager.prototype.update = function (ecModel, api) {
        each(this._coordinateSystems, function (coordSys) {
          coordSys.update && coordSys.update(ecModel, api)
        })
      }

      CoordinateSystemManager.prototype.getCoordinateSystems = function () {
        return this._coordinateSystems.slice()
      }

      CoordinateSystemManager.register = function (type, creator) {
        coordinateSystemCreators[type] = creator
      }

      CoordinateSystemManager.get = function (type) {
        return coordinateSystemCreators[type]
      }

      return CoordinateSystemManager
    }())

  const QUERY_REG = /^(min|max)?(.+)$/ // Key: mainType
  // type FakeComponentsMap = HashMap<(MappingExistingItem & { subType: string })[]>;

  /**
     * TERM EXPLANATIONS:
     * See `ECOption` and `ECUnitOption` in `src/util/types.ts`.
     */

  const OptionManager =
    /** @class */
    (function () {
      // timeline.notMerge is not supported in ec3. Firstly there is rearly
      // case that notMerge is needed. Secondly supporting 'notMerge' requires
      // rawOption cloned and backuped when timeline changed, which does no
      // good to performance. What's more, that both timeline and setOption
      // method supply 'notMerge' brings complex and some problems.
      // Consider this case:
      // (step1) chart.setOption({timeline: {notMerge: false}, ...}, false);
      // (step2) chart.setOption({timeline: {notMerge: true}, ...}, false);
      function OptionManager (api) {
        this._timelineOptions = []
        this._mediaList = []
        /**
         * -1, means default.
         * empty means no media.
         */

        this._currentMediaIndices = []
        this._api = api
      }

      OptionManager.prototype.setOption = function (rawOption, optionPreprocessorFuncs, opt) {
        if (rawOption) {
          // That set dat primitive is dangerous if user reuse the data when setOption again.
          each(normalizeToArray(rawOption.series), function (series) {
            series && series.data && isTypedArray(series.data) && setAsPrimitive(series.data)
          })
          each(normalizeToArray(rawOption.dataset), function (dataset) {
            dataset && dataset.source && isTypedArray(dataset.source) && setAsPrimitive(dataset.source)
          })
        } // Caution: some series modify option data, if do not clone,
        // it should ensure that the repeat modify correctly
        // (create a new object when modify itself).

        rawOption = clone(rawOption) // FIXME
        // If some property is set in timeline options or media option but
        // not set in baseOption, a warning should be given.

        const optionBackup = this._optionBackup
        const newParsedOption = parseRawOption(rawOption, optionPreprocessorFuncs, !optionBackup)
        this._newBaseOption = newParsedOption.baseOption // For setOption at second time (using merge mode);

        if (optionBackup) {
          // FIXME
          // the restore merge solution is essentially incorrect.
          // the mapping can not be 100% consistent with ecModel, which probably brings
          // potential bug!
          // The first merge is delayed, becuase in most cases, users do not call `setOption` twice.
          // let fakeCmptsMap = this._fakeCmptsMap;
          // if (!fakeCmptsMap) {
          //     fakeCmptsMap = this._fakeCmptsMap = createHashMap();
          //     mergeToBackupOption(fakeCmptsMap, null, optionBackup.baseOption, null);
          // }
          // mergeToBackupOption(
          //     fakeCmptsMap, optionBackup.baseOption, newParsedOption.baseOption, opt
          // );
          // For simplicity, timeline options and media options do not support merge,
          // that is, if you `setOption` twice and both has timeline options, the latter
          // timeline opitons will not be merged to the formers, but just substitude them.
          if (newParsedOption.timelineOptions.length) {
            optionBackup.timelineOptions = newParsedOption.timelineOptions
          }

          if (newParsedOption.mediaList.length) {
            optionBackup.mediaList = newParsedOption.mediaList
          }

          if (newParsedOption.mediaDefault) {
            optionBackup.mediaDefault = newParsedOption.mediaDefault
          }
        } else {
          this._optionBackup = newParsedOption
        }
      }

      OptionManager.prototype.mountOption = function (isRecreate) {
        const optionBackup = this._optionBackup
        this._timelineOptions = optionBackup.timelineOptions
        this._mediaList = optionBackup.mediaList
        this._mediaDefault = optionBackup.mediaDefault
        this._currentMediaIndices = []
        return clone(isRecreate // this._optionBackup.baseOption, which is created at the first `setOption`
        // called, and is merged into every new option by inner method `mergeToBackupOption`
        // each time `setOption` called, can be only used in `isRecreate`, because
        // its reliability is under suspicion. In other cases option merge is
        // performed by `model.mergeOption`.
          ? optionBackup.baseOption : this._newBaseOption)
      }

      OptionManager.prototype.getTimelineOption = function (ecModel) {
        let option
        const timelineOptions = this._timelineOptions

        if (timelineOptions.length) {
          // getTimelineOption can only be called after ecModel inited,
          // so we can get currentIndex from timelineModel.
          const timelineModel = ecModel.getComponent('timeline')

          if (timelineModel) {
            option = clone( // FIXME:TS as TimelineModel or quivlant interface
              timelineOptions[timelineModel.getCurrentIndex()])
          }
        }

        return option
      }

      OptionManager.prototype.getMediaOption = function (ecModel) {
        const ecWidth = this._api.getWidth()

        const ecHeight = this._api.getHeight()

        const mediaList = this._mediaList
        const mediaDefault = this._mediaDefault
        let indices = []
        let result = [] // No media defined.

        if (!mediaList.length && !mediaDefault) {
          return result
        } // Multi media may be applied, the latter defined media has higher priority.

        for (let i = 0, len = mediaList.length; i < len; i++) {
          if (applyMediaQuery(mediaList[i].query, ecWidth, ecHeight)) {
            indices.push(i)
          }
        } // FIXME
        // Whether mediaDefault should force users to provide? Otherwise
        // the change by media query can not be recorvered.

        if (!indices.length && mediaDefault) {
          indices = [-1]
        }

        if (indices.length && !indicesEquals(indices, this._currentMediaIndices)) {
          result = map(indices, function (index) {
            return clone(index === -1 ? mediaDefault.option : mediaList[index].option)
          })
        } // Otherwise return nothing.

        this._currentMediaIndices = indices
        return result
      }

      return OptionManager
    }())
    /**
     * [RAW_OPTION_PATTERNS]
     * (Note: "series: []" represents all other props in `ECUnitOption`)
     *
     * (1) No prop "baseOption" declared:
     * Root option is used as "baseOption" (except prop "options" and "media").
     * ```js
     * option = {
     *     series: [],
     *     timeline: {},
     *     options: [],
     * };
     * option = {
     *     series: [],
     *     media: {},
     * };
     * option = {
     *     series: [],
     *     timeline: {},
     *     options: [],
     *     media: {},
     * }
     * ```
     *
     * (2) Prop "baseOption" declared:
     * If "baseOption" declared, `ECUnitOption` props can only be declared
     * inside "baseOption" except prop "timeline" (compat ec2).
     * ```js
     * option = {
     *     baseOption: {
     *         timeline: {},
     *         series: [],
     *     },
     *     options: []
     * };
     * option = {
     *     baseOption: {
     *         series: [],
     *     },
     *     media: []
     * };
     * option = {
     *     baseOption: {
     *         timeline: {},
     *         series: [],
     *     },
     *     options: []
     *     media: []
     * };
     * option = {
     *     // ec3 compat ec2: allow (only) `timeline` declared
     *     // outside baseOption. Keep this setting for compat.
     *     timeline: {},
     *     baseOption: {
     *         series: [],
     *     },
     *     options: [],
     *     media: []
     * };
     * ```
     */

  function parseRawOption ( // `rawOption` May be modified
    rawOption, optionPreprocessorFuncs, isNew) {
    const mediaList = []
    let mediaDefault
    let baseOption
    const declaredBaseOption = rawOption.baseOption // Compatible with ec2, [RAW_OPTION_PATTERNS] above.

    const timelineOnRoot = rawOption.timeline
    const timelineOptionsOnRoot = rawOption.options
    const mediaOnRoot = rawOption.media
    const hasMedia = !!rawOption.media
    const hasTimeline = !!(timelineOptionsOnRoot || timelineOnRoot || declaredBaseOption && declaredBaseOption.timeline)

    if (declaredBaseOption) {
      baseOption = declaredBaseOption // For merge option.

      if (!baseOption.timeline) {
        baseOption.timeline = timelineOnRoot
      }
    } // For convenience, enable to use the root option as the `baseOption`:
    // `{ ...normalOptionProps, media: [{ ... }, { ... }] }`
    else {
      if (hasTimeline || hasMedia) {
        rawOption.options = rawOption.media = null
      }

      baseOption = rawOption
    }

    if (hasMedia) {
      if (isArray(mediaOnRoot)) {
        each(mediaOnRoot, function (singleMedia) {
          if ('development' !== 'production') {
            // Real case of wrong config.
            if (singleMedia && !singleMedia.option && isObject(singleMedia.query) && isObject(singleMedia.query.option)) {
              error('Illegal media option. Must be like { media: [ { query: {}, option: {} } ] }')
            }
          }

          if (singleMedia && singleMedia.option) {
            if (singleMedia.query) {
              mediaList.push(singleMedia)
            } else if (!mediaDefault) {
              // Use the first media default.
              mediaDefault = singleMedia
            }
          }
        })
      } else {
        if ('development' !== 'production') {
          // Real case of wrong config.
          error('Illegal media option. Must be an array. Like { media: [ {...}, {...} ] }')
        }
      }
    }

    doPreprocess(baseOption)
    each(timelineOptionsOnRoot, function (option) {
      return doPreprocess(option)
    })
    each(mediaList, function (media) {
      return doPreprocess(media.option)
    })

    function doPreprocess (option) {
      each(optionPreprocessorFuncs, function (preProcess) {
        preProcess(option, isNew)
      })
    }

    return {
      baseOption: baseOption,
      timelineOptions: timelineOptionsOnRoot || [],
      mediaDefault: mediaDefault,
      mediaList: mediaList
    }
  }
  /**
     * @see <http://www.w3.org/TR/css3-mediaqueries/#media1>
     * Support: width, height, aspectRatio
     * Can use max or min as prefix.
     */

  function applyMediaQuery (query, ecWidth, ecHeight) {
    const realMap = {
      width: ecWidth,
      height: ecHeight,
      aspectratio: ecWidth / ecHeight // lowser case for convenientce.

    }
    let applicatable = true
    each(query, function (value, attr) {
      const matched = attr.match(QUERY_REG)

      if (!matched || !matched[1] || !matched[2]) {
        return
      }

      const operator = matched[1]
      const realAttr = matched[2].toLowerCase()

      if (!compare(realMap[realAttr], value, operator)) {
        applicatable = false
      }
    })
    return applicatable
  }

  function compare (real, expect, operator) {
    if (operator === 'min') {
      return real >= expect
    } else if (operator === 'max') {
      return real <= expect
    } else {
      // Equals
      return real === expect
    }
  }

  function indicesEquals (indices1, indices2) {
    // indices is always order by asc and has only finite number.
    return indices1.join(',') === indices2.join(',')
  }

  const each$2 = each
  const isObject$1 = isObject
  const POSSIBLE_STYLES = ['areaStyle', 'lineStyle', 'nodeStyle', 'linkStyle', 'chordStyle', 'label', 'labelLine']

  function compatEC2ItemStyle (opt) {
    const itemStyleOpt = opt && opt.itemStyle

    if (!itemStyleOpt) {
      return
    }

    for (let i = 0, len = POSSIBLE_STYLES.length; i < len; i++) {
      const styleName = POSSIBLE_STYLES[i]
      const normalItemStyleOpt = itemStyleOpt.normal
      const emphasisItemStyleOpt = itemStyleOpt.emphasis

      if (normalItemStyleOpt && normalItemStyleOpt[styleName]) {
        if ('development' !== 'production') {
          deprecateReplaceLog('itemStyle.normal.' + styleName, styleName)
        }

        opt[styleName] = opt[styleName] || {}

        if (!opt[styleName].normal) {
          opt[styleName].normal = normalItemStyleOpt[styleName]
        } else {
          merge(opt[styleName].normal, normalItemStyleOpt[styleName])
        }

        normalItemStyleOpt[styleName] = null
      }

      if (emphasisItemStyleOpt && emphasisItemStyleOpt[styleName]) {
        if ('development' !== 'production') {
          deprecateReplaceLog('itemStyle.emphasis.' + styleName, 'emphasis.' + styleName)
        }

        opt[styleName] = opt[styleName] || {}

        if (!opt[styleName].emphasis) {
          opt[styleName].emphasis = emphasisItemStyleOpt[styleName]
        } else {
          merge(opt[styleName].emphasis, emphasisItemStyleOpt[styleName])
        }

        emphasisItemStyleOpt[styleName] = null
      }
    }
  }

  function convertNormalEmphasis (opt, optType, useExtend) {
    if (opt && opt[optType] && (opt[optType].normal || opt[optType].emphasis)) {
      const normalOpt = opt[optType].normal
      const emphasisOpt = opt[optType].emphasis

      if (normalOpt) {
        if ('development' !== 'production') {
          // eslint-disable-next-line max-len
          deprecateLog("'normal' hierarchy in " + optType + ' has been removed since 4.0. All style properties are configured in ' + optType + ' directly now.')
        } // Timeline controlStyle has other properties besides normal and emphasis

        if (useExtend) {
          opt[optType].normal = opt[optType].emphasis = null
          defaults(opt[optType], normalOpt)
        } else {
          opt[optType] = normalOpt
        }
      }

      if (emphasisOpt) {
        if ('development' !== 'production') {
          deprecateLog(optType + '.emphasis has been changed to emphasis.' + optType + ' since 4.0')
        }

        opt.emphasis = opt.emphasis || {}
        opt.emphasis[optType] = emphasisOpt // Also compat the case user mix the style and focus together in ec3 style
        // for example: { itemStyle: { normal: {}, emphasis: {focus, shadowBlur} } }

        if (emphasisOpt.focus) {
          opt.emphasis.focus = emphasisOpt.focus
        }

        if (emphasisOpt.blurScope) {
          opt.emphasis.blurScope = emphasisOpt.blurScope
        }
      }
    }
  }

  function removeEC3NormalStatus (opt) {
    convertNormalEmphasis(opt, 'itemStyle')
    convertNormalEmphasis(opt, 'lineStyle')
    convertNormalEmphasis(opt, 'areaStyle')
    convertNormalEmphasis(opt, 'label')
    convertNormalEmphasis(opt, 'labelLine') // treemap

    convertNormalEmphasis(opt, 'upperLabel') // graph

    convertNormalEmphasis(opt, 'edgeLabel')
  }

  function compatTextStyle (opt, propName) {
    // Check whether is not object (string\null\undefined ...)
    const labelOptSingle = isObject$1(opt) && opt[propName]
    const textStyle = isObject$1(labelOptSingle) && labelOptSingle.textStyle

    if (textStyle) {
      if ('development' !== 'production') {
        // eslint-disable-next-line max-len
        deprecateLog('textStyle hierarchy in ' + propName + ' has been removed since 4.0. All textStyle properties are configured in ' + propName + ' directly now.')
      }

      for (let i = 0, len = TEXT_STYLE_OPTIONS.length; i < len; i++) {
        const textPropName = TEXT_STYLE_OPTIONS[i]

        if (textStyle.hasOwnProperty(textPropName)) {
          labelOptSingle[textPropName] = textStyle[textPropName]
        }
      }
    }
  }

  function compatEC3CommonStyles (opt) {
    if (opt) {
      removeEC3NormalStatus(opt)
      compatTextStyle(opt, 'label')
      opt.emphasis && compatTextStyle(opt.emphasis, 'label')
    }
  }

  function processSeries (seriesOpt) {
    if (!isObject$1(seriesOpt)) {
      return
    }

    compatEC2ItemStyle(seriesOpt)
    removeEC3NormalStatus(seriesOpt)
    compatTextStyle(seriesOpt, 'label') // treemap

    compatTextStyle(seriesOpt, 'upperLabel') // graph

    compatTextStyle(seriesOpt, 'edgeLabel')

    if (seriesOpt.emphasis) {
      compatTextStyle(seriesOpt.emphasis, 'label') // treemap

      compatTextStyle(seriesOpt.emphasis, 'upperLabel') // graph

      compatTextStyle(seriesOpt.emphasis, 'edgeLabel')
    }

    let markPoint = seriesOpt.markPoint

    if (markPoint) {
      compatEC2ItemStyle(markPoint)
      compatEC3CommonStyles(markPoint)
    }

    let markLine = seriesOpt.markLine

    if (markLine) {
      compatEC2ItemStyle(markLine)
      compatEC3CommonStyles(markLine)
    }

    const markArea = seriesOpt.markArea

    if (markArea) {
      compatEC3CommonStyles(markArea)
    }

    let data = seriesOpt.data // Break with ec3: if `setOption` again, there may be no `type` in option,
    // then the backward compat based on option type will not be performed.

    if (seriesOpt.type === 'graph') {
      data = data || seriesOpt.nodes
      const edgeData = seriesOpt.links || seriesOpt.edges

      if (edgeData && !isTypedArray(edgeData)) {
        for (var i = 0; i < edgeData.length; i++) {
          compatEC3CommonStyles(edgeData[i])
        }
      }

      each(seriesOpt.categories, function (opt) {
        removeEC3NormalStatus(opt)
      })
    }

    if (data && !isTypedArray(data)) {
      for (var i = 0; i < data.length; i++) {
        compatEC3CommonStyles(data[i])
      }
    } // mark point data

    markPoint = seriesOpt.markPoint

    if (markPoint && markPoint.data) {
      const mpData = markPoint.data

      for (var i = 0; i < mpData.length; i++) {
        compatEC3CommonStyles(mpData[i])
      }
    } // mark line data

    markLine = seriesOpt.markLine

    if (markLine && markLine.data) {
      const mlData = markLine.data

      for (var i = 0; i < mlData.length; i++) {
        if (isArray(mlData[i])) {
          compatEC3CommonStyles(mlData[i][0])
          compatEC3CommonStyles(mlData[i][1])
        } else {
          compatEC3CommonStyles(mlData[i])
        }
      }
    } // Series

    if (seriesOpt.type === 'gauge') {
      compatTextStyle(seriesOpt, 'axisLabel')
      compatTextStyle(seriesOpt, 'title')
      compatTextStyle(seriesOpt, 'detail')
    } else if (seriesOpt.type === 'treemap') {
      convertNormalEmphasis(seriesOpt.breadcrumb, 'itemStyle')
      each(seriesOpt.levels, function (opt) {
        removeEC3NormalStatus(opt)
      })
    } else if (seriesOpt.type === 'tree') {
      removeEC3NormalStatus(seriesOpt.leaves)
    } // sunburst starts from ec4, so it does not need to compat levels.
  }

  function toArr (o) {
    return isArray(o) ? o : o ? [o] : []
  }

  function toObj (o) {
    return (isArray(o) ? o[0] : o) || {}
  }

  function globalCompatStyle (option, isTheme) {
    each$2(toArr(option.series), function (seriesOpt) {
      isObject$1(seriesOpt) && processSeries(seriesOpt)
    })
    const axes = ['xAxis', 'yAxis', 'radiusAxis', 'angleAxis', 'singleAxis', 'parallelAxis', 'radar']
    isTheme && axes.push('valueAxis', 'categoryAxis', 'logAxis', 'timeAxis')
    each$2(axes, function (axisName) {
      each$2(toArr(option[axisName]), function (axisOpt) {
        if (axisOpt) {
          compatTextStyle(axisOpt, 'axisLabel')
          compatTextStyle(axisOpt.axisPointer, 'label')
        }
      })
    })
    each$2(toArr(option.parallel), function (parallelOpt) {
      const parallelAxisDefault = parallelOpt && parallelOpt.parallelAxisDefault
      compatTextStyle(parallelAxisDefault, 'axisLabel')
      compatTextStyle(parallelAxisDefault && parallelAxisDefault.axisPointer, 'label')
    })
    each$2(toArr(option.calendar), function (calendarOpt) {
      convertNormalEmphasis(calendarOpt, 'itemStyle')
      compatTextStyle(calendarOpt, 'dayLabel')
      compatTextStyle(calendarOpt, 'monthLabel')
      compatTextStyle(calendarOpt, 'yearLabel')
    }) // radar.name.textStyle

    each$2(toArr(option.radar), function (radarOpt) {
      compatTextStyle(radarOpt, 'name') // Use axisName instead of name because component has name property

      if (radarOpt.name && radarOpt.axisName == null) {
        radarOpt.axisName = radarOpt.name
        delete radarOpt.name

        if ('development' !== 'production') {
          deprecateLog('name property in radar component has been changed to axisName')
        }
      }

      if (radarOpt.nameGap != null && radarOpt.axisNameGap == null) {
        radarOpt.axisNameGap = radarOpt.nameGap
        delete radarOpt.nameGap

        if ('development' !== 'production') {
          deprecateLog('nameGap property in radar component has been changed to axisNameGap')
        }
      }

      if ('development' !== 'production') {
        each$2(radarOpt.indicator, function (indicatorOpt) {
          if (indicatorOpt.text) {
            deprecateReplaceLog('text', 'name', 'radar.indicator')
          }
        })
      }
    })
    each$2(toArr(option.geo), function (geoOpt) {
      if (isObject$1(geoOpt)) {
        compatEC3CommonStyles(geoOpt)
        each$2(toArr(geoOpt.regions), function (regionObj) {
          compatEC3CommonStyles(regionObj)
        })
      }
    })
    each$2(toArr(option.timeline), function (timelineOpt) {
      compatEC3CommonStyles(timelineOpt)
      convertNormalEmphasis(timelineOpt, 'label')
      convertNormalEmphasis(timelineOpt, 'itemStyle')
      convertNormalEmphasis(timelineOpt, 'controlStyle', true)
      const data = timelineOpt.data
      isArray(data) && each(data, function (item) {
        if (isObject(item)) {
          convertNormalEmphasis(item, 'label')
          convertNormalEmphasis(item, 'itemStyle')
        }
      })
    })
    each$2(toArr(option.toolbox), function (toolboxOpt) {
      convertNormalEmphasis(toolboxOpt, 'iconStyle')
      each$2(toolboxOpt.feature, function (featureOpt) {
        convertNormalEmphasis(featureOpt, 'iconStyle')
      })
    })
    compatTextStyle(toObj(option.axisPointer), 'label')
    compatTextStyle(toObj(option.tooltip).axisPointer, 'label') // Clean logs
    // storedLogs = {};
  }

  function get (opt, path) {
    const pathArr = path.split(',')
    let obj = opt

    for (let i = 0; i < pathArr.length; i++) {
      obj = obj && obj[pathArr[i]]

      if (obj == null) {
        break
      }
    }

    return obj
  }

  function set$1 (opt, path, val, overwrite) {
    const pathArr = path.split(',')
    let obj = opt
    let key
    let i = 0

    for (; i < pathArr.length - 1; i++) {
      key = pathArr[i]

      if (obj[key] == null) {
        obj[key] = {}
      }

      obj = obj[key]
    }

    if (overwrite || obj[pathArr[i]] == null) {
      obj[pathArr[i]] = val
    }
  }

  function compatLayoutProperties (option) {
    option && each(LAYOUT_PROPERTIES, function (prop) {
      if (prop[0] in option && !(prop[1] in option)) {
        option[prop[1]] = option[prop[0]]
      }
    })
  }

  var LAYOUT_PROPERTIES = [['x', 'left'], ['y', 'top'], ['x2', 'right'], ['y2', 'bottom']]
  const COMPATITABLE_COMPONENTS = ['grid', 'geo', 'parallel', 'legend', 'toolbox', 'title', 'visualMap', 'dataZoom', 'timeline']
  const BAR_ITEM_STYLE_MAP = [['borderRadius', 'barBorderRadius'], ['borderColor', 'barBorderColor'], ['borderWidth', 'barBorderWidth']]

  function compatBarItemStyle (option) {
    const itemStyle = option && option.itemStyle

    if (itemStyle) {
      for (let i = 0; i < BAR_ITEM_STYLE_MAP.length; i++) {
        const oldName = BAR_ITEM_STYLE_MAP[i][1]
        const newName = BAR_ITEM_STYLE_MAP[i][0]

        if (itemStyle[oldName] != null) {
          itemStyle[newName] = itemStyle[oldName]

          if ('development' !== 'production') {
            deprecateReplaceLog(oldName, newName)
          }
        }
      }
    }
  }

  function compatPieLabel (option) {
    if (!option) {
      return
    }

    if (option.alignTo === 'edge' && option.margin != null && option.edgeDistance == null) {
      if ('development' !== 'production') {
        deprecateReplaceLog('label.margin', 'label.edgeDistance', 'pie')
      }

      option.edgeDistance = option.margin
    }
  }

  function compatSunburstState (option) {
    if (!option) {
      return
    }

    if (option.downplay && !option.blur) {
      option.blur = option.downplay

      if ('development' !== 'production') {
        deprecateReplaceLog('downplay', 'blur', 'sunburst')
      }
    }
  }

  function compatGraphFocus (option) {
    if (!option) {
      return
    }

    if (option.focusNodeAdjacency != null) {
      option.emphasis = option.emphasis || {}

      if (option.emphasis.focus == null) {
        if ('development' !== 'production') {
          deprecateReplaceLog('focusNodeAdjacency', 'emphasis: { focus: \'adjacency\'}', 'graph/sankey')
        }

        option.emphasis.focus = 'adjacency'
      }
    }
  }

  function traverseTree (data, cb) {
    if (data) {
      for (let i = 0; i < data.length; i++) {
        cb(data[i])
        data[i] && traverseTree(data[i].children, cb)
      }
    }
  }

  function globalBackwardCompat (option, isTheme) {
    globalCompatStyle(option, isTheme) // Make sure series array for model initialization.

    option.series = normalizeToArray(option.series)
    each(option.series, function (seriesOpt) {
      if (!isObject(seriesOpt)) {
        return
      }

      const seriesType = seriesOpt.type

      if (seriesType === 'line') {
        if (seriesOpt.clipOverflow != null) {
          seriesOpt.clip = seriesOpt.clipOverflow

          if ('development' !== 'production') {
            deprecateReplaceLog('clipOverflow', 'clip', 'line')
          }
        }
      } else if (seriesType === 'pie' || seriesType === 'gauge') {
        if (seriesOpt.clockWise != null) {
          seriesOpt.clockwise = seriesOpt.clockWise

          if ('development' !== 'production') {
            deprecateReplaceLog('clockWise', 'clockwise')
          }
        }

        compatPieLabel(seriesOpt.label)
        var data = seriesOpt.data

        if (data && !isTypedArray(data)) {
          for (var i = 0; i < data.length; i++) {
            compatPieLabel(data[i])
          }
        }

        if (seriesOpt.hoverOffset != null) {
          seriesOpt.emphasis = seriesOpt.emphasis || {}

          if (seriesOpt.emphasis.scaleSize = null) {
            if ('development' !== 'production') {
              deprecateReplaceLog('hoverOffset', 'emphasis.scaleSize')
            }

            seriesOpt.emphasis.scaleSize = seriesOpt.hoverOffset
          }
        }
      } else if (seriesType === 'gauge') {
        const pointerColor = get(seriesOpt, 'pointer.color')
        pointerColor != null && set$1(seriesOpt, 'itemStyle.color', pointerColor)
      } else if (seriesType === 'bar') {
        compatBarItemStyle(seriesOpt)
        compatBarItemStyle(seriesOpt.backgroundStyle)
        compatBarItemStyle(seriesOpt.emphasis)
        var data = seriesOpt.data

        if (data && !isTypedArray(data)) {
          for (var i = 0; i < data.length; i++) {
            if (typeof data[i] === 'object') {
              compatBarItemStyle(data[i])
              compatBarItemStyle(data[i] && data[i].emphasis)
            }
          }
        }
      } else if (seriesType === 'sunburst') {
        const highlightPolicy = seriesOpt.highlightPolicy

        if (highlightPolicy) {
          seriesOpt.emphasis = seriesOpt.emphasis || {}

          if (!seriesOpt.emphasis.focus) {
            seriesOpt.emphasis.focus = highlightPolicy

            if ('development' !== 'production') {
              deprecateReplaceLog('highlightPolicy', 'emphasis.focus', 'sunburst')
            }
          }
        }

        compatSunburstState(seriesOpt)
        traverseTree(seriesOpt.data, compatSunburstState)
      } else if (seriesType === 'graph' || seriesType === 'sankey') {
        compatGraphFocus(seriesOpt) // TODO nodes, edges?
      } else if (seriesType === 'map') {
        if (seriesOpt.mapType && !seriesOpt.map) {
          if ('development' !== 'production') {
            deprecateReplaceLog('mapType', 'map', 'map')
          }

          seriesOpt.map = seriesOpt.mapType
        }

        if (seriesOpt.mapLocation) {
          if ('development' !== 'production') {
            deprecateLog('`mapLocation` is not used anymore.')
          }

          defaults(seriesOpt, seriesOpt.mapLocation)
        }
      }

      if (seriesOpt.hoverAnimation != null) {
        seriesOpt.emphasis = seriesOpt.emphasis || {}

        if (seriesOpt.emphasis && seriesOpt.emphasis.scale == null) {
          if ('development' !== 'production') {
            deprecateReplaceLog('hoverAnimation', 'emphasis.scale')
          }

          seriesOpt.emphasis.scale = seriesOpt.hoverAnimation
        }
      }

      compatLayoutProperties(seriesOpt)
    }) // dataRange has changed to visualMap

    if (option.dataRange) {
      option.visualMap = option.dataRange
    }

    each(COMPATITABLE_COMPONENTS, function (componentName) {
      let options = option[componentName]

      if (options) {
        if (!isArray(options)) {
          options = [options]
        }

        each(options, function (option) {
          compatLayoutProperties(option)
        })
      }
    })
  }

  //     data processing stage is blocked in stream.
  //     See <module:echarts/stream/Scheduler#performDataProcessorTasks>
  // (2) Only register once when import repeatedly.
  //     Should be executed after series is filtered and before stack calculation.

  function dataStack (ecModel) {
    const stackInfoMap = createHashMap()
    ecModel.eachSeries(function (seriesModel) {
      const stack = seriesModel.get('stack') // Compatible: when `stack` is set as '', do not stack.

      if (stack) {
        const stackInfoList = stackInfoMap.get(stack) || stackInfoMap.set(stack, [])
        const data = seriesModel.getData()
        const stackInfo = {
          // Used for calculate axis extent automatically.
          // TODO: Type getCalculationInfo return more specific type?
          stackResultDimension: data.getCalculationInfo('stackResultDimension'),
          stackedOverDimension: data.getCalculationInfo('stackedOverDimension'),
          stackedDimension: data.getCalculationInfo('stackedDimension'),
          stackedByDimension: data.getCalculationInfo('stackedByDimension'),
          isStackedByIndex: data.getCalculationInfo('isStackedByIndex'),
          data: data,
          seriesModel: seriesModel
        } // If stacked on axis that do not support data stack.

        if (!stackInfo.stackedDimension || !(stackInfo.isStackedByIndex || stackInfo.stackedByDimension)) {
          return
        }

        stackInfoList.length && data.setCalculationInfo('stackedOnSeries', stackInfoList[stackInfoList.length - 1].seriesModel)
        stackInfoList.push(stackInfo)
      }
    })
    stackInfoMap.each(calculateStack)
  }

  function calculateStack (stackInfoList) {
    each(stackInfoList, function (targetStackInfo, idxInStack) {
      const resultVal = []
      const resultNaN = [NaN, NaN]
      const dims = [targetStackInfo.stackResultDimension, targetStackInfo.stackedOverDimension]
      const targetData = targetStackInfo.data
      const isStackedByIndex = targetStackInfo.isStackedByIndex
      const stackStrategy = targetStackInfo.seriesModel.get('stackStrategy') || 'samesign' // Should not write on raw data, because stack series model list changes
      // depending on legend selection.

      targetData.modify(dims, function (v0, v1, dataIndex) {
        let sum = targetData.get(targetStackInfo.stackedDimension, dataIndex) // Consider `connectNulls` of line area, if value is NaN, stackedOver
        // should also be NaN, to draw a appropriate belt area.

        if (isNaN(sum)) {
          return resultNaN
        }

        let byValue
        let stackedDataRawIndex

        if (isStackedByIndex) {
          stackedDataRawIndex = targetData.getRawIndex(dataIndex)
        } else {
          byValue = targetData.get(targetStackInfo.stackedByDimension, dataIndex)
        } // If stackOver is NaN, chart view will render point on value start.

        let stackedOver = NaN

        for (let j = idxInStack - 1; j >= 0; j--) {
          const stackInfo = stackInfoList[j] // Has been optimized by inverted indices on `stackedByDimension`.

          if (!isStackedByIndex) {
            stackedDataRawIndex = stackInfo.data.rawIndexOf(stackInfo.stackedByDimension, byValue)
          }

          if (stackedDataRawIndex >= 0) {
            const val = stackInfo.data.getByRawIndex(stackInfo.stackResultDimension, stackedDataRawIndex) // Considering positive stack, negative stack and empty data

            if (stackStrategy === 'all' || // single stack group
              stackStrategy === 'positive' && val > 0 || stackStrategy === 'negative' && val < 0 || stackStrategy === 'samesign' && sum >= 0 && val > 0 || // All positive stack
              stackStrategy === 'samesign' && sum <= 0 && val < 0 // All negative stack
            ) {
              // The sum has to be very small to be affected by the
              // floating arithmetic problem. An incorrect result will probably
              // cause axis min/max to be filtered incorrectly.
              sum = addSafe(sum, val)
              stackedOver = val
              break
            }
          }
        }

        resultVal[0] = sum
        resultVal[1] = stackedOver
        return resultVal
      })
    })
  }

  const SourceImpl =
    /** @class */
    (function () {
      function SourceImpl (fields) {
        this.data = fields.data || (fields.sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS ? {} : [])
        this.sourceFormat = fields.sourceFormat || SOURCE_FORMAT_UNKNOWN // Visit config

        this.seriesLayoutBy = fields.seriesLayoutBy || SERIES_LAYOUT_BY_COLUMN
        this.startIndex = fields.startIndex || 0
        this.dimensionsDetectedCount = fields.dimensionsDetectedCount
        this.metaRawOption = fields.metaRawOption
        const dimensionsDefine = this.dimensionsDefine = fields.dimensionsDefine

        if (dimensionsDefine) {
          for (let i = 0; i < dimensionsDefine.length; i++) {
            const dim = dimensionsDefine[i]

            if (dim.type == null) {
              if (guessOrdinal(this, i) === BE_ORDINAL.Must) {
                dim.type = 'ordinal'
              }
            }
          }
        }
      }

      return SourceImpl
    }())

  function isSourceInstance (val) {
    return val instanceof SourceImpl
  }
  /**
     * Create a source from option.
     * NOTE: Created source is immutable. Don't change any properties in it.
     */

  function createSource (sourceData, thisMetaRawOption, // can be null. If not provided, auto detect it from `sourceData`.
    sourceFormat) {
    sourceFormat = sourceFormat || detectSourceFormat(sourceData)
    const seriesLayoutBy = thisMetaRawOption.seriesLayoutBy
    const determined = determineSourceDimensions(sourceData, sourceFormat, seriesLayoutBy, thisMetaRawOption.sourceHeader, thisMetaRawOption.dimensions)
    const source = new SourceImpl({
      data: sourceData,
      sourceFormat: sourceFormat,
      seriesLayoutBy: seriesLayoutBy,
      dimensionsDefine: determined.dimensionsDefine,
      startIndex: determined.startIndex,
      dimensionsDetectedCount: determined.dimensionsDetectedCount,
      metaRawOption: clone(thisMetaRawOption)
    })
    return source
  }
  /**
     * Wrap original series data for some compatibility cases.
     */

  function createSourceFromSeriesDataOption (data) {
    return new SourceImpl({
      data: data,
      sourceFormat: isTypedArray(data) ? SOURCE_FORMAT_TYPED_ARRAY : SOURCE_FORMAT_ORIGINAL
    })
  }
  /**
     * Clone source but excludes source data.
     */

  function cloneSourceShallow (source) {
    return new SourceImpl({
      data: source.data,
      sourceFormat: source.sourceFormat,
      seriesLayoutBy: source.seriesLayoutBy,
      dimensionsDefine: clone(source.dimensionsDefine),
      startIndex: source.startIndex,
      dimensionsDetectedCount: source.dimensionsDetectedCount
    })
  }
  /**
     * Note: An empty array will be detected as `SOURCE_FORMAT_ARRAY_ROWS`.
     */

  function detectSourceFormat (data) {
    let sourceFormat = SOURCE_FORMAT_UNKNOWN

    if (isTypedArray(data)) {
      sourceFormat = SOURCE_FORMAT_TYPED_ARRAY
    } else if (isArray(data)) {
      // FIXME Whether tolerate null in top level array?
      if (data.length === 0) {
        sourceFormat = SOURCE_FORMAT_ARRAY_ROWS
      }

      for (let i = 0, len = data.length; i < len; i++) {
        const item = data[i]

        if (item == null) {
          continue
        } else if (isArray(item)) {
          sourceFormat = SOURCE_FORMAT_ARRAY_ROWS
          break
        } else if (isObject(item)) {
          sourceFormat = SOURCE_FORMAT_OBJECT_ROWS
          break
        }
      }
    } else if (isObject(data)) {
      for (const key in data) {
        if (hasOwn(data, key) && isArrayLike(data[key])) {
          sourceFormat = SOURCE_FORMAT_KEYED_COLUMNS
          break
        }
      }
    }

    return sourceFormat
  }
  /**
     * Determine the source definitions from data standalone dimensions definitions
     * are not specified.
     */

  function determineSourceDimensions (data, sourceFormat, seriesLayoutBy, sourceHeader, // standalone raw dimensions definition, like:
    // {
    //     dimensions: ['aa', 'bb', { name: 'cc', type: 'time' }]
    // }
    // in `dataset` or `series`
    dimensionsDefine) {
    let dimensionsDetectedCount
    let startIndex // PEDING: could data be null/undefined here?
    // currently, if `dataset.source` not specified, error thrown.
    // if `series.data` not specified, nothing rendered without error thrown.
    // Should test these cases.

    if (!data) {
      return {
        dimensionsDefine: normalizeDimensionsOption(dimensionsDefine),
        startIndex: startIndex,
        dimensionsDetectedCount: dimensionsDetectedCount
      }
    }

    if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {
      const dataArrayRows = data // Rule: Most of the first line are string: it is header.
      // Caution: consider a line with 5 string and 1 number,
      // it still can not be sure it is a head, because the
      // 5 string may be 5 values of category columns.

      if (sourceHeader === 'auto' || sourceHeader == null) {
        arrayRowsTravelFirst(function (val) {
          // '-' is regarded as null/undefined.
          if (val != null && val !== '-') {
            if (isString(val)) {
              startIndex == null && (startIndex = 1)
            } else {
              startIndex = 0
            }
          } // 10 is an experience number, avoid long loop.
        }, seriesLayoutBy, dataArrayRows, 10)
      } else {
        startIndex = isNumber(sourceHeader) ? sourceHeader : sourceHeader ? 1 : 0
      }

      if (!dimensionsDefine && startIndex === 1) {
        dimensionsDefine = []
        arrayRowsTravelFirst(function (val, index) {
          dimensionsDefine[index] = val != null ? val + '' : ''
        }, seriesLayoutBy, dataArrayRows, Infinity)
      }

      dimensionsDetectedCount = dimensionsDefine ? dimensionsDefine.length : seriesLayoutBy === SERIES_LAYOUT_BY_ROW ? dataArrayRows.length : dataArrayRows[0] ? dataArrayRows[0].length : null
    } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {
      if (!dimensionsDefine) {
        dimensionsDefine = objectRowsCollectDimensions(data)
      }
    } else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {
      if (!dimensionsDefine) {
        dimensionsDefine = []
        each(data, function (colArr, key) {
          dimensionsDefine.push(key)
        })
      }
    } else if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {
      const value0 = getDataItemValue(data[0])
      dimensionsDetectedCount = isArray(value0) && value0.length || 1
    } else if (sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {
      if ('development' !== 'production') {
        assert(!!dimensionsDefine, 'dimensions must be given if data is TypedArray.')
      }
    }

    return {
      startIndex: startIndex,
      dimensionsDefine: normalizeDimensionsOption(dimensionsDefine),
      dimensionsDetectedCount: dimensionsDetectedCount
    }
  }

  function objectRowsCollectDimensions (data) {
    let firstIndex = 0
    let obj

    while (firstIndex < data.length && !(obj = data[firstIndex++])) {} // jshint ignore: line

    if (obj) {
      const dimensions_1 = []
      each(obj, function (value, key) {
        dimensions_1.push(key)
      })
      return dimensions_1
    }
  } // Consider dimensions defined like ['A', 'price', 'B', 'price', 'C', 'price'],
  // which is reasonable. But dimension name is duplicated.
  // Returns undefined or an array contains only object without null/undefiend or string.

  function normalizeDimensionsOption (dimensionsDefine) {
    if (!dimensionsDefine) {
      // The meaning of null/undefined is different from empty array.
      return
    }

    const nameMap = createHashMap()
    return map(dimensionsDefine, function (rawItem, index) {
      rawItem = isObject(rawItem)
        ? rawItem
        : {
            name: rawItem
          } // Other fields will be discarded.

      const item = {
        name: rawItem.name,
        displayName: rawItem.displayName,
        type: rawItem.type
      } // User can set null in dimensions.
      // We dont auto specify name, othewise a given name may
      // cause it be refered unexpectedly.

      if (item.name == null) {
        return item
      } // Also consider number form like 2012.

      item.name += '' // User may also specify displayName.
      // displayName will always exists except user not
      // specified or dim name is not specified or detected.
      // (A auto generated dim name will not be used as
      // displayName).

      if (item.displayName == null) {
        item.displayName = item.name
      }

      const exist = nameMap.get(item.name)

      if (!exist) {
        nameMap.set(item.name, {
          count: 1
        })
      } else {
        item.name += '-' + exist.count++
      }

      return item
    })
  }

  function arrayRowsTravelFirst (cb, seriesLayoutBy, data, maxLoop) {
    if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW) {
      for (var i = 0; i < data.length && i < maxLoop; i++) {
        cb(data[i] ? data[i][0] : null, i)
      }
    } else {
      const value0 = data[0] || []

      for (var i = 0; i < value0.length && i < maxLoop; i++) {
        cb(value0[i], i)
      }
    }
  }

  function shouldRetrieveDataByName (source) {
    const sourceFormat = source.sourceFormat
    return sourceFormat === SOURCE_FORMAT_OBJECT_ROWS || sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS
  }

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

  /**
     * AUTO-GENERATED FILE. DO NOT MODIFY.
     */

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
  let _a, _b, _c // TODO
  let providerMethods
  let mountMethods
  /**
     * If normal array used, mutable chunk size is supported.
     * If typed array used, chunk size must be fixed.
     */

  const DefaultDataProvider =
    /** @class */
    (function () {
      function DefaultDataProvider (sourceParam, dimSize) {
        // let source: Source;
        const source = !isSourceInstance(sourceParam) ? createSourceFromSeriesDataOption(sourceParam) : sourceParam // declare source is Source;

        this._source = source
        const data = this._data = source.data // Typed array. TODO IE10+?

        if (source.sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {
          if ('development' !== 'production') {
            if (dimSize == null) {
              throw new Error('Typed array data must specify dimension size')
            }
          }

          this._offset = 0
          this._dimSize = dimSize
          this._data = data
        }

        mountMethods(this, data, source)
      }

      DefaultDataProvider.prototype.getSource = function () {
        return this._source
      }

      DefaultDataProvider.prototype.count = function () {
        return 0
      }

      DefaultDataProvider.prototype.getItem = function (idx, out) {

      }

      DefaultDataProvider.prototype.appendData = function (newData) {}

      DefaultDataProvider.prototype.clean = function () {}

      DefaultDataProvider.protoInitialize = (function () {
        // PENDING: To avoid potential incompat (e.g., prototype
        // is visited somewhere), still init them on prototype.
        const proto = DefaultDataProvider.prototype
        proto.pure = false
        proto.persistent = true
      }())

      DefaultDataProvider.internalField = (function () {
        let _a

        mountMethods = function (provider, data, source) {
          const sourceFormat = source.sourceFormat
          const seriesLayoutBy = source.seriesLayoutBy
          const startIndex = source.startIndex
          const dimsDef = source.dimensionsDefine
          const methods = providerMethods[getMethodMapKey(sourceFormat, seriesLayoutBy)]

          if ('development' !== 'production') {
            assert(methods, 'Invalide sourceFormat: ' + sourceFormat)
          }

          extend(provider, methods)

          if (sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {
            provider.getItem = getItemForTypedArray
            provider.count = countForTypedArray
            provider.fillStorage = fillStorageForTypedArray
          } else {
            const rawItemGetter = getRawSourceItemGetter(sourceFormat, seriesLayoutBy)
            provider.getItem = bind(rawItemGetter, null, data, startIndex, dimsDef)
            const rawCounter = getRawSourceDataCounter(sourceFormat, seriesLayoutBy)
            provider.count = bind(rawCounter, null, data, startIndex, dimsDef)
          }
        }

        var getItemForTypedArray = function (idx, out) {
          idx = idx - this._offset
          out = out || []
          const data = this._data
          const dimSize = this._dimSize
          const offset = dimSize * idx

          for (let i = 0; i < dimSize; i++) {
            out[i] = data[offset + i]
          }

          return out
        }

        var fillStorageForTypedArray = function (start, end, storage, extent) {
          const data = this._data
          const dimSize = this._dimSize

          for (let dim = 0; dim < dimSize; dim++) {
            const dimExtent = extent[dim]
            let min = dimExtent[0] == null ? Infinity : dimExtent[0]
            let max = dimExtent[1] == null ? -Infinity : dimExtent[1]
            const count = end - start
            const arr = storage[dim]

            for (let i = 0; i < count; i++) {
              // appendData with TypedArray will always do replace in provider.
              const val = data[i * dimSize + dim]
              arr[start + i] = val
              val < min && (min = val)
              val > max && (max = val)
            }

            dimExtent[0] = min
            dimExtent[1] = max
          }
        }

        var countForTypedArray = function () {
          return this._data ? this._data.length / this._dimSize : 0
        }

        providerMethods = (_a = {}, _a[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_COLUMN] = {
          pure: true,
          appendData: appendDataSimply
        }, _a[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_ROW] = {
          pure: true,
          appendData: function () {
            throw new Error('Do not support appendData when set seriesLayoutBy: "row".')
          }
        }, _a[SOURCE_FORMAT_OBJECT_ROWS] = {
          pure: true,
          appendData: appendDataSimply
        }, _a[SOURCE_FORMAT_KEYED_COLUMNS] = {
          pure: true,
          appendData: function (newData) {
            const data = this._data
            each(newData, function (newCol, key) {
              const oldCol = data[key] || (data[key] = [])

              for (let i = 0; i < (newCol || []).length; i++) {
                oldCol.push(newCol[i])
              }
            })
          }
        }, _a[SOURCE_FORMAT_ORIGINAL] = {
          appendData: appendDataSimply
        }, _a[SOURCE_FORMAT_TYPED_ARRAY] = {
          persistent: false,
          pure: true,
          appendData: function (newData) {
            if ('development' !== 'production') {
              assert(isTypedArray(newData), 'Added data must be TypedArray if data in initialization is TypedArray')
            }

            this._data = newData
          },
          // Clean self if data is already used.
          clean: function () {
            // PENDING
            this._offset += this.count()
            this._data = null
          }
        }, _a)

        function appendDataSimply (newData) {
          for (let i = 0; i < newData.length; i++) {
            this._data.push(newData[i])
          }
        }
      }())

      return DefaultDataProvider
    }())

  const getItemSimply = function (rawData, startIndex, dimsDef, idx) {
    return rawData[idx]
  }

  const rawSourceItemGetterMap = (_a = {}, _a[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_COLUMN] = function (rawData, startIndex, dimsDef, idx) {
    return rawData[idx + startIndex]
  }, _a[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_ROW] = function (rawData, startIndex, dimsDef, idx, out) {
    idx += startIndex
    const item = out || []
    const data = rawData

    for (let i = 0; i < data.length; i++) {
      const row = data[i]
      item[i] = row ? row[idx] : null
    }

    return item
  }, _a[SOURCE_FORMAT_OBJECT_ROWS] = getItemSimply, _a[SOURCE_FORMAT_KEYED_COLUMNS] = function (rawData, startIndex, dimsDef, idx, out) {
    const item = out || []

    for (let i = 0; i < dimsDef.length; i++) {
      const dimName = dimsDef[i].name

      if ('development' !== 'production') {
        if (dimName == null) {
          throw new Error()
        }
      }

      const col = rawData[dimName]
      item[i] = col ? col[idx] : null
    }

    return item
  }, _a[SOURCE_FORMAT_ORIGINAL] = getItemSimply, _a)
  function getRawSourceItemGetter (sourceFormat, seriesLayoutBy) {
    const method = rawSourceItemGetterMap[getMethodMapKey(sourceFormat, seriesLayoutBy)]

    if ('development' !== 'production') {
      assert(method, 'Do not support get item on "' + sourceFormat + '", "' + seriesLayoutBy + '".')
    }

    return method
  }

  const countSimply = function (rawData, startIndex, dimsDef) {
    return rawData.length
  }

  const rawSourceDataCounterMap = (_b = {}, _b[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_COLUMN] = function (rawData, startIndex, dimsDef) {
    return Math.max(0, rawData.length - startIndex)
  }, _b[SOURCE_FORMAT_ARRAY_ROWS + '_' + SERIES_LAYOUT_BY_ROW] = function (rawData, startIndex, dimsDef) {
    const row = rawData[0]
    return row ? Math.max(0, row.length - startIndex) : 0
  }, _b[SOURCE_FORMAT_OBJECT_ROWS] = countSimply, _b[SOURCE_FORMAT_KEYED_COLUMNS] = function (rawData, startIndex, dimsDef) {
    const dimName = dimsDef[0].name

    if ('development' !== 'production') {
      if (dimName == null) {
        throw new Error()
      }
    }

    const col = rawData[dimName]
    return col ? col.length : 0
  }, _b[SOURCE_FORMAT_ORIGINAL] = countSimply, _b)
  function getRawSourceDataCounter (sourceFormat, seriesLayoutBy) {
    const method = rawSourceDataCounterMap[getMethodMapKey(sourceFormat, seriesLayoutBy)]

    if ('development' !== 'production') {
      assert(method, 'Do not suppport count on "' + sourceFormat + '", "' + seriesLayoutBy + '".')
    }

    return method
  }

  const getRawValueSimply = function (dataItem, dimIndex, property) {
    return dataItem[dimIndex]
  }

  const rawSourceValueGetterMap = (_c = {}, _c[SOURCE_FORMAT_ARRAY_ROWS] = getRawValueSimply, _c[SOURCE_FORMAT_OBJECT_ROWS] = function (dataItem, dimIndex, property) {
    return dataItem[property]
  }, _c[SOURCE_FORMAT_KEYED_COLUMNS] = getRawValueSimply, _c[SOURCE_FORMAT_ORIGINAL] = function (dataItem, dimIndex, property) {
    // FIXME: In some case (markpoint in geo (geo-map.html)),
    // dataItem is {coord: [...]}
    const value = getDataItemValue(dataItem)
    return !(value instanceof Array) ? value : value[dimIndex]
  }, _c[SOURCE_FORMAT_TYPED_ARRAY] = getRawValueSimply, _c)
  function getRawSourceValueGetter (sourceFormat) {
    const method = rawSourceValueGetterMap[sourceFormat]

    if ('development' !== 'production') {
      assert(method, 'Do not suppport get value on "' + sourceFormat + '".')
    }

    return method
  }

  function getMethodMapKey (sourceFormat, seriesLayoutBy) {
    return sourceFormat === SOURCE_FORMAT_ARRAY_ROWS ? sourceFormat + '_' + seriesLayoutBy : sourceFormat
  } // ??? FIXME can these logic be more neat: getRawValue, getRawDataItem,
  // Consider persistent.
  // Caution: why use raw value to display on label or tooltip?
  // A reason is to avoid format. For example time value we do not know
  // how to format is expected. More over, if stack is used, calculated
  // value may be 0.91000000001, which have brings trouble to display.
  // TODO: consider how to treat null/undefined/NaN when display?

  function retrieveRawValue (data, dataIndex, // If dimIndex is null/undefined, return OptionDataItem.
    // Otherwise, return OptionDataValue.
    dim) {
    if (!data) {
      return
    } // Consider data may be not persistent.

    const dataItem = data.getRawDataItem(dataIndex)

    if (dataItem == null) {
      return
    }

    const store = data.getStore()
    const sourceFormat = store.getSource().sourceFormat

    if (dim != null) {
      const dimIndex = data.getDimensionIndex(dim)
      const property = store.getDimensionProperty(dimIndex)
      return getRawSourceValueGetter(sourceFormat)(dataItem, dimIndex, property)
    } else {
      let result = dataItem

      if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {
        result = getDataItemValue(dataItem)
      }

      return result
    }
  }

  const DIMENSION_LABEL_REG = /\{@(.+?)\}/g

  const DataFormatMixin =
    /** @class */
    (function () {
      function DataFormatMixin () {}
      /**
       * Get params for formatter
       */

      DataFormatMixin.prototype.getDataParams = function (dataIndex, dataType) {
        const data = this.getData(dataType)
        const rawValue = this.getRawValue(dataIndex, dataType)
        const rawDataIndex = data.getRawIndex(dataIndex)
        const name = data.getName(dataIndex)
        const itemOpt = data.getRawDataItem(dataIndex)
        const style = data.getItemVisual(dataIndex, 'style')
        const color = style && style[data.getItemVisual(dataIndex, 'drawType') || 'fill']
        const borderColor = style && style.stroke
        const mainType = this.mainType
        const isSeries = mainType === 'series'
        const userOutput = data.userOutput && data.userOutput.get()
        return {
          componentType: mainType,
          componentSubType: this.subType,
          componentIndex: this.componentIndex,
          seriesType: isSeries ? this.subType : null,
          seriesIndex: this.seriesIndex,
          seriesId: isSeries ? this.id : null,
          seriesName: isSeries ? this.name : null,
          name: name,
          dataIndex: rawDataIndex,
          data: itemOpt,
          dataType: dataType,
          value: rawValue,
          color: color,
          borderColor: borderColor,
          dimensionNames: userOutput ? userOutput.fullDimensions : null,
          encode: userOutput ? userOutput.encode : null,
          // Param name list for mapping `a`, `b`, `c`, `d`, `e`
          $vars: ['seriesName', 'name', 'value']
        }
      }
      /**
       * Format label
       * @param dataIndex
       * @param status 'normal' by default
       * @param dataType
       * @param labelDimIndex Only used in some chart that
       *        use formatter in different dimensions, like radar.
       * @param formatter Formatter given outside.
       * @return return null/undefined if no formatter
       */

      DataFormatMixin.prototype.getFormattedLabel = function (dataIndex, status, dataType, labelDimIndex, formatter, extendParams) {
        status = status || 'normal'
        const data = this.getData(dataType)
        const params = this.getDataParams(dataIndex, dataType)

        if (extendParams) {
          params.value = extendParams.interpolatedValue
        }

        if (labelDimIndex != null && isArray(params.value)) {
          params.value = params.value[labelDimIndex]
        }

        if (!formatter) {
          const itemModel = data.getItemModel(dataIndex) // @ts-ignore

          formatter = itemModel.get(status === 'normal' ? ['label', 'formatter'] : [status, 'label', 'formatter'])
        }

        if (isFunction(formatter)) {
          params.status = status
          params.dimensionIndex = labelDimIndex
          return formatter(params)
        } else if (isString(formatter)) {
          const str = formatTpl(formatter, params) // Support 'aaa{@[3]}bbb{@product}ccc'.
          // Do not support '}' in dim name util have to.

          return str.replace(DIMENSION_LABEL_REG, function (origin, dimStr) {
            const len = dimStr.length
            let dimLoose = dimStr

            if (dimLoose.charAt(0) === '[' && dimLoose.charAt(len - 1) === ']') {
              dimLoose = +dimLoose.slice(1, len - 1) // Also support: '[]' => 0

              if ('development' !== 'production') {
                if (isNaN(dimLoose)) {
                  error('Invalide label formatter: @' + dimStr + ', only support @[0], @[1], @[2], ...')
                }
              }
            }

            let val = retrieveRawValue(data, dataIndex, dimLoose)

            if (extendParams && isArray(extendParams.interpolatedValue)) {
              const dimIndex = data.getDimensionIndex(dimLoose)

              if (dimIndex >= 0) {
                val = extendParams.interpolatedValue[dimIndex]
              }
            }

            return val != null ? val + '' : ''
          })
        }
      }
      /**
       * Get raw value in option
       */

      DataFormatMixin.prototype.getRawValue = function (idx, dataType) {
        return retrieveRawValue(this.getData(dataType), idx)
      }
      /**
       * Should be implemented.
       * @param {number} dataIndex
       * @param {boolean} [multipleSeries=false]
       * @param {string} [dataType]
       */

      DataFormatMixin.prototype.formatTooltip = function (dataIndex, multipleSeries, dataType) {
        // Empty function

      }

      return DataFormatMixin
    }())
    // but guess little chance has been used outside. Do we need to backward
    // compat it?
    // type TooltipFormatResultLegacyObject = {
    //     // `html` means the markup language text, either in 'html' or 'richText'.
    //     // The name `html` is not appropriate becuase in 'richText' it is not a HTML
    //     // string. But still support it for backward compat.
    //     html: string;
    //     markers: Dictionary<ColorString>;
    // };

  /**
     * For backward compat, normalize the return from `formatTooltip`.
     */

  function normalizeTooltipFormatResult (result) {
    let markupText // let markers: Dictionary<ColorString>;

    let markupFragment

    if (isObject(result)) {
      if (result.type) {
        markupFragment = result
      } else {
        if ('development' !== 'production') {
          console.warn('The return type of `formatTooltip` is not supported: ' + makePrintable(result))
        }
      } // else {
      //     markupText = (result as TooltipFormatResultLegacyObject).html;
      //     markers = (result as TooltipFormatResultLegacyObject).markers;
      //     if (markersExisting) {
      //         markers = zrUtil.merge(markersExisting, markers);
      //     }
      // }
    } else {
      markupText = result
    }

    return {
      text: markupText,
      // markers: markers || markersExisting,
      frag: markupFragment
    }
  }

  /**
     * @param {Object} define
     * @return See the return of `createTask`.
     */

  function createTask (define) {
    return new Task(define)
  }

  var Task =
    /** @class */
    (function () {
      function Task (define) {
        define = define || {}
        this._reset = define.reset
        this._plan = define.plan
        this._count = define.count
        this._onDirty = define.onDirty
        this._dirty = true
      }
      /**
       * @param step Specified step.
       * @param skip Skip customer perform call.
       * @param modBy Sampling window size.
       * @param modDataCount Sampling count.
       * @return whether unfinished.
       */

      Task.prototype.perform = function (performArgs) {
        const upTask = this._upstream
        const skip = performArgs && performArgs.skip // TODO some refactor.
        // Pull data. Must pull data each time, because context.data
        // may be updated by Series.setData.

        if (this._dirty && upTask) {
          const context = this.context
          context.data = context.outputData = upTask.context.outputData
        }

        if (this.__pipeline) {
          this.__pipeline.currentTask = this
        }

        let planResult

        if (this._plan && !skip) {
          planResult = this._plan(this.context)
        } // Support sharding by mod, which changes the render sequence and makes the rendered graphic
        // elements uniformed distributed when progress, especially when moving or zooming.

        const lastModBy = normalizeModBy(this._modBy)
        const lastModDataCount = this._modDataCount || 0
        const modBy = normalizeModBy(performArgs && performArgs.modBy)
        const modDataCount = performArgs && performArgs.modDataCount || 0

        if (lastModBy !== modBy || lastModDataCount !== modDataCount) {
          planResult = 'reset'
        }

        function normalizeModBy (val) {
          !(val >= 1) && (val = 1) // jshint ignore:line

          return val
        }

        let forceFirstProgress

        if (this._dirty || planResult === 'reset') {
          this._dirty = false
          forceFirstProgress = this._doReset(skip)
        }

        this._modBy = modBy
        this._modDataCount = modDataCount
        const step = performArgs && performArgs.step

        if (upTask) {
          if ('development' !== 'production') {
            assert(upTask._outputDueEnd != null)
          }

          this._dueEnd = upTask._outputDueEnd
        } // DataTask or overallTask
        else {
          if ('development' !== 'production') {
            assert(!this._progress || this._count)
          }

          this._dueEnd = this._count ? this._count(this.context) : Infinity
        } // Note: Stubs, that its host overall task let it has progress, has progress.
        // If no progress, pass index from upstream to downstream each time plan called.

        if (this._progress) {
          const start = this._dueIndex
          const end = Math.min(step != null ? this._dueIndex + step : Infinity, this._dueEnd)

          if (!skip && (forceFirstProgress || start < end)) {
            const progress = this._progress

            if (isArray(progress)) {
              for (let i = 0; i < progress.length; i++) {
                this._doProgress(progress[i], start, end, modBy, modDataCount)
              }
            } else {
              this._doProgress(progress, start, end, modBy, modDataCount)
            }
          }

          this._dueIndex = end // If no `outputDueEnd`, assume that output data and
          // input data is the same, so use `dueIndex` as `outputDueEnd`.

          const outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : end

          if ('development' !== 'production') {
            // ??? Can not rollback.
            assert(outputDueEnd >= this._outputDueEnd)
          }

          this._outputDueEnd = outputDueEnd
        } else {
          // (1) Some overall task has no progress.
          // (2) Stubs, that its host overall task do not let it has progress, has no progress.
          // This should always be performed so it can be passed to downstream.
          this._dueIndex = this._outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : this._dueEnd
        }

        return this.unfinished()
      }

      Task.prototype.dirty = function () {
        this._dirty = true
        this._onDirty && this._onDirty(this.context)
      }

      Task.prototype._doProgress = function (progress, start, end, modBy, modDataCount) {
        iterator.reset(start, end, modBy, modDataCount)
        this._callingProgress = progress

        this._callingProgress({
          start: start,
          end: end,
          count: end - start,
          next: iterator.next
        }, this.context)
      }

      Task.prototype._doReset = function (skip) {
        this._dueIndex = this._outputDueEnd = this._dueEnd = 0
        this._settedOutputEnd = null
        let progress
        let forceFirstProgress

        if (!skip && this._reset) {
          progress = this._reset(this.context)

          if (progress && progress.progress) {
            forceFirstProgress = progress.forceFirstProgress
            progress = progress.progress
          } // To simplify no progress checking, array must has item.

          if (isArray(progress) && !progress.length) {
            progress = null
          }
        }

        this._progress = progress
        this._modBy = this._modDataCount = null
        const downstream = this._downstream
        downstream && downstream.dirty()
        return forceFirstProgress
      }

      Task.prototype.unfinished = function () {
        return this._progress && this._dueIndex < this._dueEnd
      }
      /**
       * @param downTask The downstream task.
       * @return The downstream task.
       */

      Task.prototype.pipe = function (downTask) {
        if ('development' !== 'production') {
          assert(downTask && !downTask._disposed && downTask !== this)
        } // If already downstream, do not dirty downTask.

        if (this._downstream !== downTask || this._dirty) {
          this._downstream = downTask
          downTask._upstream = this
          downTask.dirty()
        }
      }

      Task.prototype.dispose = function () {
        if (this._disposed) {
          return
        }

        this._upstream && (this._upstream._downstream = null)
        this._downstream && (this._downstream._upstream = null)
        this._dirty = false
        this._disposed = true
      }

      Task.prototype.getUpstream = function () {
        return this._upstream
      }

      Task.prototype.getDownstream = function () {
        return this._downstream
      }

      Task.prototype.setOutputEnd = function (end) {
        // This only happend in dataTask, dataZoom, map, currently.
        // where dataZoom do not set end each time, but only set
        // when reset. So we should record the setted end, in case
        // that the stub of dataZoom perform again and earse the
        // setted end by upstream.
        this._outputDueEnd = this._settedOutputEnd = end
      }

      return Task
    }())

  var iterator = (function () {
    let end
    let current
    let modBy
    let modDataCount
    let winCount
    var it = {
      reset: function (s, e, sStep, sCount) {
        current = s
        end = e
        modBy = sStep
        modDataCount = sCount
        winCount = Math.ceil(modDataCount / modBy)
        it.next = modBy > 1 && modDataCount > 0 ? modNext : sequentialNext
      }
    }
    return it

    function sequentialNext () {
      return current < end ? current++ : null
    }

    function modNext () {
      const dataIndex = current % winCount * modBy + Math.ceil(current / winCount)
      const result = current >= end ? null : dataIndex < modDataCount ? dataIndex // If modDataCount is smaller than data.count() (consider `appendData` case),
        // Use normal linear rendering mode.
        : current
      current++
      return result
    }
  }()) /// ////////////////////////////////////////////////////////
  // For stream debug (Should be commented out after used!)
  // @usage: printTask(this, 'begin');
  // @usage: printTask(this, null, {someExtraProp});
  // @usage: Use `__idxInPipeline` as conditional breakpiont.
  //
  // window.printTask = function (task: any, prefix: string, extra: { [key: string]: unknown }): void {
  //     window.ecTaskUID == null && (window.ecTaskUID = 0);
  //     task.uidDebug == null && (task.uidDebug = `task_${window.ecTaskUID++}`);
  //     task.agent && task.agent.uidDebug == null && (task.agent.uidDebug = `task_${window.ecTaskUID++}`);
  //     let props = [];
  //     if (task.__pipeline) {
  //         let val = `${task.__idxInPipeline}/${task.__pipeline.tail.__idxInPipeline} ${task.agent ? '(stub)' : ''}`;
  //         props.push({text: '__idxInPipeline/total', value: val});
  //     } else {
  //         let stubCount = 0;
  //         task.agentStubMap.each(() => stubCount++);
  //         props.push({text: 'idx', value: `overall (stubs: ${stubCount})`});
  //     }
  //     props.push({text: 'uid', value: task.uidDebug});
  //     if (task.__pipeline) {
  //         props.push({text: 'pipelineId', value: task.__pipeline.id});
  //         task.agent && props.push(
  //             {text: 'stubFor', value: task.agent.uidDebug}
  //         );
  //     }
  //     props.push(
  //         {text: 'dirty', value: task._dirty},
  //         {text: 'dueIndex', value: task._dueIndex},
  //         {text: 'dueEnd', value: task._dueEnd},
  //         {text: 'outputDueEnd', value: task._outputDueEnd}
  //     );
  //     if (extra) {
  //         Object.keys(extra).forEach(key => {
  //             props.push({text: key, value: extra[key]});
  //         });
  //     }
  //     let args = ['color: blue'];
  //     let msg = `%c[${prefix || 'T'}] %c` + props.map(item => (
  //         args.push('color: green', 'color: red'),
  //         `${item.text}: %c${item.value}`
  //     )).join('%c, ');
  //     console.log.apply(console, [msg].concat(args));
  //     // console.log(this);
  // };
  // window.printPipeline = function (task: any, prefix: string) {
  //     const pipeline = task.__pipeline;
  //     let currTask = pipeline.head;
  //     while (currTask) {
  //         window.printTask(currTask, prefix);
  //         currTask = currTask._downstream;
  //     }
  // };
  // window.showChain = function (chainHeadTask) {
  //     var chain = [];
  //     var task = chainHeadTask;
  //     while (task) {
  //         chain.push({
  //             task: task,
  //             up: task._upstream,
  //             down: task._downstream,
  //             idxInPipeline: task.__idxInPipeline
  //         });
  //         task = task._downstream;
  //     }
  //     return chain;
  // };
  // window.findTaskInChain = function (task, chainHeadTask) {
  //     let chain = window.showChain(chainHeadTask);
  //     let result = [];
  //     for (let i = 0; i < chain.length; i++) {
  //         let chainItem = chain[i];
  //         if (chainItem.task === task) {
  //             result.push(i);
  //         }
  //     }
  //     return result;
  // };
  // window.printChainAEachInChainB = function (chainHeadTaskA, chainHeadTaskB) {
  //     let chainA = window.showChain(chainHeadTaskA);
  //     for (let i = 0; i < chainA.length; i++) {
  //         console.log('chainAIdx:', i, 'inChainB:', window.findTaskInChain(chainA[i].task, chainHeadTaskB));
  //     }
  // };

  /**
     * Convert raw the value in to inner value in List.
     *
     * [Performance sensitive]
     *
     * [Caution]: this is the key logic of user value parser.
     * For backward compatibiliy, do not modify it until have to!
     */

  function parseDataValue (value, // For high performance, do not omit the second param.
    opt) {
    // Performance sensitive.
    const dimType = opt && opt.type

    if (dimType === 'ordinal') {
      // If given value is a category string
      return value
    }

    if (dimType === 'time' && // spead up when using timestamp
      !isNumber(value) && value != null && value !== '-') {
      value = +parseDate(value)
    } // dimType defaults 'number'.
    // If dimType is not ordinal and value is null or undefined or NaN or '-',
    // parse to NaN.
    // number-like string (like ' 123 ') can be converted to a number.
    // where null/undefined or other string will be converted to NaN.

    return value == null || value === '' ? NaN // If string (like '-'), using '+' parse to NaN
      // If object, also parse to NaN
      : +value
  }
  const valueParserMap = createHashMap({
    number: function (val) {
      // Do not use `numericToNumber` here. We have by defualt `numericToNumber`.
      // Here the number parser can have loose rule:
      // enable to cut suffix: "120px" => 120, "14%" => 14.
      return parseFloat(val)
    },
    time: function (val) {
      // return timestamp.
      return +parseDate(val)
    },
    trim: function (val) {
      return isString(val) ? trim(val) : val
    }
  })
  function getRawValueParser (type) {
    return valueParserMap.get(type)
  }
  const ORDER_COMPARISON_OP_MAP = {
    lt: function (lval, rval) {
      return lval < rval
    },
    lte: function (lval, rval) {
      return lval <= rval
    },
    gt: function (lval, rval) {
      return lval > rval
    },
    gte: function (lval, rval) {
      return lval >= rval
    }
  }

  const FilterOrderComparator =
    /** @class */
    (function () {
      function FilterOrderComparator (op, rval) {
        if (!isNumber(rval)) {
          let errMsg = ''

          if ('development' !== 'production') {
            errMsg = 'rvalue of "<", ">", "<=", ">=" can only be number in filter.'
          }

          throwError(errMsg)
        }

        this._opFn = ORDER_COMPARISON_OP_MAP[op]
        this._rvalFloat = numericToNumber(rval)
      } // Performance sensitive.

      FilterOrderComparator.prototype.evaluate = function (lval) {
        // Most cases is 'number', and typeof maybe 10 times faseter than parseFloat.
        return isNumber(lval) ? this._opFn(lval, this._rvalFloat) : this._opFn(numericToNumber(lval), this._rvalFloat)
      }

      return FilterOrderComparator
    }())

  const SortOrderComparator =
    /** @class */
    (function () {
      /**
       * @param order by defualt: 'asc'
       * @param incomparable by defualt: Always on the tail.
       *        That is, if 'asc' => 'max', if 'desc' => 'min'
       *        See the definition of "incomparable" in [SORT_COMPARISON_RULE]
       */
      function SortOrderComparator (order, incomparable) {
        const isDesc = order === 'desc'
        this._resultLT = isDesc ? 1 : -1

        if (incomparable == null) {
          incomparable = isDesc ? 'min' : 'max'
        }

        this._incomparable = incomparable === 'min' ? -Infinity : Infinity
      } // See [SORT_COMPARISON_RULE].
      // Performance sensitive.

      SortOrderComparator.prototype.evaluate = function (lval, rval) {
        // Most cases is 'number', and typeof maybe 10 times faseter than parseFloat.
        let lvalFloat = isNumber(lval) ? lval : numericToNumber(lval)
        let rvalFloat = isNumber(rval) ? rval : numericToNumber(rval)
        const lvalNotNumeric = isNaN(lvalFloat)
        const rvalNotNumeric = isNaN(rvalFloat)

        if (lvalNotNumeric) {
          lvalFloat = this._incomparable
        }

        if (rvalNotNumeric) {
          rvalFloat = this._incomparable
        }

        if (lvalNotNumeric && rvalNotNumeric) {
          const lvalIsStr = isString(lval)
          const rvalIsStr = isString(rval)

          if (lvalIsStr) {
            lvalFloat = rvalIsStr ? lval : 0
          }

          if (rvalIsStr) {
            rvalFloat = lvalIsStr ? rval : 0
          }
        }

        return lvalFloat < rvalFloat ? this._resultLT : lvalFloat > rvalFloat ? -this._resultLT : 0
      }

      return SortOrderComparator
    }())

  const FilterEqualityComparator =
    /** @class */
    (function () {
      function FilterEqualityComparator (isEq, rval) {
        this._rval = rval
        this._isEQ = isEq
        this._rvalTypeof = typeof rval
        this._rvalFloat = numericToNumber(rval)
      } // Performance sensitive.

      FilterEqualityComparator.prototype.evaluate = function (lval) {
        let eqResult = lval === this._rval

        if (!eqResult) {
          const lvalTypeof = typeof lval

          if (lvalTypeof !== this._rvalTypeof && (lvalTypeof === 'number' || this._rvalTypeof === 'number')) {
            eqResult = numericToNumber(lval) === this._rvalFloat
          }
        }

        return this._isEQ ? eqResult : !eqResult
      }

      return FilterEqualityComparator
    }())
    /**
     * [FILTER_COMPARISON_RULE]
     * `lt`|`lte`|`gt`|`gte`:
     * + rval must be a number. And lval will be converted to number (`numericToNumber`) to compare.
     * `eq`:
     * + If same type, compare with `===`.
     * + If there is one number, convert to number (`numericToNumber`) to compare.
     * + Else return `false`.
     * `ne`:
     * + Not `eq`.
     *
     *
     * [SORT_COMPARISON_RULE]
     * All the values are grouped into three categories:
     * + "numeric" (number and numeric string)
     * + "non-numeric-string" (string that excluding numeric string)
     * + "others"
     * "numeric" vs "numeric": values are ordered by number order.
     * "non-numeric-string" vs "non-numeric-string": values are ordered by ES spec (#sec-abstract-relational-comparison).
     * "others" vs "others": do not change order (always return 0).
     * "numeric" vs "non-numeric-string": "non-numeric-string" is treated as "incomparable".
     * "number" vs "others": "others" is treated as "incomparable".
     * "non-numeric-string" vs "others": "others" is treated as "incomparable".
     * "incomparable" will be seen as -Infinity or Infinity (depends on the settings).
     * MEMO:
     *   non-numeric string sort make sence when need to put the items with the same tag together.
     *   But if we support string sort, we still need to avoid the misleading like `'2' > '12'`,
     *   So we treat "numeric-string" sorted by number order rather than string comparison.
     *
     *
     * [CHECK_LIST_OF_THE_RULE_DESIGN]
     * + Do not support string comparison until required. And also need to
     *   void the misleading of "2" > "12".
     * + Should avoid the misleading case:
     *   `" 22 " gte "22"` is `true` but `" 22 " eq "22"` is `false`.
     * + JS bad case should be avoided: null <= 0, [] <= 0, ' ' <= 0, ...
     * + Only "numeric" can be converted to comparable number, otherwise converted to NaN.
     *   See `util/number.ts#numericToNumber`.
     *
     * @return If `op` is not `RelationalOperator`, return null;
     */

  function createFilterComparator (op, rval) {
    return op === 'eq' || op === 'ne' ? new FilterEqualityComparator(op === 'eq', rval) : hasOwn(ORDER_COMPARISON_OP_MAP, op) ? new FilterOrderComparator(op, rval) : null
  }

  /**
     * TODO: disable writable.
     * This structure will be exposed to users.
     */

  const ExternalSource =
    /** @class */
    (function () {
      function ExternalSource () {}

      ExternalSource.prototype.getRawData = function () {
        // Only built-in transform available.
        throw new Error('not supported')
      }

      ExternalSource.prototype.getRawDataItem = function (dataIndex) {
        // Only built-in transform available.
        throw new Error('not supported')
      }

      ExternalSource.prototype.cloneRawData = function () {

      }
      /**
       * @return If dimension not found, return null/undefined.
       */

      ExternalSource.prototype.getDimensionInfo = function (dim) {

      }
      /**
       * dimensions defined if and only if either:
       * (a) dataset.dimensions are declared.
       * (b) dataset data include dimensions definitions in data (detected or via specified `sourceHeader`).
       * If dimensions are defined, `dimensionInfoAll` is corresponding to
       * the defined dimensions.
       * Otherwise, `dimensionInfoAll` is determined by data columns.
       * @return Always return an array (even empty array).
       */

      ExternalSource.prototype.cloneAllDimensionInfo = function () {

      }

      ExternalSource.prototype.count = function () {

      }
      /**
       * Only support by dimension index.
       * No need to support by dimension name in transform function,
       * becuase transform function is not case-specific, no need to use name literally.
       */

      ExternalSource.prototype.retrieveValue = function (dataIndex, dimIndex) {

      }

      ExternalSource.prototype.retrieveValueFromItem = function (dataItem, dimIndex) {

      }

      ExternalSource.prototype.convertValue = function (rawVal, dimInfo) {
        return parseDataValue(rawVal, dimInfo)
      }

      return ExternalSource
    }())

  function createExternalSource (internalSource, externalTransform) {
    const extSource = new ExternalSource()
    const data = internalSource.data
    const sourceFormat = extSource.sourceFormat = internalSource.sourceFormat
    const sourceHeaderCount = internalSource.startIndex
    let errMsg = ''

    if (internalSource.seriesLayoutBy !== SERIES_LAYOUT_BY_COLUMN) {
      // For the logic simplicity in transformer, only 'culumn' is
      // supported in data transform. Otherwise, the `dimensionsDefine`
      // might be detected by 'row', which probably confuses users.
      if ('development' !== 'production') {
        errMsg = '`seriesLayoutBy` of upstream dataset can only be "column" in data transform.'
      }

      throwError(errMsg)
    } // [MEMO]
    // Create a new dimensions structure for exposing.
    // Do not expose all dimension info to users directly.
    // Becuase the dimension is probably auto detected from data and not might reliable.
    // Should not lead the transformers to think that is relialbe and return it.
    // See [DIMENSION_INHERIT_RULE] in `sourceManager.ts`.

    const dimensions = []
    const dimsByName = {}
    const dimsDef = internalSource.dimensionsDefine

    if (dimsDef) {
      each(dimsDef, function (dimDef, idx) {
        const name = dimDef.name
        const dimDefExt = {
          index: idx,
          name: name,
          displayName: dimDef.displayName
        }
        dimensions.push(dimDefExt) // Users probably not sepcify dimension name. For simplicity, data transform
        // do not generate dimension name.

        if (name != null) {
          // Dimension name should not be duplicated.
          // For simplicity, data transform forbid name duplication, do not generate
          // new name like module `completeDimensions.ts` did, but just tell users.
          let errMsg_1 = ''

          if (hasOwn(dimsByName, name)) {
            if ('development' !== 'production') {
              errMsg_1 = 'dimension name "' + name + '" duplicated.'
            }

            throwError(errMsg_1)
          }

          dimsByName[name] = dimDefExt
        }
      })
    } // If dimension definitions are not defined and can not be detected.
    // e.g., pure data `[[11, 22], ...]`.
    else {
      for (let i = 0; i < internalSource.dimensionsDetectedCount || 0; i++) {
        // Do not generete name or anything others. The consequence process in
        // `transform` or `series` probably have there own name generation strategry.
        dimensions.push({
          index: i
        })
      }
    } // Implement public methods:

    const rawItemGetter = getRawSourceItemGetter(sourceFormat, SERIES_LAYOUT_BY_COLUMN)

    if (externalTransform.__isBuiltIn) {
      extSource.getRawDataItem = function (dataIndex) {
        return rawItemGetter(data, sourceHeaderCount, dimensions, dataIndex)
      }

      extSource.getRawData = bind(getRawData, null, internalSource)
    }

    extSource.cloneRawData = bind(cloneRawData, null, internalSource)
    const rawCounter = getRawSourceDataCounter(sourceFormat, SERIES_LAYOUT_BY_COLUMN)
    extSource.count = bind(rawCounter, null, data, sourceHeaderCount, dimensions)
    const rawValueGetter = getRawSourceValueGetter(sourceFormat)

    extSource.retrieveValue = function (dataIndex, dimIndex) {
      const rawItem = rawItemGetter(data, sourceHeaderCount, dimensions, dataIndex)
      return retrieveValueFromItem(rawItem, dimIndex)
    }

    var retrieveValueFromItem = extSource.retrieveValueFromItem = function (dataItem, dimIndex) {
      if (dataItem == null) {
        return
      }

      const dimDef = dimensions[dimIndex] // When `dimIndex` is `null`, `rawValueGetter` return the whole item.

      if (dimDef) {
        return rawValueGetter(dataItem, dimIndex, dimDef.name)
      }
    }

    extSource.getDimensionInfo = bind(getDimensionInfo, null, dimensions, dimsByName)
    extSource.cloneAllDimensionInfo = bind(cloneAllDimensionInfo, null, dimensions)
    return extSource
  }

  function getRawData (upstream) {
    const sourceFormat = upstream.sourceFormat

    if (!isSupportedSourceFormat(sourceFormat)) {
      let errMsg = ''

      if ('development' !== 'production') {
        errMsg = '`getRawData` is not supported in source format ' + sourceFormat
      }

      throwError(errMsg)
    }

    return upstream.data
  }

  function cloneRawData (upstream) {
    const sourceFormat = upstream.sourceFormat
    const data = upstream.data

    if (!isSupportedSourceFormat(sourceFormat)) {
      let errMsg = ''

      if ('development' !== 'production') {
        errMsg = '`cloneRawData` is not supported in source format ' + sourceFormat
      }

      throwError(errMsg)
    }

    if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {
      var result = []

      for (var i = 0, len = data.length; i < len; i++) {
        // Not strictly clone for performance
        result.push(data[i].slice())
      }

      return result
    } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {
      var result = []

      for (var i = 0, len = data.length; i < len; i++) {
        // Not strictly clone for performance
        result.push(extend({}, data[i]))
      }

      return result
    }
  }

  function getDimensionInfo (dimensions, dimsByName, dim) {
    if (dim == null) {
      return
    } // Keep the same logic as `List::getDimension` did.

    if (isNumber(dim) || // If being a number-like string but not being defined a dimension name.
      !isNaN(dim) && !hasOwn(dimsByName, dim)) {
      return dimensions[dim]
    } else if (hasOwn(dimsByName, dim)) {
      return dimsByName[dim]
    }
  }

  function cloneAllDimensionInfo (dimensions) {
    return clone(dimensions)
  }

  const externalTransformMap = createHashMap()
  function registerExternalTransform (externalTransform) {
    externalTransform = clone(externalTransform)
    let type = externalTransform.type
    let errMsg = ''

    if (!type) {
      if ('development' !== 'production') {
        errMsg = 'Must have a `type` when `registerTransform`.'
      }

      throwError(errMsg)
    }

    const typeParsed = type.split(':')

    if (typeParsed.length !== 2) {
      if ('development' !== 'production') {
        errMsg = 'Name must include namespace like "ns:regression".'
      }

      throwError(errMsg)
    } // Namespace 'echarts:xxx' is official namespace, where the transforms should
    // be called directly via 'xxx' rather than 'echarts:xxx'.

    let isBuiltIn = false

    if (typeParsed[0] === 'echarts') {
      type = typeParsed[1]
      isBuiltIn = true
    }

    externalTransform.__isBuiltIn = isBuiltIn
    externalTransformMap.set(type, externalTransform)
  }
  function applyDataTransform (rawTransOption, sourceList, infoForPrint) {
    const pipedTransOption = normalizeToArray(rawTransOption)
    const pipeLen = pipedTransOption.length
    let errMsg = ''

    if (!pipeLen) {
      if ('development' !== 'production') {
        errMsg = 'If `transform` declared, it should at least contain one transform.'
      }

      throwError(errMsg)
    }

    for (let i = 0, len = pipeLen; i < len; i++) {
      const transOption = pipedTransOption[i]
      sourceList = applySingleDataTransform(transOption, sourceList, infoForPrint, pipeLen === 1 ? null : i) // piped transform only support single input, except the fist one.
      // piped transform only support single output, except the last one.

      if (i !== len - 1) {
        sourceList.length = Math.max(sourceList.length, 1)
      }
    }

    return sourceList
  }

  function applySingleDataTransform (transOption, upSourceList, infoForPrint, // If `pipeIndex` is null/undefined, no piped transform.
    pipeIndex) {
    let errMsg = ''

    if (!upSourceList.length) {
      if ('development' !== 'production') {
        errMsg = 'Must have at least one upstream dataset.'
      }

      throwError(errMsg)
    }

    if (!isObject(transOption)) {
      if ('development' !== 'production') {
        errMsg = 'transform declaration must be an object rather than ' + typeof transOption + '.'
      }

      throwError(errMsg)
    }

    const transType = transOption.type
    const externalTransform = externalTransformMap.get(transType)

    if (!externalTransform) {
      if ('development' !== 'production') {
        errMsg = 'Can not find transform on type "' + transType + '".'
      }

      throwError(errMsg)
    } // Prepare source

    const extUpSourceList = map(upSourceList, function (upSource) {
      return createExternalSource(upSource, externalTransform)
    })
    const resultList = normalizeToArray(externalTransform.transform({
      upstream: extUpSourceList[0],
      upstreamList: extUpSourceList,
      config: clone(transOption.config)
    }))

    if ('development' !== 'production') {
      if (transOption.print) {
        const printStrArr = map(resultList, function (extSource) {
          const pipeIndexStr = pipeIndex != null ? ' === pipe index: ' + pipeIndex : ''
          return ['=== dataset index: ' + infoForPrint.datasetIndex + pipeIndexStr + ' ===', '- transform result data:', makePrintable(extSource.data), '- transform result dimensions:', makePrintable(extSource.dimensions)].join('\n')
        }).join('\n')
        log(printStrArr)
      }
    }

    return map(resultList, function (result, resultIndex) {
      let errMsg = ''

      if (!isObject(result)) {
        if ('development' !== 'production') {
          errMsg = 'A transform should not return some empty results.'
        }

        throwError(errMsg)
      }

      if (!result.data) {
        if ('development' !== 'production') {
          errMsg = 'Transform result data should be not be null or undefined'
        }

        throwError(errMsg)
      }

      const sourceFormat = detectSourceFormat(result.data)

      if (!isSupportedSourceFormat(sourceFormat)) {
        if ('development' !== 'production') {
          errMsg = 'Transform result data should be array rows or object rows.'
        }

        throwError(errMsg)
      }

      let resultMetaRawOption
      const firstUpSource = upSourceList[0]
      /**
         * Intuitively, the end users known the content of the original `dataset.source`,
         * calucating the transform result in mind.
         * Suppose the original `dataset.source` is:
         * ```js
         * [
         *     ['product', '2012', '2013', '2014', '2015'],
         *     ['AAA', 41.1, 30.4, 65.1, 53.3],
         *     ['BBB', 86.5, 92.1, 85.7, 83.1],
         *     ['CCC', 24.1, 67.2, 79.5, 86.4]
         * ]
         * ```
         * The dimension info have to be detected from the source data.
         * Some of the transformers (like filter, sort) will follow the dimension info
         * of upstream, while others use new dimensions (like aggregate).
         * Transformer can output a field `dimensions` to define the its own output dimensions.
         * We also allow transformers to ignore the output `dimensions` field, and
         * inherit the upstream dimensions definition. It can reduce the burden of handling
         * dimensions in transformers.
         *
         * See also [DIMENSION_INHERIT_RULE] in `sourceManager.ts`.
         */

      if (firstUpSource && resultIndex === 0 && // If transformer returns `dimensions`, it means that the transformer has different
        // dimensions definitions. We do not inherit anything from upstream.
        !result.dimensions) {
        const startIndex = firstUpSource.startIndex // We copy the header of upstream to the result becuase:
        // (1) The returned data always does not contain header line and can not be used
        // as dimension-detection. In this case we can not use "detected dimensions" of
        // upstream directly, because it might be detected based on different `seriesLayoutBy`.
        // (2) We should support that the series read the upstream source in `seriesLayoutBy: 'row'`.
        // So the original detected header should be add to the result, otherwise they can not be read.

        if (startIndex) {
          result.data = firstUpSource.data.slice(0, startIndex).concat(result.data)
        }

        resultMetaRawOption = {
          seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN,
          sourceHeader: startIndex,
          dimensions: firstUpSource.metaRawOption.dimensions
        }
      } else {
        resultMetaRawOption = {
          seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN,
          sourceHeader: 0,
          dimensions: result.dimensions
        }
      }

      return createSource(result.data, resultMetaRawOption, null)
    })
  }

  function isSupportedSourceFormat (sourceFormat) {
    return sourceFormat === SOURCE_FORMAT_ARRAY_ROWS || sourceFormat === SOURCE_FORMAT_OBJECT_ROWS
  }

  const UNDEFINED = 'undefined'
  /* global Float64Array, Int32Array, Uint32Array, Uint16Array */
  // Caution: MUST not use `new CtorUint32Array(arr, 0, len)`, because the Ctor of array is
  // different from the Ctor of typed array.

  const CtorUint32Array = typeof Uint32Array === UNDEFINED ? Array : Uint32Array
  const CtorUint16Array = typeof Uint16Array === UNDEFINED ? Array : Uint16Array
  const CtorInt32Array = typeof Int32Array === UNDEFINED ? Array : Int32Array
  const CtorFloat64Array = typeof Float64Array === UNDEFINED ? Array : Float64Array
  /**
     * Multi dimensional data store
     */

  const dataCtors = {
    float: CtorFloat64Array,
    int: CtorInt32Array,
    // Ordinal data type can be string or int
    ordinal: Array,
    number: Array,
    time: CtorFloat64Array
  }
  let defaultDimValueGetters

  function getIndicesCtor (rawCount) {
    // The possible max value in this._indicies is always this._rawCount despite of filtering.
    return rawCount > 65535 ? CtorUint32Array : CtorUint16Array
  }

  function getInitialExtent () {
    return [Infinity, -Infinity]
  }

  function cloneChunk (originalChunk) {
    const Ctor = originalChunk.constructor // Only shallow clone is enough when Array.

    return Ctor === Array ? originalChunk.slice() : new Ctor(originalChunk)
  }

  function prepareStore (store, dimIdx, dimType, end, append) {
    const DataCtor = dataCtors[dimType || 'float']

    if (append) {
      const oldStore = store[dimIdx]
      const oldLen = oldStore && oldStore.length

      if (!(oldLen === end)) {
        const newStore = new DataCtor(end) // The cost of the copy is probably inconsiderable
        // within the initial chunkSize.

        for (let j = 0; j < oldLen; j++) {
          newStore[j] = oldStore[j]
        }

        store[dimIdx] = newStore
      }
    } else {
      store[dimIdx] = new DataCtor(end)
    }
  }
  /**
     * Basically, DataStore API keep immutable.
     */

  const DataStore =
    /** @class */
    (function () {
      function DataStore () {
        this._chunks = [] // It will not be calculated util needed.

        this._rawExtent = []
        this._extent = []
        this._count = 0
        this._rawCount = 0
        this._calcDimNameToIdx = createHashMap()
      }
      /**
       * Initialize from data
       */

      DataStore.prototype.initData = function (provider, inputDimensions, dimValueGetter) {
        if ('development' !== 'production') {
          assert(isFunction(provider.getItem) && isFunction(provider.count), 'Invalid data provider.')
        }

        this._provider = provider // Clear

        this._chunks = []
        this._indices = null
        this.getRawIndex = this._getRawIdxIdentity
        const source = provider.getSource()
        const defaultGetter = this.defaultDimValueGetter = defaultDimValueGetters[source.sourceFormat] // Default dim value getter

        this._dimValueGetter = dimValueGetter || defaultGetter // Reset raw extent.

        this._rawExtent = []
        const willRetrieveDataByName = shouldRetrieveDataByName(source)
        this._dimensions = map(inputDimensions, function (dim) {
          if ('development' !== 'production') {
            if (willRetrieveDataByName) {
              assert(dim.property != null)
            }
          }

          return {
            // Only pick these two props. Not leak other properties like orderMeta.
            type: dim.type,
            property: dim.property
          }
        })

        this._initDataFromProvider(0, provider.count())
      }

      DataStore.prototype.getProvider = function () {
        return this._provider
      }
      /**
       * Caution: even when a `source` instance owned by a series, the created data store
       * may still be shared by different sereis (the source hash does not use all `source`
       * props, see `sourceManager`). In this case, the `source` props that are not used in
       * hash (like `source.dimensionDefine`) probably only belongs to a certain series and
       * thus should not be fetch here.
       */

      DataStore.prototype.getSource = function () {
        return this._provider.getSource()
      }
      /**
       * @caution Only used in dataStack.
       */

      DataStore.prototype.ensureCalculationDimension = function (dimName, type) {
        const calcDimNameToIdx = this._calcDimNameToIdx
        const dimensions = this._dimensions
        let calcDimIdx = calcDimNameToIdx.get(dimName)

        if (calcDimIdx != null) {
          if (dimensions[calcDimIdx].type === type) {
            return calcDimIdx
          }
        } else {
          calcDimIdx = dimensions.length
        }

        dimensions[calcDimIdx] = {
          type: type
        }
        calcDimNameToIdx.set(dimName, calcDimIdx)
        this._chunks[calcDimIdx] = new dataCtors[type || 'float'](this._rawCount)
        this._rawExtent[calcDimIdx] = getInitialExtent()
        return calcDimIdx
      }

      DataStore.prototype.collectOrdinalMeta = function (dimIdx, ordinalMeta) {
        const chunk = this._chunks[dimIdx]
        const dim = this._dimensions[dimIdx]
        const rawExtents = this._rawExtent
        const offset = dim.ordinalOffset || 0
        const len = chunk.length

        if (offset === 0) {
          // We need to reset the rawExtent if collect is from start.
          // Because this dimension may be guessed as number and calcuating a wrong extent.
          rawExtents[dimIdx] = getInitialExtent()
        }

        const dimRawExtent = rawExtents[dimIdx] // Parse from previous data offset. len may be changed after appendData

        for (let i = offset; i < len; i++) {
          const val = chunk[i] = ordinalMeta.parseAndCollect(chunk[i])

          if (!isNaN(val)) {
            dimRawExtent[0] = Math.min(val, dimRawExtent[0])
            dimRawExtent[1] = Math.max(val, dimRawExtent[1])
          }
        }

        dim.ordinalMeta = ordinalMeta
        dim.ordinalOffset = len
        dim.type = 'ordinal' // Force to be ordinal
      }

      DataStore.prototype.getOrdinalMeta = function (dimIdx) {
        const dimInfo = this._dimensions[dimIdx]
        const ordinalMeta = dimInfo.ordinalMeta
        return ordinalMeta
      }

      DataStore.prototype.getDimensionProperty = function (dimIndex) {
        const item = this._dimensions[dimIndex]
        return item && item.property
      }
      /**
       * Caution: Can be only called on raw data (before `this._indices` created).
       */

      DataStore.prototype.appendData = function (data) {
        if ('development' !== 'production') {
          assert(!this._indices, 'appendData can only be called on raw data.')
        }

        const provider = this._provider
        const start = this.count()
        provider.appendData(data)
        let end = provider.count()

        if (!provider.persistent) {
          end += start
        }

        if (start < end) {
          this._initDataFromProvider(start, end, true)
        }

        return [start, end]
      }

      DataStore.prototype.appendValues = function (values, minFillLen) {
        const chunks = this._chunks
        const dimensions = this._dimensions
        const dimLen = dimensions.length
        const rawExtent = this._rawExtent
        const start = this.count()
        const end = start + Math.max(values.length, minFillLen || 0)

        for (let i = 0; i < dimLen; i++) {
          var dim = dimensions[i]
          prepareStore(chunks, i, dim.type, end, true)
        }

        const emptyDataItem = []

        for (let idx = start; idx < end; idx++) {
          const sourceIdx = idx - start // Store the data by dimensions

          for (let dimIdx = 0; dimIdx < dimLen; dimIdx++) {
            var dim = dimensions[dimIdx]
            const val = defaultDimValueGetters.arrayRows.call(this, values[sourceIdx] || emptyDataItem, dim.property, sourceIdx, dimIdx)
            chunks[dimIdx][idx] = val
            const dimRawExtent = rawExtent[dimIdx]
            val < dimRawExtent[0] && (dimRawExtent[0] = val)
            val > dimRawExtent[1] && (dimRawExtent[1] = val)
          }
        }

        this._rawCount = this._count = end
        return {
          start: start,
          end: end
        }
      }

      DataStore.prototype._initDataFromProvider = function (start, end, append) {
        const provider = this._provider
        const chunks = this._chunks
        const dimensions = this._dimensions
        const dimLen = dimensions.length
        const rawExtent = this._rawExtent
        const dimNames = map(dimensions, function (dim) {
          return dim.property
        })

        for (let i = 0; i < dimLen; i++) {
          const dim = dimensions[i]

          if (!rawExtent[i]) {
            rawExtent[i] = getInitialExtent()
          }

          prepareStore(chunks, i, dim.type, end, append)
        }

        if (provider.fillStorage) {
          provider.fillStorage(start, end, chunks, rawExtent)
        } else {
          let dataItem = []

          for (let idx = start; idx < end; idx++) {
            // NOTICE: Try not to write things into dataItem
            dataItem = provider.getItem(idx, dataItem) // Each data item is value
            // [1, 2]
            // 2
            // Bar chart, line chart which uses category axis
            // only gives the 'y' value. 'x' value is the indices of category
            // Use a tempValue to normalize the value to be a (x, y) value
            // Store the data by dimensions

            for (let dimIdx = 0; dimIdx < dimLen; dimIdx++) {
              const dimStorage = chunks[dimIdx] // PENDING NULL is empty or zero

              const val = this._dimValueGetter(dataItem, dimNames[dimIdx], idx, dimIdx)

              dimStorage[idx] = val
              const dimRawExtent = rawExtent[dimIdx]
              val < dimRawExtent[0] && (dimRawExtent[0] = val)
              val > dimRawExtent[1] && (dimRawExtent[1] = val)
            }
          }
        }

        if (!provider.persistent && provider.clean) {
          // Clean unused data if data source is typed array.
          provider.clean()
        }

        this._rawCount = this._count = end // Reset data extent

        this._extent = []
      }

      DataStore.prototype.count = function () {
        return this._count
      }
      /**
       * Get value. Return NaN if idx is out of range.
       */

      DataStore.prototype.get = function (dim, idx) {
        if (!(idx >= 0 && idx < this._count)) {
          return NaN
        }

        const dimStore = this._chunks[dim]
        return dimStore ? dimStore[this.getRawIndex(idx)] : NaN
      }

      DataStore.prototype.getValues = function (dimensions, idx) {
        const values = []
        let dimArr = []

        if (idx == null) {
          idx = dimensions // TODO get all from store?

          dimensions = [] // All dimensions

          for (var i = 0; i < this._dimensions.length; i++) {
            dimArr.push(i)
          }
        } else {
          dimArr = dimensions
        }

        for (var i = 0, len = dimArr.length; i < len; i++) {
          values.push(this.get(dimArr[i], idx))
        }

        return values
      }
      /**
       * @param dim concrete dim
       */

      DataStore.prototype.getByRawIndex = function (dim, rawIdx) {
        if (!(rawIdx >= 0 && rawIdx < this._rawCount)) {
          return NaN
        }

        const dimStore = this._chunks[dim]
        return dimStore ? dimStore[rawIdx] : NaN
      }
      /**
       * Get sum of data in one dimension
       */

      DataStore.prototype.getSum = function (dim) {
        const dimData = this._chunks[dim]
        let sum = 0

        if (dimData) {
          for (let i = 0, len = this.count(); i < len; i++) {
            const value = this.get(dim, i)

            if (!isNaN(value)) {
              sum += value
            }
          }
        }

        return sum
      }
      /**
       * Get median of data in one dimension
       */

      DataStore.prototype.getMedian = function (dim) {
        const dimDataArray = [] // map all data of one dimension

        this.each([dim], function (val) {
          if (!isNaN(val)) {
            dimDataArray.push(val)
          }
        }) // TODO
        // Use quick select?

        const sortedDimDataArray = dimDataArray.sort(function (a, b) {
          return a - b
        })
        const len = this.count() // calculate median

        return len === 0 ? 0 : len % 2 === 1 ? sortedDimDataArray[(len - 1) / 2] : (sortedDimDataArray[len / 2] + sortedDimDataArray[len / 2 - 1]) / 2
      }
      /**
       * Retreive the index with given raw data index
       */

      DataStore.prototype.indexOfRawIndex = function (rawIndex) {
        if (rawIndex >= this._rawCount || rawIndex < 0) {
          return -1
        }

        if (!this._indices) {
          return rawIndex
        } // Indices are ascending

        const indices = this._indices // If rawIndex === dataIndex

        const rawDataIndex = indices[rawIndex]

        if (rawDataIndex != null && rawDataIndex < this._count && rawDataIndex === rawIndex) {
          return rawIndex
        }

        let left = 0
        let right = this._count - 1

        while (left <= right) {
          const mid = (left + right) / 2 | 0

          if (indices[mid] < rawIndex) {
            left = mid + 1
          } else if (indices[mid] > rawIndex) {
            right = mid - 1
          } else {
            return mid
          }
        }

        return -1
      }
      /**
       * Retreive the index of nearest value
       * @param dim
       * @param value
       * @param [maxDistance=Infinity]
       * @return If and only if multiple indices has
       *         the same value, they are put to the result.
       */

      DataStore.prototype.indicesOfNearest = function (dim, value, maxDistance) {
        const chunks = this._chunks
        const dimData = chunks[dim]
        const nearestIndices = []

        if (!dimData) {
          return nearestIndices
        }

        if (maxDistance == null) {
          maxDistance = Infinity
        }

        let minDist = Infinity
        let minDiff = -1
        let nearestIndicesLen = 0 // Check the test case of `test/ut/spec/data/SeriesData.js`.

        for (let i = 0, len = this.count(); i < len; i++) {
          const dataIndex = this.getRawIndex(i)
          const diff = value - dimData[dataIndex]
          const dist = Math.abs(diff)

          if (dist <= maxDistance) {
            // When the `value` is at the middle of `this.get(dim, i)` and `this.get(dim, i+1)`,
            // we'd better not push both of them to `nearestIndices`, otherwise it is easy to
            // get more than one item in `nearestIndices` (more specifically, in `tooltip`).
            // So we chose the one that `diff >= 0` in this csae.
            // But if `this.get(dim, i)` and `this.get(dim, j)` get the same value, both of them
            // should be push to `nearestIndices`.
            if (dist < minDist || dist === minDist && diff >= 0 && minDiff < 0) {
              minDist = dist
              minDiff = diff
              nearestIndicesLen = 0
            }

            if (diff === minDiff) {
              nearestIndices[nearestIndicesLen++] = i
            }
          }
        }

        nearestIndices.length = nearestIndicesLen
        return nearestIndices
      }

      DataStore.prototype.getIndices = function () {
        let newIndices
        const indices = this._indices

        if (indices) {
          var Ctor = indices.constructor
          const thisCount = this._count // `new Array(a, b, c)` is different from `new Uint32Array(a, b, c)`.

          if (Ctor === Array) {
            newIndices = new Ctor(thisCount)

            for (var i = 0; i < thisCount; i++) {
              newIndices[i] = indices[i]
            }
          } else {
            newIndices = new Ctor(indices.buffer, 0, thisCount)
          }
        } else {
          var Ctor = getIndicesCtor(this._rawCount)
          newIndices = new Ctor(this.count())

          for (var i = 0; i < newIndices.length; i++) {
            newIndices[i] = i
          }
        }

        return newIndices
      }
      /**
       * Data filter.
       */

      DataStore.prototype.filter = function (dims, cb) {
        if (!this._count) {
          return this
        }

        const newStore = this.clone()
        const count = newStore.count()
        const Ctor = getIndicesCtor(newStore._rawCount)
        const newIndices = new Ctor(count)
        const value = []
        const dimSize = dims.length
        let offset = 0
        const dim0 = dims[0]
        const chunks = newStore._chunks

        for (let i = 0; i < count; i++) {
          let keep = void 0
          const rawIdx = newStore.getRawIndex(i) // Simple optimization

          if (dimSize === 0) {
            keep = cb(i)
          } else if (dimSize === 1) {
            const val = chunks[dim0][rawIdx]
            keep = cb(val, i)
          } else {
            let k = 0

            for (; k < dimSize; k++) {
              value[k] = chunks[dims[k]][rawIdx]
            }

            value[k] = i
            keep = cb.apply(null, value)
          }

          if (keep) {
            newIndices[offset++] = rawIdx
          }
        } // Set indices after filtered.

        if (offset < count) {
          newStore._indices = newIndices
        }

        newStore._count = offset // Reset data extent

        newStore._extent = []

        newStore._updateGetRawIdx()

        return newStore
      }
      /**
       * Select data in range. (For optimization of filter)
       * (Manually inline code, support 5 million data filtering in data zoom.)
       */

      DataStore.prototype.selectRange = function (range) {
        const newStore = this.clone()
        const len = newStore._count

        if (!len) {
          return this
        }

        const dims = keys(range)
        const dimSize = dims.length

        if (!dimSize) {
          return this
        }

        const originalCount = newStore.count()
        const Ctor = getIndicesCtor(newStore._rawCount)
        const newIndices = new Ctor(originalCount)
        let offset = 0
        const dim0 = dims[0]
        const min = range[dim0][0]
        const max = range[dim0][1]
        const storeArr = newStore._chunks
        let quickFinished = false

        if (!newStore._indices) {
          // Extreme optimization for common case. About 2x faster in chrome.
          let idx = 0

          if (dimSize === 1) {
            var dimStorage = storeArr[dims[0]]

            for (var i = 0; i < len; i++) {
              var val = dimStorage[i] // NaN will not be filtered. Consider the case, in line chart, empty
              // value indicates the line should be broken. But for the case like
              // scatter plot, a data item with empty value will not be rendered,
              // but the axis extent may be effected if some other dim of the data
              // item has value. Fortunately it is not a significant negative effect.

              if (val >= min && val <= max || isNaN(val)) {
                newIndices[offset++] = idx
              }

              idx++
            }

            quickFinished = true
          } else if (dimSize === 2) {
            var dimStorage = storeArr[dims[0]]
            const dimStorage2 = storeArr[dims[1]]
            const min2 = range[dims[1]][0]
            const max2 = range[dims[1]][1]

            for (var i = 0; i < len; i++) {
              var val = dimStorage[i]
              const val2 = dimStorage2[i] // Do not filter NaN, see comment above.

              if ((val >= min && val <= max || isNaN(val)) && (val2 >= min2 && val2 <= max2 || isNaN(val2))) {
                newIndices[offset++] = idx
              }

              idx++
            }

            quickFinished = true
          }
        }

        if (!quickFinished) {
          if (dimSize === 1) {
            for (var i = 0; i < originalCount; i++) {
              var rawIndex = newStore.getRawIndex(i)
              var val = storeArr[dims[0]][rawIndex] // Do not filter NaN, see comment above.

              if (val >= min && val <= max || isNaN(val)) {
                newIndices[offset++] = rawIndex
              }
            }
          } else {
            for (var i = 0; i < originalCount; i++) {
              let keep = true
              var rawIndex = newStore.getRawIndex(i)

              for (let k = 0; k < dimSize; k++) {
                const dimk = dims[k]
                var val = storeArr[dimk][rawIndex] // Do not filter NaN, see comment above.

                if (val < range[dimk][0] || val > range[dimk][1]) {
                  keep = false
                }
              }

              if (keep) {
                newIndices[offset++] = newStore.getRawIndex(i)
              }
            }
          }
        } // Set indices after filtered.

        if (offset < originalCount) {
          newStore._indices = newIndices
        }

        newStore._count = offset // Reset data extent

        newStore._extent = []

        newStore._updateGetRawIdx()

        return newStore
      } // /**
      //  * Data mapping to a plain array
      //  */
      // mapArray(dims: DimensionIndex[], cb: MapArrayCb): any[] {
      //     const result: any[] = [];
      //     this.each(dims, function () {
      //         result.push(cb && (cb as MapArrayCb).apply(null, arguments));
      //     });
      //     return result;
      // }

      /**
       * Data mapping to a new List with given dimensions
       */

      DataStore.prototype.map = function (dims, cb) {
        // TODO only clone picked chunks.
        const target = this.clone(dims)

        this._updateDims(target, dims, cb)

        return target
      }
      /**
       * @caution Danger!! Only used in dataStack.
       */

      DataStore.prototype.modify = function (dims, cb) {
        this._updateDims(this, dims, cb)
      }

      DataStore.prototype._updateDims = function (target, dims, cb) {
        const targetChunks = target._chunks
        const tmpRetValue = []
        const dimSize = dims.length
        const dataCount = target.count()
        const values = []
        const rawExtent = target._rawExtent

        for (var i = 0; i < dims.length; i++) {
          rawExtent[dims[i]] = getInitialExtent()
        }

        for (let dataIndex = 0; dataIndex < dataCount; dataIndex++) {
          const rawIndex = target.getRawIndex(dataIndex)

          for (let k = 0; k < dimSize; k++) {
            values[k] = targetChunks[dims[k]][rawIndex]
          }

          values[dimSize] = dataIndex
          let retValue = cb && cb.apply(null, values)

          if (retValue != null) {
            // a number or string (in oridinal dimension)?
            if (typeof retValue !== 'object') {
              tmpRetValue[0] = retValue
              retValue = tmpRetValue
            }

            for (var i = 0; i < retValue.length; i++) {
              const dim = dims[i]
              const val = retValue[i]
              const rawExtentOnDim = rawExtent[dim]
              const dimStore = targetChunks[dim]

              if (dimStore) {
                dimStore[rawIndex] = val
              }

              if (val < rawExtentOnDim[0]) {
                rawExtentOnDim[0] = val
              }

              if (val > rawExtentOnDim[1]) {
                rawExtentOnDim[1] = val
              }
            }
          }
        }
      }
      /**
       * Large data down sampling using largest-triangle-three-buckets
       * @param {string} valueDimension
       * @param {number} targetCount
       */

      DataStore.prototype.lttbDownSample = function (valueDimension, rate) {
        const target = this.clone([valueDimension], true)
        const targetStorage = target._chunks
        const dimStore = targetStorage[valueDimension]
        const len = this.count()
        let sampledIndex = 0
        const frameSize = Math.floor(1 / rate)
        let currentRawIndex = this.getRawIndex(0)
        let maxArea
        let area
        let nextRawIndex
        const newIndices = new (getIndicesCtor(this._rawCount))(Math.min((Math.ceil(len / frameSize) + 2) * 2, len)) // First frame use the first data.

        newIndices[sampledIndex++] = currentRawIndex

        for (let i = 1; i < len - 1; i += frameSize) {
          const nextFrameStart = Math.min(i + frameSize, len - 1)
          const nextFrameEnd = Math.min(i + frameSize * 2, len)
          const avgX = (nextFrameEnd + nextFrameStart) / 2
          let avgY = 0

          for (var idx = nextFrameStart; idx < nextFrameEnd; idx++) {
            var rawIndex = this.getRawIndex(idx)
            var y = dimStore[rawIndex]

            if (isNaN(y)) {
              continue
            }

            avgY += y
          }

          avgY /= nextFrameEnd - nextFrameStart
          const frameStart = i
          const frameEnd = Math.min(i + frameSize, len)
          const pointAX = i - 1
          const pointAY = dimStore[currentRawIndex]
          maxArea = -1
          nextRawIndex = frameStart
          let firstNaNIndex = -1
          let countNaN = 0 // Find a point from current frame that construct a triangel with largest area with previous selected point
          // And the average of next frame.

          for (var idx = frameStart; idx < frameEnd; idx++) {
            var rawIndex = this.getRawIndex(idx)
            var y = dimStore[rawIndex]

            if (isNaN(y)) {
              countNaN++

              if (firstNaNIndex < 0) {
                firstNaNIndex = rawIndex
              }

              continue
            } // Calculate triangle area over three buckets

            area = Math.abs((pointAX - avgX) * (y - pointAY) - (pointAX - idx) * (avgY - pointAY))

            if (area > maxArea) {
              maxArea = area
              nextRawIndex = rawIndex // Next a is this b
            }
          }

          if (countNaN > 0 && countNaN < frameEnd - frameStart) {
            // Append first NaN point in every bucket.
            // It is necessary to ensure the correct order of indices.
            newIndices[sampledIndex++] = Math.min(firstNaNIndex, nextRawIndex)
            nextRawIndex = Math.max(firstNaNIndex, nextRawIndex)
          }

          newIndices[sampledIndex++] = nextRawIndex
          currentRawIndex = nextRawIndex // This a is the next a (chosen b)
        } // First frame use the last data.

        newIndices[sampledIndex++] = this.getRawIndex(len - 1)
        target._count = sampledIndex
        target._indices = newIndices
        target.getRawIndex = this._getRawIdx
        return target
      }
      /**
       * Large data down sampling on given dimension
       * @param sampleIndex Sample index for name and id
       */

      DataStore.prototype.downSample = function (dimension, rate, sampleValue, sampleIndex) {
        const target = this.clone([dimension], true)
        const targetStorage = target._chunks
        const frameValues = []
        let frameSize = Math.floor(1 / rate)
        const dimStore = targetStorage[dimension]
        const len = this.count()
        const rawExtentOnDim = target._rawExtent[dimension] = getInitialExtent()
        const newIndices = new (getIndicesCtor(this._rawCount))(Math.ceil(len / frameSize))
        let offset = 0

        for (let i = 0; i < len; i += frameSize) {
          // Last frame
          if (frameSize > len - i) {
            frameSize = len - i
            frameValues.length = frameSize
          }

          for (let k = 0; k < frameSize; k++) {
            const dataIdx = this.getRawIndex(i + k)
            frameValues[k] = dimStore[dataIdx]
          }

          const value = sampleValue(frameValues)
          const sampleFrameIdx = this.getRawIndex(Math.min(i + sampleIndex(frameValues, value) || 0, len - 1)) // Only write value on the filtered data

          dimStore[sampleFrameIdx] = value

          if (value < rawExtentOnDim[0]) {
            rawExtentOnDim[0] = value
          }

          if (value > rawExtentOnDim[1]) {
            rawExtentOnDim[1] = value
          }

          newIndices[offset++] = sampleFrameIdx
        }

        target._count = offset
        target._indices = newIndices

        target._updateGetRawIdx()

        return target
      }
      /**
       * Data iteration
       * @param ctx default this
       * @example
       *  list.each('x', function (x, idx) {});
       *  list.each(['x', 'y'], function (x, y, idx) {});
       *  list.each(function (idx) {})
       */

      DataStore.prototype.each = function (dims, cb) {
        if (!this._count) {
          return
        }

        const dimSize = dims.length
        const chunks = this._chunks

        for (let i = 0, len = this.count(); i < len; i++) {
          const rawIdx = this.getRawIndex(i) // Simple optimization

          switch (dimSize) {
            case 0:
              cb(i)
              break

            case 1:
              cb(chunks[dims[0]][rawIdx], i)
              break

            case 2:
              cb(chunks[dims[0]][rawIdx], chunks[dims[1]][rawIdx], i)
              break

            default:
              var k = 0
              var value = []

              for (; k < dimSize; k++) {
                value[k] = chunks[dims[k]][rawIdx]
              } // Index

              value[k] = i
              cb.apply(null, value)
          }
        }
      }
      /**
       * Get extent of data in one dimension
       */

      DataStore.prototype.getDataExtent = function (dim) {
        // Make sure use concrete dim as cache name.
        const dimData = this._chunks[dim]
        const initialExtent = getInitialExtent()

        if (!dimData) {
          return initialExtent
        } // Make more strict checkings to ensure hitting cache.

        const currEnd = this.count() // Consider the most cases when using data zoom, `getDataExtent`
        // happened before filtering. We cache raw extent, which is not
        // necessary to be cleared and recalculated when restore data.

        const useRaw = !this._indices
        let dimExtent

        if (useRaw) {
          return this._rawExtent[dim].slice()
        }

        dimExtent = this._extent[dim]

        if (dimExtent) {
          return dimExtent.slice()
        }

        dimExtent = initialExtent
        let min = dimExtent[0]
        let max = dimExtent[1]

        for (let i = 0; i < currEnd; i++) {
          const rawIdx = this.getRawIndex(i)
          const value = dimData[rawIdx]
          value < min && (min = value)
          value > max && (max = value)
        }

        dimExtent = [min, max]
        this._extent[dim] = dimExtent
        return dimExtent
      }
      /**
       * Get raw data item
       */

      DataStore.prototype.getRawDataItem = function (idx) {
        const rawIdx = this.getRawIndex(idx)

        if (!this._provider.persistent) {
          const val = []
          const chunks = this._chunks

          for (let i = 0; i < chunks.length; i++) {
            val.push(chunks[i][rawIdx])
          }

          return val
        } else {
          return this._provider.getItem(rawIdx)
        }
      }
      /**
       * Clone shallow.
       *
       * @param clonedDims Determine which dims to clone. Will share the data if not specified.
       */

      DataStore.prototype.clone = function (clonedDims, ignoreIndices) {
        const target = new DataStore()
        const chunks = this._chunks
        const clonedDimsMap = clonedDims && reduce(clonedDims, function (obj, dimIdx) {
          obj[dimIdx] = true
          return obj
        }, {})

        if (clonedDimsMap) {
          for (let i = 0; i < chunks.length; i++) {
            // Not clone if dim is not picked.
            target._chunks[i] = !clonedDimsMap[i] ? chunks[i] : cloneChunk(chunks[i])
          }
        } else {
          target._chunks = chunks
        }

        this._copyCommonProps(target)

        if (!ignoreIndices) {
          target._indices = this._cloneIndices()
        }

        target._updateGetRawIdx()

        return target
      }

      DataStore.prototype._copyCommonProps = function (target) {
        target._count = this._count
        target._rawCount = this._rawCount
        target._provider = this._provider
        target._dimensions = this._dimensions
        target._extent = clone(this._extent)
        target._rawExtent = clone(this._rawExtent)
      }

      DataStore.prototype._cloneIndices = function () {
        if (this._indices) {
          const Ctor = this._indices.constructor
          let indices = void 0

          if (Ctor === Array) {
            const thisCount = this._indices.length
            indices = new Ctor(thisCount)

            for (let i = 0; i < thisCount; i++) {
              indices[i] = this._indices[i]
            }
          } else {
            indices = new Ctor(this._indices)
          }

          return indices
        }

        return null
      }

      DataStore.prototype._getRawIdxIdentity = function (idx) {
        return idx
      }

      DataStore.prototype._getRawIdx = function (idx) {
        if (idx < this._count && idx >= 0) {
          return this._indices[idx]
        }

        return -1
      }

      DataStore.prototype._updateGetRawIdx = function () {
        this.getRawIndex = this._indices ? this._getRawIdx : this._getRawIdxIdentity
      }

      DataStore.internalField = (function () {
        function getDimValueSimply (dataItem, property, dataIndex, dimIndex) {
          return parseDataValue(dataItem[dimIndex], this._dimensions[dimIndex])
        }

        defaultDimValueGetters = {
          arrayRows: getDimValueSimply,
          objectRows: function (dataItem, property, dataIndex, dimIndex) {
            return parseDataValue(dataItem[property], this._dimensions[dimIndex])
          },
          keyedColumns: getDimValueSimply,
          original: function (dataItem, property, dataIndex, dimIndex) {
            // Performance sensitive, do not use modelUtil.getDataItemValue.
            // If dataItem is an plain object with no value field, the let `value`
            // will be assigned with the object, but it will be tread correctly
            // in the `convertValue`.
            const value = dataItem && (dataItem.value == null ? dataItem : dataItem.value)
            return parseDataValue(value instanceof Array ? value[dimIndex] // If value is a single number or something else not array.
              : value, this._dimensions[dimIndex])
          },
          typedArray: function (dataItem, property, dataIndex, dimIndex) {
            return dataItem[dimIndex]
          }
        }
      }())

      return DataStore
    }())

  /**
     * [REQUIREMENT_MEMO]:
     * (0) `metaRawOption` means `dimensions`/`sourceHeader`/`seriesLayoutBy` in raw option.
     * (1) Keep support the feature: `metaRawOption` can be specified both on `series` and
     * `root-dataset`. Them on `series` has higher priority.
     * (2) Do not support to set `metaRawOption` on a `non-root-dataset`, because it might
     * confuse users: whether those props indicate how to visit the upstream source or visit
     * the transform result source, and some transforms has nothing to do with these props,
     * and some transforms might have multiple upstream.
     * (3) Transforms should specify `metaRawOption` in each output, just like they can be
     * declared in `root-dataset`.
     * (4) At present only support visit source in `SERIES_LAYOUT_BY_COLUMN` in transforms.
     * That is for reducing complexity in transfroms.
     * PENDING: Whether to provide transposition transform?
     *
     * [IMPLEMENTAION_MEMO]:
     * "sourceVisitConfig" are calculated from `metaRawOption` and `data`.
     * They will not be calculated until `source` is about to be visited (to prevent from
     * duplicate calcuation). `source` is visited only in series and input to transforms.
     *
     * [DIMENSION_INHERIT_RULE]:
     * By default the dimensions are inherited from ancestors, unless a transform return
     * a new dimensions definition.
     * Consider the case:
     * ```js
     * dataset: [{
     *     source: [ ['Product', 'Sales', 'Prise'], ['Cookies', 321, 44.21], ...]
     * }, {
     *     transform: { type: 'filter', ... }
     * }]
     * dataset: [{
     *     dimension: ['Product', 'Sales', 'Prise'],
     *     source: [ ['Cookies', 321, 44.21], ...]
     * }, {
     *     transform: { type: 'filter', ... }
     * }]
     * ```
     * The two types of option should have the same behavior after transform.
     *
     *
     * [SCENARIO]:
     * (1) Provide source data directly:
     * ```js
     * series: {
     *     encode: {...},
     *     dimensions: [...]
     *     seriesLayoutBy: 'row',
     *     data: [[...]]
     * }
     * ```
     * (2) Series refer to dataset.
     * ```js
     * series: [{
     *     encode: {...}
     *     // Ignore datasetIndex means `datasetIndex: 0`
     *     // and the dimensions defination in dataset is used
     * }, {
     *     encode: {...},
     *     seriesLayoutBy: 'column',
     *     datasetIndex: 1
     * }]
     * ```
     * (3) dataset transform
     * ```js
     * dataset: [{
     *     source: [...]
     * }, {
     *     source: [...]
     * }, {
     *     // By default from 0.
     *     transform: { type: 'filter', config: {...} }
     * }, {
     *     // Piped.
     *     transform: [
     *         { type: 'filter', config: {...} },
     *         { type: 'sort', config: {...} }
     *     ]
     * }, {
     *     id: 'regressionData',
     *     fromDatasetIndex: 1,
     *     // Third-party transform
     *     transform: { type: 'ecStat:regression', config: {...} }
     * }, {
     *     // retrieve the extra result.
     *     id: 'regressionFormula',
     *     fromDatasetId: 'regressionData',
     *     fromTransformResult: 1
     * }]
     * ```
     */

  const SourceManager =
    /** @class */
    (function () {
      function SourceManager (sourceHost) {
        // Cached source. Do not repeat calculating if not dirty.
        this._sourceList = []
        this._storeList = [] // version sign of each upstream source manager.

        this._upstreamSignList = []
        this._versionSignBase = 0
        this._dirty = true
        this._sourceHost = sourceHost
      }
      /**
       * Mark dirty.
       */

      SourceManager.prototype.dirty = function () {
        this._setLocalSource([], [])

        this._storeList = []
        this._dirty = true
      }

      SourceManager.prototype._setLocalSource = function (sourceList, upstreamSignList) {
        this._sourceList = sourceList
        this._upstreamSignList = upstreamSignList
        this._versionSignBase++

        if (this._versionSignBase > 9e10) {
          this._versionSignBase = 0
        }
      }
      /**
       * For detecting whether the upstream source is dirty, so that
       * the local cached source (in `_sourceList`) should be discarded.
       */

      SourceManager.prototype._getVersionSign = function () {
        return this._sourceHost.uid + '_' + this._versionSignBase
      }
      /**
       * Always return a source instance. Otherwise throw error.
       */

      SourceManager.prototype.prepareSource = function () {
        // For the case that call `setOption` multiple time but no data changed,
        // cache the result source to prevent from repeating transform.
        if (this._isDirty()) {
          this._createSource()

          this._dirty = false
        }
      }

      SourceManager.prototype._createSource = function () {
        this._setLocalSource([], [])

        const sourceHost = this._sourceHost

        const upSourceMgrList = this._getUpstreamSourceManagers()

        const hasUpstream = !!upSourceMgrList.length
        let resultSourceList
        let upstreamSignList

        if (isSeries(sourceHost)) {
          const seriesModel = sourceHost
          let data = void 0
          let sourceFormat = void 0
          let upSource = void 0 // Has upstream dataset

          if (hasUpstream) {
            const upSourceMgr = upSourceMgrList[0]
            upSourceMgr.prepareSource()
            upSource = upSourceMgr.getSource()
            data = upSource.data
            sourceFormat = upSource.sourceFormat
            upstreamSignList = [upSourceMgr._getVersionSign()]
          } // Series data is from own.
          else {
            data = seriesModel.get('data', true)
            sourceFormat = isTypedArray(data) ? SOURCE_FORMAT_TYPED_ARRAY : SOURCE_FORMAT_ORIGINAL
            upstreamSignList = []
          } // See [REQUIREMENT_MEMO], merge settings on series and parent dataset if it is root.

          const newMetaRawOption = this._getSourceMetaRawOption() || {}
          const upMetaRawOption = upSource && upSource.metaRawOption || {}
          const seriesLayoutBy = retrieve2(newMetaRawOption.seriesLayoutBy, upMetaRawOption.seriesLayoutBy) || null
          const sourceHeader = retrieve2(newMetaRawOption.sourceHeader, upMetaRawOption.sourceHeader) // Note here we should not use `upSource.dimensionsDefine`. Consider the case:
          // `upSource.dimensionsDefine` is detected by `seriesLayoutBy: 'column'`,
          // but series need `seriesLayoutBy: 'row'`.

          const dimensions = retrieve2(newMetaRawOption.dimensions, upMetaRawOption.dimensions) // We share source with dataset as much as possible
          // to avoid extra memroy cost of high dimensional data.

          const needsCreateSource = seriesLayoutBy !== upMetaRawOption.seriesLayoutBy || !!sourceHeader !== !!upMetaRawOption.sourceHeader || dimensions
          resultSourceList = needsCreateSource
            ? [createSource(data, {
                seriesLayoutBy: seriesLayoutBy,
                sourceHeader: sourceHeader,
                dimensions: dimensions
              }, sourceFormat)]
            : []
        } else {
          const datasetModel = sourceHost // Has upstream dataset.

          if (hasUpstream) {
            const result = this._applyTransform(upSourceMgrList)

            resultSourceList = result.sourceList
            upstreamSignList = result.upstreamSignList
          } // Is root dataset.
          else {
            const sourceData = datasetModel.get('source', true)
            resultSourceList = [createSource(sourceData, this._getSourceMetaRawOption(), null)]
            upstreamSignList = []
          }
        }

        if ('development' !== 'production') {
          assert(resultSourceList && upstreamSignList)
        }

        this._setLocalSource(resultSourceList, upstreamSignList)
      }

      SourceManager.prototype._applyTransform = function (upMgrList) {
        const datasetModel = this._sourceHost
        const transformOption = datasetModel.get('transform', true)
        const fromTransformResult = datasetModel.get('fromTransformResult', true)

        if ('development' !== 'production') {
          assert(fromTransformResult != null || transformOption != null)
        }

        if (fromTransformResult != null) {
          let errMsg = ''

          if (upMgrList.length !== 1) {
            if ('development' !== 'production') {
              errMsg = 'When using `fromTransformResult`, there should be only one upstream dataset'
            }

            doThrow(errMsg)
          }
        }

        let sourceList
        const upSourceList = []
        const upstreamSignList = []
        each(upMgrList, function (upMgr) {
          upMgr.prepareSource()
          const upSource = upMgr.getSource(fromTransformResult || 0)
          let errMsg = ''

          if (fromTransformResult != null && !upSource) {
            if ('development' !== 'production') {
              errMsg = 'Can not retrieve result by `fromTransformResult`: ' + fromTransformResult
            }

            doThrow(errMsg)
          }

          upSourceList.push(upSource)
          upstreamSignList.push(upMgr._getVersionSign())
        })

        if (transformOption) {
          sourceList = applyDataTransform(transformOption, upSourceList, {
            datasetIndex: datasetModel.componentIndex
          })
        } else if (fromTransformResult != null) {
          sourceList = [cloneSourceShallow(upSourceList[0])]
        }

        return {
          sourceList: sourceList,
          upstreamSignList: upstreamSignList
        }
      }

      SourceManager.prototype._isDirty = function () {
        if (this._dirty) {
          return true
        } // All sourceList is from the some upsteam.

        const upSourceMgrList = this._getUpstreamSourceManagers()

        for (let i = 0; i < upSourceMgrList.length; i++) {
          const upSrcMgr = upSourceMgrList[i]

          if ( // Consider the case that there is ancestor diry, call it recursively.
          // The performance is probably not an issue because usually the chain is not long.
            upSrcMgr._isDirty() || this._upstreamSignList[i] !== upSrcMgr._getVersionSign()) {
            return true
          }
        }
      }
      /**
       * @param sourceIndex By defualt 0, means "main source".
       *                    Most cases there is only one source.
       */

      SourceManager.prototype.getSource = function (sourceIndex) {
        sourceIndex = sourceIndex || 0
        const source = this._sourceList[sourceIndex]

        if (!source) {
          // Series may share source instance with dataset.
          const upSourceMgrList = this._getUpstreamSourceManagers()

          return upSourceMgrList[0] && upSourceMgrList[0].getSource(sourceIndex)
        }

        return source
      }
      /**
       *
       * Get a data store which can be shared across series.
       * Only available for series.
       *
       * @param seriesDimRequest Dimensions that are generated in series.
       *        Should have been sorted by `storeDimIndex` asc.
       */

      SourceManager.prototype.getSharedDataStore = function (seriesDimRequest) {
        if ('development' !== 'production') {
          assert(isSeries(this._sourceHost), 'Can only call getDataStore on series source manager.')
        }

        const schema = seriesDimRequest.makeStoreSchema()
        return this._innerGetDataStore(schema.dimensions, seriesDimRequest.source, schema.hash)
      }

      SourceManager.prototype._innerGetDataStore = function (storeDims, seriesSource, sourceReadKey) {
        // TODO Can use other sourceIndex?
        const sourceIndex = 0
        const storeList = this._storeList
        let cachedStoreMap = storeList[sourceIndex]

        if (!cachedStoreMap) {
          cachedStoreMap = storeList[sourceIndex] = {}
        }

        let cachedStore = cachedStoreMap[sourceReadKey]

        if (!cachedStore) {
          const upSourceMgr = this._getUpstreamSourceManagers()[0]

          if (isSeries(this._sourceHost) && upSourceMgr) {
            cachedStore = upSourceMgr._innerGetDataStore(storeDims, seriesSource, sourceReadKey)
          } else {
            cachedStore = new DataStore() // Always create store from source of series.

            cachedStore.initData(new DefaultDataProvider(seriesSource, storeDims.length), storeDims)
          }

          cachedStoreMap[sourceReadKey] = cachedStore
        }

        return cachedStore
      }
      /**
       * PEDING: Is it fast enough?
       * If no upstream, return empty array.
       */

      SourceManager.prototype._getUpstreamSourceManagers = function () {
        // Always get the relationship from the raw option.
        // Do not cache the link of the dependency graph, so that
        // no need to update them when change happen.
        const sourceHost = this._sourceHost

        if (isSeries(sourceHost)) {
          const datasetModel = querySeriesUpstreamDatasetModel(sourceHost)
          return !datasetModel ? [] : [datasetModel.getSourceManager()]
        } else {
          return map(queryDatasetUpstreamDatasetModels(sourceHost), function (datasetModel) {
            return datasetModel.getSourceManager()
          })
        }
      }

      SourceManager.prototype._getSourceMetaRawOption = function () {
        const sourceHost = this._sourceHost
        let seriesLayoutBy
        let sourceHeader
        let dimensions

        if (isSeries(sourceHost)) {
          seriesLayoutBy = sourceHost.get('seriesLayoutBy', true)
          sourceHeader = sourceHost.get('sourceHeader', true)
          dimensions = sourceHost.get('dimensions', true)
        } // See [REQUIREMENT_MEMO], `non-root-dataset` do not support them.
        else if (!this._getUpstreamSourceManagers().length) {
          const model = sourceHost
          seriesLayoutBy = model.get('seriesLayoutBy', true)
          sourceHeader = model.get('sourceHeader', true)
          dimensions = model.get('dimensions', true)
        }

        return {
          seriesLayoutBy: seriesLayoutBy,
          sourceHeader: sourceHeader,
          dimensions: dimensions
        }
      }

      return SourceManager
    }())
    // disable the transform merge, but do not disable transfrom clone from rawOption.

  function disableTransformOptionMerge (datasetModel) {
    const transformOption = datasetModel.option.transform
    transformOption && setAsPrimitive(datasetModel.option.transform)
  }

  function isSeries (sourceHost) {
    // Avoid circular dependency with Series.ts
    return sourceHost.mainType === 'series'
  }

  function doThrow (errMsg) {
    throw new Error(errMsg)
  }

  const TOOLTIP_LINE_HEIGHT_CSS = 'line-height:1' // TODO: more textStyle option

  function getTooltipTextStyle (textStyle, renderMode) {
    const nameFontColor = textStyle.color || '#6e7079'
    const nameFontSize = textStyle.fontSize || 12
    const nameFontWeight = textStyle.fontWeight || '400'
    const valueFontColor = textStyle.color || '#464646'
    const valueFontSize = textStyle.fontSize || 14
    const valueFontWeight = textStyle.fontWeight || '900'

    if (renderMode === 'html') {
      // `textStyle` is probably from user input, should be encoded to reduce security risk.
      return {
        // eslint-disable-next-line max-len
        nameStyle: 'font-size:' + encodeHTML(nameFontSize + '') + 'px;color:' + encodeHTML(nameFontColor) + ';font-weight:' + encodeHTML(nameFontWeight + ''),
        // eslint-disable-next-line max-len
        valueStyle: 'font-size:' + encodeHTML(valueFontSize + '') + 'px;color:' + encodeHTML(valueFontColor) + ';font-weight:' + encodeHTML(valueFontWeight + '')
      }
    } else {
      return {
        nameStyle: {
          fontSize: nameFontSize,
          fill: nameFontColor,
          fontWeight: nameFontWeight
        },
        valueStyle: {
          fontSize: valueFontSize,
          fill: valueFontColor,
          fontWeight: valueFontWeight
        }
      }
    }
  } // See `TooltipMarkupLayoutIntent['innerGapLevel']`.
  // (value from UI design)

  const HTML_GAPS = [0, 10, 20, 30]
  const RICH_TEXT_GAPS = ['', '\n', '\n\n', '\n\n\n'] // eslint-disable-next-line max-len

  function createTooltipMarkup (type, option) {
    option.type = type
    return option
  }

  function isSectionFragment (frag) {
    return frag.type === 'section'
  }

  function getBuilder (frag) {
    return isSectionFragment(frag) ? buildSection : buildNameValue
  }

  function getBlockGapLevel (frag) {
    if (isSectionFragment(frag)) {
      let gapLevel_1 = 0
      const subBlockLen = frag.blocks.length
      const hasInnerGap_1 = subBlockLen > 1 || subBlockLen > 0 && !frag.noHeader
      each(frag.blocks, function (subBlock) {
        const subGapLevel = getBlockGapLevel(subBlock) // If the some of the sub-blocks have some gaps (like 10px) inside, this block
        // should use a larger gap (like 20px) to distinguish those sub-blocks.

        if (subGapLevel >= gapLevel_1) {
          gapLevel_1 = subGapLevel + +(hasInnerGap_1 && ( // 0 always can not be readable gap level.
            !subGapLevel || // If no header, always keep the sub gap level. Otherwise
            // look weird in case `multipleSeries`.
            isSectionFragment(subBlock) && !subBlock.noHeader))
        }
      })
      return gapLevel_1
    }

    return 0
  }

  function buildSection (ctx, fragment, topMarginForOuterGap, toolTipTextStyle) {
    const noHeader = fragment.noHeader
    const gaps = getGap(getBlockGapLevel(fragment))
    const subMarkupTextList = []
    let subBlocks = fragment.blocks || []
    assert(!subBlocks || isArray(subBlocks))
    subBlocks = subBlocks || []
    const orderMode = ctx.orderMode

    if (fragment.sortBlocks && orderMode) {
      subBlocks = subBlocks.slice()
      const orderMap = {
        valueAsc: 'asc',
        valueDesc: 'desc'
      }

      if (hasOwn(orderMap, orderMode)) {
        const comparator_1 = new SortOrderComparator(orderMap[orderMode], null)
        subBlocks.sort(function (a, b) {
          return comparator_1.evaluate(a.sortParam, b.sortParam)
        })
      } // FIXME 'seriesDesc' necessary?
      else if (orderMode === 'seriesDesc') {
        subBlocks.reverse()
      }
    }

    each(subBlocks, function (subBlock, idx) {
      const valueFormatter = fragment.valueFormatter
      const subMarkupText = getBuilder(subBlock)( // Inherit valueFormatter
        valueFormatter
          ? extend(extend({}, ctx), {
            valueFormatter: valueFormatter
          })
          : ctx, subBlock, idx > 0 ? gaps.html : 0, toolTipTextStyle)
      subMarkupText != null && subMarkupTextList.push(subMarkupText)
    })
    const subMarkupText = ctx.renderMode === 'richText' ? subMarkupTextList.join(gaps.richText) : wrapBlockHTML(subMarkupTextList.join(''), noHeader ? topMarginForOuterGap : gaps.html)

    if (noHeader) {
      return subMarkupText
    }

    const displayableHeader = makeValueReadable(fragment.header, 'ordinal', ctx.useUTC)
    const nameStyle = getTooltipTextStyle(toolTipTextStyle, ctx.renderMode).nameStyle

    if (ctx.renderMode === 'richText') {
      return wrapInlineNameRichText(ctx, displayableHeader, nameStyle) + gaps.richText + subMarkupText
    } else {
      return wrapBlockHTML('<div style="' + nameStyle + ';' + TOOLTIP_LINE_HEIGHT_CSS + ';">' + encodeHTML(displayableHeader) + '</div>' + subMarkupText, topMarginForOuterGap)
    }
  }

  function buildNameValue (ctx, fragment, topMarginForOuterGap, toolTipTextStyle) {
    const renderMode = ctx.renderMode
    const noName = fragment.noName
    const noValue = fragment.noValue
    const noMarker = !fragment.markerType
    const name = fragment.name
    const useUTC = ctx.useUTC

    const valueFormatter = fragment.valueFormatter || ctx.valueFormatter || function (value) {
      value = isArray(value) ? value : [value]
      return map(value, function (val, idx) {
        return makeValueReadable(val, isArray(valueTypeOption) ? valueTypeOption[idx] : valueTypeOption, useUTC)
      })
    }

    if (noName && noValue) {
      return
    }

    const markerStr = noMarker ? '' : ctx.markupStyleCreator.makeTooltipMarker(fragment.markerType, fragment.markerColor || '#333', renderMode)
    const readableName = noName ? '' : makeValueReadable(name, 'ordinal', useUTC)
    var valueTypeOption = fragment.valueType
    const readableValueList = noValue ? [] : valueFormatter(fragment.value)
    const valueAlignRight = !noMarker || !noName // It little weird if only value next to marker but far from marker.

    const valueCloseToMarker = !noMarker && noName

    const _a = getTooltipTextStyle(toolTipTextStyle, renderMode)
    const nameStyle = _a.nameStyle
    const valueStyle = _a.valueStyle

    return renderMode === 'richText' ? (noMarker ? '' : markerStr) + (noName ? '' : wrapInlineNameRichText(ctx, readableName, nameStyle)) + // Value has commas inside, so use ' ' as delimiter for multiple values.
      (noValue ? '' : wrapInlineValueRichText(ctx, readableValueList, valueAlignRight, valueCloseToMarker, valueStyle)) : wrapBlockHTML((noMarker ? '' : markerStr) + (noName ? '' : wrapInlineNameHTML(readableName, !noMarker, nameStyle)) + (noValue ? '' : wrapInlineValueHTML(readableValueList, valueAlignRight, valueCloseToMarker, valueStyle)), topMarginForOuterGap)
  }
  /**
     * @return markupText. null/undefined means no content.
     */

  function buildTooltipMarkup (fragment, markupStyleCreator, renderMode, orderMode, useUTC, toolTipTextStyle) {
    if (!fragment) {
      return
    }

    const builder = getBuilder(fragment)
    const ctx = {
      useUTC: useUTC,
      renderMode: renderMode,
      orderMode: orderMode,
      markupStyleCreator: markupStyleCreator,
      valueFormatter: fragment.valueFormatter
    }
    return builder(ctx, fragment, 0, toolTipTextStyle)
  }

  function getGap (gapLevel) {
    return {
      html: HTML_GAPS[gapLevel],
      richText: RICH_TEXT_GAPS[gapLevel]
    }
  }

  function wrapBlockHTML (encodedContent, topGap) {
    const clearfix = '<div style="clear:both"></div>'
    const marginCSS = 'margin: ' + topGap + 'px 0 0'
    return '<div style="' + marginCSS + ';' + TOOLTIP_LINE_HEIGHT_CSS + ';">' + encodedContent + clearfix + '</div>'
  }

  function wrapInlineNameHTML (name, leftHasMarker, style) {
    const marginCss = leftHasMarker ? 'margin-left:2px' : ''
    return '<span style="' + style + ';' + marginCss + '">' + encodeHTML(name) + '</span>'
  }

  function wrapInlineValueHTML (valueList, alignRight, valueCloseToMarker, style) {
    // Do not too close to marker, considering there are multiple values separated by spaces.
    const paddingStr = valueCloseToMarker ? '10px' : '20px'
    const alignCSS = alignRight ? 'float:right;margin-left:' + paddingStr : ''
    valueList = isArray(valueList) ? valueList : [valueList]
    return '<span style="' + alignCSS + ';' + style + '">' + // Value has commas inside, so use '  ' as delimiter for multiple values.
      map(valueList, function (value) {
        return encodeHTML(value)
      }).join('&nbsp;&nbsp;') + '</span>'
  }

  function wrapInlineNameRichText (ctx, name, style) {
    return ctx.markupStyleCreator.wrapRichTextStyle(name, style)
  }

  function wrapInlineValueRichText (ctx, values, alignRight, valueCloseToMarker, style) {
    const styles = [style]
    const paddingLeft = valueCloseToMarker ? 10 : 20
    alignRight && styles.push({
      padding: [0, 0, 0, paddingLeft],
      align: 'right'
    }) // Value has commas inside, so use '  ' as delimiter for multiple values.

    return ctx.markupStyleCreator.wrapRichTextStyle(isArray(values) ? values.join('  ') : values, styles)
  }

  function retrieveVisualColorForTooltipMarker (series, dataIndex) {
    const style = series.getData().getItemVisual(dataIndex, 'style')
    const color = style[series.visualDrawType]
    return convertToColorString(color)
  }
  function getPaddingFromTooltipModel (model, renderMode) {
    const padding = model.get('padding')
    return padding != null ? padding // We give slightly different to look pretty.
      : renderMode === 'richText' ? [8, 10] : 10
  }
  /**
     * The major feature is generate styles for `renderMode: 'richText'`.
     * But it also serves `renderMode: 'html'` to provide
     * "renderMode-independent" API.
     */

  const TooltipMarkupStyleCreator =
    /** @class */
    (function () {
      function TooltipMarkupStyleCreator () {
        this.richTextStyles = {} // Notice that "generate a style name" usuall happens repeatly when mouse moving and
        // displaying a tooltip. So we put the `_nextStyleNameId` as a member of each creator
        // rather than static shared by all creators (which will cause it increase to fast).

        this._nextStyleNameId = getRandomIdBase()
      }

      TooltipMarkupStyleCreator.prototype._generateStyleName = function () {
        return '__EC_aUTo_' + this._nextStyleNameId++
      }

      TooltipMarkupStyleCreator.prototype.makeTooltipMarker = function (markerType, colorStr, renderMode) {
        const markerId = renderMode === 'richText' ? this._generateStyleName() : null
        const marker = getTooltipMarker({
          color: colorStr,
          type: markerType,
          renderMode: renderMode,
          markerId: markerId
        })

        if (isString(marker)) {
          return marker
        } else {
          if ('development' !== 'production') {
            assert(markerId)
          }

          this.richTextStyles[markerId] = marker.style
          return marker.content
        }
      }
      /**
       * @usage
       * ```ts
       * const styledText = markupStyleCreator.wrapRichTextStyle([
       *     // The styles will be auto merged.
       *     {
       *         fontSize: 12,
       *         color: 'blue'
       *     },
       *     {
       *         padding: 20
       *     }
       * ]);
       * ```
       */

      TooltipMarkupStyleCreator.prototype.wrapRichTextStyle = function (text, styles) {
        const finalStl = {}

        if (isArray(styles)) {
          each(styles, function (stl) {
            return extend(finalStl, stl)
          })
        } else {
          extend(finalStl, styles)
        }

        const styleName = this._generateStyleName()

        this.richTextStyles[styleName] = finalStl
        return '{' + styleName + '|' + text + '}'
      }

      return TooltipMarkupStyleCreator
    }())

  function defaultSeriesFormatTooltip (opt) {
    const series = opt.series
    const dataIndex = opt.dataIndex
    const multipleSeries = opt.multipleSeries
    const data = series.getData()
    const tooltipDims = data.mapDimensionsAll('defaultedTooltip')
    const tooltipDimLen = tooltipDims.length
    const value = series.getRawValue(dataIndex)
    const isValueArr = isArray(value)
    const markerColor = retrieveVisualColorForTooltipMarker(series, dataIndex) // Complicated rule for pretty tooltip.

    let inlineValue
    let inlineValueType
    let subBlocks
    let sortParam

    if (tooltipDimLen > 1 || isValueArr && !tooltipDimLen) {
      const formatArrResult = formatTooltipArrayValue(value, series, dataIndex, tooltipDims, markerColor)
      inlineValue = formatArrResult.inlineValues
      inlineValueType = formatArrResult.inlineValueTypes
      subBlocks = formatArrResult.blocks // Only support tooltip sort by the first inline value. It's enough in most cases.

      sortParam = formatArrResult.inlineValues[0]
    } else if (tooltipDimLen) {
      const dimInfo = data.getDimensionInfo(tooltipDims[0])
      sortParam = inlineValue = retrieveRawValue(data, dataIndex, tooltipDims[0])
      inlineValueType = dimInfo.type
    } else {
      sortParam = inlineValue = isValueArr ? value[0] : value
    } // Do not show generated series name. It might not be readable.

    const seriesNameSpecified = isNameSpecified(series)
    const seriesName = seriesNameSpecified && series.name || ''
    const itemName = data.getName(dataIndex)
    const inlineName = multipleSeries ? seriesName : itemName
    return createTooltipMarkup('section', {
      header: seriesName,
      // When series name not specified, do not show a header line with only '-'.
      // This case alway happen in tooltip.trigger: 'item'.
      noHeader: multipleSeries || !seriesNameSpecified,
      sortParam: sortParam,
      blocks: [createTooltipMarkup('nameValue', {
        markerType: 'item',
        markerColor: markerColor,
        // Do not mix display seriesName and itemName in one tooltip,
        // which might confuses users.
        name: inlineName,
        // name dimension might be auto assigned, where the name might
        // be not readable. So we check trim here.
        noName: !trim(inlineName),
        value: inlineValue,
        valueType: inlineValueType
      })].concat(subBlocks || [])
    })
  }

  function formatTooltipArrayValue (value, series, dataIndex, tooltipDims, colorStr) {
    // check: category-no-encode-has-axis-data in dataset.html
    const data = series.getData()
    const isValueMultipleLine = reduce(value, function (isValueMultipleLine, val, idx) {
      const dimItem = data.getDimensionInfo(idx)
      return isValueMultipleLine = isValueMultipleLine || dimItem && dimItem.tooltip !== false && dimItem.displayName != null
    }, false)
    const inlineValues = []
    const inlineValueTypes = []
    const blocks = []
    tooltipDims.length ? each(tooltipDims, function (dim) {
      setEachItem(retrieveRawValue(data, dataIndex, dim), dim)
    }) // By default, all dims is used on tooltip.
      : each(value, setEachItem)

    function setEachItem (val, dim) {
      const dimInfo = data.getDimensionInfo(dim) // If `dimInfo.tooltip` is not set, show tooltip.

      if (!dimInfo || dimInfo.otherDims.tooltip === false) {
        return
      }

      if (isValueMultipleLine) {
        blocks.push(createTooltipMarkup('nameValue', {
          markerType: 'subItem',
          markerColor: colorStr,
          name: dimInfo.displayName,
          value: val,
          valueType: dimInfo.type
        }))
      } else {
        inlineValues.push(val)
        inlineValueTypes.push(dimInfo.type)
      }
    }

    return {
      inlineValues: inlineValues,
      inlineValueTypes: inlineValueTypes,
      blocks: blocks
    }
  }

  const inner$1 = makeInner()

  function getSelectionKey (data, dataIndex) {
    return data.getName(dataIndex) || data.getId(dataIndex)
  }

  const SERIES_UNIVERSAL_TRANSITION_PROP = '__universalTransitionEnabled'

  const SeriesModel =
    /** @class */
    (function (_super) {
      __extends(SeriesModel, _super)

      function SeriesModel () {
        // [Caution]: Becuase this class or desecendants can be used as `XXX.extend(subProto)`,
        // the class members must not be initialized in constructor or declaration place.
        // Otherwise there is bad case:
        //   class A {xxx = 1;}
        //   enableClassExtend(A);
        //   class B extends A {}
        //   var C = B.extend({xxx: 5});
        //   var c = new C();
        //   console.log(c.xxx); // expect 5 but always 1.
        const _this = _super !== null && _super.apply(this, arguments) || this // ---------------------------------------
        // Props about data selection
        // ---------------------------------------

        _this._selectedDataIndicesMap = {}
        return _this
      }

      SeriesModel.prototype.init = function (option, parentModel, ecModel) {
        this.seriesIndex = this.componentIndex
        this.dataTask = createTask({
          count: dataTaskCount,
          reset: dataTaskReset
        })
        this.dataTask.context = {
          model: this
        }
        this.mergeDefaultAndTheme(option, ecModel)
        const sourceManager = inner$1(this).sourceManager = new SourceManager(this)
        sourceManager.prepareSource()
        const data = this.getInitialData(option, ecModel)
        wrapData(data, this)
        this.dataTask.context.data = data

        if ('development' !== 'production') {
          assert(data, 'getInitialData returned invalid data.')
        }

        inner$1(this).dataBeforeProcessed = data // If we reverse the order (make data firstly, and then make
        // dataBeforeProcessed by cloneShallow), cloneShallow will
        // cause data.graph.data !== data when using
        // module:echarts/data/Graph or module:echarts/data/Tree.
        // See module:echarts/data/helper/linkSeriesData
        // Theoretically, it is unreasonable to call `seriesModel.getData()` in the model
        // init or merge stage, because the data can be restored. So we do not `restoreData`
        // and `setData` here, which forbids calling `seriesModel.getData()` in this stage.
        // Call `seriesModel.getRawData()` instead.
        // this.restoreData();

        autoSeriesName(this)

        this._initSelectedMapFromData(data)
      }
      /**
       * Util for merge default and theme to option
       */

      SeriesModel.prototype.mergeDefaultAndTheme = function (option, ecModel) {
        const layoutMode = fetchLayoutMode(this)
        const inputPositionParams = layoutMode ? getLayoutParams(option) : {} // Backward compat: using subType on theme.
        // But if name duplicate between series subType
        // (for example: parallel) add component mainType,
        // add suffix 'Series'.

        let themeSubType = this.subType

        if (ComponentModel.hasClass(themeSubType)) {
          themeSubType += 'Series'
        }

        merge(option, ecModel.getTheme().get(this.subType))
        merge(option, this.getDefaultOption()) // Default label emphasis `show`

        defaultEmphasis(option, 'label', ['show'])
        this.fillDataTextStyle(option.data)

        if (layoutMode) {
          mergeLayoutParam(option, inputPositionParams, layoutMode)
        }
      }

      SeriesModel.prototype.mergeOption = function (newSeriesOption, ecModel) {
        // this.settingTask.dirty();
        newSeriesOption = merge(this.option, newSeriesOption, true)
        this.fillDataTextStyle(newSeriesOption.data)
        const layoutMode = fetchLayoutMode(this)

        if (layoutMode) {
          mergeLayoutParam(this.option, newSeriesOption, layoutMode)
        }

        const sourceManager = inner$1(this).sourceManager
        sourceManager.dirty()
        sourceManager.prepareSource()
        const data = this.getInitialData(newSeriesOption, ecModel)
        wrapData(data, this)
        this.dataTask.dirty()
        this.dataTask.context.data = data
        inner$1(this).dataBeforeProcessed = data
        autoSeriesName(this)

        this._initSelectedMapFromData(data)
      }

      SeriesModel.prototype.fillDataTextStyle = function (data) {
        // Default data label emphasis `show`
        // FIXME Tree structure data ?
        // FIXME Performance ?
        if (data && !isTypedArray(data)) {
          const props = ['show']

          for (let i = 0; i < data.length; i++) {
            if (data[i] && data[i].label) {
              defaultEmphasis(data[i], 'label', props)
            }
          }
        }
      }
      /**
       * Init a data structure from data related option in series
       * Must be overriden.
       */

      SeriesModel.prototype.getInitialData = function (option, ecModel) {

      }
      /**
       * Append data to list
       */

      SeriesModel.prototype.appendData = function (params) {
        // FIXME ???
        // (1) If data from dataset, forbidden append.
        // (2) support append data of dataset.
        const data = this.getRawData()
        data.appendData(params.data)
      }
      /**
       * Consider some method like `filter`, `map` need make new data,
       * We should make sure that `seriesModel.getData()` get correct
       * data in the stream procedure. So we fetch data from upstream
       * each time `task.perform` called.
       */

      SeriesModel.prototype.getData = function (dataType) {
        const task = getCurrentTask(this)

        if (task) {
          const data = task.context.data
          return dataType == null ? data : data.getLinkedData(dataType)
        } else {
          // When series is not alive (that may happen when click toolbox
          // restore or setOption with not merge mode), series data may
          // be still need to judge animation or something when graphic
          // elements want to know whether fade out.
          return inner$1(this).data
        }
      }

      SeriesModel.prototype.getAllData = function () {
        const mainData = this.getData()
        return mainData && mainData.getLinkedDataAll
          ? mainData.getLinkedDataAll()
          : [{
              data: mainData
            }]
      }

      SeriesModel.prototype.setData = function (data) {
        const task = getCurrentTask(this)

        if (task) {
          const context = task.context // Consider case: filter, data sample.
          // FIXME:TS never used, so comment it
          // if (context.data !== data && task.modifyOutputEnd) {
          //     task.setOutputEnd(data.count());
          // }

          context.outputData = data // Caution: setData should update context.data,
          // Because getData may be called multiply in a
          // single stage and expect to get the data just
          // set. (For example, AxisProxy, x y both call
          // getData and setDate sequentially).
          // So the context.data should be fetched from
          // upstream each time when a stage starts to be
          // performed.

          if (task !== this.dataTask) {
            context.data = data
          }
        }

        inner$1(this).data = data
      }

      SeriesModel.prototype.getEncode = function () {
        const encode = this.get('encode', true)

        if (encode) {
          return createHashMap(encode)
        }
      }

      SeriesModel.prototype.getSourceManager = function () {
        return inner$1(this).sourceManager
      }

      SeriesModel.prototype.getSource = function () {
        return this.getSourceManager().getSource()
      }
      /**
       * Get data before processed
       */

      SeriesModel.prototype.getRawData = function () {
        return inner$1(this).dataBeforeProcessed
      }

      SeriesModel.prototype.getColorBy = function () {
        const colorBy = this.get('colorBy')
        return colorBy || 'series'
      }

      SeriesModel.prototype.isColorBySeries = function () {
        return this.getColorBy() === 'series'
      }
      /**
       * Get base axis if has coordinate system and has axis.
       * By default use coordSys.getBaseAxis();
       * Can be overrided for some chart.
       * @return {type} description
       */

      SeriesModel.prototype.getBaseAxis = function () {
        const coordSys = this.coordinateSystem // @ts-ignore

        return coordSys && coordSys.getBaseAxis && coordSys.getBaseAxis()
      }
      /**
       * Default tooltip formatter
       *
       * @param dataIndex
       * @param multipleSeries
       * @param dataType
       * @param renderMode valid values: 'html'(by default) and 'richText'.
       *        'html' is used for rendering tooltip in extra DOM form, and the result
       *        string is used as DOM HTML content.
       *        'richText' is used for rendering tooltip in rich text form, for those where
       *        DOM operation is not supported.
       * @return formatted tooltip with `html` and `markers`
       *        Notice: The override method can also return string
       */

      SeriesModel.prototype.formatTooltip = function (dataIndex, multipleSeries, dataType) {
        return defaultSeriesFormatTooltip({
          series: this,
          dataIndex: dataIndex,
          multipleSeries: multipleSeries
        })
      }

      SeriesModel.prototype.isAnimationEnabled = function () {
        const ecModel = this.ecModel // Disable animation if using echarts in node but not give ssr flag.
        // In ssr mode, renderToString will generate svg with css animation.

        if (env.node && !(ecModel && ecModel.ssr)) {
          return false
        }

        let animationEnabled = this.getShallow('animation')

        if (animationEnabled) {
          if (this.getData().count() > this.getShallow('animationThreshold')) {
            animationEnabled = false
          }
        }

        return !!animationEnabled
      }

      SeriesModel.prototype.restoreData = function () {
        this.dataTask.dirty()
      }

      SeriesModel.prototype.getColorFromPalette = function (name, scope, requestColorNum) {
        const ecModel = this.ecModel // PENDING

        let color = PaletteMixin.prototype.getColorFromPalette.call(this, name, scope, requestColorNum)

        if (!color) {
          color = ecModel.getColorFromPalette(name, scope, requestColorNum)
        }

        return color
      }
      /**
       * Use `data.mapDimensionsAll(coordDim)` instead.
       * @deprecated
       */

      SeriesModel.prototype.coordDimToDataDim = function (coordDim) {
        return this.getRawData().mapDimensionsAll(coordDim)
      }
      /**
       * Get progressive rendering count each step
       */

      SeriesModel.prototype.getProgressive = function () {
        return this.get('progressive')
      }
      /**
       * Get progressive rendering count each step
       */

      SeriesModel.prototype.getProgressiveThreshold = function () {
        return this.get('progressiveThreshold')
      } // PENGING If selectedMode is null ?

      SeriesModel.prototype.select = function (innerDataIndices, dataType) {
        this._innerSelect(this.getData(dataType), innerDataIndices)
      }

      SeriesModel.prototype.unselect = function (innerDataIndices, dataType) {
        const selectedMap = this.option.selectedMap

        if (!selectedMap) {
          return
        }

        const selectedMode = this.option.selectedMode
        const data = this.getData(dataType)

        if (selectedMode === 'series' || selectedMap === 'all') {
          this.option.selectedMap = {}
          this._selectedDataIndicesMap = {}
          return
        }

        for (let i = 0; i < innerDataIndices.length; i++) {
          const dataIndex = innerDataIndices[i]
          const nameOrId = getSelectionKey(data, dataIndex)
          selectedMap[nameOrId] = false
          this._selectedDataIndicesMap[nameOrId] = -1
        }
      }

      SeriesModel.prototype.toggleSelect = function (innerDataIndices, dataType) {
        const tmpArr = []

        for (let i = 0; i < innerDataIndices.length; i++) {
          tmpArr[0] = innerDataIndices[i]
          this.isSelected(innerDataIndices[i], dataType) ? this.unselect(tmpArr, dataType) : this.select(tmpArr, dataType)
        }
      }

      SeriesModel.prototype.getSelectedDataIndices = function () {
        if (this.option.selectedMap === 'all') {
          return [].slice.call(this.getData().getIndices())
        }

        const selectedDataIndicesMap = this._selectedDataIndicesMap
        const nameOrIds = keys(selectedDataIndicesMap)
        const dataIndices = []

        for (let i = 0; i < nameOrIds.length; i++) {
          const dataIndex = selectedDataIndicesMap[nameOrIds[i]]

          if (dataIndex >= 0) {
            dataIndices.push(dataIndex)
          }
        }

        return dataIndices
      }

      SeriesModel.prototype.isSelected = function (dataIndex, dataType) {
        const selectedMap = this.option.selectedMap

        if (!selectedMap) {
          return false
        }

        const data = this.getData(dataType)
        return (selectedMap === 'all' || selectedMap[getSelectionKey(data, dataIndex)]) && !data.getItemModel(dataIndex).get(['select', 'disabled'])
      }

      SeriesModel.prototype.isUniversalTransitionEnabled = function () {
        if (this[SERIES_UNIVERSAL_TRANSITION_PROP]) {
          return true
        }

        const universalTransitionOpt = this.option.universalTransition // Quick reject

        if (!universalTransitionOpt) {
          return false
        }

        if (universalTransitionOpt === true) {
          return true
        } // Can be simply 'universalTransition: true'

        return universalTransitionOpt && universalTransitionOpt.enabled
      }

      SeriesModel.prototype._innerSelect = function (data, innerDataIndices) {
        let _a, _b

        const option = this.option
        const selectedMode = option.selectedMode
        const len = innerDataIndices.length

        if (!selectedMode || !len) {
          return
        }

        if (selectedMode === 'series') {
          option.selectedMap = 'all'
        } else if (selectedMode === 'multiple') {
          if (!isObject(option.selectedMap)) {
            option.selectedMap = {}
          }

          const selectedMap = option.selectedMap

          for (let i = 0; i < len; i++) {
            const dataIndex = innerDataIndices[i] // TODO diffrent types of data share same object.

            var nameOrId = getSelectionKey(data, dataIndex)
            selectedMap[nameOrId] = true
            this._selectedDataIndicesMap[nameOrId] = data.getRawIndex(dataIndex)
          }
        } else if (selectedMode === 'single' || selectedMode === true) {
          const lastDataIndex = innerDataIndices[len - 1]
          var nameOrId = getSelectionKey(data, lastDataIndex)
          option.selectedMap = (_a = {}, _a[nameOrId] = true, _a)
          this._selectedDataIndicesMap = (_b = {}, _b[nameOrId] = data.getRawIndex(lastDataIndex), _b)
        }
      }

      SeriesModel.prototype._initSelectedMapFromData = function (data) {
        // Ignore select info in data if selectedMap exists.
        // NOTE It's only for legacy usage. edge data is not supported.
        if (this.option.selectedMap) {
          return
        }

        const dataIndices = []

        if (data.hasItemOption) {
          data.each(function (idx) {
            const rawItem = data.getRawDataItem(idx)

            if (rawItem && rawItem.selected) {
              dataIndices.push(idx)
            }
          })
        }

        if (dataIndices.length > 0) {
          this._innerSelect(data, dataIndices)
        }
      } // /**
      //  * @see {module:echarts/stream/Scheduler}
      //  */
      // abstract pipeTask: null

      SeriesModel.registerClass = function (clz) {
        return ComponentModel.registerClass(clz)
      }

      SeriesModel.protoInitialize = (function () {
        const proto = SeriesModel.prototype
        proto.type = 'series.__base__'
        proto.seriesIndex = 0
        proto.ignoreStyleOnData = false
        proto.hasSymbolVisual = false
        proto.defaultSymbol = 'circle' // Make sure the values can be accessed!

        proto.visualStyleAccessPath = 'itemStyle'
        proto.visualDrawType = 'fill'
      }())

      return SeriesModel
    }(ComponentModel))

  mixin(SeriesModel, DataFormatMixin)
  mixin(SeriesModel, PaletteMixin)
  mountExtend(SeriesModel, ComponentModel)
  /**
     * MUST be called after `prepareSource` called
     * Here we need to make auto series, especially for auto legend. But we
     * do not modify series.name in option to avoid side effects.
     */

  function autoSeriesName (seriesModel) {
    // User specified name has higher priority, otherwise it may cause
    // series can not be queried unexpectedly.
    const name = seriesModel.name

    if (!isNameSpecified(seriesModel)) {
      seriesModel.name = getSeriesAutoName(seriesModel) || name
    }
  }

  function getSeriesAutoName (seriesModel) {
    const data = seriesModel.getRawData()
    const dataDims = data.mapDimensionsAll('seriesName')
    const nameArr = []
    each(dataDims, function (dataDim) {
      const dimInfo = data.getDimensionInfo(dataDim)
      dimInfo.displayName && nameArr.push(dimInfo.displayName)
    })
    return nameArr.join(' ')
  }

  function dataTaskCount (context) {
    return context.model.getRawData().count()
  }

  function dataTaskReset (context) {
    const seriesModel = context.model
    seriesModel.setData(seriesModel.getRawData().cloneShallow())
    return dataTaskProgress
  }

  function dataTaskProgress (param, context) {
    // Avoid repead cloneShallow when data just created in reset.
    if (context.outputData && param.end > context.outputData.count()) {
      context.model.getRawData().cloneShallow(context.outputData)
    }
  } // TODO refactor

  function wrapData (data, seriesModel) {
    each(concatArray(data.CHANGABLE_METHODS, data.DOWNSAMPLE_METHODS), function (methodName) {
      data.wrapMethod(methodName, curry(onDataChange, seriesModel))
    })
  }

  function onDataChange (seriesModel, newList) {
    const task = getCurrentTask(seriesModel)

    if (task) {
      // Consider case: filter, selectRange
      task.setOutputEnd((newList || this).count())
    }

    return newList
  }

  function getCurrentTask (seriesModel) {
    const scheduler = (seriesModel.ecModel || {}).scheduler
    const pipeline = scheduler && scheduler.getPipeline(seriesModel.uid)

    if (pipeline) {
      // When pipline finished, the currrentTask keep the last
      // task (renderTask).
      let task = pipeline.currentTask

      if (task) {
        const agentStubMap = task.agentStubMap

        if (agentStubMap) {
          task = agentStubMap.get(seriesModel.uid)
        }
      }

      return task
    }
  }

  const ComponentView =
    /** @class */
    (function () {
      function ComponentView () {
        this.group = new Group()
        this.uid = getUID('viewComponent')
      }

      ComponentView.prototype.init = function (ecModel, api) {}

      ComponentView.prototype.render = function (model, ecModel, api, payload) {}

      ComponentView.prototype.dispose = function (ecModel, api) {}

      ComponentView.prototype.updateView = function (model, ecModel, api, payload) { // Do nothing;
      }

      ComponentView.prototype.updateLayout = function (model, ecModel, api, payload) { // Do nothing;
      }

      ComponentView.prototype.updateVisual = function (model, ecModel, api, payload) { // Do nothing;
      }
      /**
       * Hook for toggle blur target series.
       * Can be used in marker for blur or leave blur the markers
       */

      ComponentView.prototype.toggleBlurSeries = function (seriesModels, isBlur, ecModel) { // Do nothing;
      }
      /**
       * Traverse the new rendered elements.
       *
       * It will traverse the new added element in progressive rendering.
       * And traverse all in normal rendering.
       */

      ComponentView.prototype.eachRendered = function (cb) {
        const group = this.group

        if (group) {
          group.traverse(cb)
        }
      }

      return ComponentView
    }())
  enableClassExtend(ComponentView)
  enableClassManagement(ComponentView)

  /**
     * @return {string} If large mode changed, return string 'reset';
     */

  function createRenderPlanner () {
    const inner = makeInner()
    return function (seriesModel) {
      const fields = inner(seriesModel)
      const pipelineContext = seriesModel.pipelineContext
      const originalLarge = !!fields.large
      const originalProgressive = !!fields.progressiveRender // FIXME: if the planner works on a filtered series, `pipelineContext` does not
      // exists. See #11611 . Probably we need to modify this structure, see the comment
      // on `performRawSeries` in `Schedular.js`.

      const large = fields.large = !!(pipelineContext && pipelineContext.large)
      const progressive = fields.progressiveRender = !!(pipelineContext && pipelineContext.progressiveRender)
      return !!(originalLarge !== large || originalProgressive !== progressive) && 'reset'
    }
  }

  const inner$2 = makeInner()
  const renderPlanner = createRenderPlanner()

  const ChartView =
    /** @class */
    (function () {
      function ChartView () {
        this.group = new Group()
        this.uid = getUID('viewChart')
        this.renderTask = createTask({
          plan: renderTaskPlan,
          reset: renderTaskReset
        })
        this.renderTask.context = {
          view: this
        }
      }

      ChartView.prototype.init = function (ecModel, api) {}

      ChartView.prototype.render = function (seriesModel, ecModel, api, payload) {
        if ('development' !== 'production') {
          throw new Error('render method must been implemented')
        }
      }
      /**
       * Highlight series or specified data item.
       */

      ChartView.prototype.highlight = function (seriesModel, ecModel, api, payload) {
        const data = seriesModel.getData(payload && payload.dataType)

        if (!data) {
          if ('development' !== 'production') {
            error('Unknown dataType ' + payload.dataType)
          }

          return
        }

        toggleHighlight(data, payload, 'emphasis')
      }
      /**
       * Downplay series or specified data item.
       */

      ChartView.prototype.downplay = function (seriesModel, ecModel, api, payload) {
        const data = seriesModel.getData(payload && payload.dataType)

        if (!data) {
          if ('development' !== 'production') {
            error('Unknown dataType ' + payload.dataType)
          }

          return
        }

        toggleHighlight(data, payload, 'normal')
      }
      /**
       * Remove self.
       */

      ChartView.prototype.remove = function (ecModel, api) {
        this.group.removeAll()
      }
      /**
       * Dispose self.
       */

      ChartView.prototype.dispose = function (ecModel, api) {}

      ChartView.prototype.updateView = function (seriesModel, ecModel, api, payload) {
        this.render(seriesModel, ecModel, api, payload)
      } // FIXME never used?

      ChartView.prototype.updateLayout = function (seriesModel, ecModel, api, payload) {
        this.render(seriesModel, ecModel, api, payload)
      } // FIXME never used?

      ChartView.prototype.updateVisual = function (seriesModel, ecModel, api, payload) {
        this.render(seriesModel, ecModel, api, payload)
      }
      /**
       * Traverse the new rendered elements.
       *
       * It will traverse the new added element in progressive rendering.
       * And traverse all in normal rendering.
       */

      ChartView.prototype.eachRendered = function (cb) {
        traverseElements(this.group, cb)
      }

      ChartView.markUpdateMethod = function (payload, methodName) {
        inner$2(payload).updateMethod = methodName
      }

      ChartView.protoInitialize = (function () {
        const proto = ChartView.prototype
        proto.type = 'chart'
      }())

      return ChartView
    }())
    /**
     * Set state of single element
     */

  function elSetState (el, state, highlightDigit) {
    if (el && isHighDownDispatcher(el)) {
      (state === 'emphasis' ? enterEmphasis : leaveEmphasis)(el, highlightDigit)
    }
  }

  function toggleHighlight (data, payload, state) {
    const dataIndex = queryDataIndex(data, payload)
    const highlightDigit = payload && payload.highlightKey != null ? getHighlightDigit(payload.highlightKey) : null

    if (dataIndex != null) {
      each(normalizeToArray(dataIndex), function (dataIdx) {
        elSetState(data.getItemGraphicEl(dataIdx), state, highlightDigit)
      })
    } else {
      data.eachItemGraphicEl(function (el) {
        elSetState(el, state, highlightDigit)
      })
    }
  }

  enableClassExtend(ChartView, ['dispose'])
  enableClassManagement(ChartView)

  function renderTaskPlan (context) {
    return renderPlanner(context.model)
  }

  function renderTaskReset (context) {
    const seriesModel = context.model
    const ecModel = context.ecModel
    const api = context.api
    const payload = context.payload // FIXME: remove updateView updateVisual

    const progressiveRender = seriesModel.pipelineContext.progressiveRender
    const view = context.view
    const updateMethod = payload && inner$2(payload).updateMethod
    const methodName = progressiveRender ? 'incrementalPrepareRender' : updateMethod && view[updateMethod] ? updateMethod // `appendData` is also supported when data amount
      // is less than progressive threshold.
      : 'render'

    if (methodName !== 'render') {
      view[methodName](seriesModel, ecModel, api, payload)
    }

    return progressMethodMap[methodName]
  }

  var progressMethodMap = {
    incrementalPrepareRender: {
      progress: function (params, context) {
        context.view.incrementalRender(params, context.model, context.ecModel, context.api, context.payload)
      }
    },
    render: {
      // Put view.render in `progress` to support appendData. But in this case
      // view.render should not be called in reset, otherwise it will be called
      // twise. Use `forceFirstProgress` to make sure that view.render is called
      // in any cases.
      forceFirstProgress: true,
      progress: function (params, context) {
        context.view.render(context.model, context.ecModel, context.api, context.payload)
      }
    }
  }

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

  /**
     * AUTO-GENERATED FILE. DO NOT MODIFY.
     */

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
  const ORIGIN_METHOD = '\0__throttleOriginMethod'
  const RATE = '\0__throttleRate'
  const THROTTLE_TYPE = '\0__throttleType'
  /**
     * @public
     * @param {(Function)} fn
     * @param {number} [delay=0] Unit: ms.
     * @param {boolean} [debounce=false]
     *        true: If call interval less than `delay`, only the last call works.
     *        false: If call interval less than `delay, call works on fixed rate.
     * @return {(Function)} throttled fn.
     */

  function throttle (fn, delay, debounce) {
    let currCall
    let lastCall = 0
    let lastExec = 0
    let timer = null
    let diff
    let scope
    let args
    let debounceNextCall
    delay = delay || 0

    function exec () {
      lastExec = new Date().getTime()
      timer = null
      fn.apply(scope, args || [])
    }

    const cb = function () {
      const cbArgs = []

      for (let _i = 0; _i < arguments.length; _i++) {
        cbArgs[_i] = arguments[_i]
      }

      currCall = new Date().getTime()
      scope = this
      args = cbArgs
      const thisDelay = debounceNextCall || delay
      const thisDebounce = debounceNextCall || debounce
      debounceNextCall = null
      diff = currCall - (thisDebounce ? lastCall : lastExec) - thisDelay
      clearTimeout(timer) // Here we should make sure that: the `exec` SHOULD NOT be called later
      // than a new call of `cb`, that is, preserving the command order. Consider
      // calculating "scale rate" when roaming as an example. When a call of `cb`
      // happens, either the `exec` is called dierectly, or the call is delayed.
      // But the delayed call should never be later than next call of `cb`. Under
      // this assurance, we can simply update view state each time `dispatchAction`
      // triggered by user roaming, but not need to add extra code to avoid the
      // state being "rolled-back".

      if (thisDebounce) {
        timer = setTimeout(exec, thisDelay)
      } else {
        if (diff >= 0) {
          exec()
        } else {
          timer = setTimeout(exec, -diff)
        }
      }

      lastCall = currCall
    }
    /**
       * Clear throttle.
       * @public
       */

    cb.clear = function () {
      if (timer) {
        clearTimeout(timer)
        timer = null
      }
    }
    /**
       * Enable debounce once.
       */

    cb.debounceNextCall = function (debounceDelay) {
      debounceNextCall = debounceDelay
    }

    return cb
  }
  /**
     * Create throttle method or update throttle rate.
     *
     * @example
     * ComponentView.prototype.render = function () {
     *     ...
     *     throttle.createOrUpdate(
     *         this,
     *         '_dispatchAction',
     *         this.model.get('throttle'),
     *         'fixRate'
     *     );
     * };
     * ComponentView.prototype.remove = function () {
     *     throttle.clear(this, '_dispatchAction');
     * };
     * ComponentView.prototype.dispose = function () {
     *     throttle.clear(this, '_dispatchAction');
     * };
     *
     */

  function createOrUpdate (obj, fnAttr, rate, throttleType) {
    let fn = obj[fnAttr]

    if (!fn) {
      return
    }

    const originFn = fn[ORIGIN_METHOD] || fn
    const lastThrottleType = fn[THROTTLE_TYPE]
    const lastRate = fn[RATE]

    if (lastRate !== rate || lastThrottleType !== throttleType) {
      if (rate == null || !throttleType) {
        return obj[fnAttr] = originFn
      }

      fn = obj[fnAttr] = throttle(originFn, rate, throttleType === 'debounce')
      fn[ORIGIN_METHOD] = originFn
      fn[THROTTLE_TYPE] = throttleType
      fn[RATE] = rate
    }

    return fn
  }
  /**
     * Clear throttle. Example see throttle.createOrUpdate.
     */

  function clear (obj, fnAttr) {
    const fn = obj[fnAttr]

    if (fn && fn[ORIGIN_METHOD]) {
      // Clear throttle
      fn.clear && fn.clear()
      obj[fnAttr] = fn[ORIGIN_METHOD]
    }
  }

  const inner$3 = makeInner()
  const defaultStyleMappers = {
    itemStyle: makeStyleMapper(ITEM_STYLE_KEY_MAP, true),
    lineStyle: makeStyleMapper(LINE_STYLE_KEY_MAP, true)
  }
  const defaultColorKey = {
    lineStyle: 'stroke',
    itemStyle: 'fill'
  }

  function getStyleMapper (seriesModel, stylePath) {
    const styleMapper = seriesModel.visualStyleMapper || defaultStyleMappers[stylePath]

    if (!styleMapper) {
      console.warn("Unkown style type '" + stylePath + "'.")
      return defaultStyleMappers.itemStyle
    }

    return styleMapper
  }

  function getDefaultColorKey (seriesModel, stylePath) {
    // return defaultColorKey[stylePath] ||
    const colorKey = seriesModel.visualDrawType || defaultColorKey[stylePath]

    if (!colorKey) {
      console.warn("Unkown style type '" + stylePath + "'.")
      return 'fill'
    }

    return colorKey
  }

  const seriesStyleTask = {
    createOnAllSeries: true,
    performRawSeries: true,
    reset: function (seriesModel, ecModel) {
      const data = seriesModel.getData()
      const stylePath = seriesModel.visualStyleAccessPath || 'itemStyle' // Set in itemStyle

      const styleModel = seriesModel.getModel(stylePath)
      const getStyle = getStyleMapper(seriesModel, stylePath)
      const globalStyle = getStyle(styleModel)
      const decalOption = styleModel.getShallow('decal')

      if (decalOption) {
        data.setVisual('decal', decalOption)
        decalOption.dirty = true
      } // TODO

      const colorKey = getDefaultColorKey(seriesModel, stylePath)
      const color = globalStyle[colorKey] // TODO style callback

      const colorCallback = isFunction(color) ? color : null
      const hasAutoColor = globalStyle.fill === 'auto' || globalStyle.stroke === 'auto' // Get from color palette by default.

      if (!globalStyle[colorKey] || colorCallback || hasAutoColor) {
        // Note: if some series has color specified (e.g., by itemStyle.color), we DO NOT
        // make it effect palette. Bacause some scenarios users need to make some series
        // transparent or as background, which should better not effect the palette.
        const colorPalette = seriesModel.getColorFromPalette( // TODO series count changed.
          seriesModel.name, null, ecModel.getSeriesCount())

        if (!globalStyle[colorKey]) {
          globalStyle[colorKey] = colorPalette
          data.setVisual('colorFromPalette', true)
        }

        globalStyle.fill = globalStyle.fill === 'auto' || isFunction(globalStyle.fill) ? colorPalette : globalStyle.fill
        globalStyle.stroke = globalStyle.stroke === 'auto' || isFunction(globalStyle.stroke) ? colorPalette : globalStyle.stroke
      }

      data.setVisual('style', globalStyle)
      data.setVisual('drawType', colorKey) // Only visible series has each data be visual encoded

      if (!ecModel.isSeriesFiltered(seriesModel) && colorCallback) {
        data.setVisual('colorFromPalette', false)
        return {
          dataEach: function (data, idx) {
            const dataParams = seriesModel.getDataParams(idx)
            const itemStyle = extend({}, globalStyle)
            itemStyle[colorKey] = colorCallback(dataParams)
            data.setItemVisual(idx, 'style', itemStyle)
          }
        }
      }
    }
  }
  const sharedModel = new Model()
  const dataStyleTask = {
    createOnAllSeries: true,
    performRawSeries: true,
    reset: function (seriesModel, ecModel) {
      if (seriesModel.ignoreStyleOnData || ecModel.isSeriesFiltered(seriesModel)) {
        return
      }

      const data = seriesModel.getData()
      const stylePath = seriesModel.visualStyleAccessPath || 'itemStyle' // Set in itemStyle

      const getStyle = getStyleMapper(seriesModel, stylePath)
      const colorKey = data.getVisual('drawType')
      return {
        dataEach: data.hasItemOption ? function (data, idx) {
          // Not use getItemModel for performance considuration
          const rawItem = data.getRawDataItem(idx)

          if (rawItem && rawItem[stylePath]) {
            sharedModel.option = rawItem[stylePath]
            const style = getStyle(sharedModel)
            const existsStyle = data.ensureUniqueItemVisual(idx, 'style')
            extend(existsStyle, style)

            if (sharedModel.option.decal) {
              data.setItemVisual(idx, 'decal', sharedModel.option.decal)
              sharedModel.option.decal.dirty = true
            }

            if (colorKey in style) {
              data.setItemVisual(idx, 'colorFromPalette', false)
            }
          }
        } : null
      }
    }
  } // Pick color from palette for the data which has not been set with color yet.
  // Note: do not support stream rendering. No such cases yet.

  const dataColorPaletteTask = {
    performRawSeries: true,
    overallReset: function (ecModel) {
      // Each type of series use one scope.
      // Pie and funnel are using diferrent scopes
      const paletteScopeGroupByType = createHashMap()
      ecModel.eachSeries(function (seriesModel) {
        const colorBy = seriesModel.getColorBy()

        if (seriesModel.isColorBySeries()) {
          return
        }

        const key = seriesModel.type + '-' + colorBy
        let colorScope = paletteScopeGroupByType.get(key)

        if (!colorScope) {
          colorScope = {}
          paletteScopeGroupByType.set(key, colorScope)
        }

        inner$3(seriesModel).scope = colorScope
      })
      ecModel.eachSeries(function (seriesModel) {
        if (seriesModel.isColorBySeries() || ecModel.isSeriesFiltered(seriesModel)) {
          return
        }

        const dataAll = seriesModel.getRawData()
        const idxMap = {}
        const data = seriesModel.getData()
        const colorScope = inner$3(seriesModel).scope
        const stylePath = seriesModel.visualStyleAccessPath || 'itemStyle'
        const colorKey = getDefaultColorKey(seriesModel, stylePath)
        data.each(function (idx) {
          const rawIdx = data.getRawIndex(idx)
          idxMap[rawIdx] = idx
        }) // Iterate on data before filtered. To make sure color from palette can be
        // Consistent when toggling legend.

        dataAll.each(function (rawIdx) {
          const idx = idxMap[rawIdx]
          const fromPalette = data.getItemVisual(idx, 'colorFromPalette') // Get color from palette for each data only when the color is inherited from series color, which is
          // also picked from color palette. So following situation is not in the case:
          // 1. series.itemStyle.color is set
          // 2. color is encoded by visualMap

          if (fromPalette) {
            const itemStyle = data.ensureUniqueItemVisual(idx, 'style')
            const name_1 = dataAll.getName(rawIdx) || rawIdx + ''
            const dataCount = dataAll.count()
            itemStyle[colorKey] = seriesModel.getColorFromPalette(name_1, colorScope, dataCount)
          }
        })
      })
    }
  }

  const PI$3 = Math.PI
  /**
     * @param {module:echarts/ExtensionAPI} api
     * @param {Object} [opts]
     * @param {string} [opts.text]
     * @param {string} [opts.color]
     * @param {string} [opts.textColor]
     * @return {module:zrender/Element}
     */

  function defaultLoading (api, opts) {
    opts = opts || {}
    defaults(opts, {
      text: 'loading',
      textColor: '#000',
      fontSize: 12,
      fontWeight: 'normal',
      fontStyle: 'normal',
      fontFamily: 'sans-serif',
      maskColor: 'rgba(255, 255, 255, 0.8)',
      showSpinner: true,
      color: '#5470c6',
      spinnerRadius: 10,
      lineWidth: 5,
      zlevel: 0
    })
    const group = new Group()
    const mask = new Rect({
      style: {
        fill: opts.maskColor
      },
      zlevel: opts.zlevel,
      z: 10000
    })
    group.add(mask)
    const textContent = new ZRText({
      style: {
        text: opts.text,
        fill: opts.textColor,
        fontSize: opts.fontSize,
        fontWeight: opts.fontWeight,
        fontStyle: opts.fontStyle,
        fontFamily: opts.fontFamily
      },
      zlevel: opts.zlevel,
      z: 10001
    })
    const labelRect = new Rect({
      style: {
        fill: 'none'
      },
      textContent: textContent,
      textConfig: {
        position: 'right',
        distance: 10
      },
      zlevel: opts.zlevel,
      z: 10001
    })
    group.add(labelRect)
    let arc

    if (opts.showSpinner) {
      arc = new Arc({
        shape: {
          startAngle: -PI$3 / 2,
          endAngle: -PI$3 / 2 + 0.1,
          r: opts.spinnerRadius
        },
        style: {
          stroke: opts.color,
          lineCap: 'round',
          lineWidth: opts.lineWidth
        },
        zlevel: opts.zlevel,
        z: 10001
      })
      arc.animateShape(true).when(1000, {
        endAngle: PI$3 * 3 / 2
      }).start('circularInOut')
      arc.animateShape(true).when(1000, {
        startAngle: PI$3 * 3 / 2
      }).delay(300).start('circularInOut')
      group.add(arc)
    } // Inject resize

    group.resize = function () {
      const textWidth = textContent.getBoundingRect().width
      const r = opts.showSpinner ? opts.spinnerRadius : 0 // cx = (containerWidth - arcDiameter - textDistance - textWidth) / 2
      // textDistance needs to be calculated when both animation and text exist

      const cx = (api.getWidth() - r * 2 - (opts.showSpinner && textWidth ? 10 : 0) - textWidth) / 2 - (opts.showSpinner && textWidth ? 0 : 5 + textWidth / 2) + // only show the text
        (opts.showSpinner ? 0 : textWidth / 2) + // only show the spinner
        (textWidth ? 0 : r)
      const cy = api.getHeight() / 2
      opts.showSpinner && arc.setShape({
        cx: cx,
        cy: cy
      })
      labelRect.setShape({
        x: cx - r,
        y: cy - r,
        width: r * 2,
        height: r * 2
      })
      mask.setShape({
        x: 0,
        y: 0,
        width: api.getWidth(),
        height: api.getHeight()
      })
    }

    group.resize()
    return group
  }

  const Scheduler =
    /** @class */
    (function () {
      function Scheduler (ecInstance, api, dataProcessorHandlers, visualHandlers) {
        // key: handlerUID
        this._stageTaskMap = createHashMap()
        this.ecInstance = ecInstance
        this.api = api // Fix current processors in case that in some rear cases that
        // processors might be registered after echarts instance created.
        // Register processors incrementally for a echarts instance is
        // not supported by this stream architecture.

        dataProcessorHandlers = this._dataProcessorHandlers = dataProcessorHandlers.slice()
        visualHandlers = this._visualHandlers = visualHandlers.slice()
        this._allHandlers = dataProcessorHandlers.concat(visualHandlers)
      }

      Scheduler.prototype.restoreData = function (ecModel, payload) {
        // TODO: Only restore needed series and components, but not all components.
        // Currently `restoreData` of all of the series and component will be called.
        // But some independent components like `title`, `legend`, `graphic`, `toolbox`,
        // `tooltip`, `axisPointer`, etc, do not need series refresh when `setOption`,
        // and some components like coordinate system, axes, dataZoom, visualMap only
        // need their target series refresh.
        // (1) If we are implementing this feature some day, we should consider these cases:
        // if a data processor depends on a component (e.g., dataZoomProcessor depends
        // on the settings of `dataZoom`), it should be re-performed if the component
        // is modified by `setOption`.
        // (2) If a processor depends on sevral series, speicified by its `getTargetSeries`,
        // it should be re-performed when the result array of `getTargetSeries` changed.
        // We use `dependencies` to cover these issues.
        // (3) How to update target series when coordinate system related components modified.
        // TODO: simply the dirty mechanism? Check whether only the case here can set tasks dirty,
        // and this case all of the tasks will be set as dirty.
        ecModel.restoreData(payload) // Theoretically an overall task not only depends on each of its target series, but also
        // depends on all of the series.
        // The overall task is not in pipeline, and `ecModel.restoreData` only set pipeline tasks
        // dirty. If `getTargetSeries` of an overall task returns nothing, we should also ensure
        // that the overall task is set as dirty and to be performed, otherwise it probably cause
        // state chaos. So we have to set dirty of all of the overall tasks manually, otherwise it
        // probably cause state chaos (consider `dataZoomProcessor`).

        this._stageTaskMap.each(function (taskRecord) {
          const overallTask = taskRecord.overallTask
          overallTask && overallTask.dirty()
        })
      } // If seriesModel provided, incremental threshold is check by series data.

      Scheduler.prototype.getPerformArgs = function (task, isBlock) {
        // For overall task
        if (!task.__pipeline) {
          return
        }

        const pipeline = this._pipelineMap.get(task.__pipeline.id)

        const pCtx = pipeline.context
        const incremental = !isBlock && pipeline.progressiveEnabled && (!pCtx || pCtx.progressiveRender) && task.__idxInPipeline > pipeline.blockIndex
        const step = incremental ? pipeline.step : null
        const modDataCount = pCtx && pCtx.modDataCount
        const modBy = modDataCount != null ? Math.ceil(modDataCount / step) : null
        return {
          step: step,
          modBy: modBy,
          modDataCount: modDataCount
        }
      }

      Scheduler.prototype.getPipeline = function (pipelineId) {
        return this._pipelineMap.get(pipelineId)
      }
      /**
       * Current, progressive rendering starts from visual and layout.
       * Always detect render mode in the same stage, avoiding that incorrect
       * detection caused by data filtering.
       * Caution:
       * `updateStreamModes` use `seriesModel.getData()`.
       */

      Scheduler.prototype.updateStreamModes = function (seriesModel, view) {
        const pipeline = this._pipelineMap.get(seriesModel.uid)

        const data = seriesModel.getData()
        const dataLen = data.count() // `progressiveRender` means that can render progressively in each
        // animation frame. Note that some types of series do not provide
        // `view.incrementalPrepareRender` but support `chart.appendData`. We
        // use the term `incremental` but not `progressive` to describe the
        // case that `chart.appendData`.

        const progressiveRender = pipeline.progressiveEnabled && view.incrementalPrepareRender && dataLen >= pipeline.threshold
        const large = seriesModel.get('large') && dataLen >= seriesModel.get('largeThreshold') // TODO: modDataCount should not updated if `appendData`, otherwise cause whole repaint.
        // see `test/candlestick-large3.html`

        const modDataCount = seriesModel.get('progressiveChunkMode') === 'mod' ? dataLen : null
        seriesModel.pipelineContext = pipeline.context = {
          progressiveRender: progressiveRender,
          modDataCount: modDataCount,
          large: large
        }
      }

      Scheduler.prototype.restorePipelines = function (ecModel) {
        const scheduler = this
        const pipelineMap = scheduler._pipelineMap = createHashMap()
        ecModel.eachSeries(function (seriesModel) {
          const progressive = seriesModel.getProgressive()
          const pipelineId = seriesModel.uid
          pipelineMap.set(pipelineId, {
            id: pipelineId,
            head: null,
            tail: null,
            threshold: seriesModel.getProgressiveThreshold(),
            progressiveEnabled: progressive && !(seriesModel.preventIncremental && seriesModel.preventIncremental()),
            blockIndex: -1,
            step: Math.round(progressive || 700),
            count: 0
          })

          scheduler._pipe(seriesModel, seriesModel.dataTask)
        })
      }

      Scheduler.prototype.prepareStageTasks = function () {
        const stageTaskMap = this._stageTaskMap
        const ecModel = this.api.getModel()
        const api = this.api
        each(this._allHandlers, function (handler) {
          const record = stageTaskMap.get(handler.uid) || stageTaskMap.set(handler.uid, {})
          let errMsg = ''

          if ('development' !== 'production') {
            // Currently do not need to support to sepecify them both.
            errMsg = '"reset" and "overallReset" must not be both specified.'
          }

          assert(!(handler.reset && handler.overallReset), errMsg)
          handler.reset && this._createSeriesStageTask(handler, record, ecModel, api)
          handler.overallReset && this._createOverallStageTask(handler, record, ecModel, api)
        }, this)
      }

      Scheduler.prototype.prepareView = function (view, model, ecModel, api) {
        const renderTask = view.renderTask
        const context = renderTask.context
        context.model = model
        context.ecModel = ecModel
        context.api = api
        renderTask.__block = !view.incrementalPrepareRender

        this._pipe(model, renderTask)
      }

      Scheduler.prototype.performDataProcessorTasks = function (ecModel, payload) {
        // If we do not use `block` here, it should be considered when to update modes.
        this._performStageTasks(this._dataProcessorHandlers, ecModel, payload, {
          block: true
        })
      }

      Scheduler.prototype.performVisualTasks = function (ecModel, payload, opt) {
        this._performStageTasks(this._visualHandlers, ecModel, payload, opt)
      }

      Scheduler.prototype._performStageTasks = function (stageHandlers, ecModel, payload, opt) {
        opt = opt || {}
        let unfinished = false
        const scheduler = this
        each(stageHandlers, function (stageHandler, idx) {
          if (opt.visualType && opt.visualType !== stageHandler.visualType) {
            return
          }

          const stageHandlerRecord = scheduler._stageTaskMap.get(stageHandler.uid)

          const seriesTaskMap = stageHandlerRecord.seriesTaskMap
          const overallTask = stageHandlerRecord.overallTask

          if (overallTask) {
            let overallNeedDirty_1
            const agentStubMap = overallTask.agentStubMap
            agentStubMap.each(function (stub) {
              if (needSetDirty(opt, stub)) {
                stub.dirty()
                overallNeedDirty_1 = true
              }
            })
            overallNeedDirty_1 && overallTask.dirty()
            scheduler.updatePayload(overallTask, payload)
            const performArgs_1 = scheduler.getPerformArgs(overallTask, opt.block) // Execute stubs firstly, which may set the overall task dirty,
            // then execute the overall task. And stub will call seriesModel.setData,
            // which ensures that in the overallTask seriesModel.getData() will not
            // return incorrect data.

            agentStubMap.each(function (stub) {
              stub.perform(performArgs_1)
            })

            if (overallTask.perform(performArgs_1)) {
              unfinished = true
            }
          } else if (seriesTaskMap) {
            seriesTaskMap.each(function (task, pipelineId) {
              if (needSetDirty(opt, task)) {
                task.dirty()
              }

              const performArgs = scheduler.getPerformArgs(task, opt.block) // FIXME
              // if intending to decalare `performRawSeries` in handlers, only
              // stream-independent (specifically, data item independent) operations can be
              // performed. Because is a series is filtered, most of the tasks will not
              // be performed. A stream-dependent operation probably cause wrong biz logic.
              // Perhaps we should not provide a separate callback for this case instead
              // of providing the config `performRawSeries`. The stream-dependent operaions
              // and stream-independent operations should better not be mixed.

              performArgs.skip = !stageHandler.performRawSeries && ecModel.isSeriesFiltered(task.context.model)
              scheduler.updatePayload(task, payload)

              if (task.perform(performArgs)) {
                unfinished = true
              }
            })
          }
        })

        function needSetDirty (opt, task) {
          return opt.setDirty && (!opt.dirtyMap || opt.dirtyMap.get(task.__pipeline.id))
        }

        this.unfinished = unfinished || this.unfinished
      }

      Scheduler.prototype.performSeriesTasks = function (ecModel) {
        let unfinished
        ecModel.eachSeries(function (seriesModel) {
          // Progress to the end for dataInit and dataRestore.
          unfinished = seriesModel.dataTask.perform() || unfinished
        })
        this.unfinished = unfinished || this.unfinished
      }

      Scheduler.prototype.plan = function () {
        // Travel pipelines, check block.
        this._pipelineMap.each(function (pipeline) {
          let task = pipeline.tail

          do {
            if (task.__block) {
              pipeline.blockIndex = task.__idxInPipeline
              break
            }

            task = task.getUpstream()
          } while (task)
        })
      }

      Scheduler.prototype.updatePayload = function (task, payload) {
        payload !== 'remain' && (task.context.payload = payload)
      }

      Scheduler.prototype._createSeriesStageTask = function (stageHandler, stageHandlerRecord, ecModel, api) {
        const scheduler = this
        const oldSeriesTaskMap = stageHandlerRecord.seriesTaskMap // The count of stages are totally about only several dozen, so
        // do not need to reuse the map.

        const newSeriesTaskMap = stageHandlerRecord.seriesTaskMap = createHashMap()
        const seriesType = stageHandler.seriesType
        const getTargetSeries = stageHandler.getTargetSeries // If a stageHandler should cover all series, `createOnAllSeries` should be declared mandatorily,
        // to avoid some typo or abuse. Otherwise if an extension do not specify a `seriesType`,
        // it works but it may cause other irrelevant charts blocked.

        if (stageHandler.createOnAllSeries) {
          ecModel.eachRawSeries(create)
        } else if (seriesType) {
          ecModel.eachRawSeriesByType(seriesType, create)
        } else if (getTargetSeries) {
          getTargetSeries(ecModel, api).each(create)
        }

        function create (seriesModel) {
          const pipelineId = seriesModel.uid // Init tasks for each seriesModel only once.
          // Reuse original task instance.

          const task = newSeriesTaskMap.set(pipelineId, oldSeriesTaskMap && oldSeriesTaskMap.get(pipelineId) || createTask({
            plan: seriesTaskPlan,
            reset: seriesTaskReset,
            count: seriesTaskCount
          }))
          task.context = {
            model: seriesModel,
            ecModel: ecModel,
            api: api,
            // PENDING: `useClearVisual` not used?
            useClearVisual: stageHandler.isVisual && !stageHandler.isLayout,
            plan: stageHandler.plan,
            reset: stageHandler.reset,
            scheduler: scheduler
          }

          scheduler._pipe(seriesModel, task)
        }
      }

      Scheduler.prototype._createOverallStageTask = function (stageHandler, stageHandlerRecord, ecModel, api) {
        const scheduler = this
        const overallTask = stageHandlerRecord.overallTask = stageHandlerRecord.overallTask || // For overall task, the function only be called on reset stage.
        createTask({
          reset: overallTaskReset
        })
        overallTask.context = {
          ecModel: ecModel,
          api: api,
          overallReset: stageHandler.overallReset,
          scheduler: scheduler
        }
        const oldAgentStubMap = overallTask.agentStubMap // The count of stages are totally about only several dozen, so
        // do not need to reuse the map.

        const newAgentStubMap = overallTask.agentStubMap = createHashMap()
        const seriesType = stageHandler.seriesType
        const getTargetSeries = stageHandler.getTargetSeries
        let overallProgress = true
        let shouldOverallTaskDirty = false // FIXME:TS never used, so comment it
        // let modifyOutputEnd = stageHandler.modifyOutputEnd;
        // An overall task with seriesType detected or has `getTargetSeries`, we add
        // stub in each pipelines, it will set the overall task dirty when the pipeline
        // progress. Moreover, to avoid call the overall task each frame (too frequent),
        // we set the pipeline block.

        let errMsg = ''

        if ('development' !== 'production') {
          errMsg = '"createOnAllSeries" do not supported for "overallReset", ' + 'becuase it will block all streams.'
        }

        assert(!stageHandler.createOnAllSeries, errMsg)

        if (seriesType) {
          ecModel.eachRawSeriesByType(seriesType, createStub)
        } else if (getTargetSeries) {
          getTargetSeries(ecModel, api).each(createStub)
        } // Otherwise, (usually it is legancy case), the overall task will only be
        // executed when upstream dirty. Otherwise the progressive rendering of all
        // pipelines will be disabled unexpectedly. But it still needs stubs to receive
        // dirty info from upsteam.
        else {
          overallProgress = false
          each(ecModel.getSeries(), createStub)
        }

        function createStub (seriesModel) {
          const pipelineId = seriesModel.uid
          const stub = newAgentStubMap.set(pipelineId, oldAgentStubMap && oldAgentStubMap.get(pipelineId) || ( // When the result of `getTargetSeries` changed, the overallTask
          // should be set as dirty and re-performed.
            shouldOverallTaskDirty = true, createTask({
              reset: stubReset,
              onDirty: stubOnDirty
            })))
          stub.context = {
            model: seriesModel,
            overallProgress: overallProgress // FIXME:TS never used, so comment it
            // modifyOutputEnd: modifyOutputEnd

          }
          stub.agent = overallTask
          stub.__block = overallProgress

          scheduler._pipe(seriesModel, stub)
        }

        if (shouldOverallTaskDirty) {
          overallTask.dirty()
        }
      }

      Scheduler.prototype._pipe = function (seriesModel, task) {
        const pipelineId = seriesModel.uid

        const pipeline = this._pipelineMap.get(pipelineId)

        !pipeline.head && (pipeline.head = task)
        pipeline.tail && pipeline.tail.pipe(task)
        pipeline.tail = task
        task.__idxInPipeline = pipeline.count++
        task.__pipeline = pipeline
      }

      Scheduler.wrapStageHandler = function (stageHandler, visualType) {
        if (isFunction(stageHandler)) {
          stageHandler = {
            overallReset: stageHandler,
            seriesType: detectSeriseType(stageHandler)
          }
        }

        stageHandler.uid = getUID('stageHandler')
        visualType && (stageHandler.visualType = visualType)
        return stageHandler
      }
      return Scheduler
    }())

  function overallTaskReset (context) {
    context.overallReset(context.ecModel, context.api, context.payload)
  }

  function stubReset (context) {
    return context.overallProgress && stubProgress
  }

  function stubProgress () {
    this.agent.dirty()
    this.getDownstream().dirty()
  }

  function stubOnDirty () {
    this.agent && this.agent.dirty()
  }

  function seriesTaskPlan (context) {
    return context.plan ? context.plan(context.model, context.ecModel, context.api, context.payload) : null
  }

  function seriesTaskReset (context) {
    if (context.useClearVisual) {
      context.data.clearAllVisual()
    }

    const resetDefines = context.resetDefines = normalizeToArray(context.reset(context.model, context.ecModel, context.api, context.payload))
    return resetDefines.length > 1
      ? map(resetDefines, function (v, idx) {
        return makeSeriesTaskProgress(idx)
      })
      : singleSeriesTaskProgress
  }

  var singleSeriesTaskProgress = makeSeriesTaskProgress(0)

  function makeSeriesTaskProgress (resetDefineIdx) {
    return function (params, context) {
      const data = context.data
      const resetDefine = context.resetDefines[resetDefineIdx]

      if (resetDefine && resetDefine.dataEach) {
        for (let i = params.start; i < params.end; i++) {
          resetDefine.dataEach(data, i)
        }
      } else if (resetDefine && resetDefine.progress) {
        resetDefine.progress(params, data)
      }
    }
  }

  function seriesTaskCount (context) {
    return context.data.count()
  }
  /**
     * Only some legacy stage handlers (usually in echarts extensions) are pure function.
     * To ensure that they can work normally, they should work in block mode, that is,
     * they should not be started util the previous tasks finished. So they cause the
     * progressive rendering disabled. We try to detect the series type, to narrow down
     * the block range to only the series type they concern, but not all series.
     */

  function detectSeriseType (legacyFunc) {
    seriesType = null

    try {
      // Assume there is no async when calling `eachSeriesByType`.
      legacyFunc(ecModelMock, apiMock)
    } catch (e) {}

    return seriesType
  }

  var ecModelMock = {}
  var apiMock = {}
  let seriesType
  mockMethods(ecModelMock, GlobalModel)
  mockMethods(apiMock, ExtensionAPI)

  ecModelMock.eachSeriesByType = ecModelMock.eachRawSeriesByType = function (type) {
    seriesType = type
  }

  ecModelMock.eachComponent = function (cond) {
    if (cond.mainType === 'series' && cond.subType) {
      seriesType = cond.subType
    }
  }

  function mockMethods (target, Clz) {
    /* eslint-disable */
      for (var name_1 in Clz.prototype) {
        // Do not use hasOwnProperty
        target[name_1] = noop;
      }
      /* eslint-enable */
  }

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

  /**
     * AUTO-GENERATED FILE. DO NOT MODIFY.
     */

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
  const colorAll = ['#37A2DA', '#32C5E9', '#67E0E3', '#9FE6B8', '#FFDB5C', '#ff9f7f', '#fb7293', '#E062AE', '#E690D1', '#e7bcf3', '#9d96f5', '#8378EA', '#96BFFF']
  const lightTheme = {
    color: colorAll,
    colorLayer: [['#37A2DA', '#ffd85c', '#fd7b5f'], ['#37A2DA', '#67E0E3', '#FFDB5C', '#ff9f7f', '#E062AE', '#9d96f5'], ['#37A2DA', '#32C5E9', '#9FE6B8', '#FFDB5C', '#ff9f7f', '#fb7293', '#e7bcf3', '#8378EA', '#96BFFF'], colorAll]
  }

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

  /**
     * AUTO-GENERATED FILE. DO NOT MODIFY.
     */

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
  const contrastColor = '#B9B8CE'
  const backgroundColor = '#100C2A'

  const axisCommon = function () {
    return {
      axisLine: {
        lineStyle: {
          color: contrastColor
        }
      },
      splitLine: {
        lineStyle: {
          color: '#484753'
        }
      },
      splitArea: {
        areaStyle: {
          color: ['rgba(255,255,255,0.02)', 'rgba(255,255,255,0.05)']
        }
      },
      minorSplitLine: {
        lineStyle: {
          color: '#20203B'
        }
      }
    }
  }

  const colorPalette = ['#4992ff', '#7cffb2', '#fddd60', '#ff6e76', '#58d9f9', '#05c091', '#ff8a45', '#8d48e3', '#dd79ff']
  const theme = {
    darkMode: true,
    color: colorPalette,
    backgroundColor: backgroundColor,
    axisPointer: {
      lineStyle: {
        color: '#817f91'
      },
      crossStyle: {
        color: '#817f91'
      },
      label: {
        // TODO Contrast of label backgorundColor
        color: '#fff'
      }
    },
    legend: {
      textStyle: {
        color: contrastColor
      }
    },
    textStyle: {
      color: contrastColor
    },
    title: {
      textStyle: {
        color: '#EEF1FA'
      },
      subtextStyle: {
        color: '#B9B8CE'
      }
    },
    toolbox: {
      iconStyle: {
        borderColor: contrastColor
      }
    },
    dataZoom: {
      borderColor: '#71708A',
      textStyle: {
        color: contrastColor
      },
      brushStyle: {
        color: 'rgba(135,163,206,0.3)'
      },
      handleStyle: {
        color: '#353450',
        borderColor: '#C5CBE3'
      },
      moveHandleStyle: {
        color: '#B0B6C3',
        opacity: 0.3
      },
      fillerColor: 'rgba(135,163,206,0.2)',
      emphasis: {
        handleStyle: {
          borderColor: '#91B7F2',
          color: '#4D587D'
        },
        moveHandleStyle: {
          color: '#636D9A',
          opacity: 0.7
        }
      },
      dataBackground: {
        lineStyle: {
          color: '#71708A',
          width: 1
        },
        areaStyle: {
          color: '#71708A'
        }
      },
      selectedDataBackground: {
        lineStyle: {
          color: '#87A3CE'
        },
        areaStyle: {
          color: '#87A3CE'
        }
      }
    },
    visualMap: {
      textStyle: {
        color: contrastColor
      }
    },
    timeline: {
      lineStyle: {
        color: contrastColor
      },
      label: {
        color: contrastColor
      },
      controlStyle: {
        color: contrastColor,
        borderColor: contrastColor
      }
    },
    calendar: {
      itemStyle: {
        color: backgroundColor
      },
      dayLabel: {
        color: contrastColor
      },
      monthLabel: {
        color: contrastColor
      },
      yearLabel: {
        color: contrastColor
      }
    },
    timeAxis: axisCommon(),
    logAxis: axisCommon(),
    valueAxis: axisCommon(),
    categoryAxis: axisCommon(),
    line: {
      symbol: 'circle'
    },
    graph: {
      color: colorPalette
    },
    gauge: {
      title: {
        color: contrastColor
      },
      axisLine: {
        lineStyle: {
          color: [[1, 'rgba(207,212,219,0.2)']]
        }
      },
      axisLabel: {
        color: contrastColor
      },
      detail: {
        color: '#EEF1FA'
      }
    },
    candlestick: {
      itemStyle: {
        color: '#f64e56',
        color0: '#54ea92',
        borderColor: '#f64e56',
        borderColor0: '#54ea92' // borderColor: '#ca2824',
        // borderColor0: '#09a443'

      }
    }
  }
  theme.categoryAxis.splitLine.show = false

  /**
     * Usage of query:
     * `chart.on('click', query, handler);`
     * The `query` can be:
     * + The component type query string, only `mainType` or `mainType.subType`,
     *   like: 'xAxis', 'series', 'xAxis.category' or 'series.line'.
     * + The component query object, like:
     *   `{seriesIndex: 2}`, `{seriesName: 'xx'}`, `{seriesId: 'some'}`,
     *   `{xAxisIndex: 2}`, `{xAxisName: 'xx'}`, `{xAxisId: 'some'}`.
     * + The data query object, like:
     *   `{dataIndex: 123}`, `{dataType: 'link'}`, `{name: 'some'}`.
     * + The other query object (cmponent customized query), like:
     *   `{element: 'some'}` (only available in custom series).
     *
     * Caveat: If a prop in the `query` object is `null/undefined`, it is the
     * same as there is no such prop in the `query` object.
     */

  const ECEventProcessor =
    /** @class */
    (function () {
      function ECEventProcessor () {}

      ECEventProcessor.prototype.normalizeQuery = function (query) {
        const cptQuery = {}
        const dataQuery = {}
        const otherQuery = {} // `query` is `mainType` or `mainType.subType` of component.

        if (isString(query)) {
          const condCptType = parseClassType(query) // `.main` and `.sub` may be ''.

          cptQuery.mainType = condCptType.main || null
          cptQuery.subType = condCptType.sub || null
        } // `query` is an object, convert to {mainType, index, name, id}.
        else {
          // `xxxIndex`, `xxxName`, `xxxId`, `name`, `dataIndex`, `dataType` is reserved,
          // can not be used in `compomentModel.filterForExposedEvent`.
          const suffixes_1 = ['Index', 'Name', 'Id']
          const dataKeys_1 = {
            name: 1,
            dataIndex: 1,
            dataType: 1
          }
          each(query, function (val, key) {
            let reserved = false

            for (let i = 0; i < suffixes_1.length; i++) {
              const propSuffix = suffixes_1[i]
              const suffixPos = key.lastIndexOf(propSuffix)

              if (suffixPos > 0 && suffixPos === key.length - propSuffix.length) {
                const mainType = key.slice(0, suffixPos) // Consider `dataIndex`.

                if (mainType !== 'data') {
                  cptQuery.mainType = mainType
                  cptQuery[propSuffix.toLowerCase()] = val
                  reserved = true
                }
              }
            }

            if (dataKeys_1.hasOwnProperty(key)) {
              dataQuery[key] = val
              reserved = true
            }

            if (!reserved) {
              otherQuery[key] = val
            }
          })
        }

        return {
          cptQuery: cptQuery,
          dataQuery: dataQuery,
          otherQuery: otherQuery
        }
      }

      ECEventProcessor.prototype.filter = function (eventType, query) {
        // They should be assigned before each trigger call.
        const eventInfo = this.eventInfo

        if (!eventInfo) {
          return true
        }

        const targetEl = eventInfo.targetEl
        const packedEvent = eventInfo.packedEvent
        const model = eventInfo.model
        const view = eventInfo.view // For event like 'globalout'.

        if (!model || !view) {
          return true
        }

        const cptQuery = query.cptQuery
        const dataQuery = query.dataQuery
        return check(cptQuery, model, 'mainType') && check(cptQuery, model, 'subType') && check(cptQuery, model, 'index', 'componentIndex') && check(cptQuery, model, 'name') && check(cptQuery, model, 'id') && check(dataQuery, packedEvent, 'name') && check(dataQuery, packedEvent, 'dataIndex') && check(dataQuery, packedEvent, 'dataType') && (!view.filterForExposedEvent || view.filterForExposedEvent(eventType, query.otherQuery, targetEl, packedEvent))

        function check (query, host, prop, propOnHost) {
          return query[prop] == null || host[propOnHost || prop] === query[prop]
        }
      }

      ECEventProcessor.prototype.afterTrigger = function () {
        // Make sure the eventInfo wont be used in next trigger.
        this.eventInfo = null
      }

      return ECEventProcessor
    }())

  const SYMBOL_PROPS_WITH_CB = ['symbol', 'symbolSize', 'symbolRotate', 'symbolOffset']
  const SYMBOL_PROPS = SYMBOL_PROPS_WITH_CB.concat(['symbolKeepAspect']) // Encoding visual for all series include which is filtered for legend drawing

  const seriesSymbolTask = {
    createOnAllSeries: true,
    // For legend.
    performRawSeries: true,
    reset: function (seriesModel, ecModel) {
      const data = seriesModel.getData()

      if (seriesModel.legendIcon) {
        data.setVisual('legendIcon', seriesModel.legendIcon)
      }

      if (!seriesModel.hasSymbolVisual) {
        return
      }

      const symbolOptions = {}
      const symbolOptionsCb = {}
      let hasCallback = false

      for (let i = 0; i < SYMBOL_PROPS_WITH_CB.length; i++) {
        const symbolPropName = SYMBOL_PROPS_WITH_CB[i]
        const val = seriesModel.get(symbolPropName)

        if (isFunction(val)) {
          hasCallback = true
          symbolOptionsCb[symbolPropName] = val
        } else {
          symbolOptions[symbolPropName] = val
        }
      }

      symbolOptions.symbol = symbolOptions.symbol || seriesModel.defaultSymbol
      data.setVisual(extend({
        legendIcon: seriesModel.legendIcon || symbolOptions.symbol,
        symbolKeepAspect: seriesModel.get('symbolKeepAspect')
      }, symbolOptions)) // Only visible series has each data be visual encoded

      if (ecModel.isSeriesFiltered(seriesModel)) {
        return
      }

      const symbolPropsCb = keys(symbolOptionsCb)

      function dataEach (data, idx) {
        const rawValue = seriesModel.getRawValue(idx)
        const params = seriesModel.getDataParams(idx)

        for (let i = 0; i < symbolPropsCb.length; i++) {
          const symbolPropName = symbolPropsCb[i]
          data.setItemVisual(idx, symbolPropName, symbolOptionsCb[symbolPropName](rawValue, params))
        }
      }

      return {
        dataEach: hasCallback ? dataEach : null
      }
    }
  }
  const dataSymbolTask = {
    createOnAllSeries: true,
    // For legend.
    performRawSeries: true,
    reset: function (seriesModel, ecModel) {
      if (!seriesModel.hasSymbolVisual) {
        return
      } // Only visible series has each data be visual encoded

      if (ecModel.isSeriesFiltered(seriesModel)) {
        return
      }

      const data = seriesModel.getData()

      function dataEach (data, idx) {
        const itemModel = data.getItemModel(idx)

        for (let i = 0; i < SYMBOL_PROPS.length; i++) {
          const symbolPropName = SYMBOL_PROPS[i]
          const val = itemModel.getShallow(symbolPropName, true)

          if (val != null) {
            data.setItemVisual(idx, symbolPropName, val)
          }
        }
      }

      return {
        dataEach: data.hasItemOption ? dataEach : null
      }
    }
  }

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

  /**
     * AUTO-GENERATED FILE. DO NOT MODIFY.
     */

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
  function getItemVisualFromData (data, dataIndex, key) {
    switch (key) {
      case 'color':
        var style = data.getItemVisual(dataIndex, 'style')
        return style[data.getVisual('drawType')]

      case 'opacity':
        return data.getItemVisual(dataIndex, 'style').opacity

      case 'symbol':
      case 'symbolSize':
      case 'liftZ':
        return data.getItemVisual(dataIndex, key)

      default:
        if ('development' !== 'production') {
          console.warn('Unknown visual type ' + key)
        }
    }
  }
  function getVisualFromData (data, key) {
    switch (key) {
      case 'color':
        var style = data.getVisual('style')
        return style[data.getVisual('drawType')]

      case 'opacity':
        return data.getVisual('style').opacity

      case 'symbol':
      case 'symbolSize':
      case 'liftZ':
        return data.getVisual(key)

      default:
        if ('development' !== 'production') {
          console.warn('Unknown visual type ' + key)
        }
    }
  }
  function setItemVisualFromData (data, dataIndex, key, value) {
    switch (key) {
      case 'color':
        // Make sure not sharing style object.
        var style = data.ensureUniqueItemVisual(dataIndex, 'style')
        style[data.getVisual('drawType')] = value // Mark the color has been changed, not from palette anymore

        data.setItemVisual(dataIndex, 'colorFromPalette', false)
        break

      case 'opacity':
        data.ensureUniqueItemVisual(dataIndex, 'style').opacity = value
        break

      case 'symbol':
      case 'symbolSize':
      case 'liftZ':
        data.setItemVisual(dataIndex, key, value)
        break

      default:
        if ('development' !== 'production') {
          console.warn('Unknown visual type ' + key)
        }
    }
  }

  // Inlucdes: pieSelect, pieUnSelect, pieToggleSelect, mapSelect, mapUnSelect, mapToggleSelect

  function createLegacyDataSelectAction (seriesType, ecRegisterAction) {
    function getSeriesIndices (ecModel, payload) {
      const seriesIndices = []
      ecModel.eachComponent({
        mainType: 'series',
        subType: seriesType,
        query: payload
      }, function (seriesModel) {
        seriesIndices.push(seriesModel.seriesIndex)
      })
      return seriesIndices
    }

    each([[seriesType + 'ToggleSelect', 'toggleSelect'], [seriesType + 'Select', 'select'], [seriesType + 'UnSelect', 'unselect']], function (eventsMap) {
      ecRegisterAction(eventsMap[0], function (payload, ecModel, api) {
        payload = extend({}, payload)

        if ('development' !== 'production') {
          deprecateReplaceLog(payload.type, eventsMap[1])
        }

        api.dispatchAction(extend(payload, {
          type: eventsMap[1],
          seriesIndex: getSeriesIndices(ecModel, payload)
        }))
      })
    })
  }

  function handleSeriesLegacySelectEvents (type, eventPostfix, ecIns, ecModel, payload) {
    const legacyEventName = type + eventPostfix

    if (!ecIns.isSilent(legacyEventName)) {
      if ('development' !== 'production') {
        deprecateLog('event ' + legacyEventName + ' is deprecated.')
      }

      ecModel.eachComponent({
        mainType: 'series',
        subType: 'pie'
      }, function (seriesModel) {
        const seriesIndex = seriesModel.seriesIndex
        const selectedMap = seriesModel.option.selectedMap
        const selected = payload.selected

        for (let i = 0; i < selected.length; i++) {
          if (selected[i].seriesIndex === seriesIndex) {
            const data = seriesModel.getData()
            const dataIndex = queryDataIndex(data, payload.fromActionPayload)
            ecIns.trigger(legacyEventName, {
              type: legacyEventName,
              seriesId: seriesModel.id,
              name: isArray(dataIndex) ? data.getName(dataIndex[0]) : data.getName(dataIndex),
              selected: isString(selectedMap) ? selectedMap : extend({}, selectedMap)
            })
          }
        }
      })
    }
  }

  function handleLegacySelectEvents (messageCenter, ecIns, api) {
    messageCenter.on('selectchanged', function (params) {
      const ecModel = api.getModel()

      if (params.isFromClick) {
        handleSeriesLegacySelectEvents('map', 'selectchanged', ecIns, ecModel, params)
        handleSeriesLegacySelectEvents('pie', 'selectchanged', ecIns, ecModel, params)
      } else if (params.fromAction === 'select') {
        handleSeriesLegacySelectEvents('map', 'selected', ecIns, ecModel, params)
        handleSeriesLegacySelectEvents('pie', 'selected', ecIns, ecModel, params)
      } else if (params.fromAction === 'unselect') {
        handleSeriesLegacySelectEvents('map', 'unselected', ecIns, ecModel, params)
        handleSeriesLegacySelectEvents('pie', 'unselected', ecIns, ecModel, params)
      }
    })
  }

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

  /**
     * AUTO-GENERATED FILE. DO NOT MODIFY.
     */

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
  function findEventDispatcher (target, det, returnFirstMatch) {
    let found

    while (target) {
      if (det(target)) {
        found = target

        if (returnFirstMatch) {
          break
        }
      }

      target = target.__hostTarget || target.parent
    }

    return found
  }

  let wmUniqueIndex = Math.round(Math.random() * 9)
  const supportDefineProperty = typeof Object.defineProperty === 'function'
  const WeakMap = (function () {
    function WeakMap () {
      this._id = '__ec_inner_' + wmUniqueIndex++
    }
    WeakMap.prototype.get = function (key) {
      return this._guard(key)[this._id]
    }
    WeakMap.prototype.set = function (key, value) {
      const target = this._guard(key)
      if (supportDefineProperty) {
        Object.defineProperty(target, this._id, {
          value: value,
          enumerable: false,
          configurable: true
        })
      } else {
        target[this._id] = value
      }
      return this
    }
    WeakMap.prototype.delete = function (key) {
      if (this.has(key)) {
        delete this._guard(key)[this._id]
        return true
      }
      return false
    }
    WeakMap.prototype.has = function (key) {
      return !!this._guard(key)[this._id]
    }
    WeakMap.prototype._guard = function (key) {
      if (key !== Object(key)) {
        throw TypeError('Value of WeakMap is not a non-null object.')
      }
      return key
    }
    return WeakMap
  }())

  /**
     * Triangle shape
     * @inner
     */

  const Triangle = Path.extend({
    type: 'triangle',
    shape: {
      cx: 0,
      cy: 0,
      width: 0,
      height: 0
    },
    buildPath: function (path, shape) {
      const cx = shape.cx
      const cy = shape.cy
      const width = shape.width / 2
      const height = shape.height / 2
      path.moveTo(cx, cy - height)
      path.lineTo(cx + width, cy + height)
      path.lineTo(cx - width, cy + height)
      path.closePath()
    }
  })
  /**
     * Diamond shape
     * @inner
     */

  const Diamond = Path.extend({
    type: 'diamond',
    shape: {
      cx: 0,
      cy: 0,
      width: 0,
      height: 0
    },
    buildPath: function (path, shape) {
      const cx = shape.cx
      const cy = shape.cy
      const width = shape.width / 2
      const height = shape.height / 2
      path.moveTo(cx, cy - height)
      path.lineTo(cx + width, cy)
      path.lineTo(cx, cy + height)
      path.lineTo(cx - width, cy)
      path.closePath()
    }
  })
  /**
     * Pin shape
     * @inner
     */

  const Pin = Path.extend({
    type: 'pin',
    shape: {
      // x, y on the cusp
      x: 0,
      y: 0,
      width: 0,
      height: 0
    },
    buildPath: function (path, shape) {
      const x = shape.x
      const y = shape.y
      const w = shape.width / 5 * 3 // Height must be larger than width

      const h = Math.max(w, shape.height)
      const r = w / 2 // Dist on y with tangent point and circle center

      const dy = r * r / (h - r)
      const cy = y - h + r + dy
      const angle = Math.asin(dy / r) // Dist on x with tangent point and circle center

      const dx = Math.cos(angle) * r
      const tanX = Math.sin(angle)
      const tanY = Math.cos(angle)
      const cpLen = r * 0.6
      const cpLen2 = r * 0.7
      path.moveTo(x - dx, cy + dy)
      path.arc(x, cy, r, Math.PI - angle, Math.PI * 2 + angle)
      path.bezierCurveTo(x + dx - tanX * cpLen, cy + dy + tanY * cpLen, x, y - cpLen2, x, y)
      path.bezierCurveTo(x, y - cpLen2, x - dx + tanX * cpLen, cy + dy + tanY * cpLen, x - dx, cy + dy)
      path.closePath()
    }
  })
  /**
     * Arrow shape
     * @inner
     */

  const Arrow = Path.extend({
    type: 'arrow',
    shape: {
      x: 0,
      y: 0,
      width: 0,
      height: 0
    },
    buildPath: function (ctx, shape) {
      const height = shape.height
      const width = shape.width
      const x = shape.x
      const y = shape.y
      const dx = width / 3 * 2
      ctx.moveTo(x, y)
      ctx.lineTo(x + dx, y + height)
      ctx.lineTo(x, y + height / 4 * 3)
      ctx.lineTo(x - dx, y + height)
      ctx.lineTo(x, y)
      ctx.closePath()
    }
  })
  /**
     * Map of path contructors
     */
  // TODO Use function to build symbol path.

  const symbolCtors = {
    line: Line,
    rect: Rect,
    roundRect: Rect,
    square: Rect,
    circle: Circle,
    diamond: Diamond,
    pin: Pin,
    arrow: Arrow,
    triangle: Triangle
  }
  const symbolShapeMakers = {
    line: function (x, y, w, h, shape) {
      shape.x1 = x
      shape.y1 = y + h / 2
      shape.x2 = x + w
      shape.y2 = y + h / 2
    },
    rect: function (x, y, w, h, shape) {
      shape.x = x
      shape.y = y
      shape.width = w
      shape.height = h
    },
    roundRect: function (x, y, w, h, shape) {
      shape.x = x
      shape.y = y
      shape.width = w
      shape.height = h
      shape.r = Math.min(w, h) / 4
    },
    square: function (x, y, w, h, shape) {
      const size = Math.min(w, h)
      shape.x = x
      shape.y = y
      shape.width = size
      shape.height = size
    },
    circle: function (x, y, w, h, shape) {
      // Put circle in the center of square
      shape.cx = x + w / 2
      shape.cy = y + h / 2
      shape.r = Math.min(w, h) / 2
    },
    diamond: function (x, y, w, h, shape) {
      shape.cx = x + w / 2
      shape.cy = y + h / 2
      shape.width = w
      shape.height = h
    },
    pin: function (x, y, w, h, shape) {
      shape.x = x + w / 2
      shape.y = y + h / 2
      shape.width = w
      shape.height = h
    },
    arrow: function (x, y, w, h, shape) {
      shape.x = x + w / 2
      shape.y = y + h / 2
      shape.width = w
      shape.height = h
    },
    triangle: function (x, y, w, h, shape) {
      shape.cx = x + w / 2
      shape.cy = y + h / 2
      shape.width = w
      shape.height = h
    }
  }
  const symbolBuildProxies = {}
  each(symbolCtors, function (Ctor, name) {
    symbolBuildProxies[name] = new Ctor()
  })
  const SymbolClz = Path.extend({
    type: 'symbol',
    shape: {
      symbolType: '',
      x: 0,
      y: 0,
      width: 0,
      height: 0
    },
    calculateTextPosition: function (out, config, rect) {
      const res = calculateTextPosition(out, config, rect)
      const shape = this.shape

      if (shape && shape.symbolType === 'pin' && config.position === 'inside') {
        res.y = rect.y + rect.height * 0.4
      }

      return res
    },
    buildPath: function (ctx, shape, inBundle) {
      let symbolType = shape.symbolType

      if (symbolType !== 'none') {
        let proxySymbol = symbolBuildProxies[symbolType]

        if (!proxySymbol) {
          // Default rect
          symbolType = 'rect'
          proxySymbol = symbolBuildProxies[symbolType]
        }

        symbolShapeMakers[symbolType](shape.x, shape.y, shape.width, shape.height, proxySymbol.shape)
        proxySymbol.buildPath(ctx, proxySymbol.shape, inBundle)
      }
    }
  }) // Provide setColor helper method to avoid determine if set the fill or stroke outside

  function symbolPathSetColor (color, innerColor) {
    if (this.type !== 'image') {
      const symbolStyle = this.style

      if (this.__isEmptyBrush) {
        symbolStyle.stroke = color
        symbolStyle.fill = innerColor || '#fff' // TODO Same width with lineStyle in LineView

        symbolStyle.lineWidth = 2
      } else if (this.shape.symbolType === 'line') {
        symbolStyle.stroke = color
      } else {
        symbolStyle.fill = color
      }

      this.markRedraw()
    }
  }
  /**
     * Create a symbol element with given symbol configuration: shape, x, y, width, height, color
     */

  function createSymbol (symbolType, x, y, w, h, color, // whether to keep the ratio of w/h,
    keepAspect) {
    // TODO Support image object, DynamicImage.
    const isEmpty = symbolType.indexOf('empty') === 0

    if (isEmpty) {
      symbolType = symbolType.substr(5, 1).toLowerCase() + symbolType.substr(6)
    }

    let symbolPath

    if (symbolType.indexOf('image://') === 0) {
      symbolPath = makeImage(symbolType.slice(8), new BoundingRect(x, y, w, h), keepAspect ? 'center' : 'cover')
    } else if (symbolType.indexOf('path://') === 0) {
      symbolPath = makePath(symbolType.slice(7), {}, new BoundingRect(x, y, w, h), keepAspect ? 'center' : 'cover')
    } else {
      symbolPath = new SymbolClz({
        shape: {
          symbolType: symbolType,
          x: x,
          y: y,
          width: w,
          height: h
        }
      })
    }

    symbolPath.__isEmptyBrush = isEmpty // TODO Should deprecate setColor

    symbolPath.setColor = symbolPathSetColor

    if (color) {
      symbolPath.setColor(color)
    }

    return symbolPath
  }
  function normalizeSymbolSize (symbolSize) {
    if (!isArray(symbolSize)) {
      symbolSize = [+symbolSize, +symbolSize]
    }

    return [symbolSize[0] || 0, symbolSize[1] || 0]
  }
  function normalizeSymbolOffset (symbolOffset, symbolSize) {
    if (symbolOffset == null) {
      return
    }

    if (!isArray(symbolOffset)) {
      symbolOffset = [symbolOffset, symbolOffset]
    }

    return [parsePercent$1(symbolOffset[0], symbolSize[0]) || 0, parsePercent$1(retrieve2(symbolOffset[1], symbolOffset[0]), symbolSize[1]) || 0]
  }

  function isSafeNum (num) {
    return isFinite(num)
  }
  function createLinearGradient (ctx, obj, rect) {
    let x = obj.x == null ? 0 : obj.x
    let x2 = obj.x2 == null ? 1 : obj.x2
    let y = obj.y == null ? 0 : obj.y
    let y2 = obj.y2 == null ? 0 : obj.y2
    if (!obj.global) {
      x = x * rect.width + rect.x
      x2 = x2 * rect.width + rect.x
      y = y * rect.height + rect.y
      y2 = y2 * rect.height + rect.y
    }
    x = isSafeNum(x) ? x : 0
    x2 = isSafeNum(x2) ? x2 : 1
    y = isSafeNum(y) ? y : 0
    y2 = isSafeNum(y2) ? y2 : 0
    const canvasGradient = ctx.createLinearGradient(x, y, x2, y2)
    return canvasGradient
  }
  function createRadialGradient (ctx, obj, rect) {
    const width = rect.width
    const height = rect.height
    const min = Math.min(width, height)
    let x = obj.x == null ? 0.5 : obj.x
    let y = obj.y == null ? 0.5 : obj.y
    let r = obj.r == null ? 0.5 : obj.r
    if (!obj.global) {
      x = x * width + rect.x
      y = y * height + rect.y
      r = r * min
    }
    x = isSafeNum(x) ? x : 0.5
    y = isSafeNum(y) ? y : 0.5
    r = r >= 0 && isSafeNum(r) ? r : 0.5
    const canvasGradient = ctx.createRadialGradient(x, y, 0, x, y, r)
    return canvasGradient
  }
  function getCanvasGradient (ctx, obj, rect) {
    const canvasGradient = obj.type === 'radial'
      ? createRadialGradient(ctx, obj, rect)
      : createLinearGradient(ctx, obj, rect)
    const colorStops = obj.colorStops
    for (let i = 0; i < colorStops.length; i++) {
      canvasGradient.addColorStop(colorStops[i].offset, colorStops[i].color)
    }
    return canvasGradient
  }
  function isClipPathChanged (clipPaths, prevClipPaths) {
    if (clipPaths === prevClipPaths || (!clipPaths && !prevClipPaths)) {
      return false
    }
    if (!clipPaths || !prevClipPaths || (clipPaths.length !== prevClipPaths.length)) {
      return true
    }
    for (let i = 0; i < clipPaths.length; i++) {
      if (clipPaths[i] !== prevClipPaths[i]) {
        return true
      }
    }
    return false
  }
  function parseInt10 (val) {
    return parseInt(val, 10)
  }
  function getSize (root, whIdx, opts) {
    const wh = ['width', 'height'][whIdx]
    const cwh = ['clientWidth', 'clientHeight'][whIdx]
    const plt = ['paddingLeft', 'paddingTop'][whIdx]
    const prb = ['paddingRight', 'paddingBottom'][whIdx]
    if (opts[wh] != null && opts[wh] !== 'auto') {
      return parseFloat(opts[wh])
    }
    const stl = document.defaultView.getComputedStyle(root)
    return ((root[cwh] || parseInt10(stl[wh]) || parseInt10(root.style[wh])) -
            (parseInt10(stl[plt]) || 0) -
            (parseInt10(stl[prb]) || 0)) | 0
  }

  function normalizeLineDash (lineType, lineWidth) {
    if (!lineType || lineType === 'solid' || !(lineWidth > 0)) {
      return null
    }
    return lineType === 'dashed'
      ? [4 * lineWidth, 2 * lineWidth]
      : lineType === 'dotted'
        ? [lineWidth]
        : isNumber(lineType)
          ? [lineType]
          : isArray(lineType) ? lineType : null
  }
  function getLineDash (el) {
    const style = el.style
    let lineDash = style.lineDash && style.lineWidth > 0 && normalizeLineDash(style.lineDash, style.lineWidth)
    let lineDashOffset = style.lineDashOffset
    if (lineDash) {
      const lineScale_1 = (style.strokeNoScale && el.getLineScale) ? el.getLineScale() : 1
      if (lineScale_1 && lineScale_1 !== 1) {
        lineDash = map(lineDash, function (rawVal) {
          return rawVal / lineScale_1
        })
        lineDashOffset /= lineScale_1
      }
    }
    return [lineDash, lineDashOffset]
  }

  const pathProxyForDraw = new PathProxy(true)
  function styleHasStroke (style) {
    const stroke = style.stroke
    return !(stroke == null || stroke === 'none' || !(style.lineWidth > 0))
  }
  function isValidStrokeFillStyle (strokeOrFill) {
    return typeof strokeOrFill === 'string' && strokeOrFill !== 'none'
  }
  function styleHasFill (style) {
    const fill = style.fill
    return fill != null && fill !== 'none'
  }
  function doFillPath (ctx, style) {
    if (style.fillOpacity != null && style.fillOpacity !== 1) {
      const originalGlobalAlpha = ctx.globalAlpha
      ctx.globalAlpha = style.fillOpacity * style.opacity
      ctx.fill()
      ctx.globalAlpha = originalGlobalAlpha
    } else {
      ctx.fill()
    }
  }
  function doStrokePath (ctx, style) {
    if (style.strokeOpacity != null && style.strokeOpacity !== 1) {
      const originalGlobalAlpha = ctx.globalAlpha
      ctx.globalAlpha = style.strokeOpacity * style.opacity
      ctx.stroke()
      ctx.globalAlpha = originalGlobalAlpha
    } else {
      ctx.stroke()
    }
  }
  function createCanvasPattern (ctx, pattern, el) {
    const image = createOrUpdateImage(pattern.image, pattern.__image, el)
    if (isImageReady(image)) {
      const canvasPattern = ctx.createPattern(image, pattern.repeat || 'repeat')
      if (typeof DOMMatrix === 'function' &&
                canvasPattern &&
                canvasPattern.setTransform) {
        const matrix = new DOMMatrix()
        matrix.translateSelf((pattern.x || 0), (pattern.y || 0))
        matrix.rotateSelf(0, 0, (pattern.rotation || 0) * RADIAN_TO_DEGREE)
        matrix.scaleSelf((pattern.scaleX || 1), (pattern.scaleY || 1))
        canvasPattern.setTransform(matrix)
      }
      return canvasPattern
    }
  }
  function brushPath (ctx, el, style, inBatch) {
    let _a
    let hasStroke = styleHasStroke(style)
    let hasFill = styleHasFill(style)
    const strokePercent = style.strokePercent
    const strokePart = strokePercent < 1
    const firstDraw = !el.path
    if ((!el.silent || strokePart) && firstDraw) {
      el.createPathProxy()
    }
    const path = el.path || pathProxyForDraw
    const dirtyFlag = el.__dirty
    if (!inBatch) {
      const fill = style.fill
      const stroke = style.stroke
      const hasFillGradient = hasFill && !!fill.colorStops
      const hasStrokeGradient = hasStroke && !!stroke.colorStops
      const hasFillPattern = hasFill && !!fill.image
      const hasStrokePattern = hasStroke && !!stroke.image
      let fillGradient = void 0
      let strokeGradient = void 0
      let fillPattern = void 0
      let strokePattern = void 0
      let rect = void 0
      if (hasFillGradient || hasStrokeGradient) {
        rect = el.getBoundingRect()
      }
      if (hasFillGradient) {
        fillGradient = dirtyFlag
          ? getCanvasGradient(ctx, fill, rect)
          : el.__canvasFillGradient
        el.__canvasFillGradient = fillGradient
      }
      if (hasStrokeGradient) {
        strokeGradient = dirtyFlag
          ? getCanvasGradient(ctx, stroke, rect)
          : el.__canvasStrokeGradient
        el.__canvasStrokeGradient = strokeGradient
      }
      if (hasFillPattern) {
        fillPattern = (dirtyFlag || !el.__canvasFillPattern)
          ? createCanvasPattern(ctx, fill, el)
          : el.__canvasFillPattern
        el.__canvasFillPattern = fillPattern
      }
      if (hasStrokePattern) {
        strokePattern = (dirtyFlag || !el.__canvasStrokePattern)
          ? createCanvasPattern(ctx, stroke, el)
          : el.__canvasStrokePattern
        el.__canvasStrokePattern = fillPattern
      }
      if (hasFillGradient) {
        ctx.fillStyle = fillGradient
      } else if (hasFillPattern) {
        if (fillPattern) {
          ctx.fillStyle = fillPattern
        } else {
          hasFill = false
        }
      }
      if (hasStrokeGradient) {
        ctx.strokeStyle = strokeGradient
      } else if (hasStrokePattern) {
        if (strokePattern) {
          ctx.strokeStyle = strokePattern
        } else {
          hasStroke = false
        }
      }
    }
    const scale = el.getGlobalScale()
    path.setScale(scale[0], scale[1], el.segmentIgnoreThreshold)
    let lineDash
    let lineDashOffset
    if (ctx.setLineDash && style.lineDash) {
      _a = getLineDash(el), lineDash = _a[0], lineDashOffset = _a[1]
    }
    let needsRebuild = true
    if (firstDraw || (dirtyFlag & SHAPE_CHANGED_BIT)) {
      path.setDPR(ctx.dpr)
      if (strokePart) {
        path.setContext(null)
      } else {
        path.setContext(ctx)
        needsRebuild = false
      }
      path.reset()
      el.buildPath(path, el.shape, inBatch)
      path.toStatic()
      el.pathUpdated()
    }
    if (needsRebuild) {
      path.rebuildPath(ctx, strokePart ? strokePercent : 1)
    }
    if (lineDash) {
      ctx.setLineDash(lineDash)
      ctx.lineDashOffset = lineDashOffset
    }
    if (!inBatch) {
      if (style.strokeFirst) {
        if (hasStroke) {
          doStrokePath(ctx, style)
        }
        if (hasFill) {
          doFillPath(ctx, style)
        }
      } else {
        if (hasFill) {
          doFillPath(ctx, style)
        }
        if (hasStroke) {
          doStrokePath(ctx, style)
        }
      }
    }
    if (lineDash) {
      ctx.setLineDash([])
    }
  }
  function brushImage (ctx, el, style) {
    const image = el.__image = createOrUpdateImage(style.image, el.__image, el, el.onload)
    if (!image || !isImageReady(image)) {
      return
    }
    const x = style.x || 0
    const y = style.y || 0
    let width = el.getWidth()
    let height = el.getHeight()
    const aspect = image.width / image.height
    if (width == null && height != null) {
      width = height * aspect
    } else if (height == null && width != null) {
      height = width / aspect
    } else if (width == null && height == null) {
      width = image.width
      height = image.height
    }
    if (style.sWidth && style.sHeight) {
      var sx = style.sx || 0
      var sy = style.sy || 0
      ctx.drawImage(image, sx, sy, style.sWidth, style.sHeight, x, y, width, height)
    } else if (style.sx && style.sy) {
      var sx = style.sx
      var sy = style.sy
      const sWidth = width - sx
      const sHeight = height - sy
      ctx.drawImage(image, sx, sy, sWidth, sHeight, x, y, width, height)
    } else {
      ctx.drawImage(image, x, y, width, height)
    }
  }
  function brushText (ctx, el, style) {
    let _a
    let text = style.text
    text != null && (text += '')
    if (text) {
      ctx.font = style.font || DEFAULT_FONT
      ctx.textAlign = style.textAlign
      ctx.textBaseline = style.textBaseline
      let lineDash = void 0
      let lineDashOffset = void 0
      if (ctx.setLineDash && style.lineDash) {
        _a = getLineDash(el), lineDash = _a[0], lineDashOffset = _a[1]
      }
      if (lineDash) {
        ctx.setLineDash(lineDash)
        ctx.lineDashOffset = lineDashOffset
      }
      if (style.strokeFirst) {
        if (styleHasStroke(style)) {
          ctx.strokeText(text, style.x, style.y)
        }
        if (styleHasFill(style)) {
          ctx.fillText(text, style.x, style.y)
        }
      } else {
        if (styleHasFill(style)) {
          ctx.fillText(text, style.x, style.y)
        }
        if (styleHasStroke(style)) {
          ctx.strokeText(text, style.x, style.y)
        }
      }
      if (lineDash) {
        ctx.setLineDash([])
      }
    }
  }
  const SHADOW_NUMBER_PROPS = ['shadowBlur', 'shadowOffsetX', 'shadowOffsetY']
  const STROKE_PROPS = [
    ['lineCap', 'butt'], ['lineJoin', 'miter'], ['miterLimit', 10]
  ]
  function bindCommonProps (ctx, style, prevStyle, forceSetAll, scope) {
    let styleChanged = false
    if (!forceSetAll) {
      prevStyle = prevStyle || {}
      if (style === prevStyle) {
        return false
      }
    }
    if (forceSetAll || style.opacity !== prevStyle.opacity) {
      flushPathDrawn(ctx, scope)
      styleChanged = true
      const opacity = Math.max(Math.min(style.opacity, 1), 0)
      ctx.globalAlpha = isNaN(opacity) ? DEFAULT_COMMON_STYLE.opacity : opacity
    }
    if (forceSetAll || style.blend !== prevStyle.blend) {
      if (!styleChanged) {
        flushPathDrawn(ctx, scope)
        styleChanged = true
      }
      ctx.globalCompositeOperation = style.blend || DEFAULT_COMMON_STYLE.blend
    }
    for (let i = 0; i < SHADOW_NUMBER_PROPS.length; i++) {
      const propName = SHADOW_NUMBER_PROPS[i]
      if (forceSetAll || style[propName] !== prevStyle[propName]) {
        if (!styleChanged) {
          flushPathDrawn(ctx, scope)
          styleChanged = true
        }
        ctx[propName] = ctx.dpr * (style[propName] || 0)
      }
    }
    if (forceSetAll || style.shadowColor !== prevStyle.shadowColor) {
      if (!styleChanged) {
        flushPathDrawn(ctx, scope)
        styleChanged = true
      }
      ctx.shadowColor = style.shadowColor || DEFAULT_COMMON_STYLE.shadowColor
    }
    return styleChanged
  }
  function bindPathAndTextCommonStyle (ctx, el, prevEl, forceSetAll, scope) {
    const style = getStyle(el, scope.inHover)
    const prevStyle = forceSetAll
      ? null
      : (prevEl && getStyle(prevEl, scope.inHover) || {})
    if (style === prevStyle) {
      return false
    }
    let styleChanged = bindCommonProps(ctx, style, prevStyle, forceSetAll, scope)
    if (forceSetAll || style.fill !== prevStyle.fill) {
      if (!styleChanged) {
        flushPathDrawn(ctx, scope)
        styleChanged = true
      }
      isValidStrokeFillStyle(style.fill) && (ctx.fillStyle = style.fill)
    }
    if (forceSetAll || style.stroke !== prevStyle.stroke) {
      if (!styleChanged) {
        flushPathDrawn(ctx, scope)
        styleChanged = true
      }
      isValidStrokeFillStyle(style.stroke) && (ctx.strokeStyle = style.stroke)
    }
    if (forceSetAll || style.opacity !== prevStyle.opacity) {
      if (!styleChanged) {
        flushPathDrawn(ctx, scope)
        styleChanged = true
      }
      ctx.globalAlpha = style.opacity == null ? 1 : style.opacity
    }
    if (el.hasStroke()) {
      const lineWidth = style.lineWidth
      const newLineWidth = lineWidth / ((style.strokeNoScale && el.getLineScale) ? el.getLineScale() : 1)
      if (ctx.lineWidth !== newLineWidth) {
        if (!styleChanged) {
          flushPathDrawn(ctx, scope)
          styleChanged = true
        }
        ctx.lineWidth = newLineWidth
      }
    }
    for (let i = 0; i < STROKE_PROPS.length; i++) {
      const prop = STROKE_PROPS[i]
      const propName = prop[0]
      if (forceSetAll || style[propName] !== prevStyle[propName]) {
        if (!styleChanged) {
          flushPathDrawn(ctx, scope)
          styleChanged = true
        }
        ctx[propName] = style[propName] || prop[1]
      }
    }
    return styleChanged
  }
  function bindImageStyle (ctx, el, prevEl, forceSetAll, scope) {
    return bindCommonProps(ctx, getStyle(el, scope.inHover), prevEl && getStyle(prevEl, scope.inHover), forceSetAll, scope)
  }
  function setContextTransform (ctx, el) {
    const m = el.transform
    const dpr = ctx.dpr || 1
    if (m) {
      ctx.setTransform(dpr * m[0], dpr * m[1], dpr * m[2], dpr * m[3], dpr * m[4], dpr * m[5])
    } else {
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0)
    }
  }
  function updateClipStatus (clipPaths, ctx, scope) {
    let allClipped = false
    for (let i = 0; i < clipPaths.length; i++) {
      const clipPath = clipPaths[i]
      allClipped = allClipped || clipPath.isZeroArea()
      setContextTransform(ctx, clipPath)
      ctx.beginPath()
      clipPath.buildPath(ctx, clipPath.shape)
      ctx.clip()
    }
    scope.allClipped = allClipped
  }
  function isTransformChanged (m0, m1) {
    if (m0 && m1) {
      return m0[0] !== m1[0] ||
                m0[1] !== m1[1] ||
                m0[2] !== m1[2] ||
                m0[3] !== m1[3] ||
                m0[4] !== m1[4] ||
                m0[5] !== m1[5]
    } else if (!m0 && !m1) {
      return false
    }
    return true
  }
  const DRAW_TYPE_PATH = 1
  const DRAW_TYPE_IMAGE = 2
  const DRAW_TYPE_TEXT = 3
  const DRAW_TYPE_INCREMENTAL = 4
  function canPathBatch (style) {
    const hasFill = styleHasFill(style)
    const hasStroke = styleHasStroke(style)
    return !(style.lineDash ||
            !(+hasFill ^ +hasStroke) ||
            (hasFill && typeof style.fill !== 'string') ||
            (hasStroke && typeof style.stroke !== 'string') ||
            style.strokePercent < 1 ||
            style.strokeOpacity < 1 ||
            style.fillOpacity < 1)
  }
  function flushPathDrawn (ctx, scope) {
    scope.batchFill && ctx.fill()
    scope.batchStroke && ctx.stroke()
    scope.batchFill = ''
    scope.batchStroke = ''
  }
  function getStyle (el, inHover) {
    return inHover ? (el.__hoverStyle || el.style) : el.style
  }
  function brushSingle (ctx, el) {
    brush(ctx, el, { inHover: false, viewWidth: 0, viewHeight: 0 }, true)
  }
  function brush (ctx, el, scope, isLast) {
    const m = el.transform
    if (!el.shouldBePainted(scope.viewWidth, scope.viewHeight, false, false)) {
      el.__dirty &= ~REDRAW_BIT
      el.__isRendered = false
      return
    }
    const clipPaths = el.__clipPaths
    const prevElClipPaths = scope.prevElClipPaths
    let forceSetTransform = false
    let forceSetStyle = false
    if (!prevElClipPaths || isClipPathChanged(clipPaths, prevElClipPaths)) {
      if (prevElClipPaths && prevElClipPaths.length) {
        flushPathDrawn(ctx, scope)
        ctx.restore()
        forceSetStyle = forceSetTransform = true
        scope.prevElClipPaths = null
        scope.allClipped = false
        scope.prevEl = null
      }
      if (clipPaths && clipPaths.length) {
        flushPathDrawn(ctx, scope)
        ctx.save()
        updateClipStatus(clipPaths, ctx, scope)
        forceSetTransform = true
      }
      scope.prevElClipPaths = clipPaths
    }
    if (scope.allClipped) {
      el.__isRendered = false
      return
    }
    el.beforeBrush && el.beforeBrush()
    el.innerBeforeBrush()
    const prevEl = scope.prevEl
    if (!prevEl) {
      forceSetStyle = forceSetTransform = true
    }
    const canBatchPath = el instanceof Path &&
            el.autoBatch &&
            canPathBatch(el.style)
    if (forceSetTransform || isTransformChanged(m, prevEl.transform)) {
      flushPathDrawn(ctx, scope)
      setContextTransform(ctx, el)
    } else if (!canBatchPath) {
      flushPathDrawn(ctx, scope)
    }
    const style = getStyle(el, scope.inHover)
    if (el instanceof Path) {
      if (scope.lastDrawType !== DRAW_TYPE_PATH) {
        forceSetStyle = true
        scope.lastDrawType = DRAW_TYPE_PATH
      }
      bindPathAndTextCommonStyle(ctx, el, prevEl, forceSetStyle, scope)
      if (!canBatchPath || (!scope.batchFill && !scope.batchStroke)) {
        ctx.beginPath()
      }
      brushPath(ctx, el, style, canBatchPath)
      if (canBatchPath) {
        scope.batchFill = style.fill || ''
        scope.batchStroke = style.stroke || ''
      }
    } else {
      if (el instanceof TSpan) {
        if (scope.lastDrawType !== DRAW_TYPE_TEXT) {
          forceSetStyle = true
          scope.lastDrawType = DRAW_TYPE_TEXT
        }
        bindPathAndTextCommonStyle(ctx, el, prevEl, forceSetStyle, scope)
        brushText(ctx, el, style)
      } else if (el instanceof ZRImage) {
        if (scope.lastDrawType !== DRAW_TYPE_IMAGE) {
          forceSetStyle = true
          scope.lastDrawType = DRAW_TYPE_IMAGE
        }
        bindImageStyle(ctx, el, prevEl, forceSetStyle, scope)
        brushImage(ctx, el, style)
      } else if (el.getTemporalDisplayables) {
        if (scope.lastDrawType !== DRAW_TYPE_INCREMENTAL) {
          forceSetStyle = true
          scope.lastDrawType = DRAW_TYPE_INCREMENTAL
        }
        brushIncremental(ctx, el, scope)
      }
    }
    if (canBatchPath && isLast) {
      flushPathDrawn(ctx, scope)
    }
    el.innerAfterBrush()
    el.afterBrush && el.afterBrush()
    scope.prevEl = el
    el.__dirty = 0
    el.__isRendered = true
  }
  function brushIncremental (ctx, el, scope) {
    const displayables = el.getDisplayables()
    const temporalDisplayables = el.getTemporalDisplayables()
    ctx.save()
    const innerScope = {
      prevElClipPaths: null,
      prevEl: null,
      allClipped: false,
      viewWidth: scope.viewWidth,
      viewHeight: scope.viewHeight,
      inHover: scope.inHover
    }
    let i
    let len
    for (i = el.getCursor(), len = displayables.length; i < len; i++) {
      var displayable = displayables[i]
      displayable.beforeBrush && displayable.beforeBrush()
      displayable.innerBeforeBrush()
      brush(ctx, displayable, innerScope, i === len - 1)
      displayable.innerAfterBrush()
      displayable.afterBrush && displayable.afterBrush()
      innerScope.prevEl = displayable
    }
    for (let i_1 = 0, len_1 = temporalDisplayables.length; i_1 < len_1; i_1++) {
      var displayable = temporalDisplayables[i_1]
      displayable.beforeBrush && displayable.beforeBrush()
      displayable.innerBeforeBrush()
      brush(ctx, displayable, innerScope, i_1 === len_1 - 1)
      displayable.innerAfterBrush()
      displayable.afterBrush && displayable.afterBrush()
      innerScope.prevEl = displayable
    }
    el.clearTemporalDisplayables()
    el.notClear = true
    ctx.restore()
  }

  const decalMap = new WeakMap()
  const decalCache = new LRU(100)
  const decalKeys = ['symbol', 'symbolSize', 'symbolKeepAspect', 'color', 'backgroundColor', 'dashArrayX', 'dashArrayY', 'maxTileWidth', 'maxTileHeight']
  /**
     * Create or update pattern image from decal options
     *
     * @param {InnerDecalObject | 'none'} decalObject decal options, 'none' if no decal
     * @return {Pattern} pattern with generated image, null if no decal
     */

  function createOrUpdatePatternFromDecal (decalObject, api) {
    if (decalObject === 'none') {
      return null
    }

    const dpr = api.getDevicePixelRatio()
    const zr = api.getZr()
    const isSVG = zr.painter.type === 'svg'

    if (decalObject.dirty) {
      decalMap.delete(decalObject)
    }

    const oldPattern = decalMap.get(decalObject)

    if (oldPattern) {
      return oldPattern
    }

    const decalOpt = defaults(decalObject, {
      symbol: 'rect',
      symbolSize: 1,
      symbolKeepAspect: true,
      color: 'rgba(0, 0, 0, 0.2)',
      backgroundColor: null,
      dashArrayX: 5,
      dashArrayY: 5,
      rotation: 0,
      maxTileWidth: 512,
      maxTileHeight: 512
    })

    if (decalOpt.backgroundColor === 'none') {
      decalOpt.backgroundColor = null
    }

    const pattern = {
      repeat: 'repeat'
    }
    setPatternnSource(pattern)
    pattern.rotation = decalOpt.rotation
    pattern.scaleX = pattern.scaleY = isSVG ? 1 : 1 / dpr
    decalMap.set(decalObject, pattern)
    decalObject.dirty = false
    return pattern

    function setPatternnSource (pattern) {
      const keys = [dpr]
      let isValidKey = true

      for (let i = 0; i < decalKeys.length; ++i) {
        const value = decalOpt[decalKeys[i]]

        if (value != null && !isArray(value) && !isString(value) && !isNumber(value) && typeof value !== 'boolean') {
          isValidKey = false
          break
        }

        keys.push(value)
      }

      let cacheKey

      if (isValidKey) {
        cacheKey = keys.join(',') + (isSVG ? '-svg' : '')
        const cache = decalCache.get(cacheKey)

        if (cache) {
          isSVG ? pattern.svgElement = cache : pattern.image = cache
        }
      }

      const dashArrayX = normalizeDashArrayX(decalOpt.dashArrayX)
      const dashArrayY = normalizeDashArrayY(decalOpt.dashArrayY)
      const symbolArray = normalizeSymbolArray(decalOpt.symbol)
      const lineBlockLengthsX = getLineBlockLengthX(dashArrayX)
      const lineBlockLengthY = getLineBlockLengthY(dashArrayY)
      const canvas = !isSVG && platformApi.createCanvas()
      const svgRoot = isSVG && {
        tag: 'g',
        attrs: {},
        key: 'dcl',
        children: []
      }
      const pSize = getPatternSize()
      let ctx

      if (canvas) {
        canvas.width = pSize.width * dpr
        canvas.height = pSize.height * dpr
        ctx = canvas.getContext('2d')
      }

      brushDecal()

      if (isValidKey) {
        decalCache.put(cacheKey, canvas || svgRoot)
      }

      pattern.image = canvas
      pattern.svgElement = svgRoot
      pattern.svgWidth = pSize.width
      pattern.svgHeight = pSize.height
      /**
         * Get minumum length that can make a repeatable pattern.
         *
         * @return {Object} pattern width and height
         */

      function getPatternSize () {
        /**
           * For example, if dash is [[3, 2], [2, 1]] for X, it looks like
           * |---  ---  ---  ---  --- ...
           * |-- -- -- -- -- -- -- -- ...
           * |---  ---  ---  ---  --- ...
           * |-- -- -- -- -- -- -- -- ...
           * So the minumum length of X is 15,
           * which is the least common multiple of `3 + 2` and `2 + 1`
           * |---  ---  ---  |---  --- ...
           * |-- -- -- -- -- |-- -- -- ...
           */
        let width = 1

        for (var i = 0, xlen = lineBlockLengthsX.length; i < xlen; ++i) {
          width = getLeastCommonMultiple(width, lineBlockLengthsX[i])
        }

        let symbolRepeats = 1

        for (var i = 0, xlen = symbolArray.length; i < xlen; ++i) {
          symbolRepeats = getLeastCommonMultiple(symbolRepeats, symbolArray[i].length)
        }

        width *= symbolRepeats
        const height = lineBlockLengthY * lineBlockLengthsX.length * symbolArray.length

        if ('development' !== 'production') {
          const warn = function (attrName) {
            /* eslint-disable-next-line */
              console.warn("Calculated decal size is greater than " + attrName + " due to decal option settings so " + attrName + " is used for the decal size. Please consider changing the decal option to make a smaller decal or set " + attrName + " to be larger to avoid incontinuity.");
          }

          if (width > decalOpt.maxTileWidth) {
            warn('maxTileWidth')
          }

          if (height > decalOpt.maxTileHeight) {
            warn('maxTileHeight')
          }
        }

        return {
          width: Math.max(1, Math.min(width, decalOpt.maxTileWidth)),
          height: Math.max(1, Math.min(height, decalOpt.maxTileHeight))
        }
      }

      function brushDecal () {
        if (ctx) {
          ctx.clearRect(0, 0, canvas.width, canvas.height)

          if (decalOpt.backgroundColor) {
            ctx.fillStyle = decalOpt.backgroundColor
            ctx.fillRect(0, 0, canvas.width, canvas.height)
          }
        }

        let ySum = 0

        for (var i = 0; i < dashArrayY.length; ++i) {
          ySum += dashArrayY[i]
        }

        if (ySum <= 0) {
          // dashArrayY is 0, draw nothing
          return
        }

        let y = -lineBlockLengthY
        let yId = 0
        let yIdTotal = 0
        let xId0 = 0

        while (y < pSize.height) {
          if (yId % 2 === 0) {
            const symbolYId = yIdTotal / 2 % symbolArray.length
            let x = 0
            let xId1 = 0
            let xId1Total = 0

            while (x < pSize.width * 2) {
              let xSum = 0

              for (var i = 0; i < dashArrayX[xId0].length; ++i) {
                xSum += dashArrayX[xId0][i]
              }

              if (xSum <= 0) {
                // Skip empty line
                break
              } // E.g., [15, 5, 20, 5] draws only for 15 and 20

              if (xId1 % 2 === 0) {
                const size = (1 - decalOpt.symbolSize) * 0.5
                const left = x + dashArrayX[xId0][xId1] * size
                const top_1 = y + dashArrayY[yId] * size
                const width = dashArrayX[xId0][xId1] * decalOpt.symbolSize
                const height = dashArrayY[yId] * decalOpt.symbolSize
                const symbolXId = xId1Total / 2 % symbolArray[symbolYId].length
                brushSymbol(left, top_1, width, height, symbolArray[symbolYId][symbolXId])
              }

              x += dashArrayX[xId0][xId1]
              ++xId1Total
              ++xId1

              if (xId1 === dashArrayX[xId0].length) {
                xId1 = 0
              }
            }

            ++xId0

            if (xId0 === dashArrayX.length) {
              xId0 = 0
            }
          }

          y += dashArrayY[yId]
          ++yIdTotal
          ++yId

          if (yId === dashArrayY.length) {
            yId = 0
          }
        }

        function brushSymbol (x, y, width, height, symbolType) {
          const scale = isSVG ? 1 : dpr
          const symbol = createSymbol(symbolType, x * scale, y * scale, width * scale, height * scale, decalOpt.color, decalOpt.symbolKeepAspect)

          if (isSVG) {
            const symbolVNode = zr.painter.renderOneToVNode(symbol)

            if (symbolVNode) {
              svgRoot.children.push(symbolVNode)
            }
          } else {
            // Paint to canvas for all other renderers.
            brushSingle(ctx, symbol)
          }
        }
      }
    }
  }
  /**
     * Convert symbol array into normalized array
     *
     * @param {string | (string | string[])[]} symbol symbol input
     * @return {string[][]} normolized symbol array
     */

  function normalizeSymbolArray (symbol) {
    if (!symbol || symbol.length === 0) {
      return [['rect']]
    }

    if (isString(symbol)) {
      return [[symbol]]
    }

    let isAllString = true

    for (var i = 0; i < symbol.length; ++i) {
      if (!isString(symbol[i])) {
        isAllString = false
        break
      }
    }

    if (isAllString) {
      return normalizeSymbolArray([symbol])
    }

    const result = []

    for (var i = 0; i < symbol.length; ++i) {
      if (isString(symbol[i])) {
        result.push([symbol[i]])
      } else {
        result.push(symbol[i])
      }
    }

    return result
  }
  /**
     * Convert dash input into dashArray
     *
     * @param {DecalDashArrayX} dash dash input
     * @return {number[][]} normolized dash array
     */

  function normalizeDashArrayX (dash) {
    if (!dash || dash.length === 0) {
      return [[0, 0]]
    }

    if (isNumber(dash)) {
      var dashValue = Math.ceil(dash)
      return [[dashValue, dashValue]]
    }
    /**
       * [20, 5] should be normalized into [[20, 5]],
       * while [20, [5, 10]] should be normalized into [[20, 20], [5, 10]]
       */

    let isAllNumber = true

    for (var i = 0; i < dash.length; ++i) {
      if (!isNumber(dash[i])) {
        isAllNumber = false
        break
      }
    }

    if (isAllNumber) {
      return normalizeDashArrayX([dash])
    }

    const result = []

    for (var i = 0; i < dash.length; ++i) {
      if (isNumber(dash[i])) {
        var dashValue = Math.ceil(dash[i])
        result.push([dashValue, dashValue])
      } else {
        var dashValue = map(dash[i], function (n) {
          return Math.ceil(n)
        })

        if (dashValue.length % 2 === 1) {
          // [4, 2, 1] means |----  -    -- |----  -    -- |
          // so normalize it to be [4, 2, 1, 4, 2, 1]
          result.push(dashValue.concat(dashValue))
        } else {
          result.push(dashValue)
        }
      }
    }

    return result
  }
  /**
     * Convert dash input into dashArray
     *
     * @param {DecalDashArrayY} dash dash input
     * @return {number[]} normolized dash array
     */

  function normalizeDashArrayY (dash) {
    if (!dash || typeof dash === 'object' && dash.length === 0) {
      return [0, 0]
    }

    if (isNumber(dash)) {
      const dashValue_1 = Math.ceil(dash)
      return [dashValue_1, dashValue_1]
    }

    const dashValue = map(dash, function (n) {
      return Math.ceil(n)
    })
    return dash.length % 2 ? dashValue.concat(dashValue) : dashValue
  }
  /**
     * Get block length of each line. A block is the length of dash line and space.
     * For example, a line with [4, 1] has a dash line of 4 and a space of 1 after
     * that, so the block length of this line is 5.
     *
     * @param {number[][]} dash dash arrary of X or Y
     * @return {number[]} block length of each line
     */

  function getLineBlockLengthX (dash) {
    return map(dash, function (line) {
      return getLineBlockLengthY(line)
    })
  }

  function getLineBlockLengthY (dash) {
    let blockLength = 0

    for (let i = 0; i < dash.length; ++i) {
      blockLength += dash[i]
    }

    if (dash.length % 2 === 1) {
      // [4, 2, 1] means |----  -    -- |----  -    -- |
      // So total length is (4 + 2 + 1) * 2
      return blockLength * 2
    }

    return blockLength
  }

  function decalVisual (ecModel, api) {
    ecModel.eachRawSeries(function (seriesModel) {
      if (ecModel.isSeriesFiltered(seriesModel)) {
        return
      }

      const data = seriesModel.getData()

      if (data.hasItemVisual()) {
        data.each(function (idx) {
          const decal = data.getItemVisual(idx, 'decal')

          if (decal) {
            const itemStyle = data.ensureUniqueItemVisual(idx, 'style')
            itemStyle.decal = createOrUpdatePatternFromDecal(decal, api)
          }
        })
      }

      const decal = data.getVisual('decal')

      if (decal) {
        const style = data.getVisual('style')
        style.decal = createOrUpdatePatternFromDecal(decal, api)
      }
    })
  }

  const lifecycle = new Eventful()

  // The implentations will be registered when installing the component.
  // Avoid these code being bundled to the core module.

  const implsStore = {} // TODO Type

  function registerImpl (name, impl) {
    if ('development' !== 'production') {
      if (implsStore[name]) {
        error('Already has an implementation of ' + name + '.')
      }
    }

    implsStore[name] = impl
  }
  function getImpl (name) {
    if ('development' !== 'production') {
      if (!implsStore[name]) {
        error('Implementation of ' + name + " doesn't exists.")
      }
    }

    return implsStore[name]
  }

  const hasWindow = typeof window !== 'undefined'
  const version$1 = '5.3.3'
  const dependencies = {
    zrender: '5.3.2'
  }
  const TEST_FRAME_REMAIN_TIME = 1
  const PRIORITY_PROCESSOR_SERIES_FILTER = 800 // Some data processors depends on the stack result dimension (to calculate data extent).
  // So data stack stage should be in front of data processing stage.

  const PRIORITY_PROCESSOR_DATASTACK = 900 // "Data filter" will block the stream, so it should be
  // put at the begining of data processing.

  const PRIORITY_PROCESSOR_FILTER = 1000
  const PRIORITY_PROCESSOR_DEFAULT = 2000
  const PRIORITY_PROCESSOR_STATISTIC = 5000
  const PRIORITY_VISUAL_LAYOUT = 1000
  const PRIORITY_VISUAL_PROGRESSIVE_LAYOUT = 1100
  const PRIORITY_VISUAL_GLOBAL = 2000
  const PRIORITY_VISUAL_CHART = 3000
  const PRIORITY_VISUAL_COMPONENT = 4000 // Visual property in data. Greater than `PRIORITY_VISUAL_COMPONENT` to enable to
  // overwrite the viusal result of component (like `visualMap`)
  // using data item specific setting (like itemStyle.xxx on data item)

  const PRIORITY_VISUAL_CHART_DATA_CUSTOM = 4500 // Greater than `PRIORITY_VISUAL_CHART_DATA_CUSTOM` to enable to layout based on
  // visual result like `symbolSize`.

  const PRIORITY_VISUAL_POST_CHART_LAYOUT = 4600
  const PRIORITY_VISUAL_BRUSH = 5000
  const PRIORITY_VISUAL_ARIA = 6000
  const PRIORITY_VISUAL_DECAL = 7000
  const PRIORITY = {
    PROCESSOR: {
      FILTER: PRIORITY_PROCESSOR_FILTER,
      SERIES_FILTER: PRIORITY_PROCESSOR_SERIES_FILTER,
      STATISTIC: PRIORITY_PROCESSOR_STATISTIC
    },
    VISUAL: {
      LAYOUT: PRIORITY_VISUAL_LAYOUT,
      PROGRESSIVE_LAYOUT: PRIORITY_VISUAL_PROGRESSIVE_LAYOUT,
      GLOBAL: PRIORITY_VISUAL_GLOBAL,
      CHART: PRIORITY_VISUAL_CHART,
      POST_CHART_LAYOUT: PRIORITY_VISUAL_POST_CHART_LAYOUT,
      COMPONENT: PRIORITY_VISUAL_COMPONENT,
      BRUSH: PRIORITY_VISUAL_BRUSH,
      CHART_ITEM: PRIORITY_VISUAL_CHART_DATA_CUSTOM,
      ARIA: PRIORITY_VISUAL_ARIA,
      DECAL: PRIORITY_VISUAL_DECAL
    }
  } // Main process have three entries: `setOption`, `dispatchAction` and `resize`,
  // where they must not be invoked nestedly, except the only case: invoke
  // dispatchAction with updateMethod "none" in main process.
  // This flag is used to carry out this rule.
  // All events will be triggered out side main process (i.e. when !this[IN_MAIN_PROCESS]).

  const IN_MAIN_PROCESS_KEY = '__flagInMainProcess'
  const PENDING_UPDATE = '__pendingUpdate'
  const STATUS_NEEDS_UPDATE_KEY = '__needsUpdateStatus'
  const ACTION_REG = /^[a-zA-Z0-9_]+$/
  const CONNECT_STATUS_KEY = '__connectUpdateStatus'
  const CONNECT_STATUS_PENDING = 0
  const CONNECT_STATUS_UPDATING = 1
  const CONNECT_STATUS_UPDATED = 2

  function createRegisterEventWithLowercaseECharts (method) {
    return function () {
      const args = []

      for (let _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i]
      }

      if (this.isDisposed()) {
        disposedWarning(this.id)
        return
      }

      return toLowercaseNameAndCallEventful(this, method, args)
    }
  }

  function createRegisterEventWithLowercaseMessageCenter (method) {
    return function () {
      const args = []

      for (let _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i]
      }

      return toLowercaseNameAndCallEventful(this, method, args)
    }
  }

  function toLowercaseNameAndCallEventful (host, method, args) {
    // `args[0]` is event name. Event name is all lowercase.
    args[0] = args[0] && args[0].toLowerCase()
    return Eventful.prototype[method].apply(host, args)
  }

  const MessageCenter =
    /** @class */
    (function (_super) {
      __extends(MessageCenter, _super)

      function MessageCenter () {
        return _super !== null && _super.apply(this, arguments) || this
      }

      return MessageCenter
    }(Eventful))

  const messageCenterProto = MessageCenter.prototype
  messageCenterProto.on = createRegisterEventWithLowercaseMessageCenter('on')
  messageCenterProto.off = createRegisterEventWithLowercaseMessageCenter('off') // ---------------------------------------
  // Internal method names for class ECharts
  // ---------------------------------------

  let prepare
  let prepareView
  let updateDirectly
  let updateMethods
  let doConvertPixel
  let updateStreamModes
  let doDispatchAction
  let flushPendingActions
  let triggerUpdatedEvent
  let bindRenderedEvent
  let bindMouseEvent
  let render
  let renderComponents
  let renderSeries
  let createExtensionAPI
  let enableConnect
  let markStatusToUpdate
  let applyChangedStates

  const ECharts =
    /** @class */
    (function (_super) {
      __extends(ECharts, _super)

      function ECharts (dom, // Theme name or themeOption.
        theme, opts) {
        const _this = _super.call(this, new ECEventProcessor()) || this

        _this._chartsViews = []
        _this._chartsMap = {}
        _this._componentsViews = []
        _this._componentsMap = {} // Can't dispatch action during rendering procedure

        _this._pendingActions = []
        opts = opts || {} // Get theme by name

        if (isString(theme)) {
          theme = themeStorage[theme]
        }

        _this._dom = dom
        let defaultRenderer = 'canvas'
        let defaultUseDirtyRect = false

        if ('development' !== 'production') {
          const root =
          /* eslint-disable-next-line */
          hasWindow ? window : global;
          defaultRenderer = root.__ECHARTS__DEFAULT__RENDERER__ || defaultRenderer
          const devUseDirtyRect = root.__ECHARTS__DEFAULT__USE_DIRTY_RECT__
          defaultUseDirtyRect = devUseDirtyRect == null ? defaultUseDirtyRect : devUseDirtyRect
        }

        const zr = _this._zr = init(dom, {
          renderer: opts.renderer || defaultRenderer,
          devicePixelRatio: opts.devicePixelRatio,
          width: opts.width,
          height: opts.height,
          ssr: opts.ssr,
          useDirtyRect: opts.useDirtyRect == null ? defaultUseDirtyRect : opts.useDirtyRect
        })
        _this._ssr = opts.ssr // Expect 60 fps.

        _this._throttledZrFlush = throttle(bind(zr.flush, zr), 17)
        theme = clone(theme)
        theme && globalBackwardCompat(theme, true)
        _this._theme = theme
        _this._locale = createLocaleObject(opts.locale || SYSTEM_LANG)
        _this._coordSysMgr = new CoordinateSystemManager()
        const api = _this._api = createExtensionAPI(_this) // Sort on demand

        function prioritySortFunc (a, b) {
          return a.__prio - b.__prio
        }

        sort(visualFuncs, prioritySortFunc)
        sort(dataProcessorFuncs, prioritySortFunc)
        _this._scheduler = new Scheduler(_this, api, dataProcessorFuncs, visualFuncs)
        _this._messageCenter = new MessageCenter() // Init mouse events

        _this._initEvents() // In case some people write `window.onresize = chart.resize`

        _this.resize = bind(_this.resize, _this)
        zr.animation.on('frame', _this._onframe, _this)
        bindRenderedEvent(zr, _this)
        bindMouseEvent(zr, _this) // ECharts instance can be used as value.

        setAsPrimitive(_this)
        return _this
      }

      ECharts.prototype._onframe = function () {
        if (this._disposed) {
          return
        }

        applyChangedStates(this)
        const scheduler = this._scheduler // Lazy update

        if (this[PENDING_UPDATE]) {
          const silent = this[PENDING_UPDATE].silent
          this[IN_MAIN_PROCESS_KEY] = true

          try {
            prepare(this)
            updateMethods.update.call(this, null, this[PENDING_UPDATE].updateParams)
          } catch (e) {
            this[IN_MAIN_PROCESS_KEY] = false
            this[PENDING_UPDATE] = null
            throw e
          } // At present, in each frame, zrender performs:
          //   (1) animation step forward.
          //   (2) trigger('frame') (where this `_onframe` is called)
          //   (3) zrender flush (render).
          // If we do nothing here, since we use `setToFinal: true`, the step (3) above
          // will render the final state of the elements before the real animation started.

          this._zr.flush()

          this[IN_MAIN_PROCESS_KEY] = false
          this[PENDING_UPDATE] = null
          flushPendingActions.call(this, silent)
          triggerUpdatedEvent.call(this, silent)
        } // Avoid do both lazy update and progress in one frame.
        else if (scheduler.unfinished) {
          // Stream progress.
          let remainTime = TEST_FRAME_REMAIN_TIME
          const ecModel = this._model
          const api = this._api
          scheduler.unfinished = false

          do {
            const startTime = +new Date()
            scheduler.performSeriesTasks(ecModel) // Currently dataProcessorFuncs do not check threshold.

            scheduler.performDataProcessorTasks(ecModel)
            updateStreamModes(this, ecModel) // Do not update coordinate system here. Because that coord system update in
            // each frame is not a good user experience. So we follow the rule that
            // the extent of the coordinate system is determin in the first frame (the
            // frame is executed immedietely after task reset.
            // this._coordSysMgr.update(ecModel, api);
            // console.log('--- ec frame visual ---', remainTime);

            scheduler.performVisualTasks(ecModel)
            renderSeries(this, this._model, api, 'remain', {})
            remainTime -= +new Date() - startTime
          } while (remainTime > 0 && scheduler.unfinished) // Call flush explicitly for trigger finished event.

          if (!scheduler.unfinished) {
            this._zr.flush()
          } // Else, zr flushing be ensue within the same frame,
          // because zr flushing is after onframe event.
        }
      }

      ECharts.prototype.getDom = function () {
        return this._dom
      }

      ECharts.prototype.getId = function () {
        return this.id
      }

      ECharts.prototype.getZr = function () {
        return this._zr
      }

      ECharts.prototype.isSSR = function () {
        return this._ssr
      }
      /* eslint-disable-next-line */

      ECharts.prototype.setOption = function (option, notMerge, lazyUpdate) {
        if (this[IN_MAIN_PROCESS_KEY]) {
          if ('development' !== 'production') {
            error('`setOption` should not be called during main process.')
          }

          return
        }

        if (this._disposed) {
          disposedWarning(this.id)
          return
        }

        let silent
        let replaceMerge
        let transitionOpt

        if (isObject(notMerge)) {
          lazyUpdate = notMerge.lazyUpdate
          silent = notMerge.silent
          replaceMerge = notMerge.replaceMerge
          transitionOpt = notMerge.transition
          notMerge = notMerge.notMerge
        }

        this[IN_MAIN_PROCESS_KEY] = true

        if (!this._model || notMerge) {
          const optionManager = new OptionManager(this._api)
          const theme = this._theme
          const ecModel = this._model = new GlobalModel()
          ecModel.scheduler = this._scheduler
          ecModel.ssr = this._ssr
          ecModel.init(null, null, null, theme, this._locale, optionManager)
        }

        this._model.setOption(option, {
          replaceMerge: replaceMerge
        }, optionPreprocessorFuncs)

        const updateParams = {
          seriesTransition: transitionOpt,
          optionChanged: true
        }

        if (lazyUpdate) {
          this[PENDING_UPDATE] = {
            silent: silent,
            updateParams: updateParams
          }
          this[IN_MAIN_PROCESS_KEY] = false // `setOption(option, {lazyMode: true})` may be called when zrender has been slept.
          // It should wake it up to make sure zrender start to render at the next frame.

          this.getZr().wakeUp()
        } else {
          try {
            prepare(this)
            updateMethods.update.call(this, null, updateParams)
          } catch (e) {
            this[PENDING_UPDATE] = null
            this[IN_MAIN_PROCESS_KEY] = false
            throw e
          } // Ensure zr refresh sychronously, and then pixel in canvas can be
          // fetched after `setOption`.

          if (!this._ssr) {
            // not use flush when using ssr mode.
            this._zr.flush()
          }

          this[PENDING_UPDATE] = null
          this[IN_MAIN_PROCESS_KEY] = false
          flushPendingActions.call(this, silent)
          triggerUpdatedEvent.call(this, silent)
        }
      }
      /**
       * @deprecated
       */

      ECharts.prototype.setTheme = function () {
        deprecateLog('ECharts#setTheme() is DEPRECATED in ECharts 3.0')
      } // We don't want developers to use getModel directly.

      ECharts.prototype.getModel = function () {
        return this._model
      }

      ECharts.prototype.getOption = function () {
        return this._model && this._model.getOption()
      }

      ECharts.prototype.getWidth = function () {
        return this._zr.getWidth()
      }

      ECharts.prototype.getHeight = function () {
        return this._zr.getHeight()
      }

      ECharts.prototype.getDevicePixelRatio = function () {
        return this._zr.painter.dpr
        /* eslint-disable-next-line */
        || hasWindow && window.devicePixelRatio || 1;
      }
      /**
       * Get canvas which has all thing rendered
       * @deprecated Use renderToCanvas instead.
       */

      ECharts.prototype.getRenderedCanvas = function (opts) {
        if ('development' !== 'production') {
          deprecateReplaceLog('getRenderedCanvas', 'renderToCanvas')
        }

        return this.renderToCanvas(opts)
      }

      ECharts.prototype.renderToCanvas = function (opts) {
        opts = opts || {}
        const painter = this._zr.painter

        if ('development' !== 'production') {
          if (painter.type !== 'canvas') {
            throw new Error('renderToCanvas can only be used in the canvas renderer.')
          }
        }

        return painter.getRenderedCanvas({
          backgroundColor: opts.backgroundColor || this._model.get('backgroundColor'),
          pixelRatio: opts.pixelRatio || this.getDevicePixelRatio()
        })
      }

      ECharts.prototype.renderToSVGString = function (opts) {
        opts = opts || {}
        const painter = this._zr.painter

        if ('development' !== 'production') {
          if (painter.type !== 'svg') {
            throw new Error('renderToSVGString can only be used in the svg renderer.')
          }
        }

        return painter.renderToString({
          useViewBox: opts.useViewBox
        })
      }
      /**
       * Get svg data url
       */

      ECharts.prototype.getSvgDataURL = function () {
        if (!env.svgSupported) {
          return
        }

        const zr = this._zr
        const list = zr.storage.getDisplayList() // Stop animations

        each(list, function (el) {
          el.stopAnimation(null, true)
        })
        return zr.painter.toDataURL()
      }

      ECharts.prototype.getDataURL = function (opts) {
        if (this._disposed) {
          disposedWarning(this.id)
          return
        }

        opts = opts || {}
        const excludeComponents = opts.excludeComponents
        const ecModel = this._model
        const excludesComponentViews = []
        const self = this
        each(excludeComponents, function (componentType) {
          ecModel.eachComponent({
            mainType: componentType
          }, function (component) {
            const view = self._componentsMap[component.__viewId]

            if (!view.group.ignore) {
              excludesComponentViews.push(view)
              view.group.ignore = true
            }
          })
        })
        const url = this._zr.painter.getType() === 'svg' ? this.getSvgDataURL() : this.renderToCanvas(opts).toDataURL('image/' + (opts && opts.type || 'png'))
        each(excludesComponentViews, function (view) {
          view.group.ignore = false
        })
        return url
      }

      ECharts.prototype.getConnectedDataURL = function (opts) {
        if (this._disposed) {
          disposedWarning(this.id)
          return
        }

        const isSvg = opts.type === 'svg'
        const groupId = this.group
        const mathMin = Math.min
        const mathMax = Math.max
        const MAX_NUMBER = Infinity

        if (connectedGroups[groupId]) {
          let left_1 = MAX_NUMBER
          let top_1 = MAX_NUMBER
          let right_1 = -MAX_NUMBER
          let bottom_1 = -MAX_NUMBER
          const canvasList_1 = []
          const dpr_1 = opts && opts.pixelRatio || this.getDevicePixelRatio()
          each(instances$1, function (chart, id) {
            if (chart.group === groupId) {
              const canvas = isSvg ? chart.getZr().painter.getSvgDom().innerHTML : chart.renderToCanvas(clone(opts))
              const boundingRect = chart.getDom().getBoundingClientRect()
              left_1 = mathMin(boundingRect.left, left_1)
              top_1 = mathMin(boundingRect.top, top_1)
              right_1 = mathMax(boundingRect.right, right_1)
              bottom_1 = mathMax(boundingRect.bottom, bottom_1)
              canvasList_1.push({
                dom: canvas,
                left: boundingRect.left,
                top: boundingRect.top
              })
            }
          })
          left_1 *= dpr_1
          top_1 *= dpr_1
          right_1 *= dpr_1
          bottom_1 *= dpr_1
          const width = right_1 - left_1
          const height = bottom_1 - top_1
          const targetCanvas = platformApi.createCanvas()
          const zr_1 = init(targetCanvas, {
            renderer: isSvg ? 'svg' : 'canvas'
          })
          zr_1.resize({
            width: width,
            height: height
          })

          if (isSvg) {
            let content_1 = ''
            each(canvasList_1, function (item) {
              const x = item.left - left_1
              const y = item.top - top_1
              content_1 += '<g transform="translate(' + x + ',' + y + ')">' + item.dom + '</g>'
            })
            zr_1.painter.getSvgRoot().innerHTML = content_1

            if (opts.connectedBackgroundColor) {
              zr_1.painter.setBackgroundColor(opts.connectedBackgroundColor)
            }

            zr_1.refreshImmediately()
            return zr_1.painter.toDataURL()
          } else {
            // Background between the charts
            if (opts.connectedBackgroundColor) {
              zr_1.add(new Rect({
                shape: {
                  x: 0,
                  y: 0,
                  width: width,
                  height: height
                },
                style: {
                  fill: opts.connectedBackgroundColor
                }
              }))
            }

            each(canvasList_1, function (item) {
              const img = new ZRImage({
                style: {
                  x: item.left * dpr_1 - left_1,
                  y: item.top * dpr_1 - top_1,
                  image: item.dom
                }
              })
              zr_1.add(img)
            })
            zr_1.refreshImmediately()
            return targetCanvas.toDataURL('image/' + (opts && opts.type || 'png'))
          }
        } else {
          return this.getDataURL(opts)
        }
      }

      ECharts.prototype.convertToPixel = function (finder, value) {
        return doConvertPixel(this, 'convertToPixel', finder, value)
      }

      ECharts.prototype.convertFromPixel = function (finder, value) {
        return doConvertPixel(this, 'convertFromPixel', finder, value)
      }
      /**
       * Is the specified coordinate systems or components contain the given pixel point.
       * @param {Array|number} value
       * @return {boolean} result
       */

      ECharts.prototype.containPixel = function (finder, value) {
        if (this._disposed) {
          disposedWarning(this.id)
          return
        }

        const ecModel = this._model
        let result
        const findResult = parseFinder(ecModel, finder)
        each(findResult, function (models, key) {
          key.indexOf('Models') >= 0 && each(models, function (model) {
            const coordSys = model.coordinateSystem

            if (coordSys && coordSys.containPoint) {
              result = result || !!coordSys.containPoint(value)
            } else if (key === 'seriesModels') {
              const view = this._chartsMap[model.__viewId]

              if (view && view.containPoint) {
                result = result || view.containPoint(value, model)
              } else {
                if ('development' !== 'production') {
                  console.warn(key + ': ' + (view ? 'The found component do not support containPoint.' : 'No view mapping to the found component.'))
                }
              }
            } else {
              if ('development' !== 'production') {
                console.warn(key + ': containPoint is not supported')
              }
            }
          }, this)
        }, this)
        return !!result
      }
      /**
       * Get visual from series or data.
       * @param finder
       *        If string, e.g., 'series', means {seriesIndex: 0}.
       *        If Object, could contain some of these properties below:
       *        {
       *            seriesIndex / seriesId / seriesName,
       *            dataIndex / dataIndexInside
       *        }
       *        If dataIndex is not specified, series visual will be fetched,
       *        but not data item visual.
       *        If all of seriesIndex, seriesId, seriesName are not specified,
       *        visual will be fetched from first series.
       * @param visualType 'color', 'symbol', 'symbolSize'
       */

      ECharts.prototype.getVisual = function (finder, visualType) {
        const ecModel = this._model
        const parsedFinder = parseFinder(ecModel, finder, {
          defaultMainType: 'series'
        })
        const seriesModel = parsedFinder.seriesModel

        if ('development' !== 'production') {
          if (!seriesModel) {
            console.warn('There is no specified seires model')
          }
        }

        const data = seriesModel.getData()
        const dataIndexInside = parsedFinder.hasOwnProperty('dataIndexInside') ? parsedFinder.dataIndexInside : parsedFinder.hasOwnProperty('dataIndex') ? data.indexOfRawIndex(parsedFinder.dataIndex) : null
        return dataIndexInside != null ? getItemVisualFromData(data, dataIndexInside, visualType) : getVisualFromData(data, visualType)
      }
      /**
       * Get view of corresponding component model
       */

      ECharts.prototype.getViewOfComponentModel = function (componentModel) {
        return this._componentsMap[componentModel.__viewId]
      }
      /**
       * Get view of corresponding series model
       */

      ECharts.prototype.getViewOfSeriesModel = function (seriesModel) {
        return this._chartsMap[seriesModel.__viewId]
      }

      ECharts.prototype._initEvents = function () {
        const _this = this

        each(MOUSE_EVENT_NAMES, function (eveName) {
          const handler = function (e) {
            const ecModel = _this.getModel()

            const el = e.target
            let params
            const isGlobalOut = eveName === 'globalout' // no e.target when 'globalout'.

            if (isGlobalOut) {
              params = {}
            } else {
              el && findEventDispatcher(el, function (parent) {
                const ecData = getECData(parent)

                if (ecData && ecData.dataIndex != null) {
                  const dataModel = ecData.dataModel || ecModel.getSeriesByIndex(ecData.seriesIndex)
                  params = dataModel && dataModel.getDataParams(ecData.dataIndex, ecData.dataType) || {}
                  return true
                } // If element has custom eventData of components
                else if (ecData.eventData) {
                  params = extend({}, ecData.eventData)
                  return true
                }
              }, true)
            } // Contract: if params prepared in mouse event,
            // these properties must be specified:
            // {
            //    componentType: string (component main type)
            //    componentIndex: number
            // }
            // Otherwise event query can not work.

            if (params) {
              let componentType = params.componentType
              let componentIndex = params.componentIndex // Special handling for historic reason: when trigger by
              // markLine/markPoint/markArea, the componentType is
              // 'markLine'/'markPoint'/'markArea', but we should better
              // enable them to be queried by seriesIndex, since their
              // option is set in each series.

              if (componentType === 'markLine' || componentType === 'markPoint' || componentType === 'markArea') {
                componentType = 'series'
                componentIndex = params.seriesIndex
              }

              const model = componentType && componentIndex != null && ecModel.getComponent(componentType, componentIndex)
              const view = model && _this[model.mainType === 'series' ? '_chartsMap' : '_componentsMap'][model.__viewId]

              if ('development' !== 'production') {
                // `event.componentType` and `event[componentTpype + 'Index']` must not
                // be missed, otherwise there is no way to distinguish source component.
                // See `dataFormat.getDataParams`.
                if (!isGlobalOut && !(model && view)) {
                  console.warn('model or view can not be found by params')
                }
              }

              params.event = e
              params.type = eveName
              _this._$eventProcessor.eventInfo = {
                targetEl: el,
                packedEvent: params,
                model: model,
                view: view
              }

              _this.trigger(eveName, params)
            }
          } // Consider that some component (like tooltip, brush, ...)
          // register zr event handler, but user event handler might
          // do anything, such as call `setOption` or `dispatchAction`,
          // which probably update any of the content and probably
          // cause problem if it is called previous other inner handlers.

          handler.zrEventfulCallAtLast = true

          _this._zr.on(eveName, handler, _this)
        })
        each(eventActionMap, function (actionType, eventType) {
          _this._messageCenter.on(eventType, function (event) {
            this.trigger(eventType, event)
          }, _this)
        }) // Extra events
        // TODO register?

        each(['selectchanged'], function (eventType) {
          _this._messageCenter.on(eventType, function (event) {
            this.trigger(eventType, event)
          }, _this)
        })
        handleLegacySelectEvents(this._messageCenter, this, this._api)
      }

      ECharts.prototype.isDisposed = function () {
        return this._disposed
      }

      ECharts.prototype.clear = function () {
        if (this._disposed) {
          disposedWarning(this.id)
          return
        }

        this.setOption({
          series: []
        }, true)
      }

      ECharts.prototype.dispose = function () {
        if (this._disposed) {
          disposedWarning(this.id)
          return
        }

        this._disposed = true
        const dom = this.getDom()

        if (dom) {
          setAttribute(this.getDom(), DOM_ATTRIBUTE_KEY, '')
        }

        const chart = this
        const api = chart._api
        const ecModel = chart._model
        each(chart._componentsViews, function (component) {
          component.dispose(ecModel, api)
        })
        each(chart._chartsViews, function (chart) {
          chart.dispose(ecModel, api)
        }) // Dispose after all views disposed

        chart._zr.dispose() // Set properties to null.
        // To reduce the memory cost in case the top code still holds this instance unexpectedly.

        chart._dom = chart._model = chart._chartsMap = chart._componentsMap = chart._chartsViews = chart._componentsViews = chart._scheduler = chart._api = chart._zr = chart._throttledZrFlush = chart._theme = chart._coordSysMgr = chart._messageCenter = null
        delete instances$1[chart.id]
      }
      /**
       * Resize the chart
       */

      ECharts.prototype.resize = function (opts) {
        if (this[IN_MAIN_PROCESS_KEY]) {
          if ('development' !== 'production') {
            error('`resize` should not be called during main process.')
          }

          return
        }

        if (this._disposed) {
          disposedWarning(this.id)
          return
        }

        this._zr.resize(opts)

        const ecModel = this._model // Resize loading effect

        this._loadingFX && this._loadingFX.resize()

        if (!ecModel) {
          return
        }

        let needPrepare = ecModel.resetOption('media')
        let silent = opts && opts.silent // There is some real cases that:
        // chart.setOption(option, { lazyUpdate: true });
        // chart.resize();

        if (this[PENDING_UPDATE]) {
          if (silent == null) {
            silent = this[PENDING_UPDATE].silent
          }

          needPrepare = true
          this[PENDING_UPDATE] = null
        }

        this[IN_MAIN_PROCESS_KEY] = true

        try {
          needPrepare && prepare(this)
          updateMethods.update.call(this, {
            type: 'resize',
            animation: extend({
              // Disable animation
              duration: 0
            }, opts && opts.animation)
          })
        } catch (e) {
          this[IN_MAIN_PROCESS_KEY] = false
          throw e
        }

        this[IN_MAIN_PROCESS_KEY] = false
        flushPendingActions.call(this, silent)
        triggerUpdatedEvent.call(this, silent)
      }

      ECharts.prototype.showLoading = function (name, cfg) {
        if (this._disposed) {
          disposedWarning(this.id)
          return
        }

        if (isObject(name)) {
          cfg = name
          name = ''
        }

        name = name || 'default'
        this.hideLoading()

        if (!loadingEffects[name]) {
          if ('development' !== 'production') {
            console.warn('Loading effects ' + name + ' not exists.')
          }

          return
        }

        const el = loadingEffects[name](this._api, cfg)
        const zr = this._zr
        this._loadingFX = el
        zr.add(el)
      }
      /**
       * Hide loading effect
       */

      ECharts.prototype.hideLoading = function () {
        if (this._disposed) {
          disposedWarning(this.id)
          return
        }

        this._loadingFX && this._zr.remove(this._loadingFX)
        this._loadingFX = null
      }

      ECharts.prototype.makeActionFromEvent = function (eventObj) {
        const payload = extend({}, eventObj)
        payload.type = eventActionMap[eventObj.type]
        return payload
      }
      /**
       * @param opt If pass boolean, means opt.silent
       * @param opt.silent Default `false`. Whether trigger events.
       * @param opt.flush Default `undefined`.
       *        true: Flush immediately, and then pixel in canvas can be fetched
       *            immediately. Caution: it might affect performance.
       *        false: Not flush.
       *        undefined: Auto decide whether perform flush.
       */

      ECharts.prototype.dispatchAction = function (payload, opt) {
        if (this._disposed) {
          disposedWarning(this.id)
          return
        }

        if (!isObject(opt)) {
          opt = {
            silent: !!opt
          }
        }

        if (!actions[payload.type]) {
          return
        } // Avoid dispatch action before setOption. Especially in `connect`.

        if (!this._model) {
          return
        } // May dispatchAction in rendering procedure

        if (this[IN_MAIN_PROCESS_KEY]) {
          this._pendingActions.push(payload)

          return
        }

        const silent = opt.silent
        doDispatchAction.call(this, payload, silent)
        const flush = opt.flush

        if (flush) {
          this._zr.flush()
        } else if (flush !== false && env.browser.weChat) {
          // In WeChat embeded browser, `requestAnimationFrame` and `setInterval`
          // hang when sliding page (on touch event), which cause that zr does not
          // refresh util user interaction finished, which is not expected.
          // But `dispatchAction` may be called too frequently when pan on touch
          // screen, which impacts performance if do not throttle them.
          this._throttledZrFlush()
        }

        flushPendingActions.call(this, silent)
        triggerUpdatedEvent.call(this, silent)
      }

      ECharts.prototype.updateLabelLayout = function () {
        lifecycle.trigger('series:layoutlabels', this._model, this._api, {
          // Not adding series labels.
          // TODO
          updatedSeries: []
        })
      }

      ECharts.prototype.appendData = function (params) {
        if (this._disposed) {
          disposedWarning(this.id)
          return
        }

        const seriesIndex = params.seriesIndex
        const ecModel = this.getModel()
        const seriesModel = ecModel.getSeriesByIndex(seriesIndex)

        if ('development' !== 'production') {
          assert(params.data && seriesModel)
        }

        seriesModel.appendData(params) // Note: `appendData` does not support that update extent of coordinate
        // system, util some scenario require that. In the expected usage of
        // `appendData`, the initial extent of coordinate system should better
        // be fixed by axis `min`/`max` setting or initial data, otherwise if
        // the extent changed while `appendData`, the location of the painted
        // graphic elements have to be changed, which make the usage of
        // `appendData` meaningless.

        this._scheduler.unfinished = true
        this.getZr().wakeUp()
      } // A work around for no `internal` modifier in ts yet but
      // need to strictly hide private methods to JS users.

      ECharts.internalField = (function () {
        prepare = function (ecIns) {
          const scheduler = ecIns._scheduler
          scheduler.restorePipelines(ecIns._model)
          scheduler.prepareStageTasks()
          prepareView(ecIns, true)
          prepareView(ecIns, false)
          scheduler.plan()
        }
        /**
         * Prepare view instances of charts and components
         */

        prepareView = function (ecIns, isComponent) {
          const ecModel = ecIns._model
          const scheduler = ecIns._scheduler
          const viewList = isComponent ? ecIns._componentsViews : ecIns._chartsViews
          const viewMap = isComponent ? ecIns._componentsMap : ecIns._chartsMap
          const zr = ecIns._zr
          const api = ecIns._api

          for (var i = 0; i < viewList.length; i++) {
            viewList[i].__alive = false
          }

          isComponent
            ? ecModel.eachComponent(function (componentType, model) {
              componentType !== 'series' && doPrepare(model)
            })
            : ecModel.eachSeries(doPrepare)

          function doPrepare (model) {
            // By defaut view will be reused if possible for the case that `setOption` with "notMerge"
            // mode and need to enable transition animation. (Usually, when they have the same id, or
            // especially no id but have the same type & name & index. See the `model.id` generation
            // rule in `makeIdAndName` and `viewId` generation rule here).
            // But in `replaceMerge` mode, this feature should be able to disabled when it is clear that
            // the new model has nothing to do with the old model.
            const requireNewView = model.__requireNewView // This command should not work twice.

            model.__requireNewView = false // Consider: id same and type changed.

            const viewId = '_ec_' + model.id + '_' + model.type
            let view = !requireNewView && viewMap[viewId]

            if (!view) {
              const classType = parseClassType(model.type)
              const Clazz = isComponent ? ComponentView.getClass(classType.main, classType.sub) // FIXME:TS
              // (ChartView as ChartViewConstructor).getClass('series', classType.sub)
              // For backward compat, still support a chart type declared as only subType
              // like "liquidfill", but recommend "series.liquidfill"
              // But need a base class to make a type series.
                : ChartView.getClass(classType.sub)

              if ('development' !== 'production') {
                assert(Clazz, classType.sub + ' does not exist.')
              }

              view = new Clazz()
              view.init(ecModel, api)
              viewMap[viewId] = view
              viewList.push(view)
              zr.add(view.group)
            }

            model.__viewId = view.__id = viewId
            view.__alive = true
            view.__model = model
            view.group.__ecComponentInfo = {
              mainType: model.mainType,
              index: model.componentIndex
            }
            !isComponent && scheduler.prepareView(view, model, ecModel, api)
          }

          for (var i = 0; i < viewList.length;) {
            const view = viewList[i]

            if (!view.__alive) {
              !isComponent && view.renderTask.dispose()
              zr.remove(view.group)
              view.dispose(ecModel, api)
              viewList.splice(i, 1)

              if (viewMap[view.__id] === view) {
                delete viewMap[view.__id]
              }

              view.__id = view.group.__ecComponentInfo = null
            } else {
              i++
            }
          }
        }

        updateDirectly = function (ecIns, method, payload, mainType, subType) {
          const ecModel = ecIns._model
          ecModel.setUpdatePayload(payload) // broadcast

          if (!mainType) {
            // FIXME
            // Chart will not be update directly here, except set dirty.
            // But there is no such scenario now.
            each([].concat(ecIns._componentsViews).concat(ecIns._chartsViews), callView)
            return
          }

          const query = {}
          query[mainType + 'Id'] = payload[mainType + 'Id']
          query[mainType + 'Index'] = payload[mainType + 'Index']
          query[mainType + 'Name'] = payload[mainType + 'Name']
          const condition = {
            mainType: mainType,
            query: query
          }
          subType && (condition.subType = subType) // subType may be '' by parseClassType;

          const excludeSeriesId = payload.excludeSeriesId
          let excludeSeriesIdMap

          if (excludeSeriesId != null) {
            excludeSeriesIdMap = createHashMap()
            each(normalizeToArray(excludeSeriesId), function (id) {
              const modelId = convertOptionIdName(id, null)

              if (modelId != null) {
                excludeSeriesIdMap.set(modelId, true)
              }
            })
          } // If dispatchAction before setOption, do nothing.

          ecModel && ecModel.eachComponent(condition, function (model) {
            const isExcluded = excludeSeriesIdMap && excludeSeriesIdMap.get(model.id) !== null

            if (isExcluded) {
              return
            }

            if (isHighDownPayload(payload)) {
              if (model instanceof SeriesModel) {
                if (payload.type === HIGHLIGHT_ACTION_TYPE && !payload.notBlur && !model.get(['emphasis', 'disabled'])) {
                  blurSeriesFromHighlightPayload(model, payload, ecIns._api)
                }
              } else {
                const _a = findComponentHighDownDispatchers(model.mainType, model.componentIndex, payload.name, ecIns._api)
                const focusSelf = _a.focusSelf
                const dispatchers = _a.dispatchers

                if (payload.type === HIGHLIGHT_ACTION_TYPE && focusSelf && !payload.notBlur) {
                  blurComponent(model.mainType, model.componentIndex, ecIns._api)
                } // PENDING:
                // Whether to put this "enter emphasis" code in `ComponentView`,
                // which will be the same as `ChartView` but might be not necessary
                // and will be far from this logic.

                if (dispatchers) {
                  each(dispatchers, function (dispatcher) {
                    payload.type === HIGHLIGHT_ACTION_TYPE ? enterEmphasis(dispatcher) : leaveEmphasis(dispatcher)
                  })
                }
              }
            } else if (isSelectChangePayload(payload)) {
              // TODO geo
              if (model instanceof SeriesModel) {
                toggleSelectionFromPayload(model, payload, ecIns._api)
                updateSeriesElementSelection(model)
                markStatusToUpdate(ecIns)
              }
            }
          }, ecIns)
          ecModel && ecModel.eachComponent(condition, function (model) {
            const isExcluded = excludeSeriesIdMap && excludeSeriesIdMap.get(model.id) !== null

            if (isExcluded) {
              return
            }
            callView(ecIns[mainType === 'series' ? '_chartsMap' : '_componentsMap'][model.__viewId])
          }, ecIns)

          function callView (view) {
            view && view.__alive && view[method] && view[method](view.__model, ecModel, ecIns._api, payload)
          }
        }

        updateMethods = {
          prepareAndUpdate: function (payload) {
            prepare(this)
            updateMethods.update.call(this, payload, {
              // Needs to mark option changed if newOption is given.
              // It's from MagicType.
              // TODO If use a separate flag optionChanged in payload?
              optionChanged: payload.newOption != null
            })
          },
          update: function (payload, updateParams) {
            const ecModel = this._model
            const api = this._api
            const zr = this._zr
            const coordSysMgr = this._coordSysMgr
            const scheduler = this._scheduler // update before setOption

            if (!ecModel) {
              return
            }

            ecModel.setUpdatePayload(payload)
            scheduler.restoreData(ecModel, payload)
            scheduler.performSeriesTasks(ecModel) // TODO
            // Save total ecModel here for undo/redo (after restoring data and before processing data).
            // Undo (restoration of total ecModel) can be carried out in 'action' or outside API call.
            // Create new coordinate system each update
            // In LineView may save the old coordinate system and use it to get the orignal point

            coordSysMgr.create(ecModel, api)
            scheduler.performDataProcessorTasks(ecModel, payload) // Current stream render is not supported in data process. So we can update
            // stream modes after data processing, where the filtered data is used to
            // deteming whether use progressive rendering.

            updateStreamModes(this, ecModel) // We update stream modes before coordinate system updated, then the modes info
            // can be fetched when coord sys updating (consider the barGrid extent fix). But
            // the drawback is the full coord info can not be fetched. Fortunately this full
            // coord is not requied in stream mode updater currently.

            coordSysMgr.update(ecModel, api)
            clearColorPalette(ecModel)
            scheduler.performVisualTasks(ecModel, payload)
            render(this, ecModel, api, payload, updateParams) // Set background

            const backgroundColor = ecModel.get('backgroundColor') || 'transparent'
            const darkMode = ecModel.get('darkMode')
            zr.setBackgroundColor(backgroundColor) // Force set dark mode.

            if (darkMode != null && darkMode !== 'auto') {
              zr.setDarkMode(darkMode)
            }

            lifecycle.trigger('afterupdate', ecModel, api)
          },
          updateTransform: function (payload) {
            const _this = this

            const ecModel = this._model
            const api = this._api // update before setOption

            if (!ecModel) {
              return
            }

            ecModel.setUpdatePayload(payload) // ChartView.markUpdateMethod(payload, 'updateTransform');

            const componentDirtyList = []
            ecModel.eachComponent(function (componentType, componentModel) {
              if (componentType === 'series') {
                return
              }

              const componentView = _this.getViewOfComponentModel(componentModel)

              if (componentView && componentView.__alive) {
                if (componentView.updateTransform) {
                  const result = componentView.updateTransform(componentModel, ecModel, api, payload)
                  result && result.update && componentDirtyList.push(componentView)
                } else {
                  componentDirtyList.push(componentView)
                }
              }
            })
            const seriesDirtyMap = createHashMap()
            ecModel.eachSeries(function (seriesModel) {
              const chartView = _this._chartsMap[seriesModel.__viewId]

              if (chartView.updateTransform) {
                const result = chartView.updateTransform(seriesModel, ecModel, api, payload)
                result && result.update && seriesDirtyMap.set(seriesModel.uid, 1)
              } else {
                seriesDirtyMap.set(seriesModel.uid, 1)
              }
            })
            clearColorPalette(ecModel) // Keep pipe to the exist pipeline because it depends on the render task of the full pipeline.
            // this._scheduler.performVisualTasks(ecModel, payload, 'layout', true);

            this._scheduler.performVisualTasks(ecModel, payload, {
              setDirty: true,
              dirtyMap: seriesDirtyMap
            }) // Currently, not call render of components. Geo render cost a lot.
            // renderComponents(ecIns, ecModel, api, payload, componentDirtyList);

            renderSeries(this, ecModel, api, payload, {}, seriesDirtyMap)
            lifecycle.trigger('afterupdate', ecModel, api)
          },
          updateView: function (payload) {
            const ecModel = this._model // update before setOption

            if (!ecModel) {
              return
            }

            ecModel.setUpdatePayload(payload)
            ChartView.markUpdateMethod(payload, 'updateView')
            clearColorPalette(ecModel) // Keep pipe to the exist pipeline because it depends on the render task of the full pipeline.

            this._scheduler.performVisualTasks(ecModel, payload, {
              setDirty: true
            })

            render(this, ecModel, this._api, payload, {})
            lifecycle.trigger('afterupdate', ecModel, this._api)
          },
          updateVisual: function (payload) {
            // updateMethods.update.call(this, payload);
            const _this = this

            const ecModel = this._model // update before setOption

            if (!ecModel) {
              return
            }

            ecModel.setUpdatePayload(payload) // clear all visual

            ecModel.eachSeries(function (seriesModel) {
              seriesModel.getData().clearAllVisual()
            }) // Perform visual

            ChartView.markUpdateMethod(payload, 'updateVisual')
            clearColorPalette(ecModel) // Keep pipe to the exist pipeline because it depends on the render task of the full pipeline.

            this._scheduler.performVisualTasks(ecModel, payload, {
              visualType: 'visual',
              setDirty: true
            })

            ecModel.eachComponent(function (componentType, componentModel) {
              if (componentType !== 'series') {
                const componentView = _this.getViewOfComponentModel(componentModel)

                componentView && componentView.__alive && componentView.updateVisual(componentModel, ecModel, _this._api, payload)
              }
            })
            ecModel.eachSeries(function (seriesModel) {
              const chartView = _this._chartsMap[seriesModel.__viewId]
              chartView.updateVisual(seriesModel, ecModel, _this._api, payload)
            })
            lifecycle.trigger('afterupdate', ecModel, this._api)
          },
          updateLayout: function (payload) {
            updateMethods.update.call(this, payload)
          }
        }

        doConvertPixel = function (ecIns, methodName, finder, value) {
          if (ecIns._disposed) {
            disposedWarning(ecIns.id)
            return
          }

          const ecModel = ecIns._model

          const coordSysList = ecIns._coordSysMgr.getCoordinateSystems()

          let result
          const parsedFinder = parseFinder(ecModel, finder)

          for (let i = 0; i < coordSysList.length; i++) {
            const coordSys = coordSysList[i]

            if (coordSys[methodName] && (result = coordSys[methodName](ecModel, parsedFinder, value)) != null) {
              return result
            }
          }

          if ('development' !== 'production') {
            console.warn('No coordinate system that supports ' + methodName + ' found by the given finder.')
          }
        }

        updateStreamModes = function (ecIns, ecModel) {
          const chartsMap = ecIns._chartsMap
          const scheduler = ecIns._scheduler
          ecModel.eachSeries(function (seriesModel) {
            scheduler.updateStreamModes(seriesModel, chartsMap[seriesModel.__viewId])
          })
        }

        doDispatchAction = function (payload, silent) {
          const _this = this

          const ecModel = this.getModel()
          const payloadType = payload.type
          const escapeConnect = payload.escapeConnect
          const actionWrap = actions[payloadType]
          const actionInfo = actionWrap.actionInfo
          const cptTypeTmp = (actionInfo.update || 'update').split(':')
          const updateMethod = cptTypeTmp.pop()
          const cptType = cptTypeTmp[0] != null && parseClassType(cptTypeTmp[0])
          this[IN_MAIN_PROCESS_KEY] = true
          let payloads = [payload]
          let batched = false // Batch action

          if (payload.batch) {
            batched = true
            payloads = map(payload.batch, function (item) {
              item = defaults(extend({}, item), payload)
              item.batch = null
              return item
            })
          }

          const eventObjBatch = []
          let eventObj
          const isSelectChange = isSelectChangePayload(payload)
          const isHighDown = isHighDownPayload(payload) // Only leave blur once if there are multiple batches.

          if (isHighDown) {
            allLeaveBlur(this._api)
          }

          each(payloads, function (batchItem) {
            // Action can specify the event by return it.
            eventObj = actionWrap.action(batchItem, _this._model, _this._api) // Emit event outside

            eventObj = eventObj || extend({}, batchItem) // Convert type to eventType

            eventObj.type = actionInfo.event || eventObj.type
            eventObjBatch.push(eventObj) // light update does not perform data process, layout and visual.

            if (isHighDown) {
              const _a = preParseFinder(payload)
              const queryOptionMap = _a.queryOptionMap
              const mainTypeSpecified = _a.mainTypeSpecified

              const componentMainType = mainTypeSpecified ? queryOptionMap.keys()[0] : 'series'
              updateDirectly(_this, updateMethod, batchItem, componentMainType)
              markStatusToUpdate(_this)
            } else if (isSelectChange) {
              // At present `dispatchAction({ type: 'select', ... })` is not supported on components.
              // geo still use 'geoselect'.
              updateDirectly(_this, updateMethod, batchItem, 'series')
              markStatusToUpdate(_this)
            } else if (cptType) {
              updateDirectly(_this, updateMethod, batchItem, cptType.main, cptType.sub)
            }
          })

          if (updateMethod !== 'none' && !isHighDown && !isSelectChange && !cptType) {
            try {
              // Still dirty
              if (this[PENDING_UPDATE]) {
                prepare(this)
                updateMethods.update.call(this, payload)
                this[PENDING_UPDATE] = null
              } else {
                updateMethods[updateMethod].call(this, payload)
              }
            } catch (e) {
              this[IN_MAIN_PROCESS_KEY] = false
              throw e
            }
          } // Follow the rule of action batch

          if (batched) {
            eventObj = {
              type: actionInfo.event || payloadType,
              escapeConnect: escapeConnect,
              batch: eventObjBatch
            }
          } else {
            eventObj = eventObjBatch[0]
          }

          this[IN_MAIN_PROCESS_KEY] = false

          if (!silent) {
            const messageCenter = this._messageCenter
            messageCenter.trigger(eventObj.type, eventObj) // Extra triggered 'selectchanged' event

            if (isSelectChange) {
              const newObj = {
                type: 'selectchanged',
                escapeConnect: escapeConnect,
                selected: getAllSelectedIndices(ecModel),
                isFromClick: payload.isFromClick || false,
                fromAction: payload.type,
                fromActionPayload: payload
              }
              messageCenter.trigger(newObj.type, newObj)
            }
          }
        }

        flushPendingActions = function (silent) {
          const pendingActions = this._pendingActions

          while (pendingActions.length) {
            const payload = pendingActions.shift()
            doDispatchAction.call(this, payload, silent)
          }
        }

        triggerUpdatedEvent = function (silent) {
          !silent && this.trigger('updated')
        }
        /**
         * Event `rendered` is triggered when zr
         * rendered. It is useful for realtime
         * snapshot (reflect animation).
         *
         * Event `finished` is triggered when:
         * (1) zrender rendering finished.
         * (2) initial animation finished.
         * (3) progressive rendering finished.
         * (4) no pending action.
         * (5) no delayed setOption needs to be processed.
         */

        bindRenderedEvent = function (zr, ecIns) {
          zr.on('rendered', function (params) {
            ecIns.trigger('rendered', params) // The `finished` event should not be triggered repeatly,
            // so it should only be triggered when rendering indeed happend
            // in zrender. (Consider the case that dipatchAction is keep
            // triggering when mouse move).

            if ( // Although zr is dirty if initial animation is not finished
            // and this checking is called on frame, we also check
            // animation finished for robustness.
              zr.animation.isFinished() && !ecIns[PENDING_UPDATE] && !ecIns._scheduler.unfinished && !ecIns._pendingActions.length) {
              ecIns.trigger('finished')
            }
          })
        }

        bindMouseEvent = function (zr, ecIns) {
          zr.on('mouseover', function (e) {
            const el = e.target
            const dispatcher = findEventDispatcher(el, isHighDownDispatcher)

            if (dispatcher) {
              handleGlobalMouseOverForHighDown(dispatcher, e, ecIns._api)
              markStatusToUpdate(ecIns)
            }
          }).on('mouseout', function (e) {
            const el = e.target
            const dispatcher = findEventDispatcher(el, isHighDownDispatcher)

            if (dispatcher) {
              handleGlobalMouseOutForHighDown(dispatcher, e, ecIns._api)
              markStatusToUpdate(ecIns)
            }
          }).on('click', function (e) {
            const el = e.target
            const dispatcher = findEventDispatcher(el, function (target) {
              return getECData(target).dataIndex != null
            }, true)

            if (dispatcher) {
              const actionType = dispatcher.selected ? 'unselect' : 'select'
              const ecData = getECData(dispatcher)

              ecIns._api.dispatchAction({
                type: actionType,
                dataType: ecData.dataType,
                dataIndexInside: ecData.dataIndex,
                seriesIndex: ecData.seriesIndex,
                isFromClick: true
              })
            }
          })
        }

        function clearColorPalette (ecModel) {
          ecModel.clearColorPalette()
          ecModel.eachSeries(function (seriesModel) {
            seriesModel.clearColorPalette()
          })
        }

        function allocateZlevels (ecModel) {
          const componentZLevels = []
          const seriesZLevels = []
          let hasSeperateZLevel = false
          ecModel.eachComponent(function (componentType, componentModel) {
            const zlevel = componentModel.get('zlevel') || 0
            const z = componentModel.get('z') || 0
            const zlevelKey = componentModel.getZLevelKey()
            hasSeperateZLevel = hasSeperateZLevel || !!zlevelKey;
            (componentType === 'series' ? seriesZLevels : componentZLevels).push({
              zlevel: zlevel,
              z: z,
              idx: componentModel.componentIndex,
              type: componentType,
              key: zlevelKey
            })
          })

          if (hasSeperateZLevel) {
            // Series after component
            const zLevels = componentZLevels.concat(seriesZLevels)
            let lastSeriesZLevel_1
            let lastSeriesKey_1
            sort(zLevels, function (a, b) {
              if (a.zlevel === b.zlevel) {
                return a.z - b.z
              }

              return a.zlevel - b.zlevel
            })
            each(zLevels, function (item) {
              const componentModel = ecModel.getComponent(item.type, item.idx)
              let zlevel = item.zlevel
              const key = item.key

              if (lastSeriesZLevel_1 != null) {
                zlevel = Math.max(lastSeriesZLevel_1, zlevel)
              }

              if (key) {
                if (zlevel === lastSeriesZLevel_1 && key !== lastSeriesKey_1) {
                  zlevel++
                }

                lastSeriesKey_1 = key
              } else if (lastSeriesKey_1) {
                if (zlevel === lastSeriesZLevel_1) {
                  zlevel++
                }

                lastSeriesKey_1 = ''
              }

              lastSeriesZLevel_1 = zlevel
              componentModel.setZLevel(zlevel)
            })
          }
        }

        render = function (ecIns, ecModel, api, payload, updateParams) {
          allocateZlevels(ecModel)
          renderComponents(ecIns, ecModel, api, payload, updateParams)
          each(ecIns._chartsViews, function (chart) {
            chart.__alive = false
          })
          renderSeries(ecIns, ecModel, api, payload, updateParams) // Remove groups of unrendered charts

          each(ecIns._chartsViews, function (chart) {
            if (!chart.__alive) {
              chart.remove(ecModel, api)
            }
          })
        }

        renderComponents = function (ecIns, ecModel, api, payload, updateParams, dirtyList) {
          each(dirtyList || ecIns._componentsViews, function (componentView) {
            const componentModel = componentView.__model
            clearStates(componentModel, componentView)
            componentView.render(componentModel, ecModel, api, payload)
            updateZ(componentModel, componentView)
            updateStates(componentModel, componentView)
          })
        }
        /**
         * Render each chart and component
         */

        renderSeries = function (ecIns, ecModel, api, payload, updateParams, dirtyMap) {
          // Render all charts
          const scheduler = ecIns._scheduler
          updateParams = extend(updateParams || {}, {
            updatedSeries: ecModel.getSeries()
          }) // TODO progressive?

          lifecycle.trigger('series:beforeupdate', ecModel, api, updateParams)
          let unfinished = false
          ecModel.eachSeries(function (seriesModel) {
            const chartView = ecIns._chartsMap[seriesModel.__viewId]
            chartView.__alive = true
            const renderTask = chartView.renderTask
            scheduler.updatePayload(renderTask, payload) // TODO states on marker.

            clearStates(seriesModel, chartView)

            if (dirtyMap && dirtyMap.get(seriesModel.uid)) {
              renderTask.dirty()
            }

            if (renderTask.perform(scheduler.getPerformArgs(renderTask))) {
              unfinished = true
            }

            chartView.group.silent = !!seriesModel.get('silent') // Should not call markRedraw on group, because it will disable zrender
            // increamental render (alway render from the __startIndex each frame)
            // chartView.group.markRedraw();

            updateBlend(seriesModel, chartView)
            updateSeriesElementSelection(seriesModel)
          })
          scheduler.unfinished = unfinished || scheduler.unfinished
          lifecycle.trigger('series:layoutlabels', ecModel, api, updateParams) // transition after label is layouted.

          lifecycle.trigger('series:transition', ecModel, api, updateParams)
          ecModel.eachSeries(function (seriesModel) {
            const chartView = ecIns._chartsMap[seriesModel.__viewId] // Update Z after labels updated. Before applying states.

            updateZ(seriesModel, chartView) // NOTE: Update states after label is updated.
            // label should be in normal status when layouting.

            updateStates(seriesModel, chartView)
          }) // If use hover layer

          updateHoverLayerStatus(ecIns, ecModel)
          lifecycle.trigger('series:afterupdate', ecModel, api, updateParams)
        }

        markStatusToUpdate = function (ecIns) {
          ecIns[STATUS_NEEDS_UPDATE_KEY] = true // Wake up zrender if it's sleep. Let it update states in the next frame.

          ecIns.getZr().wakeUp()
        }

        applyChangedStates = function (ecIns) {
          if (!ecIns[STATUS_NEEDS_UPDATE_KEY]) {
            return
          }

          ecIns.getZr().storage.traverse(function (el) {
            // Not applied on removed elements, it may still in fading.
            if (isElementRemoved(el)) {
              return
            }

            applyElementStates(el)
          })
          ecIns[STATUS_NEEDS_UPDATE_KEY] = false
        }

        function applyElementStates (el) {
          const newStates = []
          const oldStates = el.currentStates // Keep other states.

          for (let i = 0; i < oldStates.length; i++) {
            const stateName = oldStates[i]

            if (!(stateName === 'emphasis' || stateName === 'blur' || stateName === 'select')) {
              newStates.push(stateName)
            }
          } // Only use states when it's exists.

          if (el.selected && el.states.select) {
            newStates.push('select')
          }

          if (el.hoverState === HOVER_STATE_EMPHASIS && el.states.emphasis) {
            newStates.push('emphasis')
          } else if (el.hoverState === HOVER_STATE_BLUR && el.states.blur) {
            newStates.push('blur')
          }

          el.useStates(newStates)
        }

        function updateHoverLayerStatus (ecIns, ecModel) {
          const zr = ecIns._zr
          const storage = zr.storage
          let elCount = 0
          storage.traverse(function (el) {
            if (!el.isGroup) {
              elCount++
            }
          })

          if (elCount > ecModel.get('hoverLayerThreshold') && !env.node && !env.worker) {
            ecModel.eachSeries(function (seriesModel) {
              if (seriesModel.preventUsingHoverLayer) {
                return
              }

              const chartView = ecIns._chartsMap[seriesModel.__viewId]

              if (chartView.__alive) {
                chartView.eachRendered(function (el) {
                  if (el.states.emphasis) {
                    el.states.emphasis.hoverLayer = true
                  }
                })
              }
            })
          }
        }
        /**
         * Update chart and blend.
         */

        function updateBlend (seriesModel, chartView) {
          const blendMode = seriesModel.get('blendMode') || null
          chartView.eachRendered(function (el) {
            // FIXME marker and other components
            if (!el.isGroup) {
              // DONT mark the element dirty. In case element is incremental and don't wan't to rerender.
              el.style.blend = blendMode
            }
          })
        }

        function updateZ (model, view) {
          if (model.preventAutoZ) {
            return
          }

          const z = model.get('z') || 0
          const zlevel = model.get('zlevel') || 0 // Set z and zlevel

          view.eachRendered(function (el) {
            doUpdateZ(el, z, zlevel, -Infinity) // Don't traverse the children because it has been traversed in _updateZ.

            return true
          })
        }

        function doUpdateZ (el, z, zlevel, maxZ2) {
          // Group may also have textContent
          const label = el.getTextContent()
          const labelLine = el.getTextGuideLine()
          const isGroup = el.isGroup

          if (isGroup) {
            // set z & zlevel of children elements of Group
            const children = el.childrenRef()

            for (let i = 0; i < children.length; i++) {
              maxZ2 = Math.max(doUpdateZ(children[i], z, zlevel, maxZ2), maxZ2)
            }
          } else {
            // not Group
            el.z = z
            el.zlevel = zlevel
            maxZ2 = Math.max(el.z2, maxZ2)
          } // always set z and zlevel if label/labelLine exists

          if (label) {
            label.z = z
            label.zlevel = zlevel // lift z2 of text content
            // TODO if el.emphasis.z2 is spcefied, what about textContent.

            isFinite(maxZ2) && (label.z2 = maxZ2 + 2)
          }

          if (labelLine) {
            const textGuideLineConfig = el.textGuideLineConfig
            labelLine.z = z
            labelLine.zlevel = zlevel
            isFinite(maxZ2) && (labelLine.z2 = maxZ2 + (textGuideLineConfig && textGuideLineConfig.showAbove ? 1 : -1))
          }

          return maxZ2
        } // Clear states without animation.
        // TODO States on component.

        function clearStates (model, view) {
          view.eachRendered(function (el) {
            // Not applied on removed elements, it may still in fading.
            if (isElementRemoved(el)) {
              return
            }

            const textContent = el.getTextContent()
            const textGuide = el.getTextGuideLine()

            if (el.stateTransition) {
              el.stateTransition = null
            }

            if (textContent && textContent.stateTransition) {
              textContent.stateTransition = null
            }

            if (textGuide && textGuide.stateTransition) {
              textGuide.stateTransition = null
            } // TODO If el is incremental.

            if (el.hasState()) {
              el.prevStates = el.currentStates
              el.clearStates()
            } else if (el.prevStates) {
              el.prevStates = null
            }
          })
        }

        function updateStates (model, view) {
          const stateAnimationModel = model.getModel('stateAnimation')
          const enableAnimation = model.isAnimationEnabled()
          const duration = stateAnimationModel.get('duration')
          const stateTransition = duration > 0 ? {
            duration: duration,
            delay: stateAnimationModel.get('delay'),
            easing: stateAnimationModel.get('easing') // additive: stateAnimationModel.get('additive')

          } : null
          view.eachRendered(function (el) {
            if (el.states && el.states.emphasis) {
              // Not applied on removed elements, it may still in fading.
              if (isElementRemoved(el)) {
                return
              }

              if (el instanceof Path) {
                savePathStates(el)
              } // Only updated on changed element. In case element is incremental and don't wan't to rerender.
              // TODO, a more proper way?

              if (el.__dirty) {
                const prevStates = el.prevStates // Restore states without animation

                if (prevStates) {
                  el.useStates(prevStates)
                }
              } // Update state transition and enable animation again.

              if (enableAnimation) {
                el.stateTransition = stateTransition
                const textContent = el.getTextContent()
                const textGuide = el.getTextGuideLine() // TODO Is it necessary to animate label?

                if (textContent) {
                  textContent.stateTransition = stateTransition
                }

                if (textGuide) {
                  textGuide.stateTransition = stateTransition
                }
              } // The use higlighted and selected flag to toggle states.

              if (el.__dirty) {
                applyElementStates(el)
              }
            }
          })
        }

        createExtensionAPI = function (ecIns) {
          return new (
          /** @class */
            function (_super) {
              __extends(class_1, _super)

              function class_1 () {
                return _super !== null && _super.apply(this, arguments) || this
              }

              class_1.prototype.getCoordinateSystems = function () {
                return ecIns._coordSysMgr.getCoordinateSystems()
              }

              class_1.prototype.getComponentByElement = function (el) {
                while (el) {
                  const modelInfo = el.__ecComponentInfo

                  if (modelInfo != null) {
                    return ecIns._model.getComponent(modelInfo.mainType, modelInfo.index)
                  }

                  el = el.parent
                }
              }

              class_1.prototype.enterEmphasis = function (el, highlightDigit) {
                enterEmphasis(el, highlightDigit)
                markStatusToUpdate(ecIns)
              }

              class_1.prototype.leaveEmphasis = function (el, highlightDigit) {
                leaveEmphasis(el, highlightDigit)
                markStatusToUpdate(ecIns)
              }

              class_1.prototype.enterBlur = function (el) {
                enterBlur(el)
                markStatusToUpdate(ecIns)
              }

              class_1.prototype.leaveBlur = function (el) {
                leaveBlur(el)
                markStatusToUpdate(ecIns)
              }

              class_1.prototype.enterSelect = function (el) {
                enterSelect(el)
                markStatusToUpdate(ecIns)
              }

              class_1.prototype.leaveSelect = function (el) {
                leaveSelect(el)
                markStatusToUpdate(ecIns)
              }

              class_1.prototype.getModel = function () {
                return ecIns.getModel()
              }

              class_1.prototype.getViewOfComponentModel = function (componentModel) {
                return ecIns.getViewOfComponentModel(componentModel)
              }

              class_1.prototype.getViewOfSeriesModel = function (seriesModel) {
                return ecIns.getViewOfSeriesModel(seriesModel)
              }

              return class_1
            }(ExtensionAPI))(ecIns)
        }

        enableConnect = function (chart) {
          function updateConnectedChartsStatus (charts, status) {
            for (let i = 0; i < charts.length; i++) {
              const otherChart = charts[i]
              otherChart[CONNECT_STATUS_KEY] = status
            }
          }

          each(eventActionMap, function (actionType, eventType) {
            chart._messageCenter.on(eventType, function (event) {
              if (connectedGroups[chart.group] && chart[CONNECT_STATUS_KEY] !== CONNECT_STATUS_PENDING) {
                if (event && event.escapeConnect) {
                  return
                }

                const action_1 = chart.makeActionFromEvent(event)
                const otherCharts_1 = []
                each(instances$1, function (otherChart) {
                  if (otherChart !== chart && otherChart.group === chart.group) {
                    otherCharts_1.push(otherChart)
                  }
                })
                updateConnectedChartsStatus(otherCharts_1, CONNECT_STATUS_PENDING)
                each(otherCharts_1, function (otherChart) {
                  if (otherChart[CONNECT_STATUS_KEY] !== CONNECT_STATUS_UPDATING) {
                    otherChart.dispatchAction(action_1)
                  }
                })
                updateConnectedChartsStatus(otherCharts_1, CONNECT_STATUS_UPDATED)
              }
            })
          })
        }
      }())

      return ECharts
    }(Eventful))

  const echartsProto = ECharts.prototype
  echartsProto.on = createRegisterEventWithLowercaseECharts('on')
  echartsProto.off = createRegisterEventWithLowercaseECharts('off')
  /**
     * @deprecated
     */
  // @ts-ignore

  echartsProto.one = function (eventName, cb, ctx) {
    const self = this
    deprecateLog('ECharts#one is deprecated.')

    function wrapped () {
      const args2 = []

      for (let _i = 0; _i < arguments.length; _i++) {
        args2[_i] = arguments[_i]
      }

      cb && cb.apply && cb.apply(this, args2) // @ts-ignore

      self.off(eventName, wrapped)
    }

    this.on.call(this, eventName, wrapped, ctx)
  }

  var MOUSE_EVENT_NAMES = ['click', 'dblclick', 'mouseover', 'mouseout', 'mousemove', 'mousedown', 'mouseup', 'globalout', 'contextmenu']

  function disposedWarning (id) {
    if ('development' !== 'production') {
      console.warn('Instance ' + id + ' has been disposed')
    }
  }

  var actions = {}
  /**
     * Map eventType to actionType
     */

  var eventActionMap = {}
  var dataProcessorFuncs = []
  var optionPreprocessorFuncs = []
  var visualFuncs = []
  var themeStorage = {}
  var loadingEffects = {}
  var instances$1 = {}
  var connectedGroups = {}
  let idBase = +new Date() - 0
  let groupIdBase = +new Date() - 0
  var DOM_ATTRIBUTE_KEY = '_echarts_instance_'
  /**
     * @param opts.devicePixelRatio Use window.devicePixelRatio by default
     * @param opts.renderer Can choose 'canvas' or 'svg' to render the chart.
     * @param opts.width Use clientWidth of the input `dom` by default.
     *        Can be 'auto' (the same as null/undefined)
     * @param opts.height Use clientHeight of the input `dom` by default.
     *        Can be 'auto' (the same as null/undefined)
     * @param opts.locale Specify the locale.
     * @param opts.useDirtyRect Enable dirty rectangle rendering or not.
     */

  function init$1 (dom, theme, opts) {
    const isClient = !(opts && opts.ssr)

    if (isClient) {
      if ('development' !== 'production') {
        if (!dom) {
          throw new Error('Initialize failed: invalid dom.')
        }
      }

      const existInstance = getInstanceByDom(dom)

      if (existInstance) {
        if ('development' !== 'production') {
          console.warn('There is a chart instance already initialized on the dom.')
        }

        return existInstance
      }

      if ('development' !== 'production') {
        if (isDom(dom) && dom.nodeName.toUpperCase() !== 'CANVAS' && (!dom.clientWidth && (!opts || opts.width == null) || !dom.clientHeight && (!opts || opts.height == null))) {
          console.warn('Can\'t get DOM width or height. Please check ' + 'dom.clientWidth and dom.clientHeight. They should not be 0.' + 'For example, you may need to call this in the callback ' + 'of window.onload.')
        }
      }
    }

    const chart = new ECharts(dom, theme, opts)
    chart.id = 'ec_' + idBase++
    instances$1[chart.id] = chart
    isClient && setAttribute(dom, DOM_ATTRIBUTE_KEY, chart.id)
    enableConnect(chart)
    lifecycle.trigger('afterinit', chart)
    return chart
  }
  /**
     * @usage
     * (A)
     * ```js
     * let chart1 = echarts.init(dom1);
     * let chart2 = echarts.init(dom2);
     * chart1.group = 'xxx';
     * chart2.group = 'xxx';
     * echarts.connect('xxx');
     * ```
     * (B)
     * ```js
     * let chart1 = echarts.init(dom1);
     * let chart2 = echarts.init(dom2);
     * echarts.connect('xxx', [chart1, chart2]);
     * ```
     */

  function connect (groupId) {
    // Is array of charts
    if (isArray(groupId)) {
      const charts = groupId
      groupId = null // If any chart has group

      each(charts, function (chart) {
        if (chart.group != null) {
          groupId = chart.group
        }
      })
      groupId = groupId || 'g_' + groupIdBase++
      each(charts, function (chart) {
        chart.group = groupId
      })
    }

    connectedGroups[groupId] = true
    return groupId
  }
  /**
     * @deprecated
     */

  function disConnect (groupId) {
    connectedGroups[groupId] = false
  }
  /**
     * Alias and backword compat
     */

  const disconnect = disConnect
  /**
     * Dispose a chart instance
     */

  function dispose$1 (chart) {
    if (isString(chart)) {
      chart = instances$1[chart]
    } else if (!(chart instanceof ECharts)) {
      // Try to treat as dom
      chart = getInstanceByDom(chart)
    }

    if (chart instanceof ECharts && !chart.isDisposed()) {
      chart.dispose()
    }
  }
  function getInstanceByDom (dom) {
    return instances$1[getAttribute(dom, DOM_ATTRIBUTE_KEY)]
  }
  function getInstanceById (key) {
    return instances$1[key]
  }
  /**
     * Register theme
     */

  function registerTheme (name, theme) {
    themeStorage[name] = theme
  }
  /**
     * Register option preprocessor
     */

  function registerPreprocessor (preprocessorFunc) {
    if (indexOf(optionPreprocessorFuncs, preprocessorFunc) < 0) {
      optionPreprocessorFuncs.push(preprocessorFunc)
    }
  }
  function registerProcessor (priority, processor) {
    normalizeRegister(dataProcessorFuncs, priority, processor, PRIORITY_PROCESSOR_DEFAULT)
  }
  /**
     * Register postIniter
     * @param {Function} postInitFunc
     */

  function registerPostInit (postInitFunc) {
    registerUpdateLifecycle('afterinit', postInitFunc)
  }
  /**
     * Register postUpdater
     * @param {Function} postUpdateFunc
     */

  function registerPostUpdate (postUpdateFunc) {
    registerUpdateLifecycle('afterupdate', postUpdateFunc)
  }
  function registerUpdateLifecycle (name, cb) {
    lifecycle.on(name, cb)
  }
  function registerAction (actionInfo, eventName, action) {
    if (isFunction(eventName)) {
      action = eventName
      eventName = ''
    }

    const actionType = isObject(actionInfo)
      ? actionInfo.type
      : [actionInfo, actionInfo = {
          event: eventName
        }][0] // Event name is all lowercase

    actionInfo.event = (actionInfo.event || actionType).toLowerCase()
    eventName = actionInfo.event

    if (eventActionMap[eventName]) {
      // Already registered.
      return
    } // Validate action type and event name.

    assert(ACTION_REG.test(actionType) && ACTION_REG.test(eventName))

    if (!actions[actionType]) {
      actions[actionType] = {
        action: action,
        actionInfo: actionInfo
      }
    }

    eventActionMap[eventName] = actionType
  }
  function registerCoordinateSystem (type, coordSysCreator) {
    CoordinateSystemManager.register(type, coordSysCreator)
  }
  /**
     * Get dimensions of specified coordinate system.
     * @param {string} type
     * @return {Array.<string|Object>}
     */

  function getCoordinateSystemDimensions (type) {
    const coordSysCreator = CoordinateSystemManager.get(type)

    if (coordSysCreator) {
      return coordSysCreator.getDimensionsInfo ? coordSysCreator.getDimensionsInfo() : coordSysCreator.dimensions.slice()
    }
  }

  function registerLayout (priority, layoutTask) {
    normalizeRegister(visualFuncs, priority, layoutTask, PRIORITY_VISUAL_LAYOUT, 'layout')
  }

  function registerVisual (priority, visualTask) {
    normalizeRegister(visualFuncs, priority, visualTask, PRIORITY_VISUAL_CHART, 'visual')
  }
  const registeredTasks = []

  function normalizeRegister (targetList, priority, fn, defaultPriority, visualType) {
    if (isFunction(priority) || isObject(priority)) {
      fn = priority
      priority = defaultPriority
    }

    if ('development' !== 'production') {
      if (isNaN(priority) || priority == null) {
        throw new Error('Illegal priority')
      } // Check duplicate

      each(targetList, function (wrap) {
        assert(wrap.__raw !== fn)
      })
    } // Already registered

    if (indexOf(registeredTasks, fn) >= 0) {
      return
    }

    registeredTasks.push(fn)
    const stageHandler = Scheduler.wrapStageHandler(fn, visualType)
    stageHandler.__prio = priority
    stageHandler.__raw = fn
    targetList.push(stageHandler)
  }

  function registerLoading (name, loadingFx) {
    loadingEffects[name] = loadingFx
  }
  /**
     * ZRender need a canvas context to do measureText.
     * But in node environment canvas may be created by node-canvas.
     * So we need to specify how to create a canvas instead of using document.createElement('canvas')
     *
     *
     * @deprecated use setPlatformAPI({ createCanvas }) instead.
     *
     * @example
     *     let Canvas = require('canvas');
     *     let echarts = require('echarts');
     *     echarts.setCanvasCreator(function () {
     *         // Small size is enough.
     *         return new Canvas(32, 32);
     *     });
     */

  function setCanvasCreator (creator) {
    if ('development' !== 'production') {
      deprecateLog('setCanvasCreator is deprecated. Use setPlatformAPI({ createCanvas }) instead.')
    }

    setPlatformAPI({
      createCanvas: creator
    })
  }
  /**
     * The parameters and usage: see `geoSourceManager.registerMap`.
     * Compatible with previous `echarts.registerMap`.
     */

  function registerMap (mapName, geoJson, specialAreas) {
    const registerMap = getImpl('registerMap')
    registerMap && registerMap(mapName, geoJson, specialAreas)
  }
  function getMap (mapName) {
    const getMap = getImpl('getMap')
    return getMap && getMap(mapName)
  }
  const registerTransform = registerExternalTransform
  /**
     * Globa dispatchAction to a specified chart instance.
     */
  // export function dispatchAction(payload: { chartId: string } & Payload, opt?: Parameters<ECharts['dispatchAction']>[1]) {
  //     if (!payload || !payload.chartId) {
  //         // Must have chartId to find chart
  //         return;
  //     }
  //     const chart = instances[payload.chartId];
  //     if (chart) {
  //         chart.dispatchAction(payload, opt);
  //     }
  // }
  // Buitlin global visual

  registerVisual(PRIORITY_VISUAL_GLOBAL, seriesStyleTask)
  registerVisual(PRIORITY_VISUAL_CHART_DATA_CUSTOM, dataStyleTask)
  registerVisual(PRIORITY_VISUAL_CHART_DATA_CUSTOM, dataColorPaletteTask)
  registerVisual(PRIORITY_VISUAL_GLOBAL, seriesSymbolTask)
  registerVisual(PRIORITY_VISUAL_CHART_DATA_CUSTOM, dataSymbolTask)
  registerVisual(PRIORITY_VISUAL_DECAL, decalVisual)
  registerPreprocessor(globalBackwardCompat)
  registerProcessor(PRIORITY_PROCESSOR_DATASTACK, dataStack)
  registerLoading('default', defaultLoading) // Default actions

  registerAction({
    type: HIGHLIGHT_ACTION_TYPE,
    event: HIGHLIGHT_ACTION_TYPE,
    update: HIGHLIGHT_ACTION_TYPE
  }, noop)
  registerAction({
    type: DOWNPLAY_ACTION_TYPE,
    event: DOWNPLAY_ACTION_TYPE,
    update: DOWNPLAY_ACTION_TYPE
  }, noop)
  registerAction({
    type: SELECT_ACTION_TYPE,
    event: SELECT_ACTION_TYPE,
    update: SELECT_ACTION_TYPE
  }, noop)
  registerAction({
    type: UNSELECT_ACTION_TYPE,
    event: UNSELECT_ACTION_TYPE,
    update: UNSELECT_ACTION_TYPE
  }, noop)
  registerAction({
    type: TOGGLE_SELECT_ACTION_TYPE,
    event: TOGGLE_SELECT_ACTION_TYPE,
    update: TOGGLE_SELECT_ACTION_TYPE
  }, noop) // Default theme

  registerTheme('light', lightTheme)
  registerTheme('dark', theme) // For backward compatibility, where the namespace `dataTool` will
  // be mounted on `echarts` is the extension `dataTool` is imported.

  const dataTool = {}

  const extensions = []
  const extensionRegisters = {
    registerPreprocessor: registerPreprocessor,
    registerProcessor: registerProcessor,
    registerPostInit: registerPostInit,
    registerPostUpdate: registerPostUpdate,
    registerUpdateLifecycle: registerUpdateLifecycle,
    registerAction: registerAction,
    registerCoordinateSystem: registerCoordinateSystem,
    registerLayout: registerLayout,
    registerVisual: registerVisual,
    registerTransform: registerTransform,
    registerLoading: registerLoading,
    registerMap: registerMap,
    registerImpl: registerImpl,
    PRIORITY: PRIORITY,
    ComponentModel: ComponentModel,
    ComponentView: ComponentView,
    SeriesModel: SeriesModel,
    ChartView: ChartView,
    // TODO Use ComponentModel and SeriesModel instead of Constructor
    registerComponentModel: function (ComponentModelClass) {
      ComponentModel.registerClass(ComponentModelClass)
    },
    registerComponentView: function (ComponentViewClass) {
      ComponentView.registerClass(ComponentViewClass)
    },
    registerSeriesModel: function (SeriesModelClass) {
      SeriesModel.registerClass(SeriesModelClass)
    },
    registerChartView: function (ChartViewClass) {
      ChartView.registerClass(ChartViewClass)
    },
    registerSubTypeDefaulter: function (componentType, defaulter) {
      ComponentModel.registerSubTypeDefaulter(componentType, defaulter)
    },
    registerPainter: function (painterType, PainterCtor) {
      registerPainter(painterType, PainterCtor)
    }
  }
  function use (ext) {
    if (isArray(ext)) {
      // use([ChartLine, ChartBar]);
      each(ext, function (singleExt) {
        use(singleExt)
      })
      return
    }

    if (indexOf(extensions, ext) >= 0) {
      return
    }

    extensions.push(ext)

    if (isFunction(ext)) {
      ext = {
        install: ext
      }
    }

    ext.install(extensionRegisters)
  }

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

  /**
     * AUTO-GENERATED FILE. DO NOT MODIFY.
     */

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
  function dataIndexMapValueLength (valNumOrArrLengthMoreThan2) {
    return valNumOrArrLengthMoreThan2 == null ? 0 : valNumOrArrLengthMoreThan2.length || 1
  }

  function defaultKeyGetter (item) {
    return item
  }

  const DataDiffer =
    /** @class */
    (function () {
      /**
       * @param context Can be visited by this.context in callback.
       */
      function DataDiffer (oldArr, newArr, oldKeyGetter, newKeyGetter, context, // By default: 'oneToOne'.
        diffMode) {
        this._old = oldArr
        this._new = newArr
        this._oldKeyGetter = oldKeyGetter || defaultKeyGetter
        this._newKeyGetter = newKeyGetter || defaultKeyGetter // Visible in callback via `this.context`;

        this.context = context
        this._diffModeMultiple = diffMode === 'multiple'
      }
      /**
       * Callback function when add a data
       */

      DataDiffer.prototype.add = function (func) {
        this._add = func
        return this
      }
      /**
       * Callback function when update a data
       */

      DataDiffer.prototype.update = function (func) {
        this._update = func
        return this
      }
      /**
       * Callback function when update a data and only work in `cbMode: 'byKey'`.
       */

      DataDiffer.prototype.updateManyToOne = function (func) {
        this._updateManyToOne = func
        return this
      }
      /**
       * Callback function when update a data and only work in `cbMode: 'byKey'`.
       */

      DataDiffer.prototype.updateOneToMany = function (func) {
        this._updateOneToMany = func
        return this
      }
      /**
       * Callback function when update a data and only work in `cbMode: 'byKey'`.
       */

      DataDiffer.prototype.updateManyToMany = function (func) {
        this._updateManyToMany = func
        return this
      }
      /**
       * Callback function when remove a data
       */

      DataDiffer.prototype.remove = function (func) {
        this._remove = func
        return this
      }

      DataDiffer.prototype.execute = function () {
        this[this._diffModeMultiple ? '_executeMultiple' : '_executeOneToOne']()
      }

      DataDiffer.prototype._executeOneToOne = function () {
        const oldArr = this._old
        const newArr = this._new
        const newDataIndexMap = {}
        const oldDataKeyArr = new Array(oldArr.length)
        const newDataKeyArr = new Array(newArr.length)

        this._initIndexMap(oldArr, null, oldDataKeyArr, '_oldKeyGetter')

        this._initIndexMap(newArr, newDataIndexMap, newDataKeyArr, '_newKeyGetter')

        for (let i = 0; i < oldArr.length; i++) {
          const oldKey = oldDataKeyArr[i]
          const newIdxMapVal = newDataIndexMap[oldKey]
          const newIdxMapValLen = dataIndexMapValueLength(newIdxMapVal) // idx can never be empty array here. see 'set null' logic below.

          if (newIdxMapValLen > 1) {
            // Consider there is duplicate key (for example, use dataItem.name as key).
            // We should make sure every item in newArr and oldArr can be visited.
            const newIdx = newIdxMapVal.shift()

            if (newIdxMapVal.length === 1) {
              newDataIndexMap[oldKey] = newIdxMapVal[0]
            }

            this._update && this._update(newIdx, i)
          } else if (newIdxMapValLen === 1) {
            newDataIndexMap[oldKey] = null
            this._update && this._update(newIdxMapVal, i)
          } else {
            this._remove && this._remove(i)
          }
        }

        this._performRestAdd(newDataKeyArr, newDataIndexMap)
      }
      /**
       * For example, consider the case:
       * oldData: [o0, o1, o2, o3, o4, o5, o6, o7],
       * newData: [n0, n1, n2, n3, n4, n5, n6, n7, n8],
       * Where:
       *     o0, o1, n0 has key 'a' (many to one)
       *     o5, n4, n5, n6 has key 'b' (one to many)
       *     o2, n1 has key 'c' (one to one)
       *     n2, n3 has key 'd' (add)
       *     o3, o4 has key 'e' (remove)
       *     o6, o7, n7, n8 has key 'f' (many to many, treated as add and remove)
       * Then:
       *     (The order of the following directives are not ensured.)
       *     this._updateManyToOne(n0, [o0, o1]);
       *     this._updateOneToMany([n4, n5, n6], o5);
       *     this._update(n1, o2);
       *     this._remove(o3);
       *     this._remove(o4);
       *     this._remove(o6);
       *     this._remove(o7);
       *     this._add(n2);
       *     this._add(n3);
       *     this._add(n7);
       *     this._add(n8);
       */

      DataDiffer.prototype._executeMultiple = function () {
        const oldArr = this._old
        const newArr = this._new
        const oldDataIndexMap = {}
        const newDataIndexMap = {}
        const oldDataKeyArr = []
        const newDataKeyArr = []

        this._initIndexMap(oldArr, oldDataIndexMap, oldDataKeyArr, '_oldKeyGetter')

        this._initIndexMap(newArr, newDataIndexMap, newDataKeyArr, '_newKeyGetter')

        for (let i = 0; i < oldDataKeyArr.length; i++) {
          const oldKey = oldDataKeyArr[i]
          const oldIdxMapVal = oldDataIndexMap[oldKey]
          const newIdxMapVal = newDataIndexMap[oldKey]
          const oldIdxMapValLen = dataIndexMapValueLength(oldIdxMapVal)
          const newIdxMapValLen = dataIndexMapValueLength(newIdxMapVal)

          if (oldIdxMapValLen > 1 && newIdxMapValLen === 1) {
            this._updateManyToOne && this._updateManyToOne(newIdxMapVal, oldIdxMapVal)
            newDataIndexMap[oldKey] = null
          } else if (oldIdxMapValLen === 1 && newIdxMapValLen > 1) {
            this._updateOneToMany && this._updateOneToMany(newIdxMapVal, oldIdxMapVal)
            newDataIndexMap[oldKey] = null
          } else if (oldIdxMapValLen === 1 && newIdxMapValLen === 1) {
            this._update && this._update(newIdxMapVal, oldIdxMapVal)
            newDataIndexMap[oldKey] = null
          } else if (oldIdxMapValLen > 1 && newIdxMapValLen > 1) {
            this._updateManyToMany && this._updateManyToMany(newIdxMapVal, oldIdxMapVal)
            newDataIndexMap[oldKey] = null
          } else if (oldIdxMapValLen > 1) {
            for (let i_1 = 0; i_1 < oldIdxMapValLen; i_1++) {
              this._remove && this._remove(oldIdxMapVal[i_1])
            }
          } else {
            this._remove && this._remove(oldIdxMapVal)
          }
        }

        this._performRestAdd(newDataKeyArr, newDataIndexMap)
      }

      DataDiffer.prototype._performRestAdd = function (newDataKeyArr, newDataIndexMap) {
        for (let i = 0; i < newDataKeyArr.length; i++) {
          const newKey = newDataKeyArr[i]
          const newIdxMapVal = newDataIndexMap[newKey]
          const idxMapValLen = dataIndexMapValueLength(newIdxMapVal)

          if (idxMapValLen > 1) {
            for (let j = 0; j < idxMapValLen; j++) {
              this._add && this._add(newIdxMapVal[j])
            }
          } else if (idxMapValLen === 1) {
            this._add && this._add(newIdxMapVal)
          } // Support both `newDataKeyArr` are duplication removed or not removed.

          newDataIndexMap[newKey] = null
        }
      }

      DataDiffer.prototype._initIndexMap = function (arr, // Can be null.
        map, // In 'byKey', the output `keyArr` is duplication removed.
        // In 'byIndex', the output `keyArr` is not duplication removed and
        //     its indices are accurately corresponding to `arr`.
        keyArr, keyGetterName) {
        const cbModeMultiple = this._diffModeMultiple

        for (let i = 0; i < arr.length; i++) {
          // Add prefix to avoid conflict with Object.prototype.
          const key = '_ec_' + this[keyGetterName](arr[i], i)

          if (!cbModeMultiple) {
            keyArr[i] = key
          }

          if (!map) {
            continue
          }

          const idxMapVal = map[key]
          const idxMapValLen = dataIndexMapValueLength(idxMapVal)

          if (idxMapValLen === 0) {
            // Simple optimize: in most cases, one index has one key,
            // do not need array.
            map[key] = i

            if (cbModeMultiple) {
              keyArr.push(key)
            }
          } else if (idxMapValLen === 1) {
            map[key] = [idxMapVal, i]
          } else {
            idxMapVal.push(i)
          }
        }
      }

      return DataDiffer
    }())

  const DimensionUserOuput =
    /** @class */
    (function () {
      function DimensionUserOuput (encode, dimRequest) {
        this._encode = encode
        this._schema = dimRequest
      }

      DimensionUserOuput.prototype.get = function () {
        return {
          // Do not generate full dimension name until fist used.
          fullDimensions: this._getFullDimensionNames(),
          encode: this._encode
        }
      }
      /**
       * Get all data store dimension names.
       * Theoretically a series data store is defined both by series and used dataset (if any).
       * If some dimensions are omitted for performance reason in `this.dimensions`,
       * the dimension name may not be auto-generated if user does not specify a dimension name.
       * In this case, the dimension name is `null`/`undefined`.
       */

      DimensionUserOuput.prototype._getFullDimensionNames = function () {
        if (!this._cachedDimNames) {
          this._cachedDimNames = this._schema ? this._schema.makeOutputDimensionNames() : []
        }

        return this._cachedDimNames
      }

      return DimensionUserOuput
    }())
  function summarizeDimensions (data, schema) {
    const summary = {}
    const encode = summary.encode = {}
    const notExtraCoordDimMap = createHashMap()
    let defaultedLabel = []
    let defaultedTooltip = []
    const userOutputEncode = {}
    each(data.dimensions, function (dimName) {
      const dimItem = data.getDimensionInfo(dimName)
      const coordDim = dimItem.coordDim

      if (coordDim) {
        if ('development' !== 'production') {
          assert(VISUAL_DIMENSIONS.get(coordDim) == null)
        }

        const coordDimIndex = dimItem.coordDimIndex
        getOrCreateEncodeArr(encode, coordDim)[coordDimIndex] = dimName

        if (!dimItem.isExtraCoord) {
          notExtraCoordDimMap.set(coordDim, 1) // Use the last coord dim (and label friendly) as default label,
          // because when dataset is used, it is hard to guess which dimension
          // can be value dimension. If both show x, y on label is not look good,
          // and conventionally y axis is focused more.

          if (mayLabelDimType(dimItem.type)) {
            defaultedLabel[0] = dimName
          } // User output encode do not contain generated coords.
          // And it only has index. User can use index to retrieve value from the raw item array.

          getOrCreateEncodeArr(userOutputEncode, coordDim)[coordDimIndex] = data.getDimensionIndex(dimItem.name)
        }

        if (dimItem.defaultTooltip) {
          defaultedTooltip.push(dimName)
        }
      }

      VISUAL_DIMENSIONS.each(function (v, otherDim) {
        const encodeArr = getOrCreateEncodeArr(encode, otherDim)
        const dimIndex = dimItem.otherDims[otherDim]

        if (dimIndex != null && dimIndex !== false) {
          encodeArr[dimIndex] = dimItem.name
        }
      })
    })
    let dataDimsOnCoord = []
    const encodeFirstDimNotExtra = {}
    notExtraCoordDimMap.each(function (v, coordDim) {
      const dimArr = encode[coordDim]
      encodeFirstDimNotExtra[coordDim] = dimArr[0] // Not necessary to remove duplicate, because a data
      // dim canot on more than one coordDim.

      dataDimsOnCoord = dataDimsOnCoord.concat(dimArr)
    })
    summary.dataDimsOnCoord = dataDimsOnCoord
    summary.dataDimIndicesOnCoord = map(dataDimsOnCoord, function (dimName) {
      return data.getDimensionInfo(dimName).storeDimIndex
    })
    summary.encodeFirstDimNotExtra = encodeFirstDimNotExtra
    const encodeLabel = encode.label // FIXME `encode.label` is not recommanded, because formatter can not be set
    // in this way. Use label.formatter instead. May be remove this approach someday.

    if (encodeLabel && encodeLabel.length) {
      defaultedLabel = encodeLabel.slice()
    }

    const encodeTooltip = encode.tooltip

    if (encodeTooltip && encodeTooltip.length) {
      defaultedTooltip = encodeTooltip.slice()
    } else if (!defaultedTooltip.length) {
      defaultedTooltip = defaultedLabel.slice()
    }

    encode.defaultedLabel = defaultedLabel
    encode.defaultedTooltip = defaultedTooltip
    summary.userOutput = new DimensionUserOuput(userOutputEncode, schema)
    return summary
  }

  function getOrCreateEncodeArr (encode, dim) {
    if (!encode.hasOwnProperty(dim)) {
      encode[dim] = []
    }

    return encode[dim]
  } // FIXME:TS should be type `AxisType`

  function getDimensionTypeByAxis (axisType) {
    return axisType === 'category' ? 'ordinal' : axisType === 'time' ? 'time' : 'float'
  }

  function mayLabelDimType (dimType) {
    // In most cases, ordinal and time do not suitable for label.
    // Ordinal info can be displayed on axis. Time is too long.
    return !(dimType === 'ordinal' || dimType === 'time')
  } // function findTheLastDimMayLabel(data) {
  //     // Get last value dim
  //     let dimensions = data.dimensions.slice();
  //     let valueType;
  //     let valueDim;
  //     while (dimensions.length && (
  //         valueDim = dimensions.pop(),
  //         valueType = data.getDimensionInfo(valueDim).type,
  //         valueType === 'ordinal' || valueType === 'time'
  //     )) {} // jshint ignore:line
  //     return valueDim;
  // }

  const SeriesDimensionDefine =
    /** @class */
    (function () {
      /**
       * @param opt All of the fields will be shallow copied.
       */
      function SeriesDimensionDefine (opt) {
        /**
         * The format of `otherDims` is:
         * ```js
         * {
         *     tooltip?: number
         *     label?: number
         *     itemName?: number
         *     seriesName?: number
         * }
         * ```
         *
         * A `series.encode` can specified these fields:
         * ```js
         * encode: {
         *     // "3, 1, 5" is the index of data dimension.
         *     tooltip: [3, 1, 5],
         *     label: [0, 3],
         *     ...
         * }
         * ```
         * `otherDims` is the parse result of the `series.encode` above, like:
         * ```js
         * // Suppose the index of this data dimension is `3`.
         * this.otherDims = {
         *     // `3` is at the index `0` of the `encode.tooltip`
         *     tooltip: 0,
         *     // `3` is at the index `1` of the `encode.label`
         *     label: 1
         * };
         * ```
         *
         * This prop should never be `null`/`undefined` after initialized.
         */
        this.otherDims = {}

        if (opt != null) {
          extend(this, opt)
        }
      }

      return SeriesDimensionDefine
    }())

  const inner$4 = makeInner()
  const dimTypeShort = {
    float: 'f',
    int: 'i',
    ordinal: 'o',
    number: 'n',
    time: 't'
  }
  /**
     * Represents the dimension requirement of a series.
     *
     * NOTICE:
     * When there are too many dimensions in dataset and many series, only the used dimensions
     * (i.e., used by coord sys and declared in `series.encode`) are add to `dimensionDefineList`.
     * But users may query data by other unused dimension names.
     * In this case, users can only query data if and only if they have defined dimension names
     * via ec option, so we provide `getDimensionIndexFromSource`, which only query them from
     * `source` dimensions.
     */

  const SeriesDataSchema =
    /** @class */
    (function () {
      function SeriesDataSchema (opt) {
        this.dimensions = opt.dimensions
        this._dimOmitted = opt.dimensionOmitted
        this.source = opt.source
        this._fullDimCount = opt.fullDimensionCount

        this._updateDimOmitted(opt.dimensionOmitted)
      }

      SeriesDataSchema.prototype.isDimensionOmitted = function () {
        return this._dimOmitted
      }

      SeriesDataSchema.prototype._updateDimOmitted = function (dimensionOmitted) {
        this._dimOmitted = dimensionOmitted

        if (!dimensionOmitted) {
          return
        }

        if (!this._dimNameMap) {
          this._dimNameMap = ensureSourceDimNameMap(this.source)
        }
      }
      /**
       * @caution Can only be used when `dimensionOmitted: true`.
       *
       * Get index by user defined dimension name (i.e., not internal generate name).
       * That is, get index from `dimensionsDefine`.
       * If no `dimensionsDefine`, or no name get, return -1.
       */

      SeriesDataSchema.prototype.getSourceDimensionIndex = function (dimName) {
        return retrieve2(this._dimNameMap.get(dimName), -1)
      }
      /**
       * @caution Can only be used when `dimensionOmitted: true`.
       *
       * Notice: may return `null`/`undefined` if user not specify dimension names.
       */

      SeriesDataSchema.prototype.getSourceDimension = function (dimIndex) {
        const dimensionsDefine = this.source.dimensionsDefine

        if (dimensionsDefine) {
          return dimensionsDefine[dimIndex]
        }
      }

      SeriesDataSchema.prototype.makeStoreSchema = function () {
        const dimCount = this._fullDimCount
        const willRetrieveDataByName = shouldRetrieveDataByName(this.source)
        const makeHashStrict = !shouldOmitUnusedDimensions(dimCount) // If source don't have dimensions or series don't omit unsed dimensions.
        // Generate from seriesDimList directly

        let dimHash = ''
        const dims = []

        for (let fullDimIdx = 0, seriesDimIdx = 0; fullDimIdx < dimCount; fullDimIdx++) {
          let property = void 0
          let type = void 0
          let ordinalMeta = void 0
          const seriesDimDef = this.dimensions[seriesDimIdx] // The list has been sorted by `storeDimIndex` asc.

          if (seriesDimDef && seriesDimDef.storeDimIndex === fullDimIdx) {
            property = willRetrieveDataByName ? seriesDimDef.name : null
            type = seriesDimDef.type
            ordinalMeta = seriesDimDef.ordinalMeta
            seriesDimIdx++
          } else {
            const sourceDimDef = this.getSourceDimension(fullDimIdx)

            if (sourceDimDef) {
              property = willRetrieveDataByName ? sourceDimDef.name : null
              type = sourceDimDef.type
            }
          }

          dims.push({
            property: property,
            type: type,
            ordinalMeta: ordinalMeta
          }) // If retrieving data by index,
          //   use <index, type, ordinalMeta> to determine whether data can be shared.
          //   (Becuase in this case there might be no dimension name defined in dataset, but indices always exists).
          //   (indices are always 0, 1, 2, ..., so we can ignore them to shorten the hash).
          // Otherwise if retrieving data by property name (like `data: [{aa: 123, bb: 765}, ...]`),
          //   use <property, type, ordinalMeta> in hash.

          if (willRetrieveDataByName && property != null && // For data stack, we have make sure each series has its own dim on this store.
          // So we do not add property to hash to make sure they can share this store.
          (!seriesDimDef || !seriesDimDef.isCalculationCoord)) {
            dimHash += makeHashStrict // Use escape character '`' in case that property name contains '$'.
              ? property.replace(/\`/g, '`1').replace(/\$/g, '`2') // For better performance, when there are large dimensions, tolerant this defects that hardly meet.
              : property
          }

          dimHash += '$'
          dimHash += dimTypeShort[type] || 'f'

          if (ordinalMeta) {
            dimHash += ordinalMeta.uid
          }

          dimHash += '$'
        } // Source from endpoint(usually series) will be read differently
        // when seriesLayoutBy or startIndex(which is affected by sourceHeader) are different.
        // So we use this three props as key.

        const source = this.source
        const hash = [source.seriesLayoutBy, source.startIndex, dimHash].join('$$')
        return {
          dimensions: dims,
          hash: hash
        }
      }

      SeriesDataSchema.prototype.makeOutputDimensionNames = function () {
        const result = []

        for (let fullDimIdx = 0, seriesDimIdx = 0; fullDimIdx < this._fullDimCount; fullDimIdx++) {
          let name_1 = void 0
          const seriesDimDef = this.dimensions[seriesDimIdx] // The list has been sorted by `storeDimIndex` asc.

          if (seriesDimDef && seriesDimDef.storeDimIndex === fullDimIdx) {
            if (!seriesDimDef.isCalculationCoord) {
              name_1 = seriesDimDef.name
            }

            seriesDimIdx++
          } else {
            const sourceDimDef = this.getSourceDimension(fullDimIdx)

            if (sourceDimDef) {
              name_1 = sourceDimDef.name
            }
          }

          result.push(name_1)
        }

        return result
      }

      SeriesDataSchema.prototype.appendCalculationDimension = function (dimDef) {
        this.dimensions.push(dimDef)
        dimDef.isCalculationCoord = true
        this._fullDimCount++ // If append dimension on a data store, consider the store
        // might be shared by different series, series dimensions not
        // really map to store dimensions.

        this._updateDimOmitted(true)
      }

      return SeriesDataSchema
    }())
  function isSeriesDataSchema (schema) {
    return schema instanceof SeriesDataSchema
  }
  function createDimNameMap (dimsDef) {
    const dataDimNameMap = createHashMap()

    for (let i = 0; i < (dimsDef || []).length; i++) {
      const dimDefItemRaw = dimsDef[i]
      const userDimName = isObject(dimDefItemRaw) ? dimDefItemRaw.name : dimDefItemRaw

      if (userDimName != null && dataDimNameMap.get(userDimName) == null) {
        dataDimNameMap.set(userDimName, i)
      }
    }

    return dataDimNameMap
  }
  function ensureSourceDimNameMap (source) {
    const innerSource = inner$4(source)
    return innerSource.dimNameMap || (innerSource.dimNameMap = createDimNameMap(source.dimensionsDefine))
  }
  function shouldOmitUnusedDimensions (dimCount) {
    return dimCount > 30
  }

  const isObject$2 = isObject
  const map$1 = map
  const CtorInt32Array$1 = typeof Int32Array === 'undefined' ? Array : Int32Array // Use prefix to avoid index to be the same as otherIdList[idx],
  // which will cause weird udpate animation.

  const ID_PREFIX = 'e\0\0'
  const INDEX_NOT_FOUND = -1 // type SeriesDimensionIndex = DimensionIndex;

  const TRANSFERABLE_PROPERTIES = ['hasItemOption', '_nameList', '_idList', '_invertedIndicesMap', '_dimSummary', 'userOutput', '_rawData', '_dimValueGetter', '_nameDimIdx', '_idDimIdx', '_nameRepeatCount']
  const CLONE_PROPERTIES = ['_approximateExtent'] // -----------------------------
  // Internal method declarations:
  // -----------------------------

  let prepareInvertedIndex
  let getId
  let getIdNameFromStore
  let normalizeDimensions
  let transferProperties
  let cloneListForMapAndSample
  let makeIdFromName

  const SeriesData =
    /** @class */
    (function () {
      /**
       * @param dimensionsInput.dimensions
       *        For example, ['someDimName', {name: 'someDimName', type: 'someDimType'}, ...].
       *        Dimensions should be concrete names like x, y, z, lng, lat, angle, radius
       */
      function SeriesData (dimensionsInput, hostModel) {
        this.type = 'list'
        this._dimOmitted = false
        this._nameList = []
        this._idList = [] // Models of data option is stored sparse for optimizing memory cost
        // Never used yet (not used yet).
        // private _optionModels: Model[] = [];
        // Global visual properties after visual coding

        this._visual = {} // Globel layout properties.

        this._layout = {} // Item visual properties after visual coding

        this._itemVisuals = [] // Item layout properties after layout

        this._itemLayouts = [] // Graphic elemnents

        this._graphicEls = [] // key: dim, value: extent

        this._approximateExtent = {}
        this._calculationInfo = {} // Having detected that there is data item is non primitive type
        // (in type `OptionDataItemObject`).
        // Like `data: [ { value: xx, itemStyle: {...} }, ...]`
        // At present it only happen in `SOURCE_FORMAT_ORIGINAL`.

        this.hasItemOption = false // Methods that create a new list based on this list should be listed here.
        // Notice that those method should `RETURN` the new list.

        this.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'lttbDownSample', 'map'] // Methods that change indices of this list should be listed here.

        this.CHANGABLE_METHODS = ['filterSelf', 'selectRange']
        this.DOWNSAMPLE_METHODS = ['downSample', 'lttbDownSample']
        let dimensions
        let assignStoreDimIdx = false

        if (isSeriesDataSchema(dimensionsInput)) {
          dimensions = dimensionsInput.dimensions
          this._dimOmitted = dimensionsInput.isDimensionOmitted()
          this._schema = dimensionsInput
        } else {
          assignStoreDimIdx = true
          dimensions = dimensionsInput
        }

        dimensions = dimensions || ['x', 'y']
        const dimensionInfos = {}
        const dimensionNames = []
        const invertedIndicesMap = {}
        let needsHasOwn = false
        const emptyObj = {}

        for (let i = 0; i < dimensions.length; i++) {
          // Use the original dimensions[i], where other flag props may exists.
          const dimInfoInput = dimensions[i]
          const dimensionInfo = isString(dimInfoInput)
            ? new SeriesDimensionDefine({
              name: dimInfoInput
            })
            : !(dimInfoInput instanceof SeriesDimensionDefine) ? new SeriesDimensionDefine(dimInfoInput) : dimInfoInput
          const dimensionName = dimensionInfo.name
          dimensionInfo.type = dimensionInfo.type || 'float'

          if (!dimensionInfo.coordDim) {
            dimensionInfo.coordDim = dimensionName
            dimensionInfo.coordDimIndex = 0
          }

          const otherDims = dimensionInfo.otherDims = dimensionInfo.otherDims || {}
          dimensionNames.push(dimensionName)
          dimensionInfos[dimensionName] = dimensionInfo

          if (emptyObj[dimensionName] != null) {
            needsHasOwn = true
          }

          if (dimensionInfo.createInvertedIndices) {
            invertedIndicesMap[dimensionName] = []
          }

          if (otherDims.itemName === 0) {
            this._nameDimIdx = i
          }

          if (otherDims.itemId === 0) {
            this._idDimIdx = i
          }

          if ('development' !== 'production') {
            assert(assignStoreDimIdx || dimensionInfo.storeDimIndex >= 0)
          }

          if (assignStoreDimIdx) {
            dimensionInfo.storeDimIndex = i
          }
        }

        this.dimensions = dimensionNames
        this._dimInfos = dimensionInfos

        this._initGetDimensionInfo(needsHasOwn)

        this.hostModel = hostModel
        this._invertedIndicesMap = invertedIndicesMap

        if (this._dimOmitted) {
          const dimIdxToName_1 = this._dimIdxToName = createHashMap()
          each(dimensionNames, function (dimName) {
            dimIdxToName_1.set(dimensionInfos[dimName].storeDimIndex, dimName)
          })
        }
      }
      /**
       *
       * Get concrete dimension name by dimension name or dimension index.
       * If input a dimension name, do not validate whether the dimension name exits.
       *
       * @caution
       * @param dim Must make sure the dimension is `SeriesDimensionLoose`.
       * Because only those dimensions will have auto-generated dimension names if not
       * have a user-specified name, and other dimensions will get a return of null/undefined.
       *
       * @notice Becuause of this reason, should better use `getDimensionIndex` instead, for examples:
       * ```js
       * const val = data.getStore().get(data.getDimensionIndex(dim), dataIdx);
       * ```
       *
       * @return Concrete dim name.
       */

      SeriesData.prototype.getDimension = function (dim) {
        let dimIdx = this._recognizeDimIndex(dim)

        if (dimIdx == null) {
          return dim
        }

        dimIdx = dim

        if (!this._dimOmitted) {
          return this.dimensions[dimIdx]
        } // Retrieve from series dimension definition becuase it probably contains
        // generated dimension name (like 'x', 'y').

        const dimName = this._dimIdxToName.get(dimIdx)

        if (dimName != null) {
          return dimName
        }

        const sourceDimDef = this._schema.getSourceDimension(dimIdx)

        if (sourceDimDef) {
          return sourceDimDef.name
        }
      }
      /**
       * Get dimension index in data store. Return -1 if not found.
       * Can be used to index value from getRawValue.
       */

      SeriesData.prototype.getDimensionIndex = function (dim) {
        const dimIdx = this._recognizeDimIndex(dim)

        if (dimIdx != null) {
          return dimIdx
        }

        if (dim == null) {
          return -1
        }

        const dimInfo = this._getDimInfo(dim)

        return dimInfo ? dimInfo.storeDimIndex : this._dimOmitted ? this._schema.getSourceDimensionIndex(dim) : -1
      }
      /**
       * The meanings of the input parameter `dim`:
       *
       * + If dim is a number (e.g., `1`), it means the index of the dimension.
       *   For example, `getDimension(0)` will return 'x' or 'lng' or 'radius'.
       * + If dim is a number-like string (e.g., `"1"`):
       *     + If there is the same concrete dim name defined in `series.dimensions` or `dataset.dimensions`,
       *        it means that concrete name.
       *     + If not, it will be converted to a number, which means the index of the dimension.
       *        (why? because of the backward compatbility. We have been tolerating number-like string in
       *        dimension setting, although now it seems that it is not a good idea.)
       *     For example, `visualMap[i].dimension: "1"` is the same meaning as `visualMap[i].dimension: 1`,
       *     if no dimension name is defined as `"1"`.
       * + If dim is a not-number-like string, it means the concrete dim name.
       *   For example, it can be be default name `"x"`, `"y"`, `"z"`, `"lng"`, `"lat"`, `"angle"`, `"radius"`,
       *   or customized in `dimensions` property of option like `"age"`.
       *
       * @return recogonized `DimensionIndex`. Otherwise return null/undefined (means that dim is `DimensionName`).
       */

      SeriesData.prototype._recognizeDimIndex = function (dim) {
        if (isNumber(dim) || // If being a number-like string but not being defined as a dimension name.
        dim != null && !isNaN(dim) && !this._getDimInfo(dim) && (!this._dimOmitted || this._schema.getSourceDimensionIndex(dim) < 0)) {
          return +dim
        }
      }

      SeriesData.prototype._getStoreDimIndex = function (dim) {
        const dimIdx = this.getDimensionIndex(dim)

        if ('development' !== 'production') {
          if (dimIdx == null) {
            throw new Error('Unkown dimension ' + dim)
          }
        }

        return dimIdx
      }
      /**
       * Get type and calculation info of particular dimension
       * @param dim
       *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius
       *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'
       */

      SeriesData.prototype.getDimensionInfo = function (dim) {
        // Do not clone, because there may be categories in dimInfo.
        return this._getDimInfo(this.getDimension(dim))
      }

      SeriesData.prototype._initGetDimensionInfo = function (needsHasOwn) {
        const dimensionInfos = this._dimInfos
        this._getDimInfo = needsHasOwn
          ? function (dimName) {
            return dimensionInfos.hasOwnProperty(dimName) ? dimensionInfos[dimName] : undefined
          }
          : function (dimName) {
            return dimensionInfos[dimName]
          }
      }
      /**
       * concrete dimension name list on coord.
       */

      SeriesData.prototype.getDimensionsOnCoord = function () {
        return this._dimSummary.dataDimsOnCoord.slice()
      }

      SeriesData.prototype.mapDimension = function (coordDim, idx) {
        const dimensionsSummary = this._dimSummary

        if (idx == null) {
          return dimensionsSummary.encodeFirstDimNotExtra[coordDim]
        }

        const dims = dimensionsSummary.encode[coordDim]
        return dims ? dims[idx] : null
      }

      SeriesData.prototype.mapDimensionsAll = function (coordDim) {
        const dimensionsSummary = this._dimSummary
        const dims = dimensionsSummary.encode[coordDim]
        return (dims || []).slice()
      }

      SeriesData.prototype.getStore = function () {
        return this._store
      }
      /**
       * Initialize from data
       * @param data source or data or data store.
       * @param nameList The name of a datum is used on data diff and
       *        default label/tooltip.
       *        A name can be specified in encode.itemName,
       *        or dataItem.name (only for series option data),
       *        or provided in nameList from outside.
       */

      SeriesData.prototype.initData = function (data, nameList, dimValueGetter) {
        const _this = this

        let store

        if (data instanceof DataStore) {
          store = data
        }

        if (!store) {
          const dimensions = this.dimensions
          const provider = isSourceInstance(data) || isArrayLike(data) ? new DefaultDataProvider(data, dimensions.length) : data
          store = new DataStore()
          const dimensionInfos = map$1(dimensions, function (dimName) {
            return {
              type: _this._dimInfos[dimName].type,
              property: dimName
            }
          })
          store.initData(provider, dimensionInfos, dimValueGetter)
        }

        this._store = store // Reset

        this._nameList = (nameList || []).slice()
        this._idList = []
        this._nameRepeatCount = {}

        this._doInit(0, store.count()) // Cache summary info for fast visit. See "dimensionHelper".
        // Needs to be initialized after store is prepared.

        this._dimSummary = summarizeDimensions(this, this._schema)
        this.userOutput = this._dimSummary.userOutput
      }
      /**
       * Caution: Can be only called on raw data (before `this._indices` created).
       */

      SeriesData.prototype.appendData = function (data) {
        const range = this._store.appendData(data)

        this._doInit(range[0], range[1])
      }
      /**
       * Caution: Can be only called on raw data (before `this._indices` created).
       * This method does not modify `rawData` (`dataProvider`), but only
       * add values to store.
       *
       * The final count will be increased by `Math.max(values.length, names.length)`.
       *
       * @param values That is the SourceType: 'arrayRows', like
       *        [
       *            [12, 33, 44],
       *            [NaN, 43, 1],
       *            ['-', 'asdf', 0]
       *        ]
       *        Each item is exaclty cooresponding to a dimension.
       */

      SeriesData.prototype.appendValues = function (values, names) {
        const _a = this._store.appendValues(values, names.length)
        const start = _a.start
        const end = _a.end

        const shouldMakeIdFromName = this._shouldMakeIdFromName()

        this._updateOrdinalMeta()

        if (names) {
          for (let idx = start; idx < end; idx++) {
            const sourceIdx = idx - start
            this._nameList[idx] = names[sourceIdx]

            if (shouldMakeIdFromName) {
              makeIdFromName(this, idx)
            }
          }
        }
      }

      SeriesData.prototype._updateOrdinalMeta = function () {
        const store = this._store
        const dimensions = this.dimensions

        for (let i = 0; i < dimensions.length; i++) {
          const dimInfo = this._dimInfos[dimensions[i]]

          if (dimInfo.ordinalMeta) {
            store.collectOrdinalMeta(dimInfo.storeDimIndex, dimInfo.ordinalMeta)
          }
        }
      }

      SeriesData.prototype._shouldMakeIdFromName = function () {
        const provider = this._store.getProvider()

        return this._idDimIdx == null && provider.getSource().sourceFormat !== SOURCE_FORMAT_TYPED_ARRAY && !provider.fillStorage
      }

      SeriesData.prototype._doInit = function (start, end) {
        if (start >= end) {
          return
        }

        const store = this._store
        const provider = store.getProvider()

        this._updateOrdinalMeta()

        const nameList = this._nameList
        const idList = this._idList
        const sourceFormat = provider.getSource().sourceFormat
        const isFormatOriginal = sourceFormat === SOURCE_FORMAT_ORIGINAL // Each data item is value
        // [1, 2]
        // 2
        // Bar chart, line chart which uses category axis
        // only gives the 'y' value. 'x' value is the indices of category
        // Use a tempValue to normalize the value to be a (x, y) value
        // If dataItem is {name: ...} or {id: ...}, it has highest priority.
        // This kind of ids and names are always stored `_nameList` and `_idList`.

        if (isFormatOriginal && !provider.pure) {
          const sharedDataItem = []

          for (var idx = start; idx < end; idx++) {
            // NOTICE: Try not to write things into dataItem
            const dataItem = provider.getItem(idx, sharedDataItem)

            if (!this.hasItemOption && isDataItemOption(dataItem)) {
              this.hasItemOption = true
            }

            if (dataItem) {
              const itemName = dataItem.name

              if (nameList[idx] == null && itemName != null) {
                nameList[idx] = convertOptionIdName(itemName, null)
              }

              const itemId = dataItem.id

              if (idList[idx] == null && itemId != null) {
                idList[idx] = convertOptionIdName(itemId, null)
              }
            }
          }
        }

        if (this._shouldMakeIdFromName()) {
          for (var idx = start; idx < end; idx++) {
            makeIdFromName(this, idx)
          }
        }

        prepareInvertedIndex(this)
      }
      /**
       * PENDING: In fact currently this function is only used to short-circuit
       * the calling of `scale.unionExtentFromData` when data have been filtered by modules
       * like "dataZoom". `scale.unionExtentFromData` is used to calculate data extent for series on
       * an axis, but if a "axis related data filter module" is used, the extent of the axis have
       * been fixed and no need to calling `scale.unionExtentFromData` actually.
       * But if we add "custom data filter" in future, which is not "axis related", this method may
       * be still needed.
       *
       * Optimize for the scenario that data is filtered by a given extent.
       * Consider that if data amount is more than hundreds of thousand,
       * extent calculation will cost more than 10ms and the cache will
       * be erased because of the filtering.
       */

      SeriesData.prototype.getApproximateExtent = function (dim) {
        return this._approximateExtent[dim] || this._store.getDataExtent(this._getStoreDimIndex(dim))
      }
      /**
       * Calculate extent on a filtered data might be time consuming.
       * Approximate extent is only used for: calculte extent of filtered data outside.
       */

      SeriesData.prototype.setApproximateExtent = function (extent, dim) {
        dim = this.getDimension(dim)
        this._approximateExtent[dim] = extent.slice()
      }

      SeriesData.prototype.getCalculationInfo = function (key) {
        return this._calculationInfo[key]
      }

      SeriesData.prototype.setCalculationInfo = function (key, value) {
        isObject$2(key) ? extend(this._calculationInfo, key) : this._calculationInfo[key] = value
      }
      /**
       * @return Never be null/undefined. `number` will be converted to string. Becuase:
       * In most cases, name is used in display, where returning a string is more convenient.
       * In other cases, name is used in query (see `indexOfName`), where we can keep the
       * rule that name `2` equals to name `'2'`.
       */

      SeriesData.prototype.getName = function (idx) {
        const rawIndex = this.getRawIndex(idx)
        let name = this._nameList[rawIndex]

        if (name == null && this._nameDimIdx != null) {
          name = getIdNameFromStore(this, this._nameDimIdx, rawIndex)
        }

        if (name == null) {
          name = ''
        }

        return name
      }

      SeriesData.prototype._getCategory = function (dimIdx, idx) {
        const ordinal = this._store.get(dimIdx, idx)

        const ordinalMeta = this._store.getOrdinalMeta(dimIdx)

        if (ordinalMeta) {
          return ordinalMeta.categories[ordinal]
        }

        return ordinal
      }
      /**
       * @return Never null/undefined. `number` will be converted to string. Becuase:
       * In all cases having encountered at present, id is used in making diff comparison, which
       * are usually based on hash map. We can keep the rule that the internal id are always string
       * (treat `2` is the same as `'2'`) to make the related logic simple.
       */

      SeriesData.prototype.getId = function (idx) {
        return getId(this, this.getRawIndex(idx))
      }

      SeriesData.prototype.count = function () {
        return this._store.count()
      }
      /**
       * Get value. Return NaN if idx is out of range.
       *
       * @notice Should better to use `data.getStore().get(dimIndex, dataIdx)` instead.
       */

      SeriesData.prototype.get = function (dim, idx) {
        const store = this._store
        const dimInfo = this._dimInfos[dim]

        if (dimInfo) {
          return store.get(dimInfo.storeDimIndex, idx)
        }
      }
      /**
       * @notice Should better to use `data.getStore().getByRawIndex(dimIndex, dataIdx)` instead.
       */

      SeriesData.prototype.getByRawIndex = function (dim, rawIdx) {
        const store = this._store
        const dimInfo = this._dimInfos[dim]

        if (dimInfo) {
          return store.getByRawIndex(dimInfo.storeDimIndex, rawIdx)
        }
      }

      SeriesData.prototype.getIndices = function () {
        return this._store.getIndices()
      }

      SeriesData.prototype.getDataExtent = function (dim) {
        return this._store.getDataExtent(this._getStoreDimIndex(dim))
      }

      SeriesData.prototype.getSum = function (dim) {
        return this._store.getSum(this._getStoreDimIndex(dim))
      }

      SeriesData.prototype.getMedian = function (dim) {
        return this._store.getMedian(this._getStoreDimIndex(dim))
      }

      SeriesData.prototype.getValues = function (dimensions, idx) {
        const _this = this

        const store = this._store
        return isArray(dimensions)
          ? store.getValues(map$1(dimensions, function (dim) {
            return _this._getStoreDimIndex(dim)
          }), idx)
          : store.getValues(dimensions)
      }
      /**
       * If value is NaN. Inlcuding '-'
       * Only check the coord dimensions.
       */

      SeriesData.prototype.hasValue = function (idx) {
        const dataDimIndicesOnCoord = this._dimSummary.dataDimIndicesOnCoord

        for (let i = 0, len = dataDimIndicesOnCoord.length; i < len; i++) {
          // Ordinal type originally can be string or number.
          // But when an ordinal type is used on coord, it can
          // not be string but only number. So we can also use isNaN.
          if (isNaN(this._store.get(dataDimIndicesOnCoord[i], idx))) {
            return false
          }
        }

        return true
      }
      /**
       * Retreive the index with given name
       */

      SeriesData.prototype.indexOfName = function (name) {
        for (let i = 0, len = this._store.count(); i < len; i++) {
          if (this.getName(i) === name) {
            return i
          }
        }

        return -1
      }

      SeriesData.prototype.getRawIndex = function (idx) {
        return this._store.getRawIndex(idx)
      }

      SeriesData.prototype.indexOfRawIndex = function (rawIndex) {
        return this._store.indexOfRawIndex(rawIndex)
      }
      /**
       * Only support the dimension which inverted index created.
       * Do not support other cases until required.
       * @param dim concrete dim
       * @param value ordinal index
       * @return rawIndex
       */

      SeriesData.prototype.rawIndexOf = function (dim, value) {
        const invertedIndices = dim && this._invertedIndicesMap[dim]

        if ('development' !== 'production') {
          if (!invertedIndices) {
            throw new Error('Do not supported yet')
          }
        }

        const rawIndex = invertedIndices[value]

        if (rawIndex == null || isNaN(rawIndex)) {
          return INDEX_NOT_FOUND
        }

        return rawIndex
      }
      /**
       * Retreive the index of nearest value
       * @param dim
       * @param value
       * @param [maxDistance=Infinity]
       * @return If and only if multiple indices has
       *         the same value, they are put to the result.
       */

      SeriesData.prototype.indicesOfNearest = function (dim, value, maxDistance) {
        return this._store.indicesOfNearest(this._getStoreDimIndex(dim), value, maxDistance)
      }

      SeriesData.prototype.each = function (dims, cb, ctx) {
        if (isFunction(dims)) {
          ctx = cb
          cb = dims
          dims = []
        } // ctxCompat just for compat echarts3

        const fCtx = ctx || this
        const dimIndices = map$1(normalizeDimensions(dims), this._getStoreDimIndex, this)

        this._store.each(dimIndices, fCtx ? bind(cb, fCtx) : cb)
      }

      SeriesData.prototype.filterSelf = function (dims, cb, ctx) {
        if (isFunction(dims)) {
          ctx = cb
          cb = dims
          dims = []
        } // ctxCompat just for compat echarts3

        const fCtx = ctx || this
        const dimIndices = map$1(normalizeDimensions(dims), this._getStoreDimIndex, this)
        this._store = this._store.filter(dimIndices, fCtx ? bind(cb, fCtx) : cb)
        return this
      }
      /**
       * Select data in range. (For optimization of filter)
       * (Manually inline code, support 5 million data filtering in data zoom.)
       */

      SeriesData.prototype.selectRange = function (range) {
        const _this = this

        const innerRange = {}
        const dims = keys(range)
        each(dims, function (dim) {
          const dimIdx = _this._getStoreDimIndex(dim)

          innerRange[dimIdx] = range[dim]
        })
        this._store = this._store.selectRange(innerRange)
        return this
      }
      /* eslint-enable max-len */

      SeriesData.prototype.mapArray = function (dims, cb, ctx) {
        if (isFunction(dims)) {
          ctx = cb
          cb = dims
          dims = []
        } // ctxCompat just for compat echarts3

        ctx = ctx || this
        const result = []
        this.each(dims, function () {
          result.push(cb && cb.apply(this, arguments))
        }, ctx)
        return result
      }

      SeriesData.prototype.map = function (dims, cb, ctx, ctxCompat) {
        const fCtx = ctx || ctxCompat || this
        const dimIndices = map$1(normalizeDimensions(dims), this._getStoreDimIndex, this)
        const list = cloneListForMapAndSample(this)
        list._store = this._store.map(dimIndices, fCtx ? bind(cb, fCtx) : cb)
        return list
      }

      SeriesData.prototype.modify = function (dims, cb, ctx, ctxCompat) {
        const _this = this // ctxCompat just for compat echarts3

        const fCtx = ctx || ctxCompat || this

        if ('development' !== 'production') {
          each(normalizeDimensions(dims), function (dim) {
            const dimInfo = _this.getDimensionInfo(dim)

            if (!dimInfo.isCalculationCoord) {
              console.error('Danger: only stack dimension can be modified')
            }
          })
        }

        const dimIndices = map$1(normalizeDimensions(dims), this._getStoreDimIndex, this) // If do shallow clone here, if there are too many stacked series,
        // it still cost lots of memory, becuase `_store.dimensions` are not shared.
        // We should consider there probably be shallow clone happen in each sereis
        // in consequent filter/map.

        this._store.modify(dimIndices, fCtx ? bind(cb, fCtx) : cb)
      }
      /**
       * Large data down sampling on given dimension
       * @param sampleIndex Sample index for name and id
       */

      SeriesData.prototype.downSample = function (dimension, rate, sampleValue, sampleIndex) {
        const list = cloneListForMapAndSample(this)
        list._store = this._store.downSample(this._getStoreDimIndex(dimension), rate, sampleValue, sampleIndex)
        return list
      }
      /**
       * Large data down sampling using largest-triangle-three-buckets
       * @param {string} valueDimension
       * @param {number} targetCount
       */

      SeriesData.prototype.lttbDownSample = function (valueDimension, rate) {
        const list = cloneListForMapAndSample(this)
        list._store = this._store.lttbDownSample(this._getStoreDimIndex(valueDimension), rate)
        return list
      }

      SeriesData.prototype.getRawDataItem = function (idx) {
        return this._store.getRawDataItem(idx)
      }
      /**
       * Get model of one data item.
       */
      // TODO: Type of data item

      SeriesData.prototype.getItemModel = function (idx) {
        const hostModel = this.hostModel
        const dataItem = this.getRawDataItem(idx)
        return new Model(dataItem, hostModel, hostModel && hostModel.ecModel)
      }
      /**
       * Create a data differ
       */

      SeriesData.prototype.diff = function (otherList) {
        const thisList = this
        return new DataDiffer(otherList ? otherList.getStore().getIndices() : [], this.getStore().getIndices(), function (idx) {
          return getId(otherList, idx)
        }, function (idx) {
          return getId(thisList, idx)
        })
      }
      /**
       * Get visual property.
       */

      SeriesData.prototype.getVisual = function (key) {
        const visual = this._visual
        return visual && visual[key]
      }

      SeriesData.prototype.setVisual = function (kvObj, val) {
        this._visual = this._visual || {}

        if (isObject$2(kvObj)) {
          extend(this._visual, kvObj)
        } else {
          this._visual[kvObj] = val
        }
      }
      /**
       * Get visual property of single data item
       */
      // eslint-disable-next-line

      SeriesData.prototype.getItemVisual = function (idx, key) {
        const itemVisual = this._itemVisuals[idx]
        const val = itemVisual && itemVisual[key]

        if (val == null) {
          // Use global visual property
          return this.getVisual(key)
        }

        return val
      }
      /**
       * If exists visual property of single data item
       */

      SeriesData.prototype.hasItemVisual = function () {
        return this._itemVisuals.length > 0
      }
      /**
       * Make sure itemVisual property is unique
       */
      // TODO: use key to save visual to reduce memory.

      SeriesData.prototype.ensureUniqueItemVisual = function (idx, key) {
        const itemVisuals = this._itemVisuals
        let itemVisual = itemVisuals[idx]

        if (!itemVisual) {
          itemVisual = itemVisuals[idx] = {}
        }

        let val = itemVisual[key]

        if (val == null) {
          val = this.getVisual(key) // TODO Performance?

          if (isArray(val)) {
            val = val.slice()
          } else if (isObject$2(val)) {
            val = extend({}, val)
          }

          itemVisual[key] = val
        }

        return val
      } // eslint-disable-next-line

      SeriesData.prototype.setItemVisual = function (idx, key, value) {
        const itemVisual = this._itemVisuals[idx] || {}
        this._itemVisuals[idx] = itemVisual

        if (isObject$2(key)) {
          extend(itemVisual, key)
        } else {
          itemVisual[key] = value
        }
      }
      /**
       * Clear itemVisuals and list visual.
       */

      SeriesData.prototype.clearAllVisual = function () {
        this._visual = {}
        this._itemVisuals = []
      }

      SeriesData.prototype.setLayout = function (key, val) {
        isObject$2(key) ? extend(this._layout, key) : this._layout[key] = val
      }
      /**
       * Get layout property.
       */

      SeriesData.prototype.getLayout = function (key) {
        return this._layout[key]
      }
      /**
       * Get layout of single data item
       */

      SeriesData.prototype.getItemLayout = function (idx) {
        return this._itemLayouts[idx]
      }
      /**
       * Set layout of single data item
       */

      SeriesData.prototype.setItemLayout = function (idx, layout, merge) {
        this._itemLayouts[idx] = merge ? extend(this._itemLayouts[idx] || {}, layout) : layout
      }
      /**
       * Clear all layout of single data item
       */

      SeriesData.prototype.clearItemLayouts = function () {
        this._itemLayouts.length = 0
      }
      /**
       * Set graphic element relative to data. It can be set as null
       */

      SeriesData.prototype.setItemGraphicEl = function (idx, el) {
        const seriesIndex = this.hostModel && this.hostModel.seriesIndex
        setCommonECData(seriesIndex, this.dataType, idx, el)
        this._graphicEls[idx] = el
      }

      SeriesData.prototype.getItemGraphicEl = function (idx) {
        return this._graphicEls[idx]
      }

      SeriesData.prototype.eachItemGraphicEl = function (cb, context) {
        each(this._graphicEls, function (el, idx) {
          if (el) {
            cb && cb.call(context, el, idx)
          }
        })
      }
      /**
       * Shallow clone a new list except visual and layout properties, and graph elements.
       * New list only change the indices.
       */

      SeriesData.prototype.cloneShallow = function (list) {
        if (!list) {
          list = new SeriesData(this._schema ? this._schema : map$1(this.dimensions, this._getDimInfo, this), this.hostModel)
        }

        transferProperties(list, this)
        list._store = this._store
        return list
      }
      /**
       * Wrap some method to add more feature
       */

      SeriesData.prototype.wrapMethod = function (methodName, injectFunction) {
        const originalMethod = this[methodName]

        if (!isFunction(originalMethod)) {
          return
        }

        this.__wrappedMethods = this.__wrappedMethods || []

        this.__wrappedMethods.push(methodName)

        this[methodName] = function () {
          const res = originalMethod.apply(this, arguments)
          return injectFunction.apply(this, [res].concat(slice(arguments)))
        }
      } // ----------------------------------------------------------
      // A work around for internal method visiting private member.
      // ----------------------------------------------------------

      SeriesData.internalField = (function () {
        prepareInvertedIndex = function (data) {
          const invertedIndicesMap = data._invertedIndicesMap
          each(invertedIndicesMap, function (invertedIndices, dim) {
            const dimInfo = data._dimInfos[dim] // Currently, only dimensions that has ordinalMeta can create inverted indices.

            const ordinalMeta = dimInfo.ordinalMeta
            const store = data._store

            if (ordinalMeta) {
              invertedIndices = invertedIndicesMap[dim] = new CtorInt32Array$1(ordinalMeta.categories.length) // The default value of TypedArray is 0. To avoid miss
              // mapping to 0, we should set it as INDEX_NOT_FOUND.

              for (var i = 0; i < invertedIndices.length; i++) {
                invertedIndices[i] = INDEX_NOT_FOUND
              }

              for (var i = 0; i < store.count(); i++) {
                // Only support the case that all values are distinct.
                invertedIndices[store.get(dimInfo.storeDimIndex, i)] = i
              }
            }
          })
        }

        getIdNameFromStore = function (data, dimIdx, idx) {
          return convertOptionIdName(data._getCategory(dimIdx, idx), null)
        }
        /**
         * @see the comment of `List['getId']`.
         */

        getId = function (data, rawIndex) {
          let id = data._idList[rawIndex]

          if (id == null && data._idDimIdx != null) {
            id = getIdNameFromStore(data, data._idDimIdx, rawIndex)
          }

          if (id == null) {
            id = ID_PREFIX + rawIndex
          }

          return id
        }

        normalizeDimensions = function (dimensions) {
          if (!isArray(dimensions)) {
            dimensions = dimensions != null ? [dimensions] : []
          }

          return dimensions
        }
        /**
         * Data in excludeDimensions is copied, otherwise transfered.
         */

        cloneListForMapAndSample = function (original) {
          const list = new SeriesData(original._schema ? original._schema : map$1(original.dimensions, original._getDimInfo, original), original.hostModel) // FIXME If needs stackedOn, value may already been stacked

          transferProperties(list, original)
          return list
        }

        transferProperties = function (target, source) {
          each(TRANSFERABLE_PROPERTIES.concat(source.__wrappedMethods || []), function (propName) {
            if (source.hasOwnProperty(propName)) {
              target[propName] = source[propName]
            }
          })
          target.__wrappedMethods = source.__wrappedMethods
          each(CLONE_PROPERTIES, function (propName) {
            target[propName] = clone(source[propName])
          })
          target._calculationInfo = extend({}, source._calculationInfo)
        }

        makeIdFromName = function (data, idx) {
          const nameList = data._nameList
          const idList = data._idList
          const nameDimIdx = data._nameDimIdx
          const idDimIdx = data._idDimIdx
          let name = nameList[idx]
          let id = idList[idx]

          if (name == null && nameDimIdx != null) {
            nameList[idx] = name = getIdNameFromStore(data, nameDimIdx, idx)
          }

          if (id == null && idDimIdx != null) {
            idList[idx] = id = getIdNameFromStore(data, idDimIdx, idx)
          }

          if (id == null && name != null) {
            const nameRepeatCount = data._nameRepeatCount
            const nmCnt = nameRepeatCount[name] = (nameRepeatCount[name] || 0) + 1
            id = name

            if (nmCnt > 1) {
              id += '__ec__' + nmCnt
            }

            idList[idx] = id
          }
        }
      }())

      return SeriesData
    }())

  /**
     * For outside usage compat (like echarts-gl are using it).
     */

  function createDimensions (source, opt) {
    return prepareSeriesDataSchema(source, opt).dimensions
  }
  /**
     * This method builds the relationship between:
     * + "what the coord sys or series requires (see `coordDimensions`)",
     * + "what the user defines (in `encode` and `dimensions`, see `opt.dimensionsDefine` and `opt.encodeDefine`)"
     * + "what the data source provids (see `source`)".
     *
     * Some guess strategy will be adapted if user does not define something.
     * If no 'value' dimension specified, the first no-named dimension will be
     * named as 'value'.
     *
     * @return The results are always sorted by `storeDimIndex` asc.
     */

  function prepareSeriesDataSchema ( // TODO: TYPE completeDimensions type
    source, opt) {
    if (!isSourceInstance(source)) {
      source = createSourceFromSeriesDataOption(source)
    }

    opt = opt || {}
    const sysDims = opt.coordDimensions || []
    const dimsDef = opt.dimensionsDefine || source.dimensionsDefine || []
    const coordDimNameMap = createHashMap()
    const resultList = []
    const dimCount = getDimCount(source, sysDims, dimsDef, opt.dimensionsCount) // Try to ignore unsed dimensions if sharing a high dimension datastore
    // 30 is an experience value.

    const omitUnusedDimensions = opt.canOmitUnusedDimensions && shouldOmitUnusedDimensions(dimCount)
    const isUsingSourceDimensionsDef = dimsDef === source.dimensionsDefine
    const dataDimNameMap = isUsingSourceDimensionsDef ? ensureSourceDimNameMap(source) : createDimNameMap(dimsDef)
    let encodeDef = opt.encodeDefine

    if (!encodeDef && opt.encodeDefaulter) {
      encodeDef = opt.encodeDefaulter(source, dimCount)
    }

    const encodeDefMap = createHashMap(encodeDef)
    const indicesMap = new CtorInt32Array(dimCount)

    for (var i = 0; i < indicesMap.length; i++) {
      indicesMap[i] = -1
    }

    function getResultItem (dimIdx) {
      const idx = indicesMap[dimIdx]

      if (idx < 0) {
        const dimDefItemRaw = dimsDef[dimIdx]
        const dimDefItem = isObject(dimDefItemRaw)
          ? dimDefItemRaw
          : {
              name: dimDefItemRaw
            }
        const resultItem = new SeriesDimensionDefine()
        const userDimName = dimDefItem.name

        if (userDimName != null && dataDimNameMap.get(userDimName) != null) {
          // Only if `series.dimensions` is defined in option
          // displayName, will be set, and dimension will be diplayed vertically in
          // tooltip by default.
          resultItem.name = resultItem.displayName = userDimName
        }

        dimDefItem.type != null && (resultItem.type = dimDefItem.type)
        dimDefItem.displayName != null && (resultItem.displayName = dimDefItem.displayName)
        const newIdx = resultList.length
        indicesMap[dimIdx] = newIdx
        resultItem.storeDimIndex = dimIdx
        resultList.push(resultItem)
        return resultItem
      }

      return resultList[idx]
    }

    if (!omitUnusedDimensions) {
      for (var i = 0; i < dimCount; i++) {
        getResultItem(i)
      }
    } // Set `coordDim` and `coordDimIndex` by `encodeDefMap` and normalize `encodeDefMap`.

    encodeDefMap.each(function (dataDimsRaw, coordDim) {
      const dataDims = normalizeToArray(dataDimsRaw).slice() // Note: It is allowed that `dataDims.length` is `0`, e.g., options is
      // `{encode: {x: -1, y: 1}}`. Should not filter anything in
      // this case.

      if (dataDims.length === 1 && !isString(dataDims[0]) && dataDims[0] < 0) {
        encodeDefMap.set(coordDim, false)
        return
      }

      const validDataDims = encodeDefMap.set(coordDim, [])
      each(dataDims, function (resultDimIdxOrName, idx) {
        // The input resultDimIdx can be dim name or index.
        const resultDimIdx = isString(resultDimIdxOrName) ? dataDimNameMap.get(resultDimIdxOrName) : resultDimIdxOrName

        if (resultDimIdx != null && resultDimIdx < dimCount) {
          validDataDims[idx] = resultDimIdx
          applyDim(getResultItem(resultDimIdx), coordDim, idx)
        }
      })
    }) // Apply templetes and default order from `sysDims`.

    let availDimIdx = 0
    each(sysDims, function (sysDimItemRaw) {
      let coordDim
      let sysDimItemDimsDef
      let sysDimItemOtherDims
      let sysDimItem

      if (isString(sysDimItemRaw)) {
        coordDim = sysDimItemRaw
        sysDimItem = {}
      } else {
        sysDimItem = sysDimItemRaw
        coordDim = sysDimItem.name
        const ordinalMeta = sysDimItem.ordinalMeta
        sysDimItem.ordinalMeta = null
        sysDimItem = extend({}, sysDimItem)
        sysDimItem.ordinalMeta = ordinalMeta // `coordDimIndex` should not be set directly.

        sysDimItemDimsDef = sysDimItem.dimsDef
        sysDimItemOtherDims = sysDimItem.otherDims
        sysDimItem.name = sysDimItem.coordDim = sysDimItem.coordDimIndex = sysDimItem.dimsDef = sysDimItem.otherDims = null
      }

      let dataDims = encodeDefMap.get(coordDim) // negative resultDimIdx means no need to mapping.

      if (dataDims === false) {
        return
      }

      dataDims = normalizeToArray(dataDims) // dimensions provides default dim sequences.

      if (!dataDims.length) {
        for (let i = 0; i < (sysDimItemDimsDef && sysDimItemDimsDef.length || 1); i++) {
          while (availDimIdx < dimCount && getResultItem(availDimIdx).coordDim != null) {
            availDimIdx++
          }

          availDimIdx < dimCount && dataDims.push(availDimIdx++)
        }
      } // Apply templates.

      each(dataDims, function (resultDimIdx, coordDimIndex) {
        const resultItem = getResultItem(resultDimIdx) // Coordinate system has a higher priority on dim type than source.

        if (isUsingSourceDimensionsDef && sysDimItem.type != null) {
          resultItem.type = sysDimItem.type
        }

        applyDim(defaults(resultItem, sysDimItem), coordDim, coordDimIndex)

        if (resultItem.name == null && sysDimItemDimsDef) {
          let sysDimItemDimsDefItem = sysDimItemDimsDef[coordDimIndex]
          !isObject(sysDimItemDimsDefItem) && (sysDimItemDimsDefItem = {
            name: sysDimItemDimsDefItem
          })
          resultItem.name = resultItem.displayName = sysDimItemDimsDefItem.name
          resultItem.defaultTooltip = sysDimItemDimsDefItem.defaultTooltip
        } // FIXME refactor, currently only used in case: {otherDims: {tooltip: false}}

        sysDimItemOtherDims && defaults(resultItem.otherDims, sysDimItemOtherDims)
      })
    })

    function applyDim (resultItem, coordDim, coordDimIndex) {
      if (VISUAL_DIMENSIONS.get(coordDim) != null) {
        resultItem.otherDims[coordDim] = coordDimIndex
      } else {
        resultItem.coordDim = coordDim
        resultItem.coordDimIndex = coordDimIndex
        coordDimNameMap.set(coordDim, true)
      }
    } // Make sure the first extra dim is 'value'.

    const generateCoord = opt.generateCoord
    let generateCoordCount = opt.generateCoordCount
    const fromZero = generateCoordCount != null
    generateCoordCount = generateCoord ? generateCoordCount || 1 : 0
    const extra = generateCoord || 'value'

    function ifNoNameFillWithCoordName (resultItem) {
      if (resultItem.name == null) {
        // Duplication will be removed in the next step.
        resultItem.name = resultItem.coordDim
      }
    } // Set dim `name` and other `coordDim` and other props.

    if (!omitUnusedDimensions) {
      for (let resultDimIdx = 0; resultDimIdx < dimCount; resultDimIdx++) {
        const resultItem = getResultItem(resultDimIdx)
        const coordDim = resultItem.coordDim

        if (coordDim == null) {
          // TODO no need to generate coordDim for isExtraCoord?
          resultItem.coordDim = genCoordDimName(extra, coordDimNameMap, fromZero)
          resultItem.coordDimIndex = 0 // Series specified generateCoord is using out.

          if (!generateCoord || generateCoordCount <= 0) {
            resultItem.isExtraCoord = true
          }

          generateCoordCount--
        }

        ifNoNameFillWithCoordName(resultItem)

        if (resultItem.type == null && (guessOrdinal(source, resultDimIdx) === BE_ORDINAL.Must || // Consider the case:
          // {
          //    dataset: {source: [
          //        ['2001', 123],
          //        ['2002', 456],
          //        ...
          //        ['The others', 987],
          //    ]},
          //    series: {type: 'pie'}
          // }
          // The first colum should better be treated as a "ordinal" although it
          // might not able to be detected as an "ordinal" by `guessOrdinal`.
          resultItem.isExtraCoord && (resultItem.otherDims.itemName != null || resultItem.otherDims.seriesName != null))) {
          resultItem.type = 'ordinal'
        }
      }
    } else {
      each(resultList, function (resultItem) {
        // PENDING: guessOrdinal or let user specify type: 'ordinal' manually?
        ifNoNameFillWithCoordName(resultItem)
      }) // Sort dimensions: there are some rule that use the last dim as label,
      // and for some latter travel process easier.

      resultList.sort(function (item0, item1) {
        return item0.storeDimIndex - item1.storeDimIndex
      })
    }

    removeDuplication(resultList)
    return new SeriesDataSchema({
      source: source,
      dimensions: resultList,
      fullDimensionCount: dimCount,
      dimensionOmitted: omitUnusedDimensions
    })
  }

  function removeDuplication (result) {
    const duplicationMap = createHashMap()

    for (let i = 0; i < result.length; i++) {
      const dim = result[i]
      const dimOriginalName = dim.name
      let count = duplicationMap.get(dimOriginalName) || 0

      if (count > 0) {
        // Starts from 0.
        dim.name = dimOriginalName + (count - 1)
      }

      count++
      duplicationMap.set(dimOriginalName, count)
    }
  } // ??? TODO
  // Originally detect dimCount by data[0]. Should we
  // optimize it to only by sysDims and dimensions and encode.
  // So only necessary dims will be initialized.
  // But
  // (1) custom series should be considered. where other dims
  // may be visited.
  // (2) sometimes user need to calcualte bubble size or use visualMap
  // on other dimensions besides coordSys needed.
  // So, dims that is not used by system, should be shared in data store?

  function getDimCount (source, sysDims, dimsDef, optDimCount) {
    // Note that the result dimCount should not small than columns count
    // of data, otherwise `dataDimNameMap` checking will be incorrect.
    let dimCount = Math.max(source.dimensionsDetectedCount || 1, sysDims.length, dimsDef.length, optDimCount || 0)
    each(sysDims, function (sysDimItem) {
      let sysDimItemDimsDef

      if (isObject(sysDimItem) && (sysDimItemDimsDef = sysDimItem.dimsDef)) {
        dimCount = Math.max(dimCount, sysDimItemDimsDef.length)
      }
    })
    return dimCount
  }

  function genCoordDimName (name, map, fromZero) {
    const mapData = map.data

    if (fromZero || mapData.hasOwnProperty(name)) {
      let i = 0

      while (mapData.hasOwnProperty(name + i)) {
        i++
      }

      name += i
    }

    map.set(name, true)
    return name
  }

  /**
     * @class
     * For example:
     * {
     *     coordSysName: 'cartesian2d',
     *     coordSysDims: ['x', 'y', ...],
     *     axisMap: HashMap({
     *         x: xAxisModel,
     *         y: yAxisModel
     *     }),
     *     categoryAxisMap: HashMap({
     *         x: xAxisModel,
     *         y: undefined
     *     }),
     *     // The index of the first category axis in `coordSysDims`.
     *     // `null/undefined` means no category axis exists.
     *     firstCategoryDimIndex: 1,
     *     // To replace user specified encode.
     * }
     */

  const CoordSysInfo =
    /** @class */
    (function () {
      function CoordSysInfo (coordSysName) {
        this.coordSysDims = []
        this.axisMap = createHashMap()
        this.categoryAxisMap = createHashMap()
        this.coordSysName = coordSysName
      }

      return CoordSysInfo
    }())

  function getCoordSysInfoBySeries (seriesModel) {
    const coordSysName = seriesModel.get('coordinateSystem')
    const result = new CoordSysInfo(coordSysName)
    const fetch = fetchers[coordSysName]

    if (fetch) {
      fetch(seriesModel, result, result.axisMap, result.categoryAxisMap)
      return result
    }
  }
  var fetchers = {
    cartesian2d: function (seriesModel, result, axisMap, categoryAxisMap) {
      const xAxisModel = seriesModel.getReferringComponents('xAxis', SINGLE_REFERRING).models[0]
      const yAxisModel = seriesModel.getReferringComponents('yAxis', SINGLE_REFERRING).models[0]

      if ('development' !== 'production') {
        if (!xAxisModel) {
          throw new Error('xAxis "' + retrieve(seriesModel.get('xAxisIndex'), seriesModel.get('xAxisId'), 0) + '" not found')
        }

        if (!yAxisModel) {
          throw new Error('yAxis "' + retrieve(seriesModel.get('xAxisIndex'), seriesModel.get('yAxisId'), 0) + '" not found')
        }
      }

      result.coordSysDims = ['x', 'y']
      axisMap.set('x', xAxisModel)
      axisMap.set('y', yAxisModel)

      if (isCategory(xAxisModel)) {
        categoryAxisMap.set('x', xAxisModel)
        result.firstCategoryDimIndex = 0
      }

      if (isCategory(yAxisModel)) {
        categoryAxisMap.set('y', yAxisModel)
        result.firstCategoryDimIndex == null && (result.firstCategoryDimIndex = 1)
      }
    },
    singleAxis: function (seriesModel, result, axisMap, categoryAxisMap) {
      const singleAxisModel = seriesModel.getReferringComponents('singleAxis', SINGLE_REFERRING).models[0]

      if ('development' !== 'production') {
        if (!singleAxisModel) {
          throw new Error('singleAxis should be specified.')
        }
      }

      result.coordSysDims = ['single']
      axisMap.set('single', singleAxisModel)

      if (isCategory(singleAxisModel)) {
        categoryAxisMap.set('single', singleAxisModel)
        result.firstCategoryDimIndex = 0
      }
    },
    polar: function (seriesModel, result, axisMap, categoryAxisMap) {
      const polarModel = seriesModel.getReferringComponents('polar', SINGLE_REFERRING).models[0]
      const radiusAxisModel = polarModel.findAxisModel('radiusAxis')
      const angleAxisModel = polarModel.findAxisModel('angleAxis')

      if ('development' !== 'production') {
        if (!angleAxisModel) {
          throw new Error('angleAxis option not found')
        }

        if (!radiusAxisModel) {
          throw new Error('radiusAxis option not found')
        }
      }

      result.coordSysDims = ['radius', 'angle']
      axisMap.set('radius', radiusAxisModel)
      axisMap.set('angle', angleAxisModel)

      if (isCategory(radiusAxisModel)) {
        categoryAxisMap.set('radius', radiusAxisModel)
        result.firstCategoryDimIndex = 0
      }

      if (isCategory(angleAxisModel)) {
        categoryAxisMap.set('angle', angleAxisModel)
        result.firstCategoryDimIndex == null && (result.firstCategoryDimIndex = 1)
      }
    },
    geo: function (seriesModel, result, axisMap, categoryAxisMap) {
      result.coordSysDims = ['lng', 'lat']
    },
    parallel: function (seriesModel, result, axisMap, categoryAxisMap) {
      const ecModel = seriesModel.ecModel
      const parallelModel = ecModel.getComponent('parallel', seriesModel.get('parallelIndex'))
      const coordSysDims = result.coordSysDims = parallelModel.dimensions.slice()
      each(parallelModel.parallelAxisIndex, function (axisIndex, index) {
        const axisModel = ecModel.getComponent('parallelAxis', axisIndex)
        const axisDim = coordSysDims[index]
        axisMap.set(axisDim, axisModel)

        if (isCategory(axisModel)) {
          categoryAxisMap.set(axisDim, axisModel)

          if (result.firstCategoryDimIndex == null) {
            result.firstCategoryDimIndex = index
          }
        }
      })
    }
  }

  function isCategory (axisModel) {
    return axisModel.get('type') === 'category'
  }

  /**
     * Note that it is too complicated to support 3d stack by value
     * (have to create two-dimension inverted index), so in 3d case
     * we just support that stacked by index.
     *
     * @param seriesModel
     * @param dimensionsInput The same as the input of <module:echarts/data/SeriesData>.
     *        The input will be modified.
     * @param opt
     * @param opt.stackedCoordDimension Specify a coord dimension if needed.
     * @param opt.byIndex=false
     * @return calculationInfo
     * {
     *     stackedDimension: string
     *     stackedByDimension: string
     *     isStackedByIndex: boolean
     *     stackedOverDimension: string
     *     stackResultDimension: string
     * }
     */

  function enableDataStack (seriesModel, dimensionsInput, opt) {
    opt = opt || {}
    let byIndex = opt.byIndex
    const stackedCoordDimension = opt.stackedCoordDimension
    let dimensionDefineList
    let schema
    let store

    if (isLegacyDimensionsInput(dimensionsInput)) {
      dimensionDefineList = dimensionsInput
    } else {
      schema = dimensionsInput.schema
      dimensionDefineList = schema.dimensions
      store = dimensionsInput.store
    } // Compatibal: when `stack` is set as '', do not stack.

    const mayStack = !!(seriesModel && seriesModel.get('stack'))
    let stackedByDimInfo
    let stackedDimInfo
    let stackResultDimension
    let stackedOverDimension
    each(dimensionDefineList, function (dimensionInfo, index) {
      if (isString(dimensionInfo)) {
        dimensionDefineList[index] = dimensionInfo = {
          name: dimensionInfo
        }
      }

      if (mayStack && !dimensionInfo.isExtraCoord) {
        // Find the first ordinal dimension as the stackedByDimInfo.
        if (!byIndex && !stackedByDimInfo && dimensionInfo.ordinalMeta) {
          stackedByDimInfo = dimensionInfo
        } // Find the first stackable dimension as the stackedDimInfo.

        if (!stackedDimInfo && dimensionInfo.type !== 'ordinal' && dimensionInfo.type !== 'time' && (!stackedCoordDimension || stackedCoordDimension === dimensionInfo.coordDim)) {
          stackedDimInfo = dimensionInfo
        }
      }
    })

    if (stackedDimInfo && !byIndex && !stackedByDimInfo) {
      // Compatible with previous design, value axis (time axis) only stack by index.
      // It may make sense if the user provides elaborately constructed data.
      byIndex = true
    } // Add stack dimension, they can be both calculated by coordinate system in `unionExtent`.
    // That put stack logic in List is for using conveniently in echarts extensions, but it
    // might not be a good way.

    if (stackedDimInfo) {
      // Use a weird name that not duplicated with other names.
      // Also need to use seriesModel.id as postfix because different
      // series may share same data store. The stack dimension needs to be distinguished.
      stackResultDimension = '__\0ecstackresult_' + seriesModel.id
      stackedOverDimension = '__\0ecstackedover_' + seriesModel.id // Create inverted index to fast query index by value.

      if (stackedByDimInfo) {
        stackedByDimInfo.createInvertedIndices = true
      }

      const stackedDimCoordDim_1 = stackedDimInfo.coordDim
      const stackedDimType = stackedDimInfo.type
      let stackedDimCoordIndex_1 = 0
      each(dimensionDefineList, function (dimensionInfo) {
        if (dimensionInfo.coordDim === stackedDimCoordDim_1) {
          stackedDimCoordIndex_1++
        }
      })
      const stackedOverDimensionDefine = {
        name: stackResultDimension,
        coordDim: stackedDimCoordDim_1,
        coordDimIndex: stackedDimCoordIndex_1,
        type: stackedDimType,
        isExtraCoord: true,
        isCalculationCoord: true,
        storeDimIndex: dimensionDefineList.length
      }
      const stackResultDimensionDefine = {
        name: stackedOverDimension,
        // This dimension contains stack base (generally, 0), so do not set it as
        // `stackedDimCoordDim` to avoid extent calculation, consider log scale.
        coordDim: stackedOverDimension,
        coordDimIndex: stackedDimCoordIndex_1 + 1,
        type: stackedDimType,
        isExtraCoord: true,
        isCalculationCoord: true,
        storeDimIndex: dimensionDefineList.length + 1
      }

      if (schema) {
        if (store) {
          stackedOverDimensionDefine.storeDimIndex = store.ensureCalculationDimension(stackedOverDimension, stackedDimType)
          stackResultDimensionDefine.storeDimIndex = store.ensureCalculationDimension(stackResultDimension, stackedDimType)
        }

        schema.appendCalculationDimension(stackedOverDimensionDefine)
        schema.appendCalculationDimension(stackResultDimensionDefine)
      } else {
        dimensionDefineList.push(stackedOverDimensionDefine)
        dimensionDefineList.push(stackResultDimensionDefine)
      }
    }

    return {
      stackedDimension: stackedDimInfo && stackedDimInfo.name,
      stackedByDimension: stackedByDimInfo && stackedByDimInfo.name,
      isStackedByIndex: byIndex,
      stackedOverDimension: stackedOverDimension,
      stackResultDimension: stackResultDimension
    }
  }

  function isLegacyDimensionsInput (dimensionsInput) {
    return !isSeriesDataSchema(dimensionsInput.schema)
  }

  function isDimensionStacked (data, stackedDim) {
    // Each single series only maps to one pair of axis. So we do not need to
    // check stackByDim, whatever stacked by a dimension or stacked by index.
    return !!stackedDim && stackedDim === data.getCalculationInfo('stackedDimension')
  }
  function getStackedDimension (data, targetDim) {
    return isDimensionStacked(data, targetDim) ? data.getCalculationInfo('stackResultDimension') : targetDim
  }

  function getCoordSysDimDefs (seriesModel, coordSysInfo) {
    const coordSysName = seriesModel.get('coordinateSystem')
    const registeredCoordSys = CoordinateSystemManager.get(coordSysName)
    let coordSysDimDefs

    if (coordSysInfo && coordSysInfo.coordSysDims) {
      coordSysDimDefs = map(coordSysInfo.coordSysDims, function (dim) {
        const dimInfo = {
          name: dim
        }
        const axisModel = coordSysInfo.axisMap.get(dim)

        if (axisModel) {
          const axisType = axisModel.get('type')
          dimInfo.type = getDimensionTypeByAxis(axisType)
        }

        return dimInfo
      })
    }

    if (!coordSysDimDefs) {
      // Get dimensions from registered coordinate system
      coordSysDimDefs = registeredCoordSys && (registeredCoordSys.getDimensionsInfo ? registeredCoordSys.getDimensionsInfo() : registeredCoordSys.dimensions.slice()) || ['x', 'y']
    }

    return coordSysDimDefs
  }

  function injectOrdinalMeta (dimInfoList, createInvertedIndices, coordSysInfo) {
    let firstCategoryDimIndex
    let hasNameEncode
    coordSysInfo && each(dimInfoList, function (dimInfo, dimIndex) {
      const coordDim = dimInfo.coordDim
      const categoryAxisModel = coordSysInfo.categoryAxisMap.get(coordDim)

      if (categoryAxisModel) {
        if (firstCategoryDimIndex == null) {
          firstCategoryDimIndex = dimIndex
        }

        dimInfo.ordinalMeta = categoryAxisModel.getOrdinalMeta()

        if (createInvertedIndices) {
          dimInfo.createInvertedIndices = true
        }
      }

      if (dimInfo.otherDims.itemName != null) {
        hasNameEncode = true
      }
    })

    if (!hasNameEncode && firstCategoryDimIndex != null) {
      dimInfoList[firstCategoryDimIndex].otherDims.itemName = 0
    }

    return firstCategoryDimIndex
  }
  /**
     * Caution: there are side effects to `sourceManager` in this method.
     * Should better only be called in `Series['getInitialData']`.
     */

  function createSeriesData (sourceRaw, seriesModel, opt) {
    opt = opt || {}
    const sourceManager = seriesModel.getSourceManager()
    let source
    let isOriginalSource = false

    if (sourceRaw) {
      isOriginalSource = true
      source = createSourceFromSeriesDataOption(sourceRaw)
    } else {
      source = sourceManager.getSource() // Is series.data. not dataset.

      isOriginalSource = source.sourceFormat === SOURCE_FORMAT_ORIGINAL
    }

    const coordSysInfo = getCoordSysInfoBySeries(seriesModel)
    const coordSysDimDefs = getCoordSysDimDefs(seriesModel, coordSysInfo)
    const useEncodeDefaulter = opt.useEncodeDefaulter
    const encodeDefaulter = isFunction(useEncodeDefaulter) ? useEncodeDefaulter : useEncodeDefaulter ? curry(makeSeriesEncodeForAxisCoordSys, coordSysDimDefs, seriesModel) : null
    const createDimensionOptions = {
      coordDimensions: coordSysDimDefs,
      generateCoord: opt.generateCoord,
      encodeDefine: seriesModel.getEncode(),
      encodeDefaulter: encodeDefaulter,
      canOmitUnusedDimensions: !isOriginalSource
    }
    const schema = prepareSeriesDataSchema(source, createDimensionOptions)
    const firstCategoryDimIndex = injectOrdinalMeta(schema.dimensions, opt.createInvertedIndices, coordSysInfo)
    const store = !isOriginalSource ? sourceManager.getSharedDataStore(schema) : null
    const stackCalculationInfo = enableDataStack(seriesModel, {
      schema: schema,
      store: store
    })
    const data = new SeriesData(schema, seriesModel)
    data.setCalculationInfo(stackCalculationInfo)
    const dimValueGetter = firstCategoryDimIndex != null && isNeedCompleteOrdinalData(source) ? function (itemOpt, dimName, dataIndex, dimIndex) {
      // Use dataIndex as ordinal value in categoryAxis
      return dimIndex === firstCategoryDimIndex ? dataIndex : this.defaultDimValueGetter(itemOpt, dimName, dataIndex, dimIndex)
    } : null
    data.hasItemOption = false
    data.initData( // Try to reuse the data store in sourceManager if using dataset.
      isOriginalSource ? source : store, null, dimValueGetter)
    return data
  }

  function isNeedCompleteOrdinalData (source) {
    if (source.sourceFormat === SOURCE_FORMAT_ORIGINAL) {
      const sampleItem = firstDataNotNull(source.data || [])
      return !isArray(getDataItemValue(sampleItem))
    }
  }

  function firstDataNotNull (arr) {
    let i = 0

    while (i < arr.length && arr[i] == null) {
      i++
    }

    return arr[i]
  }

  const Scale =
    /** @class */
    (function () {
      function Scale (setting) {
        this._setting = setting || {}
        this._extent = [Infinity, -Infinity]
      }

      Scale.prototype.getSetting = function (name) {
        return this._setting[name]
      }
      /**
       * Set extent from data
       */

      Scale.prototype.unionExtent = function (other) {
        const extent = this._extent
        other[0] < extent[0] && (extent[0] = other[0])
        other[1] > extent[1] && (extent[1] = other[1]) // not setExtent because in log axis it may transformed to power
        // this.setExtent(extent[0], extent[1]);
      }
      /**
       * Set extent from data
       */

      Scale.prototype.unionExtentFromData = function (data, dim) {
        this.unionExtent(data.getApproximateExtent(dim))
      }
      /**
       * Get extent
       *
       * Extent is always in increase order.
       */

      Scale.prototype.getExtent = function () {
        return this._extent.slice()
      }
      /**
       * Set extent
       */

      Scale.prototype.setExtent = function (start, end) {
        const thisExtent = this._extent

        if (!isNaN(start)) {
          thisExtent[0] = start
        }

        if (!isNaN(end)) {
          thisExtent[1] = end
        }
      }
      /**
       * If value is in extent range
       */

      Scale.prototype.isInExtentRange = function (value) {
        return this._extent[0] <= value && this._extent[1] >= value
      }
      /**
       * When axis extent depends on data and no data exists,
       * axis ticks should not be drawn, which is named 'blank'.
       */

      Scale.prototype.isBlank = function () {
        return this._isBlank
      }
      /**
       * When axis extent depends on data and no data exists,
       * axis ticks should not be drawn, which is named 'blank'.
       */

      Scale.prototype.setBlank = function (isBlank) {
        this._isBlank = isBlank
      }

      return Scale
    }())

  enableClassManagement(Scale)

  let uidBase = 0

  const OrdinalMeta =
    /** @class */
    (function () {
      function OrdinalMeta (opt) {
        this.categories = opt.categories || []
        this._needCollect = opt.needCollect
        this._deduplication = opt.deduplication
        this.uid = ++uidBase
      }

      OrdinalMeta.createByAxisModel = function (axisModel) {
        const option = axisModel.option
        const data = option.data
        const categories = data && map(data, getName)
        return new OrdinalMeta({
          categories: categories,
          needCollect: !categories,
          // deduplication is default in axis.
          deduplication: option.dedplication !== false
        })
      }

      OrdinalMeta.prototype.getOrdinal = function (category) {
        // @ts-ignore
        return this._getOrCreateMap().get(category)
      }
      /**
       * @return The ordinal. If not found, return NaN.
       */

      OrdinalMeta.prototype.parseAndCollect = function (category) {
        let index
        const needCollect = this._needCollect // The value of category dim can be the index of the given category set.
        // This feature is only supported when !needCollect, because we should
        // consider a common case: a value is 2017, which is a number but is
        // expected to be tread as a category. This case usually happen in dataset,
        // where it happent to be no need of the index feature.

        if (!isString(category) && !needCollect) {
          return category
        } // Optimize for the scenario:
        // category is ['2012-01-01', '2012-01-02', ...], where the input
        // data has been ensured not duplicate and is large data.
        // Notice, if a dataset dimension provide categroies, usually echarts
        // should remove duplication except user tell echarts dont do that
        // (set axis.deduplication = false), because echarts do not know whether
        // the values in the category dimension has duplication (consider the
        // parallel-aqi example)

        if (needCollect && !this._deduplication) {
          index = this.categories.length
          this.categories[index] = category
          return index
        }

        const map = this._getOrCreateMap() // @ts-ignore

        index = map.get(category)

        if (index == null) {
          if (needCollect) {
            index = this.categories.length
            this.categories[index] = category // @ts-ignore

            map.set(category, index)
          } else {
            index = NaN
          }
        }

        return index
      } // Consider big data, do not create map until needed.

      OrdinalMeta.prototype._getOrCreateMap = function () {
        return this._map || (this._map = createHashMap(this.categories))
      }

      return OrdinalMeta
    }())

  function getName (obj) {
    if (isObject(obj) && obj.value != null) {
      return obj.value
    } else {
      return obj + ''
    }
  }

  function isValueNice (val) {
    const exp10 = Math.pow(10, quantityExponent(Math.abs(val)))
    const f = Math.abs(val / exp10)
    return f === 0 || f === 1 || f === 2 || f === 3 || f === 5
  }
  function isIntervalOrLogScale (scale) {
    return scale.type === 'interval' || scale.type === 'log'
  }
  /**
     * @param extent Both extent[0] and extent[1] should be valid number.
     *               Should be extent[0] < extent[1].
     * @param splitNumber splitNumber should be >= 1.
     */

  function intervalScaleNiceTicks (extent, splitNumber, minInterval, maxInterval) {
    const result = {}
    const span = extent[1] - extent[0]
    let interval = result.interval = nice(span / splitNumber, true)

    if (minInterval != null && interval < minInterval) {
      interval = result.interval = minInterval
    }

    if (maxInterval != null && interval > maxInterval) {
      interval = result.interval = maxInterval
    } // Tow more digital for tick.

    const precision = result.intervalPrecision = getIntervalPrecision(interval) // Niced extent inside original extent

    const niceTickExtent = result.niceTickExtent = [round(Math.ceil(extent[0] / interval) * interval, precision), round(Math.floor(extent[1] / interval) * interval, precision)]
    fixExtent(niceTickExtent, extent)
    return result
  }
  function increaseInterval (interval) {
    const exp10 = Math.pow(10, quantityExponent(interval)) // Increase interval

    let f = interval / exp10

    if (!f) {
      f = 1
    } else if (f === 2) {
      f = 3
    } else if (f === 3) {
      f = 5
    } else {
      // f is 1 or 5
      f *= 2
    }

    return round(f * exp10)
  }
  /**
     * @return interval precision
     */

  function getIntervalPrecision (interval) {
    // Tow more digital for tick.
    return getPrecision(interval) + 2
  }

  function clamp (niceTickExtent, idx, extent) {
    niceTickExtent[idx] = Math.max(Math.min(niceTickExtent[idx], extent[1]), extent[0])
  } // In some cases (e.g., splitNumber is 1), niceTickExtent may be out of extent.

  function fixExtent (niceTickExtent, extent) {
    !isFinite(niceTickExtent[0]) && (niceTickExtent[0] = extent[0])
    !isFinite(niceTickExtent[1]) && (niceTickExtent[1] = extent[1])
    clamp(niceTickExtent, 0, extent)
    clamp(niceTickExtent, 1, extent)

    if (niceTickExtent[0] > niceTickExtent[1]) {
      niceTickExtent[0] = niceTickExtent[1]
    }
  }
  function contain$1 (val, extent) {
    return val >= extent[0] && val <= extent[1]
  }
  function normalize$1 (val, extent) {
    if (extent[1] === extent[0]) {
      return 0.5
    }

    return (val - extent[0]) / (extent[1] - extent[0])
  }
  function scale$2 (val, extent) {
    return val * (extent[1] - extent[0]) + extent[0]
  }

  const OrdinalScale =
    /** @class */
    (function (_super) {
      __extends(OrdinalScale, _super)

      function OrdinalScale (setting) {
        const _this = _super.call(this, setting) || this

        _this.type = 'ordinal'

        let ordinalMeta = _this.getSetting('ordinalMeta') // Caution: Should not use instanceof, consider ec-extensions using
        // import approach to get OrdinalMeta class.

        if (!ordinalMeta) {
          ordinalMeta = new OrdinalMeta({})
        }

        if (isArray(ordinalMeta)) {
          ordinalMeta = new OrdinalMeta({
            categories: map(ordinalMeta, function (item) {
              return isObject(item) ? item.value : item
            })
          })
        }

        _this._ordinalMeta = ordinalMeta
        _this._extent = _this.getSetting('extent') || [0, ordinalMeta.categories.length - 1]
        return _this
      }

      OrdinalScale.prototype.parse = function (val) {
        // Caution: Math.round(null) will return `0` rather than `NaN`
        if (val == null) {
          return NaN
        }

        return isString(val) ? this._ordinalMeta.getOrdinal(val) // val might be float.
          : Math.round(val)
      }

      OrdinalScale.prototype.contain = function (rank) {
        rank = this.parse(rank)
        return contain$1(rank, this._extent) && this._ordinalMeta.categories[rank] != null
      }
      /**
       * Normalize given rank or name to linear [0, 1]
       * @param val raw ordinal number.
       * @return normalized value in [0, 1].
       */

      OrdinalScale.prototype.normalize = function (val) {
        val = this._getTickNumber(this.parse(val))
        return normalize$1(val, this._extent)
      }
      /**
       * @param val normalized value in [0, 1].
       * @return raw ordinal number.
       */

      OrdinalScale.prototype.scale = function (val) {
        val = Math.round(scale$2(val, this._extent))
        return this.getRawOrdinalNumber(val)
      }

      OrdinalScale.prototype.getTicks = function () {
        const ticks = []
        const extent = this._extent
        let rank = extent[0]

        while (rank <= extent[1]) {
          ticks.push({
            value: rank
          })
          rank++
        }

        return ticks
      }

      OrdinalScale.prototype.getMinorTicks = function (splitNumber) {
        // Not support.

      }
      /**
       * @see `Ordinal['_ordinalNumbersByTick']`
       */

      OrdinalScale.prototype.setSortInfo = function (info) {
        if (info == null) {
          this._ordinalNumbersByTick = this._ticksByOrdinalNumber = null
          return
        }

        const infoOrdinalNumbers = info.ordinalNumbers
        const ordinalsByTick = this._ordinalNumbersByTick = []
        const ticksByOrdinal = this._ticksByOrdinalNumber = [] // Unnecessary support negative tick in `realtimeSort`.

        let tickNum = 0
        const allCategoryLen = this._ordinalMeta.categories.length

        for (let len = Math.min(allCategoryLen, infoOrdinalNumbers.length); tickNum < len; ++tickNum) {
          const ordinalNumber = infoOrdinalNumbers[tickNum]
          ordinalsByTick[tickNum] = ordinalNumber
          ticksByOrdinal[ordinalNumber] = tickNum
        } // Handle that `series.data` only covers part of the `axis.category.data`.

        let unusedOrdinal = 0

        for (; tickNum < allCategoryLen; ++tickNum) {
          while (ticksByOrdinal[unusedOrdinal] != null) {
            unusedOrdinal++
          }
          ordinalsByTick.push(unusedOrdinal)
          ticksByOrdinal[unusedOrdinal] = tickNum
        }
      }

      OrdinalScale.prototype._getTickNumber = function (ordinal) {
        const ticksByOrdinalNumber = this._ticksByOrdinalNumber // also support ordinal out of range of `ordinalMeta.categories.length`,
        // where ordinal numbers are used as tick value directly.

        return ticksByOrdinalNumber && ordinal >= 0 && ordinal < ticksByOrdinalNumber.length ? ticksByOrdinalNumber[ordinal] : ordinal
      }
      /**
       * @usage
       * ```js
       * const ordinalNumber = ordinalScale.getRawOrdinalNumber(tickVal);
       *
       * // case0
       * const rawOrdinalValue = axisModel.getCategories()[ordinalNumber];
       * // case1
       * const rawOrdinalValue = this._ordinalMeta.categories[ordinalNumber];
       * // case2
       * const coord = axis.dataToCoord(ordinalNumber);
       * ```
       *
       * @param {OrdinalNumber} tickNumber index of display
       */

      OrdinalScale.prototype.getRawOrdinalNumber = function (tickNumber) {
        const ordinalNumbersByTick = this._ordinalNumbersByTick // tickNumber may be out of range, e.g., when axis max is larger than `ordinalMeta.categories.length`.,
        // where ordinal numbers are used as tick value directly.

        return ordinalNumbersByTick && tickNumber >= 0 && tickNumber < ordinalNumbersByTick.length ? ordinalNumbersByTick[tickNumber] : tickNumber
      }
      /**
       * Get item on tick
       */

      OrdinalScale.prototype.getLabel = function (tick) {
        if (!this.isBlank()) {
          const ordinalNumber = this.getRawOrdinalNumber(tick.value)
          const cateogry = this._ordinalMeta.categories[ordinalNumber] // Note that if no data, ordinalMeta.categories is an empty array.
          // Return empty if it's not exist.

          return cateogry == null ? '' : cateogry + ''
        }
      }

      OrdinalScale.prototype.count = function () {
        return this._extent[1] - this._extent[0] + 1
      }

      OrdinalScale.prototype.unionExtentFromData = function (data, dim) {
        this.unionExtent(data.getApproximateExtent(dim))
      }
      /**
       * @override
       * If value is in extent range
       */

      OrdinalScale.prototype.isInExtentRange = function (value) {
        value = this._getTickNumber(value)
        return this._extent[0] <= value && this._extent[1] >= value
      }

      OrdinalScale.prototype.getOrdinalMeta = function () {
        return this._ordinalMeta
      }

      OrdinalScale.prototype.calcNiceTicks = function () {}

      OrdinalScale.prototype.calcNiceExtent = function () {}

      OrdinalScale.type = 'ordinal'
      return OrdinalScale
    }(Scale))

  Scale.registerClass(OrdinalScale)

  const roundNumber = round

  const IntervalScale =
    /** @class */
    (function (_super) {
      __extends(IntervalScale, _super)

      function IntervalScale () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = 'interval' // Step is calculated in adjustExtent.

        _this._interval = 0
        _this._intervalPrecision = 2
        return _this
      }

      IntervalScale.prototype.parse = function (val) {
        return val
      }

      IntervalScale.prototype.contain = function (val) {
        return contain$1(val, this._extent)
      }

      IntervalScale.prototype.normalize = function (val) {
        return normalize$1(val, this._extent)
      }

      IntervalScale.prototype.scale = function (val) {
        return scale$2(val, this._extent)
      }

      IntervalScale.prototype.setExtent = function (start, end) {
        const thisExtent = this._extent // start,end may be a Number like '25',so...

        if (!isNaN(start)) {
          thisExtent[0] = parseFloat(start)
        }

        if (!isNaN(end)) {
          thisExtent[1] = parseFloat(end)
        }
      }

      IntervalScale.prototype.unionExtent = function (other) {
        const extent = this._extent
        other[0] < extent[0] && (extent[0] = other[0])
        other[1] > extent[1] && (extent[1] = other[1]) // unionExtent may called by it's sub classes

        this.setExtent(extent[0], extent[1])
      }

      IntervalScale.prototype.getInterval = function () {
        return this._interval
      }

      IntervalScale.prototype.setInterval = function (interval) {
        this._interval = interval // Dropped auto calculated niceExtent and use user setted extent
        // We assume user wan't to set both interval, min, max to get a better result

        this._niceExtent = this._extent.slice()
        this._intervalPrecision = getIntervalPrecision(interval)
      }
      /**
       * @param expandToNicedExtent Whether expand the ticks to niced extent.
       */

      IntervalScale.prototype.getTicks = function (expandToNicedExtent) {
        const interval = this._interval
        const extent = this._extent
        const niceTickExtent = this._niceExtent
        const intervalPrecision = this._intervalPrecision
        const ticks = [] // If interval is 0, return [];

        if (!interval) {
          return ticks
        } // Consider this case: using dataZoom toolbox, zoom and zoom.

        const safeLimit = 10000

        if (extent[0] < niceTickExtent[0]) {
          if (expandToNicedExtent) {
            ticks.push({
              value: roundNumber(niceTickExtent[0] - interval, intervalPrecision)
            })
          } else {
            ticks.push({
              value: extent[0]
            })
          }
        }

        let tick = niceTickExtent[0]

        while (tick <= niceTickExtent[1]) {
          ticks.push({
            value: tick
          }) // Avoid rounding error

          tick = roundNumber(tick + interval, intervalPrecision)

          if (tick === ticks[ticks.length - 1].value) {
            // Consider out of safe float point, e.g.,
            // -3711126.9907707 + 2e-10 === -3711126.9907707
            break
          }

          if (ticks.length > safeLimit) {
            return []
          }
        } // Consider this case: the last item of ticks is smaller
        // than niceTickExtent[1] and niceTickExtent[1] === extent[1].

        const lastNiceTick = ticks.length ? ticks[ticks.length - 1].value : niceTickExtent[1]

        if (extent[1] > lastNiceTick) {
          if (expandToNicedExtent) {
            ticks.push({
              value: roundNumber(lastNiceTick + interval, intervalPrecision)
            })
          } else {
            ticks.push({
              value: extent[1]
            })
          }
        }

        return ticks
      }

      IntervalScale.prototype.getMinorTicks = function (splitNumber) {
        const ticks = this.getTicks(true)
        const minorTicks = []
        const extent = this.getExtent()

        for (let i = 1; i < ticks.length; i++) {
          const nextTick = ticks[i]
          const prevTick = ticks[i - 1]
          let count = 0
          const minorTicksGroup = []
          const interval = nextTick.value - prevTick.value
          const minorInterval = interval / splitNumber

          while (count < splitNumber - 1) {
            const minorTick = roundNumber(prevTick.value + (count + 1) * minorInterval) // For the first and last interval. The count may be less than splitNumber.

            if (minorTick > extent[0] && minorTick < extent[1]) {
              minorTicksGroup.push(minorTick)
            }

            count++
          }

          minorTicks.push(minorTicksGroup)
        }

        return minorTicks
      }
      /**
       * @param opt.precision If 'auto', use nice presision.
       * @param opt.pad returns 1.50 but not 1.5 if precision is 2.
       */

      IntervalScale.prototype.getLabel = function (data, opt) {
        if (data == null) {
          return ''
        }

        let precision = opt && opt.precision

        if (precision == null) {
          precision = getPrecision(data.value) || 0
        } else if (precision === 'auto') {
          // Should be more precise then tick.
          precision = this._intervalPrecision
        } // (1) If `precision` is set, 12.005 should be display as '12.00500'.
        // (2) Use roundNumber (toFixed) to avoid scientific notation like '3.5e-7'.

        const dataNum = roundNumber(data.value, precision, true)
        return addCommas(dataNum)
      }
      /**
       * @param splitNumber By default `5`.
       */

      IntervalScale.prototype.calcNiceTicks = function (splitNumber, minInterval, maxInterval) {
        splitNumber = splitNumber || 5
        const extent = this._extent
        let span = extent[1] - extent[0]

        if (!isFinite(span)) {
          return
        } // User may set axis min 0 and data are all negative
        // FIXME If it needs to reverse ?

        if (span < 0) {
          span = -span
          extent.reverse()
        }

        const result = intervalScaleNiceTicks(extent, splitNumber, minInterval, maxInterval)
        this._intervalPrecision = result.intervalPrecision
        this._interval = result.interval
        this._niceExtent = result.niceTickExtent
      }

      IntervalScale.prototype.calcNiceExtent = function (opt) {
        const extent = this._extent // If extent start and end are same, expand them

        if (extent[0] === extent[1]) {
          if (extent[0] !== 0) {
            // Expand extent
            const expandSize = extent[0] // In the fowllowing case
            //      Axis has been fixed max 100
            //      Plus data are all 100 and axis extent are [100, 100].
            // Extend to the both side will cause expanded max is larger than fixed max.
            // So only expand to the smaller side.

            if (!opt.fixMax) {
              extent[1] += expandSize / 2
              extent[0] -= expandSize / 2
            } else {
              extent[0] -= expandSize / 2
            }
          } else {
            extent[1] = 1
          }
        }

        const span = extent[1] - extent[0] // If there are no data and extent are [Infinity, -Infinity]

        if (!isFinite(span)) {
          extent[0] = 0
          extent[1] = 1
        }

        this.calcNiceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval) // let extent = this._extent;

        const interval = this._interval

        if (!opt.fixMin) {
          extent[0] = roundNumber(Math.floor(extent[0] / interval) * interval)
        }

        if (!opt.fixMax) {
          extent[1] = roundNumber(Math.ceil(extent[1] / interval) * interval)
        }
      }

      IntervalScale.prototype.setNiceExtent = function (min, max) {
        this._niceExtent = [min, max]
      }

      IntervalScale.type = 'interval'
      return IntervalScale
    }(Scale))

  Scale.registerClass(IntervalScale)

  /* global Float32Array */

  const supportFloat32Array = typeof Float32Array !== 'undefined'
  const Float32ArrayCtor = !supportFloat32Array ? Array : Float32Array
  function createFloat32Array (arg) {
    if (isArray(arg)) {
      // Return self directly if don't support TypedArray.
      return supportFloat32Array ? new Float32Array(arg) : arg
    } // Else is number

    return new Float32ArrayCtor(arg)
  }

  const STACK_PREFIX = '__ec_stack_'

  function getSeriesStackId (seriesModel) {
    return seriesModel.get('stack') || STACK_PREFIX + seriesModel.seriesIndex
  }

  function getAxisKey (axis) {
    return axis.dim + axis.index
  }
  /**
     * @return {Object} {width, offset, offsetCenter} If axis.type is not 'category', return undefined.
     */

  function getLayoutOnAxis (opt) {
    const params = []
    const baseAxis = opt.axis
    const axisKey = 'axis0'

    if (baseAxis.type !== 'category') {
      return
    }

    const bandWidth = baseAxis.getBandWidth()

    for (var i = 0; i < opt.count || 0; i++) {
      params.push(defaults({
        bandWidth: bandWidth,
        axisKey: axisKey,
        stackId: STACK_PREFIX + i
      }, opt))
    }

    const widthAndOffsets = doCalBarWidthAndOffset(params)
    const result = []

    for (var i = 0; i < opt.count; i++) {
      const item = widthAndOffsets[axisKey][STACK_PREFIX + i]
      item.offsetCenter = item.offset + item.width / 2
      result.push(item)
    }

    return result
  }
  function prepareLayoutBarSeries (seriesType, ecModel) {
    const seriesModels = []
    ecModel.eachSeriesByType(seriesType, function (seriesModel) {
      // Check series coordinate, do layout for cartesian2d only
      if (isOnCartesian(seriesModel)) {
        seriesModels.push(seriesModel)
      }
    })
    return seriesModels
  }
  /**
     * Map from (baseAxis.dim + '_' + baseAxis.index) to min gap of two adjacent
     * values.
     * This works for time axes, value axes, and log axes.
     * For a single time axis, return value is in the form like
     * {'x_0': [1000000]}.
     * The value of 1000000 is in milliseconds.
     */

  function getValueAxesMinGaps (barSeries) {
    /**
       * Map from axis.index to values.
       * For a single time axis, axisValues is in the form like
       * {'x_0': [1495555200000, 1495641600000, 1495728000000]}.
       * Items in axisValues[x], e.g. 1495555200000, are time values of all
       * series.
       */
    const axisValues = {}
    each(barSeries, function (seriesModel) {
      const cartesian = seriesModel.coordinateSystem
      const baseAxis = cartesian.getBaseAxis()

      if (baseAxis.type !== 'time' && baseAxis.type !== 'value') {
        return
      }

      const data = seriesModel.getData()
      const key = baseAxis.dim + '_' + baseAxis.index
      const dimIdx = data.getDimensionIndex(data.mapDimension(baseAxis.dim))
      const store = data.getStore()

      for (let i = 0, cnt = store.count(); i < cnt; ++i) {
        const value = store.get(dimIdx, i)

        if (!axisValues[key]) {
          // No previous data for the axis
          axisValues[key] = [value]
        } else {
          // No value in previous series
          axisValues[key].push(value)
        } // Ignore duplicated time values in the same axis
      }
    })
    const axisMinGaps = {}

    for (const key in axisValues) {
      if (axisValues.hasOwnProperty(key)) {
        const valuesInAxis = axisValues[key]

        if (valuesInAxis) {
          // Sort axis values into ascending order to calculate gaps
          valuesInAxis.sort(function (a, b) {
            return a - b
          })
          let min = null

          for (let j = 1; j < valuesInAxis.length; ++j) {
            const delta = valuesInAxis[j] - valuesInAxis[j - 1]

            if (delta > 0) {
              // Ignore 0 delta because they are of the same axis value
              min = min === null ? delta : Math.min(min, delta)
            }
          } // Set to null if only have one data

          axisMinGaps[key] = min
        }
      }
    }

    return axisMinGaps
  }

  function makeColumnLayout (barSeries) {
    const axisMinGaps = getValueAxesMinGaps(barSeries)
    const seriesInfoList = []
    each(barSeries, function (seriesModel) {
      const cartesian = seriesModel.coordinateSystem
      const baseAxis = cartesian.getBaseAxis()
      const axisExtent = baseAxis.getExtent()
      let bandWidth

      if (baseAxis.type === 'category') {
        bandWidth = baseAxis.getBandWidth()
      } else if (baseAxis.type === 'value' || baseAxis.type === 'time') {
        const key = baseAxis.dim + '_' + baseAxis.index
        const minGap = axisMinGaps[key]
        const extentSpan = Math.abs(axisExtent[1] - axisExtent[0])
        const scale = baseAxis.scale.getExtent()
        const scaleSpan = Math.abs(scale[1] - scale[0])
        bandWidth = minGap ? extentSpan / scaleSpan * minGap : extentSpan // When there is only one data value
      } else {
        const data = seriesModel.getData()
        bandWidth = Math.abs(axisExtent[1] - axisExtent[0]) / data.count()
      }

      const barWidth = parsePercent$1(seriesModel.get('barWidth'), bandWidth)
      const barMaxWidth = parsePercent$1(seriesModel.get('barMaxWidth'), bandWidth)
      const barMinWidth = parsePercent$1( // barMinWidth by default is 0.5 / 1 in cartesian. Because in value axis,
        // the auto-calculated bar width might be less than 0.5 / 1.
        seriesModel.get('barMinWidth') || (isInLargeMode(seriesModel) ? 0.5 : 1), bandWidth)
      const barGap = seriesModel.get('barGap')
      const barCategoryGap = seriesModel.get('barCategoryGap')
      seriesInfoList.push({
        bandWidth: bandWidth,
        barWidth: barWidth,
        barMaxWidth: barMaxWidth,
        barMinWidth: barMinWidth,
        barGap: barGap,
        barCategoryGap: barCategoryGap,
        axisKey: getAxisKey(baseAxis),
        stackId: getSeriesStackId(seriesModel)
      })
    })
    return doCalBarWidthAndOffset(seriesInfoList)
  }

  function doCalBarWidthAndOffset (seriesInfoList) {
    // Columns info on each category axis. Key is cartesian name
    const columnsMap = {}
    each(seriesInfoList, function (seriesInfo, idx) {
      const axisKey = seriesInfo.axisKey
      const bandWidth = seriesInfo.bandWidth
      const columnsOnAxis = columnsMap[axisKey] || {
        bandWidth: bandWidth,
        remainedWidth: bandWidth,
        autoWidthCount: 0,
        categoryGap: null,
        gap: '20%',
        stacks: {}
      }
      const stacks = columnsOnAxis.stacks
      columnsMap[axisKey] = columnsOnAxis
      const stackId = seriesInfo.stackId

      if (!stacks[stackId]) {
        columnsOnAxis.autoWidthCount++
      }

      stacks[stackId] = stacks[stackId] || {
        width: 0,
        maxWidth: 0
      } // Caution: In a single coordinate system, these barGrid attributes
      // will be shared by series. Consider that they have default values,
      // only the attributes set on the last series will work.
      // Do not change this fact unless there will be a break change.

      let barWidth = seriesInfo.barWidth

      if (barWidth && !stacks[stackId].width) {
        // See #6312, do not restrict width.
        stacks[stackId].width = barWidth
        barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth)
        columnsOnAxis.remainedWidth -= barWidth
      }

      const barMaxWidth = seriesInfo.barMaxWidth
      barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth)
      const barMinWidth = seriesInfo.barMinWidth
      barMinWidth && (stacks[stackId].minWidth = barMinWidth)
      const barGap = seriesInfo.barGap
      barGap != null && (columnsOnAxis.gap = barGap)
      const barCategoryGap = seriesInfo.barCategoryGap
      barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap)
    })
    const result = {}
    each(columnsMap, function (columnsOnAxis, coordSysName) {
      result[coordSysName] = {}
      const stacks = columnsOnAxis.stacks
      const bandWidth = columnsOnAxis.bandWidth
      let categoryGapPercent = columnsOnAxis.categoryGap

      if (categoryGapPercent == null) {
        const columnCount = keys(stacks).length // More columns in one group
        // the spaces between group is smaller. Or the column will be too thin.

        categoryGapPercent = Math.max(35 - columnCount * 4, 15) + '%'
      }

      const categoryGap = parsePercent$1(categoryGapPercent, bandWidth)
      const barGapPercent = parsePercent$1(columnsOnAxis.gap, 1)
      let remainedWidth = columnsOnAxis.remainedWidth
      let autoWidthCount = columnsOnAxis.autoWidthCount
      let autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent)
      autoWidth = Math.max(autoWidth, 0) // Find if any auto calculated bar exceeded maxBarWidth

      each(stacks, function (column) {
        const maxWidth = column.maxWidth
        const minWidth = column.minWidth

        if (!column.width) {
          var finalWidth = autoWidth

          if (maxWidth && maxWidth < finalWidth) {
            finalWidth = Math.min(maxWidth, remainedWidth)
          } // `minWidth` has higher priority. `minWidth` decide that wheter the
          // bar is able to be visible. So `minWidth` should not be restricted
          // by `maxWidth` or `remainedWidth` (which is from `bandWidth`). In
          // the extreme cases for `value` axis, bars are allowed to overlap
          // with each other if `minWidth` specified.

          if (minWidth && minWidth > finalWidth) {
            finalWidth = minWidth
          }

          if (finalWidth !== autoWidth) {
            column.width = finalWidth
            remainedWidth -= finalWidth + barGapPercent * finalWidth
            autoWidthCount--
          }
        } else {
          // `barMinWidth/barMaxWidth` has higher priority than `barWidth`, as
          // CSS does. Becuase barWidth can be a percent value, where
          // `barMaxWidth` can be used to restrict the final width.
          var finalWidth = column.width

          if (maxWidth) {
            finalWidth = Math.min(finalWidth, maxWidth)
          } // `minWidth` has higher priority, as described above

          if (minWidth) {
            finalWidth = Math.max(finalWidth, minWidth)
          }

          column.width = finalWidth
          remainedWidth -= finalWidth + barGapPercent * finalWidth
          autoWidthCount--
        }
      }) // Recalculate width again

      autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent)
      autoWidth = Math.max(autoWidth, 0)
      let widthSum = 0
      let lastColumn
      each(stacks, function (column, idx) {
        if (!column.width) {
          column.width = autoWidth
        }

        lastColumn = column
        widthSum += column.width * (1 + barGapPercent)
      })

      if (lastColumn) {
        widthSum -= lastColumn.width * barGapPercent
      }

      let offset = -widthSum / 2
      each(stacks, function (column, stackId) {
        result[coordSysName][stackId] = result[coordSysName][stackId] || {
          bandWidth: bandWidth,
          offset: offset,
          width: column.width
        }
        offset += column.width * (1 + barGapPercent)
      })
    })
    return result
  }

  function retrieveColumnLayout (barWidthAndOffset, axis, seriesModel) {
    if (barWidthAndOffset && axis) {
      const result = barWidthAndOffset[getAxisKey(axis)]

      if (result != null && seriesModel != null) {
        return result[getSeriesStackId(seriesModel)]
      }

      return result
    }
  }
  function layout (seriesType, ecModel) {
    const seriesModels = prepareLayoutBarSeries(seriesType, ecModel)
    const barWidthAndOffset = makeColumnLayout(seriesModels)
    each(seriesModels, function (seriesModel) {
      const data = seriesModel.getData()
      const cartesian = seriesModel.coordinateSystem
      const baseAxis = cartesian.getBaseAxis()
      const stackId = getSeriesStackId(seriesModel)
      const columnLayoutInfo = barWidthAndOffset[getAxisKey(baseAxis)][stackId]
      const columnOffset = columnLayoutInfo.offset
      const columnWidth = columnLayoutInfo.width
      data.setLayout({
        bandWidth: columnLayoutInfo.bandWidth,
        offset: columnOffset,
        size: columnWidth
      })
    })
  } // TODO: Do not support stack in large mode yet.

  function createProgressiveLayout (seriesType) {
    return {
      seriesType: seriesType,
      plan: createRenderPlanner(),
      reset: function (seriesModel) {
        if (!isOnCartesian(seriesModel)) {
          return
        }

        const data = seriesModel.getData()
        const cartesian = seriesModel.coordinateSystem
        const baseAxis = cartesian.getBaseAxis()
        const valueAxis = cartesian.getOtherAxis(baseAxis)
        const valueDimIdx = data.getDimensionIndex(data.mapDimension(valueAxis.dim))
        const baseDimIdx = data.getDimensionIndex(data.mapDimension(baseAxis.dim))
        const drawBackground = seriesModel.get('showBackground', true)
        const valueDim = data.mapDimension(valueAxis.dim)
        const stackResultDim = data.getCalculationInfo('stackResultDimension')
        const stacked = isDimensionStacked(data, valueDim) && !!data.getCalculationInfo('stackedOnSeries')
        const isValueAxisH = valueAxis.isHorizontal()
        const valueAxisStart = getValueAxisStart(baseAxis, valueAxis)
        const isLarge = isInLargeMode(seriesModel)
        const barMinHeight = seriesModel.get('barMinHeight') || 0
        const stackedDimIdx = stackResultDim && data.getDimensionIndex(stackResultDim) // Layout info.

        const columnWidth = data.getLayout('size')
        const columnOffset = data.getLayout('offset')
        return {
          progress: function (params, data) {
            const count = params.count
            const largePoints = isLarge && createFloat32Array(count * 3)
            const largeBackgroundPoints = isLarge && drawBackground && createFloat32Array(count * 3)
            const largeDataIndices = isLarge && createFloat32Array(count)
            const coordLayout = cartesian.master.getRect()
            const bgSize = isValueAxisH ? coordLayout.width : coordLayout.height
            let dataIndex
            const store = data.getStore()
            let idxOffset = 0

            while ((dataIndex = params.next()) != null) {
              const value = store.get(stacked ? stackedDimIdx : valueDimIdx, dataIndex)
              const baseValue = store.get(baseDimIdx, dataIndex)
              let baseCoord = valueAxisStart
              let startValue = void 0 // Because of the barMinHeight, we can not use the value in
              // stackResultDimension directly.

              if (stacked) {
                startValue = +value - store.get(valueDimIdx, dataIndex)
              }

              let x = void 0
              let y = void 0
              let width = void 0
              let height = void 0

              if (isValueAxisH) {
                var coord = cartesian.dataToPoint([value, baseValue])

                if (stacked) {
                  var startCoord = cartesian.dataToPoint([startValue, baseValue])
                  baseCoord = startCoord[0]
                }

                x = baseCoord
                y = coord[1] + columnOffset
                width = coord[0] - baseCoord
                height = columnWidth

                if (Math.abs(width) < barMinHeight) {
                  width = (width < 0 ? -1 : 1) * barMinHeight
                }
              } else {
                var coord = cartesian.dataToPoint([baseValue, value])

                if (stacked) {
                  var startCoord = cartesian.dataToPoint([baseValue, startValue])
                  baseCoord = startCoord[1]
                }

                x = coord[0] + columnOffset
                y = baseCoord
                width = columnWidth
                height = coord[1] - baseCoord

                if (Math.abs(height) < barMinHeight) {
                  // Include zero to has a positive bar
                  height = (height <= 0 ? -1 : 1) * barMinHeight
                }
              }

              if (!isLarge) {
                data.setItemLayout(dataIndex, {
                  x: x,
                  y: y,
                  width: width,
                  height: height
                })
              } else {
                largePoints[idxOffset] = x
                largePoints[idxOffset + 1] = y
                largePoints[idxOffset + 2] = isValueAxisH ? width : height

                if (largeBackgroundPoints) {
                  largeBackgroundPoints[idxOffset] = isValueAxisH ? coordLayout.x : x
                  largeBackgroundPoints[idxOffset + 1] = isValueAxisH ? y : coordLayout.y
                  largeBackgroundPoints[idxOffset + 2] = bgSize
                }

                largeDataIndices[dataIndex] = dataIndex
              }

              idxOffset += 3
            }

            if (isLarge) {
              data.setLayout({
                largePoints: largePoints,
                largeDataIndices: largeDataIndices,
                largeBackgroundPoints: largeBackgroundPoints,
                valueAxisHorizontal: isValueAxisH
              })
            }
          }
        }
      }
    }
  }

  function isOnCartesian (seriesModel) {
    return seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === 'cartesian2d'
  }

  function isInLargeMode (seriesModel) {
    return seriesModel.pipelineContext && seriesModel.pipelineContext.large
  } // See cases in `test/bar-start.html` and `#7412`, `#8747`.

  function getValueAxisStart (baseAxis, valueAxis) {
    return valueAxis.toGlobalCoord(valueAxis.dataToCoord(valueAxis.type === 'log' ? 1 : 0))
  }

  const bisect = function (a, x, lo, hi) {
    while (lo < hi) {
      const mid = lo + hi >>> 1

      if (a[mid][1] < x) {
        lo = mid + 1
      } else {
        hi = mid
      }
    }

    return lo
  }

  const TimeScale =
    /** @class */
    (function (_super) {
      __extends(TimeScale, _super)

      function TimeScale (settings) {
        const _this = _super.call(this, settings) || this

        _this.type = 'time'
        return _this
      }
      /**
       * Get label is mainly for other components like dataZoom, tooltip.
       */

      TimeScale.prototype.getLabel = function (tick) {
        const useUTC = this.getSetting('useUTC')
        return format(tick.value, fullLeveledFormatter[getDefaultFormatPrecisionOfInterval(getPrimaryTimeUnit(this._minLevelUnit))] || fullLeveledFormatter.second, useUTC, this.getSetting('locale'))
      }

      TimeScale.prototype.getFormattedLabel = function (tick, idx, labelFormatter) {
        const isUTC = this.getSetting('useUTC')
        const lang = this.getSetting('locale')
        return leveledFormat(tick, idx, labelFormatter, lang, isUTC)
      }
      /**
       * @override
       */

      TimeScale.prototype.getTicks = function () {
        const interval = this._interval
        const extent = this._extent
        let ticks = [] // If interval is 0, return [];

        if (!interval) {
          return ticks
        }

        ticks.push({
          value: extent[0],
          level: 0
        })
        const useUTC = this.getSetting('useUTC')
        const innerTicks = getIntervalTicks(this._minLevelUnit, this._approxInterval, useUTC, extent)
        ticks = ticks.concat(innerTicks)
        ticks.push({
          value: extent[1],
          level: 0
        })
        return ticks
      }

      TimeScale.prototype.calcNiceExtent = function (opt) {
        const extent = this._extent // If extent start and end are same, expand them

        if (extent[0] === extent[1]) {
          // Expand extent
          extent[0] -= ONE_DAY
          extent[1] += ONE_DAY
        } // If there are no data and extent are [Infinity, -Infinity]

        if (extent[1] === -Infinity && extent[0] === Infinity) {
          const d = new Date()
          extent[1] = +new Date(d.getFullYear(), d.getMonth(), d.getDate())
          extent[0] = extent[1] - ONE_DAY
        }

        this.calcNiceTicks(opt.splitNumber, opt.minInterval, opt.maxInterval)
      }

      TimeScale.prototype.calcNiceTicks = function (approxTickNum, minInterval, maxInterval) {
        approxTickNum = approxTickNum || 10
        const extent = this._extent
        const span = extent[1] - extent[0]
        this._approxInterval = span / approxTickNum

        if (minInterval != null && this._approxInterval < minInterval) {
          this._approxInterval = minInterval
        }

        if (maxInterval != null && this._approxInterval > maxInterval) {
          this._approxInterval = maxInterval
        }

        const scaleIntervalsLen = scaleIntervals.length
        const idx = Math.min(bisect(scaleIntervals, this._approxInterval, 0, scaleIntervalsLen), scaleIntervalsLen - 1) // Interval that can be used to calculate ticks

        this._interval = scaleIntervals[idx][1] // Min level used when picking ticks from top down.
        // We check one more level to avoid the ticks are to sparse in some case.

        this._minLevelUnit = scaleIntervals[Math.max(idx - 1, 0)][0]
      }

      TimeScale.prototype.parse = function (val) {
        // val might be float.
        return isNumber(val) ? val : +parseDate(val)
      }

      TimeScale.prototype.contain = function (val) {
        return contain$1(this.parse(val), this._extent)
      }

      TimeScale.prototype.normalize = function (val) {
        return normalize$1(this.parse(val), this._extent)
      }

      TimeScale.prototype.scale = function (val) {
        return scale$2(val, this._extent)
      }

      TimeScale.type = 'time'
      return TimeScale
    }(IntervalScale))
    /**
     * This implementation was originally copied from "d3.js"
     * <https://github.com/d3/d3/blob/b516d77fb8566b576088e73410437494717ada26/src/time/scale.js>
     * with some modifications made for this program.
     * See the license statement at the head of this file.
     */

  var scaleIntervals = [// Format                           interval
    ['second', ONE_SECOND], ['minute', ONE_MINUTE], ['hour', ONE_HOUR], ['quarter-day', ONE_HOUR * 6], ['half-day', ONE_HOUR * 12], ['day', ONE_DAY * 1.2], ['half-week', ONE_DAY * 3.5], ['week', ONE_DAY * 7], ['month', ONE_DAY * 31], ['quarter', ONE_DAY * 95], ['half-year', ONE_YEAR / 2], ['year', ONE_YEAR] // 1Y
  ]

  function isUnitValueSame (unit, valueA, valueB, isUTC) {
    const dateA = parseDate(valueA)
    const dateB = parseDate(valueB)

    const isSame = function (unit) {
      return getUnitValue(dateA, unit, isUTC) === getUnitValue(dateB, unit, isUTC)
    }

    const isSameYear = function () {
      return isSame('year')
    } // const isSameHalfYear = () => isSameYear() && isSame('half-year');
    // const isSameQuater = () => isSameYear() && isSame('quarter');

    const isSameMonth = function () {
      return isSameYear() && isSame('month')
    }

    const isSameDay = function () {
      return isSameMonth() && isSame('day')
    } // const isSameHalfDay = () => isSameDay() && isSame('half-day');

    const isSameHour = function () {
      return isSameDay() && isSame('hour')
    }

    const isSameMinute = function () {
      return isSameHour() && isSame('minute')
    }

    const isSameSecond = function () {
      return isSameMinute() && isSame('second')
    }

    const isSameMilliSecond = function () {
      return isSameSecond() && isSame('millisecond')
    }

    switch (unit) {
      case 'year':
        return isSameYear()

      case 'month':
        return isSameMonth()

      case 'day':
        return isSameDay()

      case 'hour':
        return isSameHour()

      case 'minute':
        return isSameMinute()

      case 'second':
        return isSameSecond()

      case 'millisecond':
        return isSameMilliSecond()
    }
  } // const primaryUnitGetters = {
  //     year: fullYearGetterName(),
  //     month: monthGetterName(),
  //     day: dateGetterName(),
  //     hour: hoursGetterName(),
  //     minute: minutesGetterName(),
  //     second: secondsGetterName(),
  //     millisecond: millisecondsGetterName()
  // };
  // const primaryUnitUTCGetters = {
  //     year: fullYearGetterName(true),
  //     month: monthGetterName(true),
  //     day: dateGetterName(true),
  //     hour: hoursGetterName(true),
  //     minute: minutesGetterName(true),
  //     second: secondsGetterName(true),
  //     millisecond: millisecondsGetterName(true)
  // };
  // function moveTick(date: Date, unitName: TimeUnit, step: number, isUTC: boolean) {
  //     step = step || 1;
  //     switch (getPrimaryTimeUnit(unitName)) {
  //         case 'year':
  //             date[fullYearSetterName(isUTC)](date[fullYearGetterName(isUTC)]() + step);
  //             break;
  //         case 'month':
  //             date[monthSetterName(isUTC)](date[monthGetterName(isUTC)]() + step);
  //             break;
  //         case 'day':
  //             date[dateSetterName(isUTC)](date[dateGetterName(isUTC)]() + step);
  //             break;
  //         case 'hour':
  //             date[hoursSetterName(isUTC)](date[hoursGetterName(isUTC)]() + step);
  //             break;
  //         case 'minute':
  //             date[minutesSetterName(isUTC)](date[minutesGetterName(isUTC)]() + step);
  //             break;
  //         case 'second':
  //             date[secondsSetterName(isUTC)](date[secondsGetterName(isUTC)]() + step);
  //             break;
  //         case 'millisecond':
  //             date[millisecondsSetterName(isUTC)](date[millisecondsGetterName(isUTC)]() + step);
  //             break;
  //     }
  //     return date.getTime();
  // }
  // const DATE_INTERVALS = [[8, 7.5], [4, 3.5], [2, 1.5]];
  // const MONTH_INTERVALS = [[6, 5.5], [3, 2.5], [2, 1.5]];
  // const MINUTES_SECONDS_INTERVALS = [[30, 30], [20, 20], [15, 15], [10, 10], [5, 5], [2, 2]];

  function getDateInterval (approxInterval, daysInMonth) {
    approxInterval /= ONE_DAY
    return approxInterval > 16 ? 16 // Math.floor(daysInMonth / 2) + 1  // In this case we only want one tick betwen two month.
      : approxInterval > 7.5 ? 7 // TODO week 7 or day 8?
        : approxInterval > 3.5 ? 4 : approxInterval > 1.5 ? 2 : 1
  }

  function getMonthInterval (approxInterval) {
    const APPROX_ONE_MONTH = 30 * ONE_DAY
    approxInterval /= APPROX_ONE_MONTH
    return approxInterval > 6 ? 6 : approxInterval > 3 ? 3 : approxInterval > 2 ? 2 : 1
  }

  function getHourInterval (approxInterval) {
    approxInterval /= ONE_HOUR
    return approxInterval > 12 ? 12 : approxInterval > 6 ? 6 : approxInterval > 3.5 ? 4 : approxInterval > 2 ? 2 : 1
  }

  function getMinutesAndSecondsInterval (approxInterval, isMinutes) {
    approxInterval /= isMinutes ? ONE_MINUTE : ONE_SECOND
    return approxInterval > 30 ? 30 : approxInterval > 20 ? 20 : approxInterval > 15 ? 15 : approxInterval > 10 ? 10 : approxInterval > 5 ? 5 : approxInterval > 2 ? 2 : 1
  }

  function getMillisecondsInterval (approxInterval) {
    return nice(approxInterval, true)
  }

  function getFirstTimestampOfUnit (date, unitName, isUTC) {
    const outDate = new Date(date)

    switch (getPrimaryTimeUnit(unitName)) {
      case 'year':
      case 'month':
        outDate[monthSetterName(isUTC)](0)

      case 'day':
        outDate[dateSetterName(isUTC)](1)

      case 'hour':
        outDate[hoursSetterName(isUTC)](0)

      case 'minute':
        outDate[minutesSetterName(isUTC)](0)

      case 'second':
        outDate[secondsSetterName(isUTC)](0)
        outDate[millisecondsSetterName(isUTC)](0)
    }

    return outDate.getTime()
  }

  function getIntervalTicks (bottomUnitName, approxInterval, isUTC, extent) {
    const safeLimit = 10000
    const unitNames = timeUnits
    let iter = 0

    function addTicksInSpan (interval, minTimestamp, maxTimestamp, getMethodName, setMethodName, isDate, out) {
      const date = new Date(minTimestamp)
      let dateTime = minTimestamp
      let d = date[getMethodName]() // if (isDate) {
      //     d -= 1; // Starts with 0;   PENDING
      // }

      while (dateTime < maxTimestamp && dateTime <= extent[1]) {
        out.push({
          value: dateTime
        })
        d += interval
        date[setMethodName](d)
        dateTime = date.getTime()
      } // This extra tick is for calcuating ticks of next level. Will not been added to the final result

      out.push({
        value: dateTime,
        notAdd: true
      })
    }

    function addLevelTicks (unitName, lastLevelTicks, levelTicks) {
      const newAddedTicks = []
      const isFirstLevel = !lastLevelTicks.length

      if (isUnitValueSame(getPrimaryTimeUnit(unitName), extent[0], extent[1], isUTC)) {
        return
      }

      if (isFirstLevel) {
        lastLevelTicks = [{
          // TODO Optimize. Not include so may ticks.
          value: getFirstTimestampOfUnit(new Date(extent[0]), unitName, isUTC)
        }, {
          value: extent[1]
        }]
      }

      for (var i = 0; i < lastLevelTicks.length - 1; i++) {
        const startTick = lastLevelTicks[i].value
        const endTick = lastLevelTicks[i + 1].value

        if (startTick === endTick) {
          continue
        }

        let interval = void 0
        let getterName = void 0
        let setterName = void 0
        let isDate = false

        switch (unitName) {
          case 'year':
            interval = Math.max(1, Math.round(approxInterval / ONE_DAY / 365))
            getterName = fullYearGetterName(isUTC)
            setterName = fullYearSetterName(isUTC)
            break

          case 'half-year':
          case 'quarter':
          case 'month':
            interval = getMonthInterval(approxInterval)
            getterName = monthGetterName(isUTC)
            setterName = monthSetterName(isUTC)
            break

          case 'week': // PENDING If week is added. Ignore day.

          case 'half-week':
          case 'day':
            interval = getDateInterval(approxInterval) // Use 32 days and let interval been 16

            getterName = dateGetterName(isUTC)
            setterName = dateSetterName(isUTC)
            isDate = true
            break

          case 'half-day':
          case 'quarter-day':
          case 'hour':
            interval = getHourInterval(approxInterval)
            getterName = hoursGetterName(isUTC)
            setterName = hoursSetterName(isUTC)
            break

          case 'minute':
            interval = getMinutesAndSecondsInterval(approxInterval, true)
            getterName = minutesGetterName(isUTC)
            setterName = minutesSetterName(isUTC)
            break

          case 'second':
            interval = getMinutesAndSecondsInterval(approxInterval, false)
            getterName = secondsGetterName(isUTC)
            setterName = secondsSetterName(isUTC)
            break

          case 'millisecond':
            interval = getMillisecondsInterval(approxInterval)
            getterName = millisecondsGetterName(isUTC)
            setterName = millisecondsSetterName(isUTC)
            break
        }

        addTicksInSpan(interval, startTick, endTick, getterName, setterName, isDate, newAddedTicks)

        if (unitName === 'year' && levelTicks.length > 1 && i === 0) {
          // Add nearest years to the left extent.
          levelTicks.unshift({
            value: levelTicks[0].value - interval
          })
        }
      }

      for (var i = 0; i < newAddedTicks.length; i++) {
        levelTicks.push(newAddedTicks[i])
      } // newAddedTicks.length && console.log(unitName, newAddedTicks);

      return newAddedTicks
    }

    const levelsTicks = []
    let currentLevelTicks = []
    let tickCount = 0
    let lastLevelTickCount = 0

    for (var i = 0; i < unitNames.length && iter++ < safeLimit; ++i) {
      const primaryTimeUnit = getPrimaryTimeUnit(unitNames[i])

      if (!isPrimaryTimeUnit(unitNames[i])) {
        // TODO
        continue
      }

      addLevelTicks(unitNames[i], levelsTicks[levelsTicks.length - 1] || [], currentLevelTicks)
      const nextPrimaryTimeUnit = unitNames[i + 1] ? getPrimaryTimeUnit(unitNames[i + 1]) : null

      if (primaryTimeUnit !== nextPrimaryTimeUnit) {
        if (currentLevelTicks.length) {
          lastLevelTickCount = tickCount // Remove the duplicate so the tick count can be precisely.

          currentLevelTicks.sort(function (a, b) {
            return a.value - b.value
          })
          const levelTicksRemoveDuplicated = []

          for (let i_1 = 0; i_1 < currentLevelTicks.length; ++i_1) {
            const tickValue = currentLevelTicks[i_1].value

            if (i_1 === 0 || currentLevelTicks[i_1 - 1].value !== tickValue) {
              levelTicksRemoveDuplicated.push(currentLevelTicks[i_1])

              if (tickValue >= extent[0] && tickValue <= extent[1]) {
                tickCount++
              }
            }
          }

          const targetTickNum = (extent[1] - extent[0]) / approxInterval // Added too much in this level and not too less in last level

          if (tickCount > targetTickNum * 1.5 && lastLevelTickCount > targetTickNum / 1.5) {
            break
          } // Only treat primary time unit as one level.

          levelsTicks.push(levelTicksRemoveDuplicated)

          if (tickCount > targetTickNum || bottomUnitName === unitNames[i]) {
            break
          }
        } // Reset if next unitName is primary

        currentLevelTicks = []
      }
    }

    if ('development' !== 'production') {
      if (iter >= safeLimit) {
        warn('Exceed safe limit.')
      }
    }

    const levelsTicksInExtent = filter(map(levelsTicks, function (levelTicks) {
      return filter(levelTicks, function (tick) {
        return tick.value >= extent[0] && tick.value <= extent[1] && !tick.notAdd
      })
    }), function (levelTicks) {
      return levelTicks.length > 0
    })
    const ticks = []
    const maxLevel = levelsTicksInExtent.length - 1

    for (var i = 0; i < levelsTicksInExtent.length; ++i) {
      const levelTicks = levelsTicksInExtent[i]

      for (let k = 0; k < levelTicks.length; ++k) {
        ticks.push({
          value: levelTicks[k].value,
          level: maxLevel - i
        })
      }
    }

    ticks.sort(function (a, b) {
      return a.value - b.value
    }) // Remove duplicates

    const result = []

    for (var i = 0; i < ticks.length; ++i) {
      if (i === 0 || ticks[i].value !== ticks[i - 1].value) {
        result.push(ticks[i])
      }
    }

    return result
  }

  Scale.registerClass(TimeScale)

  const scaleProto = Scale.prototype // FIXME:TS refactor: not good to call it directly with `this`?

  const intervalScaleProto = IntervalScale.prototype
  const roundingErrorFix = round
  const mathFloor = Math.floor
  const mathCeil = Math.ceil
  const mathPow$1 = Math.pow
  const mathLog = Math.log

  const LogScale =
    /** @class */
    (function (_super) {
      __extends(LogScale, _super)

      function LogScale () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = 'log'
        _this.base = 10
        _this._originalScale = new IntervalScale() // FIXME:TS actually used by `IntervalScale`

        _this._interval = 0
        return _this
      }
      /**
       * @param Whether expand the ticks to niced extent.
       */

      LogScale.prototype.getTicks = function (expandToNicedExtent) {
        const originalScale = this._originalScale
        const extent = this._extent
        const originalExtent = originalScale.getExtent()
        const ticks = intervalScaleProto.getTicks.call(this, expandToNicedExtent)
        return map(ticks, function (tick) {
          const val = tick.value
          let powVal = round(mathPow$1(this.base, val)) // Fix #4158

          powVal = val === extent[0] && this._fixMin ? fixRoundingError(powVal, originalExtent[0]) : powVal
          powVal = val === extent[1] && this._fixMax ? fixRoundingError(powVal, originalExtent[1]) : powVal
          return {
            value: powVal
          }
        }, this)
      }

      LogScale.prototype.setExtent = function (start, end) {
        const base = this.base
        start = mathLog(start) / mathLog(base)
        end = mathLog(end) / mathLog(base)
        intervalScaleProto.setExtent.call(this, start, end)
      }
      /**
       * @return {number} end
       */

      LogScale.prototype.getExtent = function () {
        const base = this.base
        const extent = scaleProto.getExtent.call(this)
        extent[0] = mathPow$1(base, extent[0])
        extent[1] = mathPow$1(base, extent[1]) // Fix #4158

        const originalScale = this._originalScale
        const originalExtent = originalScale.getExtent()
        this._fixMin && (extent[0] = fixRoundingError(extent[0], originalExtent[0]))
        this._fixMax && (extent[1] = fixRoundingError(extent[1], originalExtent[1]))
        return extent
      }

      LogScale.prototype.unionExtent = function (extent) {
        this._originalScale.unionExtent(extent)

        const base = this.base
        extent[0] = mathLog(extent[0]) / mathLog(base)
        extent[1] = mathLog(extent[1]) / mathLog(base)
        scaleProto.unionExtent.call(this, extent)
      }

      LogScale.prototype.unionExtentFromData = function (data, dim) {
        // TODO
        // filter value that <= 0
        this.unionExtent(data.getApproximateExtent(dim))
      }
      /**
       * Update interval and extent of intervals for nice ticks
       * @param approxTickNum default 10 Given approx tick number
       */

      LogScale.prototype.calcNiceTicks = function (approxTickNum) {
        approxTickNum = approxTickNum || 10
        const extent = this._extent
        const span = extent[1] - extent[0]

        if (span === Infinity || span <= 0) {
          return
        }

        let interval = quantity(span)
        const err = approxTickNum / span * interval // Filter ticks to get closer to the desired count.

        if (err <= 0.5) {
          interval *= 10
        } // Interval should be integer

        while (!isNaN(interval) && Math.abs(interval) < 1 && Math.abs(interval) > 0) {
          interval *= 10
        }

        const niceExtent = [round(mathCeil(extent[0] / interval) * interval), round(mathFloor(extent[1] / interval) * interval)]
        this._interval = interval
        this._niceExtent = niceExtent
      }

      LogScale.prototype.calcNiceExtent = function (opt) {
        intervalScaleProto.calcNiceExtent.call(this, opt)
        this._fixMin = opt.fixMin
        this._fixMax = opt.fixMax
      }

      LogScale.prototype.parse = function (val) {
        return val
      }

      LogScale.prototype.contain = function (val) {
        val = mathLog(val) / mathLog(this.base)
        return contain$1(val, this._extent)
      }

      LogScale.prototype.normalize = function (val) {
        val = mathLog(val) / mathLog(this.base)
        return normalize$1(val, this._extent)
      }

      LogScale.prototype.scale = function (val) {
        val = scale$2(val, this._extent)
        return mathPow$1(this.base, val)
      }

      LogScale.type = 'log'
      return LogScale
    }(Scale))

  const proto = LogScale.prototype
  proto.getMinorTicks = intervalScaleProto.getMinorTicks
  proto.getLabel = intervalScaleProto.getLabel

  function fixRoundingError (val, originalVal) {
    return roundingErrorFix(val, getPrecision(originalVal))
  }

  Scale.registerClass(LogScale)

  const ScaleRawExtentInfo =
    /** @class */
    (function () {
      function ScaleRawExtentInfo (scale, model, // Usually: data extent from all series on this axis.
        originalExtent) {
        this._prepareParams(scale, model, originalExtent)
      }
      /**
       * Parameters depending on ouside (like model, user callback)
       * are prepared and fixed here.
       */

      ScaleRawExtentInfo.prototype._prepareParams = function (scale, model, // Usually: data extent from all series on this axis.
        dataExtent) {
        if (dataExtent[1] < dataExtent[0]) {
          dataExtent = [NaN, NaN]
        }

        this._dataMin = dataExtent[0]
        this._dataMax = dataExtent[1]
        const isOrdinal = this._isOrdinal = scale.type === 'ordinal'
        this._needCrossZero = scale.type === 'interval' && model.getNeedCrossZero && model.getNeedCrossZero()
        const modelMinRaw = this._modelMinRaw = model.get('min', true)

        if (isFunction(modelMinRaw)) {
          // This callback alway provide users the full data extent (before data filtered).
          this._modelMinNum = parseAxisModelMinMax(scale, modelMinRaw({
            min: dataExtent[0],
            max: dataExtent[1]
          }))
        } else if (modelMinRaw !== 'dataMin') {
          this._modelMinNum = parseAxisModelMinMax(scale, modelMinRaw)
        }

        const modelMaxRaw = this._modelMaxRaw = model.get('max', true)

        if (isFunction(modelMaxRaw)) {
          // This callback alway provide users the full data extent (before data filtered).
          this._modelMaxNum = parseAxisModelMinMax(scale, modelMaxRaw({
            min: dataExtent[0],
            max: dataExtent[1]
          }))
        } else if (modelMaxRaw !== 'dataMax') {
          this._modelMaxNum = parseAxisModelMinMax(scale, modelMaxRaw)
        }

        if (isOrdinal) {
          // FIXME: there is a flaw here: if there is no "block" data processor like `dataZoom`,
          // and progressive rendering is using, here the category result might just only contain
          // the processed chunk rather than the entire result.
          this._axisDataLen = model.getCategories().length
        } else {
          const boundaryGap = model.get('boundaryGap')
          const boundaryGapArr = isArray(boundaryGap) ? boundaryGap : [boundaryGap || 0, boundaryGap || 0]

          if (typeof boundaryGapArr[0] === 'boolean' || typeof boundaryGapArr[1] === 'boolean') {
            if ('development' !== 'production') {
              console.warn('Boolean type for boundaryGap is only ' + 'allowed for ordinal axis. Please use string in ' + 'percentage instead, e.g., "20%". Currently, ' + 'boundaryGap is set to be 0.')
            }

            this._boundaryGapInner = [0, 0]
          } else {
            this._boundaryGapInner = [parsePercent(boundaryGapArr[0], 1), parsePercent(boundaryGapArr[1], 1)]
          }
        }
      }
      /**
       * Calculate extent by prepared parameters.
       * This method has no external dependency and can be called duplicatedly,
       * getting the same result.
       * If parameters changed, should call this method to recalcuate.
       */

      ScaleRawExtentInfo.prototype.calculate = function () {
        // Notice: When min/max is not set (that is, when there are null/undefined,
        // which is the most common case), these cases should be ensured:
        // (1) For 'ordinal', show all axis.data.
        // (2) For others:
        //      + `boundaryGap` is applied (if min/max set, boundaryGap is
        //      disabled).
        //      + If `needCrossZero`, min/max should be zero, otherwise, min/max should
        //      be the result that originalExtent enlarged by boundaryGap.
        // (3) If no data, it should be ensured that `scale.setBlank` is set.
        const isOrdinal = this._isOrdinal
        const dataMin = this._dataMin
        const dataMax = this._dataMax
        const axisDataLen = this._axisDataLen
        const boundaryGapInner = this._boundaryGapInner
        const span = !isOrdinal ? dataMax - dataMin || Math.abs(dataMin) : null // Currently if a `'value'` axis model min is specified as 'dataMin'/'dataMax',
        // `boundaryGap` will not be used. It's the different from specifying as `null`/`undefined`.

        let min = this._modelMinRaw === 'dataMin' ? dataMin : this._modelMinNum
        let max = this._modelMaxRaw === 'dataMax' ? dataMax : this._modelMaxNum // If `_modelMinNum`/`_modelMaxNum` is `null`/`undefined`, should not be fixed.

        let minFixed = min != null
        let maxFixed = max != null

        if (min == null) {
          min = isOrdinal ? axisDataLen ? 0 : NaN : dataMin - boundaryGapInner[0] * span
        }

        if (max == null) {
          max = isOrdinal ? axisDataLen ? axisDataLen - 1 : NaN : dataMax + boundaryGapInner[1] * span
        }

        (min == null || !isFinite(min)) && (min = NaN);
        (max == null || !isFinite(max)) && (max = NaN)
        const isBlank = eqNaN(min) || eqNaN(max) || isOrdinal && !axisDataLen // If data extent modified, need to recalculated to ensure cross zero.

        if (this._needCrossZero) {
          // Axis is over zero and min is not set
          if (min > 0 && max > 0 && !minFixed) {
            min = 0 // minFixed = true;
          } // Axis is under zero and max is not set

          if (min < 0 && max < 0 && !maxFixed) {
            max = 0 // maxFixed = true;
          } // PENDING:
          // When `needCrossZero` and all data is positive/negative, should it be ensured
          // that the results processed by boundaryGap are positive/negative?
          // If so, here `minFixed`/`maxFixed` need to be set.
        }

        const determinedMin = this._determinedMin
        const determinedMax = this._determinedMax

        if (determinedMin != null) {
          min = determinedMin
          minFixed = true
        }

        if (determinedMax != null) {
          max = determinedMax
          maxFixed = true
        } // Ensure min/max be finite number or NaN here. (not to be null/undefined)
        // `NaN` means min/max axis is blank.

        return {
          min: min,
          max: max,
          minFixed: minFixed,
          maxFixed: maxFixed,
          isBlank: isBlank
        }
      }

      ScaleRawExtentInfo.prototype.modifyDataMinMax = function (minMaxName, val) {
        if ('development' !== 'production') {
          assert(!this.frozen)
        }

        this[DATA_MIN_MAX_ATTR[minMaxName]] = val
      }

      ScaleRawExtentInfo.prototype.setDeterminedMinMax = function (minMaxName, val) {
        const attr = DETERMINED_MIN_MAX_ATTR[minMaxName]

        if ('development' !== 'production') {
          assert(!this.frozen && // Earse them usually means logic flaw.
          this[attr] == null)
        }

        this[attr] = val
      }

      ScaleRawExtentInfo.prototype.freeze = function () {
        // @ts-ignore
        this.frozen = true
      }

      return ScaleRawExtentInfo
    }())
  var DETERMINED_MIN_MAX_ATTR = {
    min: '_determinedMin',
    max: '_determinedMax'
  }
  var DATA_MIN_MAX_ATTR = {
    min: '_dataMin',
    max: '_dataMax'
  }
  /**
     * Get scale min max and related info only depends on model settings.
     * This method can be called after coordinate system created.
     * For example, in data processing stage.
     *
     * Scale extent info probably be required multiple times during a workflow.
     * For example:
     * (1) `dataZoom` depends it to get the axis extent in "100%" state.
     * (2) `processor/extentCalculator` depends it to make sure whether axis extent is specified.
     * (3) `coordSys.update` use it to finally decide the scale extent.
     * But the callback of `min`/`max` should not be called multiple times.
     * The code below should not be implemented repeatedly either.
     * So we cache the result in the scale instance, which will be recreated at the begining
     * of the workflow (because `scale` instance will be recreated each round of the workflow).
     */

  function ensureScaleRawExtentInfo (scale, model, // Usually: data extent from all series on this axis.
    originalExtent) {
    // Do not permit to recreate.
    let rawExtentInfo = scale.rawExtentInfo

    if (rawExtentInfo) {
      return rawExtentInfo
    }

    rawExtentInfo = new ScaleRawExtentInfo(scale, model, originalExtent) // @ts-ignore

    scale.rawExtentInfo = rawExtentInfo
    return rawExtentInfo
  }
  function parseAxisModelMinMax (scale, minMax) {
    return minMax == null ? null : eqNaN(minMax) ? NaN : scale.parse(minMax)
  }

  /**
     * Get axis scale extent before niced.
     * Item of returned array can only be number (including Infinity and NaN).
     *
     * Caution:
     * Precondition of calling this method:
     * The scale extent has been initialized using series data extent via
     * `scale.setExtent` or `scale.unionExtentFromData`;
     */

  function getScaleExtent (scale, model) {
    const scaleType = scale.type
    const rawExtentResult = ensureScaleRawExtentInfo(scale, model, scale.getExtent()).calculate()
    scale.setBlank(rawExtentResult.isBlank)
    let min = rawExtentResult.min
    let max = rawExtentResult.max // If bars are placed on a base axis of type time or interval account for axis boundary overflow and current axis
    // is base axis
    // FIXME
    // (1) Consider support value axis, where below zero and axis `onZero` should be handled properly.
    // (2) Refactor the logic with `barGrid`. Is it not need to `makeBarWidthAndOffsetInfo` twice with different extent?
    //     Should not depend on series type `bar`?
    // (3) Fix that might overlap when using dataZoom.
    // (4) Consider other chart types using `barGrid`?
    // See #6728, #4862, `test/bar-overflow-time-plot.html`

    const ecModel = model.ecModel

    if (ecModel && scaleType === 'time'
    /* || scaleType === 'interval' */
    ) {
      const barSeriesModels = prepareLayoutBarSeries('bar', ecModel)
      let isBaseAxisAndHasBarSeries_1 = false
      each(barSeriesModels, function (seriesModel) {
        isBaseAxisAndHasBarSeries_1 = isBaseAxisAndHasBarSeries_1 || seriesModel.getBaseAxis() === model.axis
      })

      if (isBaseAxisAndHasBarSeries_1) {
        // Calculate placement of bars on axis. TODO should be decoupled
        // with barLayout
        const barWidthAndOffset = makeColumnLayout(barSeriesModels) // Adjust axis min and max to account for overflow

        const adjustedScale = adjustScaleForOverflow(min, max, model, barWidthAndOffset)
        min = adjustedScale.min
        max = adjustedScale.max
      }
    }

    return {
      extent: [min, max],
      // "fix" means "fixed", the value should not be
      // changed in the subsequent steps.
      fixMin: rawExtentResult.minFixed,
      fixMax: rawExtentResult.maxFixed
    }
  }

  function adjustScaleForOverflow (min, max, model, // Only support cartesian coord yet.
    barWidthAndOffset) {
    // Get Axis Length
    const axisExtent = model.axis.getExtent()
    const axisLength = axisExtent[1] - axisExtent[0] // Get bars on current base axis and calculate min and max overflow

    const barsOnCurrentAxis = retrieveColumnLayout(barWidthAndOffset, model.axis)

    if (barsOnCurrentAxis === undefined) {
      return {
        min: min,
        max: max
      }
    }

    let minOverflow = Infinity
    each(barsOnCurrentAxis, function (item) {
      minOverflow = Math.min(item.offset, minOverflow)
    })
    let maxOverflow = -Infinity
    each(barsOnCurrentAxis, function (item) {
      maxOverflow = Math.max(item.offset + item.width, maxOverflow)
    })
    minOverflow = Math.abs(minOverflow)
    maxOverflow = Math.abs(maxOverflow)
    const totalOverFlow = minOverflow + maxOverflow // Calculate required buffer based on old range and overflow

    const oldRange = max - min
    const oldRangePercentOfNew = 1 - (minOverflow + maxOverflow) / axisLength
    const overflowBuffer = oldRange / oldRangePercentOfNew - oldRange
    max += overflowBuffer * (maxOverflow / totalOverFlow)
    min -= overflowBuffer * (minOverflow / totalOverFlow)
    return {
      min: min,
      max: max
    }
  } // Precondition of calling this method:
  // The scale extent has been initailized using series data extent via
  // `scale.setExtent` or `scale.unionExtentFromData`;

  function niceScaleExtent (scale, inModel) {
    const model = inModel
    const extentInfo = getScaleExtent(scale, model)
    const extent = extentInfo.extent
    const splitNumber = model.get('splitNumber')

    if (scale instanceof LogScale) {
      scale.base = model.get('logBase')
    }

    const scaleType = scale.type
    const interval = model.get('interval')
    const isIntervalOrTime = scaleType === 'interval' || scaleType === 'time'
    scale.setExtent(extent[0], extent[1])
    scale.calcNiceExtent({
      splitNumber: splitNumber,
      fixMin: extentInfo.fixMin,
      fixMax: extentInfo.fixMax,
      minInterval: isIntervalOrTime ? model.get('minInterval') : null,
      maxInterval: isIntervalOrTime ? model.get('maxInterval') : null
    }) // If some one specified the min, max. And the default calculated interval
    // is not good enough. He can specify the interval. It is often appeared
    // in angle axis with angle 0 - 360. Interval calculated in interval scale is hard
    // to be 60.
    // FIXME

    if (interval != null) {
      scale.setInterval && scale.setInterval(interval)
    }
  }
  /**
     * @param axisType Default retrieve from model.type
     */

  function createScaleByModel (model, axisType) {
    axisType = axisType || model.get('type')

    if (axisType) {
      switch (axisType) {
        // Buildin scale
        case 'category':
          return new OrdinalScale({
            ordinalMeta: model.getOrdinalMeta ? model.getOrdinalMeta() : model.getCategories(),
            extent: [Infinity, -Infinity]
          })

        case 'time':
          return new TimeScale({
            locale: model.ecModel.getLocaleModel(),
            useUTC: model.ecModel.get('useUTC')
          })

        default:
          // case 'value'/'interval', 'log', or others.
          return new (Scale.getClass(axisType) || IntervalScale)()
      }
    }
  }
  /**
     * Check if the axis cross 0
     */

  function ifAxisCrossZero (axis) {
    const dataExtent = axis.scale.getExtent()
    const min = dataExtent[0]
    const max = dataExtent[1]
    return !(min > 0 && max > 0 || min < 0 && max < 0)
  }
  /**
     * @param axis
     * @return Label formatter function.
     *         param: {number} tickValue,
     *         param: {number} idx, the index in all ticks.
     *                         If category axis, this param is not required.
     *         return: {string} label string.
     */

  function makeLabelFormatter (axis) {
    const labelFormatter = axis.getLabelModel().get('formatter')
    const categoryTickStart = axis.type === 'category' ? axis.scale.getExtent()[0] : null

    if (axis.scale.type === 'time') {
      return (function (tpl) {
        return function (tick, idx) {
          return axis.scale.getFormattedLabel(tick, idx, tpl)
        }
      }(labelFormatter))
    } else if (isString(labelFormatter)) {
      return (function (tpl) {
        return function (tick) {
          // For category axis, get raw value; for numeric axis,
          // get formatted label like '1,333,444'.
          const label = axis.scale.getLabel(tick)
          const text = tpl.replace('{value}', label != null ? label : '')
          return text
        }
      }(labelFormatter))
    } else if (isFunction(labelFormatter)) {
      return (function (cb) {
        return function (tick, idx) {
          // The original intention of `idx` is "the index of the tick in all ticks".
          // But the previous implementation of category axis do not consider the
          // `axisLabel.interval`, which cause that, for example, the `interval` is
          // `1`, then the ticks "name5", "name7", "name9" are displayed, where the
          // corresponding `idx` are `0`, `2`, `4`, but not `0`, `1`, `2`. So we keep
          // the definition here for back compatibility.
          if (categoryTickStart != null) {
            idx = tick.value - categoryTickStart
          }

          return cb(getAxisRawValue(axis, tick), idx, tick.level != null
            ? {
                level: tick.level
              }
            : null)
        }
      }(labelFormatter))
    } else {
      return function (tick) {
        return axis.scale.getLabel(tick)
      }
    }
  }
  function getAxisRawValue (axis, tick) {
    // In category axis with data zoom, tick is not the original
    // index of axis.data. So tick should not be exposed to user
    // in category axis.
    return axis.type === 'category' ? axis.scale.getLabel(tick) : tick.value
  }
  /**
     * @param axis
     * @return Be null/undefined if no labels.
     */

  function estimateLabelUnionRect (axis) {
    const axisModel = axis.model
    const scale = axis.scale

    if (!axisModel.get(['axisLabel', 'show']) || scale.isBlank()) {
      return
    }

    let realNumberScaleTicks
    let tickCount
    const categoryScaleExtent = scale.getExtent() // Optimize for large category data, avoid call `getTicks()`.

    if (scale instanceof OrdinalScale) {
      tickCount = scale.count()
    } else {
      realNumberScaleTicks = scale.getTicks()
      tickCount = realNumberScaleTicks.length
    }

    const axisLabelModel = axis.getLabelModel()
    const labelFormatter = makeLabelFormatter(axis)
    let rect
    let step = 1 // Simple optimization for large amount of labels

    if (tickCount > 40) {
      step = Math.ceil(tickCount / 40)
    }

    for (let i = 0; i < tickCount; i += step) {
      const tick = realNumberScaleTicks
        ? realNumberScaleTicks[i]
        : {
            value: categoryScaleExtent[0] + i
          }
      const label = labelFormatter(tick, i)
      const unrotatedSingleRect = axisLabelModel.getTextRect(label)
      const singleRect = rotateTextRect(unrotatedSingleRect, axisLabelModel.get('rotate') || 0)
      rect ? rect.union(singleRect) : rect = singleRect
    }

    return rect
  }

  function rotateTextRect (textRect, rotate) {
    const rotateRadians = rotate * Math.PI / 180
    const beforeWidth = textRect.width
    const beforeHeight = textRect.height
    const afterWidth = beforeWidth * Math.abs(Math.cos(rotateRadians)) + Math.abs(beforeHeight * Math.sin(rotateRadians))
    const afterHeight = beforeWidth * Math.abs(Math.sin(rotateRadians)) + Math.abs(beforeHeight * Math.cos(rotateRadians))
    const rotatedRect = new BoundingRect(textRect.x, textRect.y, afterWidth, afterHeight)
    return rotatedRect
  }
  /**
     * @param model axisLabelModel or axisTickModel
     * @return {number|String} Can be null|'auto'|number|function
     */

  function getOptionCategoryInterval (model) {
    const interval = model.get('interval')
    return interval == null ? 'auto' : interval
  }
  /**
     * Set `categoryInterval` as 0 implicitly indicates that
     * show all labels reguardless of overlap.
     * @param {Object} axis axisModel.axis
     */

  function shouldShowAllLabels (axis) {
    return axis.type === 'category' && getOptionCategoryInterval(axis.getLabelModel()) === 0
  }
  function getDataDimensionsOnAxis (data, axisDim) {
    // Remove duplicated dat dimensions caused by `getStackedDimension`.
    const dataDimMap = {} // Currently `mapDimensionsAll` will contain stack result dimension ('__\0ecstackresult').
    // PENDING: is it reasonable? Do we need to remove the original dim from "coord dim" since
    // there has been stacked result dim?

    each(data.mapDimensionsAll(axisDim), function (dataDim) {
      // For example, the extent of the original dimension
      // is [0.1, 0.5], the extent of the `stackResultDimension`
      // is [7, 9], the final extent should NOT include [0.1, 0.5],
      // because there is no graphic corresponding to [0.1, 0.5].
      // See the case in `test/area-stack.html` `main1`, where area line
      // stack needs `yAxis` not start from 0.
      dataDimMap[getStackedDimension(data, dataDim)] = true
    })
    return keys(dataDimMap)
  }
  function unionAxisExtentFromData (dataExtent, data, axisDim) {
    if (data) {
      each(getDataDimensionsOnAxis(data, axisDim), function (dim) {
        const seriesExtent = data.getApproximateExtent(dim)
        seriesExtent[0] < dataExtent[0] && (dataExtent[0] = seriesExtent[0])
        seriesExtent[1] > dataExtent[1] && (dataExtent[1] = seriesExtent[1])
      })
    }
  }

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

  /**
     * AUTO-GENERATED FILE. DO NOT MODIFY.
     */

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  const AxisModelCommonMixin =
    /** @class */
    (function () {
      function AxisModelCommonMixin () {}

      AxisModelCommonMixin.prototype.getNeedCrossZero = function () {
        const option = this.option
        return !option.scale
      }
      /**
       * Should be implemented by each axis model if necessary.
       * @return coordinate system model
       */

      AxisModelCommonMixin.prototype.getCoordSysModel = function () {

      }

      return AxisModelCommonMixin
    }())

  /**
     * Create a muti dimension List structure from seriesModel.
     */

  function createList (seriesModel) {
    return createSeriesData(null, seriesModel)
  } // export function createGraph(seriesModel) {
  const dataStack$1 = {
    isDimensionStacked: isDimensionStacked,
    enableDataStack: enableDataStack,
    getStackedDimension: getStackedDimension
  }
  /**
     * Create scale
     * @param {Array.<number>} dataExtent
     * @param {Object|module:echarts/Model} option If `optoin.type`
     *        is secified, it can only be `'value'` currently.
     */

  function createScale (dataExtent, option) {
    let axisModel = option

    if (!(option instanceof Model)) {
      axisModel = new Model(option) // FIXME
      // Currently AxisModelCommonMixin has nothing to do with the
      // the requirements of `axisHelper.createScaleByModel`. For
      // example the method `getCategories` and `getOrdinalMeta`
      // are required for `'category'` axis, and ecModel are required
      // for `'time'` axis. But occationally echarts-gl happened
      // to only use `'value'` axis.
      // zrUtil.mixin(axisModel, AxisModelCommonMixin);
    }

    const scale = createScaleByModel(axisModel)
    scale.setExtent(dataExtent[0], dataExtent[1])
    niceScaleExtent(scale, axisModel)
    return scale
  }
  /**
     * Mixin common methods to axis model,
     *
     * Inlcude methods
     * `getFormattedLabels() => Array.<string>`
     * `getCategories() => Array.<string>`
     * `getMin(origin: boolean) => number`
     * `getMax(origin: boolean) => number`
     * `getNeedCrossZero() => boolean`
     */

  function mixinAxisModelCommonMethods (Model) {
    mixin(Model, AxisModelCommonMixin)
  }
  function createTextStyle$1 (textStyleModel, opts) {
    opts = opts || {}
    return createTextStyle(textStyleModel, null, null, opts.state !== 'normal')
  }

  const helper = /* #__PURE__ */Object.freeze({
    __proto__: null,
    createList: createList,
    getLayoutRect: getLayoutRect,
    dataStack: dataStack$1,
    createScale: createScale,
    mixinAxisModelCommonMethods: mixinAxisModelCommonMethods,
    getECData: getECData,
    createTextStyle: createTextStyle$1,
    createDimensions: createDimensions,
    createSymbol: createSymbol,
    enableHoverEmphasis: enableHoverEmphasis
  })

  const EPSILON$4 = 1e-8
  function isAroundEqual$1 (a, b) {
    return Math.abs(a - b) < EPSILON$4
  }
  function contain$2 (points, x, y) {
    let w = 0
    let p = points[0]
    if (!p) {
      return false
    }
    for (let i = 1; i < points.length; i++) {
      const p2 = points[i]
      w += windingLine(p[0], p[1], p2[0], p2[1], x, y)
      p = p2
    }
    const p0 = points[0]
    if (!isAroundEqual$1(p[0], p0[0]) || !isAroundEqual$1(p[1], p0[1])) {
      w += windingLine(p[0], p[1], p0[0], p0[1], x, y)
    }
    return w !== 0
  }

  const TMP_TRANSFORM = []

  function transformPoints (points, transform) {
    for (let p = 0; p < points.length; p++) {
      applyTransform(points[p], points[p], transform)
    }
  }

  function updateBBoxFromPoints (points, min$1, max$1, projection) {
    for (let i = 0; i < points.length; i++) {
      let p = points[i]

      if (projection) {
        // projection may return null point.
        p = projection.project(p)
      }

      if (p && isFinite(p[0]) && isFinite(p[1])) {
        min(min$1, min$1, p)
        max(max$1, max$1, p)
      }
    }
  }

  function centroid (points) {
    let signedArea = 0
    let cx = 0
    let cy = 0
    const len = points.length
    let x0 = points[len - 1][0]
    let y0 = points[len - 1][1] // Polygon should been closed.

    for (let i = 0; i < len; i++) {
      const x1 = points[i][0]
      const y1 = points[i][1]
      const a = x0 * y1 - x1 * y0
      signedArea += a
      cx += (x0 + x1) * a
      cy += (y0 + y1) * a
      x0 = x1
      y0 = y1
    }

    return signedArea ? [cx / signedArea / 3, cy / signedArea / 3, signedArea] : [points[0][0] || 0, points[0][1] || 0]
  }

  const Region =
    /** @class */
    (function () {
      function Region (name) {
        this.name = name
      }

      Region.prototype.setCenter = function (center) {
        this._center = center
      }
      /**
       * Get center point in data unit. That is,
       * for GeoJSONRegion, the unit is lat/lng,
       * for GeoSVGRegion, the unit is SVG local coord.
       */

      Region.prototype.getCenter = function () {
        let center = this._center

        if (!center) {
          // In most cases there are no need to calculate this center.
          // So calculate only when called.
          center = this._center = this.calcCenter()
        }

        return center
      }

      return Region
    }())

  const GeoJSONPolygonGeometry =
    /** @class */
    (function () {
      function GeoJSONPolygonGeometry (exterior, interiors) {
        this.type = 'polygon'
        this.exterior = exterior
        this.interiors = interiors
      }

      return GeoJSONPolygonGeometry
    }())

  const GeoJSONLineStringGeometry =
    /** @class */
    (function () {
      function GeoJSONLineStringGeometry (points) {
        this.type = 'linestring'
        this.points = points
      }

      return GeoJSONLineStringGeometry
    }())

  const GeoJSONRegion =
    /** @class */
    (function (_super) {
      __extends(GeoJSONRegion, _super)

      function GeoJSONRegion (name, geometries, cp) {
        const _this = _super.call(this, name) || this

        _this.type = 'geoJSON'
        _this.geometries = geometries
        _this._center = cp && [cp[0], cp[1]]
        return _this
      }

      GeoJSONRegion.prototype.calcCenter = function () {
        const geometries = this.geometries
        let largestGeo
        let largestGeoSize = 0

        for (let i = 0; i < geometries.length; i++) {
          const geo = geometries[i]
          const exterior = geo.exterior // Simple trick to use points count instead of polygon area as region size.
          // Ignore linestring

          const size = exterior && exterior.length

          if (size > largestGeoSize) {
            largestGeo = geo
            largestGeoSize = size
          }
        }

        if (largestGeo) {
          return centroid(largestGeo.exterior)
        } // from bounding rect by default.

        const rect = this.getBoundingRect()
        return [rect.x + rect.width / 2, rect.y + rect.height / 2]
      }

      GeoJSONRegion.prototype.getBoundingRect = function (projection) {
        let rect = this._rect // Always recalculate if using projection.

        if (rect && !projection) {
          return rect
        }

        const min = [Infinity, Infinity]
        const max = [-Infinity, -Infinity]
        const geometries = this.geometries
        each(geometries, function (geo) {
          if (geo.type === 'polygon') {
            // Doesn't consider hole
            updateBBoxFromPoints(geo.exterior, min, max, projection)
          } else {
            each(geo.points, function (points) {
              updateBBoxFromPoints(points, min, max, projection)
            })
          }
        }) // Normalie invalid bounding.

        if (!(isFinite(min[0]) && isFinite(min[1]) && isFinite(max[0]) && isFinite(max[1]))) {
          min[0] = min[1] = max[0] = max[1] = 0
        }

        rect = new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1])

        if (!projection) {
          this._rect = rect
        }

        return rect
      }

      GeoJSONRegion.prototype.contain = function (coord) {
        const rect = this.getBoundingRect()
        const geometries = this.geometries

        if (!rect.contain(coord[0], coord[1])) {
          return false
        }

        loopGeo: for (let i = 0, len = geometries.length; i < len; i++) {
          const geo = geometries[i] // Only support polygon.

          if (geo.type !== 'polygon') {
            continue
          }

          const exterior = geo.exterior
          const interiors = geo.interiors

          if (contain$2(exterior, coord[0], coord[1])) {
            // Not in the region if point is in the hole.
            for (let k = 0; k < (interiors ? interiors.length : 0); k++) {
              if (contain$2(interiors[k], coord[0], coord[1])) {
                continue loopGeo
              }
            }

            return true
          }
        }

        return false
      }
      /**
       * Transform the raw coords to target bounding.
       * @param x
       * @param y
       * @param width
       * @param height
       */

      GeoJSONRegion.prototype.transformTo = function (x, y, width, height) {
        let rect = this.getBoundingRect()
        const aspect = rect.width / rect.height

        if (!width) {
          width = aspect * height
        } else if (!height) {
          height = width / aspect
        }

        const target = new BoundingRect(x, y, width, height)
        const transform = rect.calculateTransform(target)
        const geometries = this.geometries

        for (let i = 0; i < geometries.length; i++) {
          const geo = geometries[i]

          if (geo.type === 'polygon') {
            transformPoints(geo.exterior, transform)
            each(geo.interiors, function (interior) {
              transformPoints(interior, transform)
            })
          } else {
            each(geo.points, function (points) {
              transformPoints(points, transform)
            })
          }
        }

        rect = this._rect
        rect.copy(target) // Update center

        this._center = [rect.x + rect.width / 2, rect.y + rect.height / 2]
      }

      GeoJSONRegion.prototype.cloneShallow = function (name) {
        name == null && (name = this.name)
        const newRegion = new GeoJSONRegion(name, this.geometries, this._center)
        newRegion._rect = this._rect
        newRegion.transformTo = null // Simply avoid to be called.

        return newRegion
      }

      return GeoJSONRegion
    }(Region))

  const GeoSVGRegion =
    /** @class */
    (function (_super) {
      __extends(GeoSVGRegion, _super)

      function GeoSVGRegion (name, elOnlyForCalculate) {
        const _this = _super.call(this, name) || this

        _this.type = 'geoSVG'
        _this._elOnlyForCalculate = elOnlyForCalculate
        return _this
      }

      GeoSVGRegion.prototype.calcCenter = function () {
        const el = this._elOnlyForCalculate
        const rect = el.getBoundingRect()
        const center = [rect.x + rect.width / 2, rect.y + rect.height / 2]
        const mat = identity(TMP_TRANSFORM)
        let target = el

        while (target && !target.isGeoSVGGraphicRoot) {
          mul$1(mat, target.getLocalTransform(), mat)
          target = target.parent
        }

        invert(mat, mat)
        applyTransform(center, center, mat)
        return center
      }

      return GeoSVGRegion
    }(Region))

  function decode (json) {
    if (!json.UTF8Encoding) {
      return json
    }

    const jsonCompressed = json
    let encodeScale = jsonCompressed.UTF8Scale

    if (encodeScale == null) {
      encodeScale = 1024
    }

    const features = jsonCompressed.features
    each(features, function (feature) {
      const geometry = feature.geometry
      const encodeOffsets = geometry.encodeOffsets
      const coordinates = geometry.coordinates // Geometry may be appeded manually in the script after json loaded.
      // In this case this geometry is usually not encoded.

      if (!encodeOffsets) {
        return
      }

      switch (geometry.type) {
        case 'LineString':
          geometry.coordinates = decodeRing(coordinates, encodeOffsets, encodeScale)
          break

        case 'Polygon':
          decodeRings(coordinates, encodeOffsets, encodeScale)
          break

        case 'MultiLineString':
          decodeRings(coordinates, encodeOffsets, encodeScale)
          break

        case 'MultiPolygon':
          each(coordinates, function (rings, idx) {
            return decodeRings(rings, encodeOffsets[idx], encodeScale)
          })
      }
    }) // Has been decoded

    jsonCompressed.UTF8Encoding = false
    return jsonCompressed
  }

  function decodeRings (rings, encodeOffsets, encodeScale) {
    for (let c = 0; c < rings.length; c++) {
      rings[c] = decodeRing(rings[c], encodeOffsets[c], encodeScale)
    }
  }

  function decodeRing (coordinate, encodeOffsets, encodeScale) {
    const result = []
    let prevX = encodeOffsets[0]
    let prevY = encodeOffsets[1]

    for (let i = 0; i < coordinate.length; i += 2) {
      let x = coordinate.charCodeAt(i) - 64
      let y = coordinate.charCodeAt(i + 1) - 64 // ZigZag decoding

      x = x >> 1 ^ -(x & 1)
      y = y >> 1 ^ -(y & 1) // Delta deocding

      x += prevX
      y += prevY
      prevX = x
      prevY = y // Dequantize

      result.push([x / encodeScale, y / encodeScale])
    }

    return result
  }

  function parseGeoJSON (geoJson, nameProperty) {
    geoJson = decode(geoJson)
    return map(filter(geoJson.features, function (featureObj) {
      // Output of mapshaper may have geometry null
      return featureObj.geometry && featureObj.properties && featureObj.geometry.coordinates.length > 0
    }), function (featureObj) {
      const properties = featureObj.properties
      const geo = featureObj.geometry
      const geometries = []

      switch (geo.type) {
        case 'Polygon':
          var coordinates = geo.coordinates // According to the GeoJSON specification.
          // First must be exterior, and the rest are all interior(holes).

          geometries.push(new GeoJSONPolygonGeometry(coordinates[0], coordinates.slice(1)))
          break

        case 'MultiPolygon':
          each(geo.coordinates, function (item) {
            if (item[0]) {
              geometries.push(new GeoJSONPolygonGeometry(item[0], item.slice(1)))
            }
          })
          break

        case 'LineString':
          geometries.push(new GeoJSONLineStringGeometry([geo.coordinates]))
          break

        case 'MultiLineString':
          geometries.push(new GeoJSONLineStringGeometry(geo.coordinates))
      }

      const region = new GeoJSONRegion(properties[nameProperty || 'name'], geometries, properties.cp)
      region.properties = properties
      return region
    })
  }

  const number = /* #__PURE__ */Object.freeze({
    __proto__: null,
    linearMap: linearMap,
    round: round,
    asc: asc,
    getPrecision: getPrecision,
    getPrecisionSafe: getPrecisionSafe,
    getPixelPrecision: getPixelPrecision,
    getPercentWithPrecision: getPercentWithPrecision,
    MAX_SAFE_INTEGER: MAX_SAFE_INTEGER,
    remRadian: remRadian,
    isRadianAroundZero: isRadianAroundZero,
    parseDate: parseDate,
    quantity: quantity,
    quantityExponent: quantityExponent,
    nice: nice,
    quantile: quantile,
    reformIntervals: reformIntervals,
    isNumeric: isNumeric,
    numericToNumber: numericToNumber
  })

  const time = /* #__PURE__ */Object.freeze({
    __proto__: null,
    parse: parseDate,
    format: format
  })

  const graphic$1 = /* #__PURE__ */Object.freeze({
    __proto__: null,
    extendShape: extendShape,
    extendPath: extendPath,
    makePath: makePath,
    makeImage: makeImage,
    mergePath: mergePath$1,
    resizePath: resizePath,
    createIcon: createIcon,
    updateProps: updateProps,
    initProps: initProps,
    getTransform: getTransform,
    clipPointsByRect: clipPointsByRect,
    clipRectByRect: clipRectByRect,
    registerShape: registerShape,
    getShapeClass: getShapeClass,
    Group: Group,
    Image: ZRImage,
    Text: ZRText,
    Circle: Circle,
    Ellipse: Ellipse,
    Sector: Sector,
    Ring: Ring,
    Polygon: Polygon,
    Polyline: Polyline,
    Rect: Rect,
    Line: Line,
    BezierCurve: BezierCurve,
    Arc: Arc,
    IncrementalDisplayable: IncrementalDisplayable,
    CompoundPath: CompoundPath,
    LinearGradient: LinearGradient,
    RadialGradient: RadialGradient,
    BoundingRect: BoundingRect
  })

  const format$1 = /* #__PURE__ */Object.freeze({
    __proto__: null,
    addCommas: addCommas,
    toCamelCase: toCamelCase,
    normalizeCssArray: normalizeCssArray$1,
    encodeHTML: encodeHTML,
    formatTpl: formatTpl,
    getTooltipMarker: getTooltipMarker,
    formatTime: formatTime,
    capitalFirst: capitalFirst,
    truncateText: truncateText,
    getTextRect: getTextRect
  })

  const util$1 = /* #__PURE__ */Object.freeze({
    __proto__: null,
    map: map,
    each: each,
    indexOf: indexOf,
    inherits: inherits,
    reduce: reduce,
    filter: filter,
    bind: bind,
    curry: curry,
    isArray: isArray,
    isString: isString,
    isObject: isObject,
    isFunction: isFunction,
    extend: extend,
    defaults: defaults,
    clone: clone,
    merge: merge
  })

  const inner$5 = makeInner()
  function createAxisLabels (axis) {
    // Only ordinal scale support tick interval
    return axis.type === 'category' ? makeCategoryLabels(axis) : makeRealNumberLabels(axis)
  }
  /**
     * @param {module:echats/coord/Axis} axis
     * @param {module:echarts/model/Model} tickModel For example, can be axisTick, splitLine, splitArea.
     * @return {Object} {
     *     ticks: Array.<number>
     *     tickCategoryInterval: number
     * }
     */

  function createAxisTicks (axis, tickModel) {
    // Only ordinal scale support tick interval
    return axis.type === 'category'
      ? makeCategoryTicks(axis, tickModel)
      : {
          ticks: map(axis.scale.getTicks(), function (tick) {
            return tick.value
          })
        }
  }

  function makeCategoryLabels (axis) {
    const labelModel = axis.getLabelModel()
    const result = makeCategoryLabelsActually(axis, labelModel)
    return !labelModel.get('show') || axis.scale.isBlank()
      ? {
          labels: [],
          labelCategoryInterval: result.labelCategoryInterval
        }
      : result
  }

  function makeCategoryLabelsActually (axis, labelModel) {
    const labelsCache = getListCache(axis, 'labels')
    const optionLabelInterval = getOptionCategoryInterval(labelModel)
    const result = listCacheGet(labelsCache, optionLabelInterval)

    if (result) {
      return result
    }

    let labels
    let numericLabelInterval

    if (isFunction(optionLabelInterval)) {
      labels = makeLabelsByCustomizedCategoryInterval(axis, optionLabelInterval)
    } else {
      numericLabelInterval = optionLabelInterval === 'auto' ? makeAutoCategoryInterval(axis) : optionLabelInterval
      labels = makeLabelsByNumericCategoryInterval(axis, numericLabelInterval)
    } // Cache to avoid calling interval function repeatly.

    return listCacheSet(labelsCache, optionLabelInterval, {
      labels: labels,
      labelCategoryInterval: numericLabelInterval
    })
  }

  function makeCategoryTicks (axis, tickModel) {
    const ticksCache = getListCache(axis, 'ticks')
    const optionTickInterval = getOptionCategoryInterval(tickModel)
    const result = listCacheGet(ticksCache, optionTickInterval)

    if (result) {
      return result
    }

    let ticks
    let tickCategoryInterval // Optimize for the case that large category data and no label displayed,
    // we should not return all ticks.

    if (!tickModel.get('show') || axis.scale.isBlank()) {
      ticks = []
    }

    if (isFunction(optionTickInterval)) {
      ticks = makeLabelsByCustomizedCategoryInterval(axis, optionTickInterval, true)
    } // Always use label interval by default despite label show. Consider this
    // scenario, Use multiple grid with the xAxis sync, and only one xAxis shows
    // labels. `splitLine` and `axisTick` should be consistent in this case.
    else if (optionTickInterval === 'auto') {
      const labelsResult = makeCategoryLabelsActually(axis, axis.getLabelModel())
      tickCategoryInterval = labelsResult.labelCategoryInterval
      ticks = map(labelsResult.labels, function (labelItem) {
        return labelItem.tickValue
      })
    } else {
      tickCategoryInterval = optionTickInterval
      ticks = makeLabelsByNumericCategoryInterval(axis, tickCategoryInterval, true)
    } // Cache to avoid calling interval function repeatly.

    return listCacheSet(ticksCache, optionTickInterval, {
      ticks: ticks,
      tickCategoryInterval: tickCategoryInterval
    })
  }

  function makeRealNumberLabels (axis) {
    const ticks = axis.scale.getTicks()
    const labelFormatter = makeLabelFormatter(axis)
    return {
      labels: map(ticks, function (tick, idx) {
        return {
          level: tick.level,
          formattedLabel: labelFormatter(tick, idx),
          rawLabel: axis.scale.getLabel(tick),
          tickValue: tick.value
        }
      })
    }
  }

  function getListCache (axis, prop) {
    // Because key can be funciton, and cache size always be small, we use array cache.
    return inner$5(axis)[prop] || (inner$5(axis)[prop] = [])
  }

  function listCacheGet (cache, key) {
    for (let i = 0; i < cache.length; i++) {
      if (cache[i].key === key) {
        return cache[i].value
      }
    }
  }

  function listCacheSet (cache, key, value) {
    cache.push({
      key: key,
      value: value
    })
    return value
  }

  function makeAutoCategoryInterval (axis) {
    const result = inner$5(axis).autoInterval
    return result != null ? result : inner$5(axis).autoInterval = axis.calculateCategoryInterval()
  }
  /**
     * Calculate interval for category axis ticks and labels.
     * To get precise result, at least one of `getRotate` and `isHorizontal`
     * should be implemented in axis.
     */

  function calculateCategoryInterval (axis) {
    const params = fetchAutoCategoryIntervalCalculationParams(axis)
    const labelFormatter = makeLabelFormatter(axis)
    const rotation = (params.axisRotate - params.labelRotate) / 180 * Math.PI
    const ordinalScale = axis.scale
    const ordinalExtent = ordinalScale.getExtent() // Providing this method is for optimization:
    // avoid generating a long array by `getTicks`
    // in large category data case.

    const tickCount = ordinalScale.count()

    if (ordinalExtent[1] - ordinalExtent[0] < 1) {
      return 0
    }

    let step = 1 // Simple optimization. Empirical value: tick count should less than 40.

    if (tickCount > 40) {
      step = Math.max(1, Math.floor(tickCount / 40))
    }

    let tickValue = ordinalExtent[0]
    const unitSpan = axis.dataToCoord(tickValue + 1) - axis.dataToCoord(tickValue)
    const unitW = Math.abs(unitSpan * Math.cos(rotation))
    const unitH = Math.abs(unitSpan * Math.sin(rotation))
    let maxW = 0
    let maxH = 0 // Caution: Performance sensitive for large category data.
    // Consider dataZoom, we should make appropriate step to avoid O(n) loop.

    for (; tickValue <= ordinalExtent[1]; tickValue += step) {
      let width = 0
      let height = 0 // Not precise, do not consider align and vertical align
      // and each distance from axis line yet.

      const rect = getBoundingRect(labelFormatter({
        value: tickValue
      }), params.font, 'center', 'top') // Magic number

      width = rect.width * 1.3
      height = rect.height * 1.3 // Min size, void long loop.

      maxW = Math.max(maxW, width, 7)
      maxH = Math.max(maxH, height, 7)
    }

    let dw = maxW / unitW
    let dh = maxH / unitH // 0/0 is NaN, 1/0 is Infinity.

    isNaN(dw) && (dw = Infinity)
    isNaN(dh) && (dh = Infinity)
    let interval = Math.max(0, Math.floor(Math.min(dw, dh)))
    const cache = inner$5(axis.model)
    const axisExtent = axis.getExtent()
    const lastAutoInterval = cache.lastAutoInterval
    const lastTickCount = cache.lastTickCount // Use cache to keep interval stable while moving zoom window,
    // otherwise the calculated interval might jitter when the zoom
    // window size is close to the interval-changing size.
    // For example, if all of the axis labels are `a, b, c, d, e, f, g`.
    // The jitter will cause that sometimes the displayed labels are
    // `a, d, g` (interval: 2) sometimes `a, c, e`(interval: 1).

    if (lastAutoInterval != null && lastTickCount != null && Math.abs(lastAutoInterval - interval) <= 1 && Math.abs(lastTickCount - tickCount) <= 1 && // Always choose the bigger one, otherwise the critical
      // point is not the same when zooming in or zooming out.
      lastAutoInterval > interval && // If the axis change is caused by chart resize, the cache should not
      // be used. Otherwise some hiden labels might not be shown again.
      cache.axisExtent0 === axisExtent[0] && cache.axisExtent1 === axisExtent[1]) {
      interval = lastAutoInterval
    } // Only update cache if cache not used, otherwise the
    // changing of interval is too insensitive.
    else {
      cache.lastTickCount = tickCount
      cache.lastAutoInterval = interval
      cache.axisExtent0 = axisExtent[0]
      cache.axisExtent1 = axisExtent[1]
    }

    return interval
  }

  function fetchAutoCategoryIntervalCalculationParams (axis) {
    const labelModel = axis.getLabelModel()
    return {
      axisRotate: axis.getRotate ? axis.getRotate() : axis.isHorizontal && !axis.isHorizontal() ? 90 : 0,
      labelRotate: labelModel.get('rotate') || 0,
      font: labelModel.getFont()
    }
  }

  function makeLabelsByNumericCategoryInterval (axis, categoryInterval, onlyTick) {
    const labelFormatter = makeLabelFormatter(axis)
    const ordinalScale = axis.scale
    const ordinalExtent = ordinalScale.getExtent()
    const labelModel = axis.getLabelModel()
    const result = [] // TODO: axisType: ordinalTime, pick the tick from each month/day/year/...

    const step = Math.max((categoryInterval || 0) + 1, 1)
    let startTick = ordinalExtent[0]
    const tickCount = ordinalScale.count() // Calculate start tick based on zero if possible to keep label consistent
    // while zooming and moving while interval > 0. Otherwise the selection
    // of displayable ticks and symbols probably keep changing.
    // 3 is empirical value.

    if (startTick !== 0 && step > 1 && tickCount / step > 2) {
      startTick = Math.round(Math.ceil(startTick / step) * step)
    } // (1) Only add min max label here but leave overlap checking
    // to render stage, which also ensure the returned list
    // suitable for splitLine and splitArea rendering.
    // (2) Scales except category always contain min max label so
    // do not need to perform this process.

    const showAllLabel = shouldShowAllLabels(axis)
    const includeMinLabel = labelModel.get('showMinLabel') || showAllLabel
    const includeMaxLabel = labelModel.get('showMaxLabel') || showAllLabel

    if (includeMinLabel && startTick !== ordinalExtent[0]) {
      addItem(ordinalExtent[0])
    } // Optimize: avoid generating large array by `ordinalScale.getTicks()`.

    let tickValue = startTick

    for (; tickValue <= ordinalExtent[1]; tickValue += step) {
      addItem(tickValue)
    }

    if (includeMaxLabel && tickValue - step !== ordinalExtent[1]) {
      addItem(ordinalExtent[1])
    }

    function addItem (tickValue) {
      const tickObj = {
        value: tickValue
      }
      result.push(onlyTick
        ? tickValue
        : {
            formattedLabel: labelFormatter(tickObj),
            rawLabel: ordinalScale.getLabel(tickObj),
            tickValue: tickValue
          })
    }

    return result
  }

  function makeLabelsByCustomizedCategoryInterval (axis, categoryInterval, onlyTick) {
    const ordinalScale = axis.scale
    const labelFormatter = makeLabelFormatter(axis)
    const result = []
    each(ordinalScale.getTicks(), function (tick) {
      const rawLabel = ordinalScale.getLabel(tick)
      const tickValue = tick.value

      if (categoryInterval(tick.value, rawLabel)) {
        result.push(onlyTick
          ? tickValue
          : {
              formattedLabel: labelFormatter(tick),
              rawLabel: rawLabel,
              tickValue: tickValue
            })
      }
    })
    return result
  }

  const NORMALIZED_EXTENT = [0, 1]
  /**
     * Base class of Axis.
     */

  const Axis =
    /** @class */
    (function () {
      function Axis (dim, scale, extent) {
        this.onBand = false
        this.inverse = false
        this.dim = dim
        this.scale = scale
        this._extent = extent || [0, 0]
      }
      /**
       * If axis extent contain given coord
       */

      Axis.prototype.contain = function (coord) {
        const extent = this._extent
        const min = Math.min(extent[0], extent[1])
        const max = Math.max(extent[0], extent[1])
        return coord >= min && coord <= max
      }
      /**
       * If axis extent contain given data
       */

      Axis.prototype.containData = function (data) {
        return this.scale.contain(data)
      }
      /**
       * Get coord extent.
       */

      Axis.prototype.getExtent = function () {
        return this._extent.slice()
      }
      /**
       * Get precision used for formatting
       */

      Axis.prototype.getPixelPrecision = function (dataExtent) {
        return getPixelPrecision(dataExtent || this.scale.getExtent(), this._extent)
      }
      /**
       * Set coord extent
       */

      Axis.prototype.setExtent = function (start, end) {
        const extent = this._extent
        extent[0] = start
        extent[1] = end
      }
      /**
       * Convert data to coord. Data is the rank if it has an ordinal scale
       */

      Axis.prototype.dataToCoord = function (data, clamp) {
        let extent = this._extent
        const scale = this.scale
        data = scale.normalize(data)

        if (this.onBand && scale.type === 'ordinal') {
          extent = extent.slice()
          fixExtentWithBands(extent, scale.count())
        }

        return linearMap(data, NORMALIZED_EXTENT, extent, clamp)
      }
      /**
       * Convert coord to data. Data is the rank if it has an ordinal scale
       */

      Axis.prototype.coordToData = function (coord, clamp) {
        let extent = this._extent
        const scale = this.scale

        if (this.onBand && scale.type === 'ordinal') {
          extent = extent.slice()
          fixExtentWithBands(extent, scale.count())
        }

        const t = linearMap(coord, extent, NORMALIZED_EXTENT, clamp)
        return this.scale.scale(t)
      }
      /**
       * Convert pixel point to data in axis
       */

      Axis.prototype.pointToData = function (point, clamp) {
        // Should be implemented in derived class if necessary.

      }
      /**
       * Different from `zrUtil.map(axis.getTicks(), axis.dataToCoord, axis)`,
       * `axis.getTicksCoords` considers `onBand`, which is used by
       * `boundaryGap:true` of category axis and splitLine and splitArea.
       * @param opt.tickModel default: axis.model.getModel('axisTick')
       * @param opt.clamp If `true`, the first and the last
       *        tick must be at the axis end points. Otherwise, clip ticks
       *        that outside the axis extent.
       */

      Axis.prototype.getTicksCoords = function (opt) {
        opt = opt || {}
        const tickModel = opt.tickModel || this.getTickModel()
        const result = createAxisTicks(this, tickModel)
        const ticks = result.ticks
        const ticksCoords = map(ticks, function (tickVal) {
          return {
            coord: this.dataToCoord(this.scale.type === 'ordinal' ? this.scale.getRawOrdinalNumber(tickVal) : tickVal),
            tickValue: tickVal
          }
        }, this)
        const alignWithLabel = tickModel.get('alignWithLabel')
        fixOnBandTicksCoords(this, ticksCoords, alignWithLabel, opt.clamp)
        return ticksCoords
      }

      Axis.prototype.getMinorTicksCoords = function () {
        if (this.scale.type === 'ordinal') {
          // Category axis doesn't support minor ticks
          return []
        }

        const minorTickModel = this.model.getModel('minorTick')
        let splitNumber = minorTickModel.get('splitNumber') // Protection.

        if (!(splitNumber > 0 && splitNumber < 100)) {
          splitNumber = 5
        }

        const minorTicks = this.scale.getMinorTicks(splitNumber)
        const minorTicksCoords = map(minorTicks, function (minorTicksGroup) {
          return map(minorTicksGroup, function (minorTick) {
            return {
              coord: this.dataToCoord(minorTick),
              tickValue: minorTick
            }
          }, this)
        }, this)
        return minorTicksCoords
      }

      Axis.prototype.getViewLabels = function () {
        return createAxisLabels(this).labels
      }

      Axis.prototype.getLabelModel = function () {
        return this.model.getModel('axisLabel')
      }
      /**
       * Notice here we only get the default tick model. For splitLine
       * or splitArea, we should pass the splitLineModel or splitAreaModel
       * manually when calling `getTicksCoords`.
       * In GL, this method may be overrided to:
       * `axisModel.getModel('axisTick', grid3DModel.getModel('axisTick'));`
       */

      Axis.prototype.getTickModel = function () {
        return this.model.getModel('axisTick')
      }
      /**
       * Get width of band
       */

      Axis.prototype.getBandWidth = function () {
        const axisExtent = this._extent
        const dataExtent = this.scale.getExtent()
        let len = dataExtent[1] - dataExtent[0] + (this.onBand ? 1 : 0) // Fix #2728, avoid NaN when only one data.

        len === 0 && (len = 1)
        const size = Math.abs(axisExtent[1] - axisExtent[0])
        return Math.abs(size) / len
      }
      /**
       * Only be called in category axis.
       * Can be overrided, consider other axes like in 3D.
       * @return Auto interval for cateogry axis tick and label
       */

      Axis.prototype.calculateCategoryInterval = function () {
        return calculateCategoryInterval(this)
      }

      return Axis
    }())

  function fixExtentWithBands (extent, nTick) {
    const size = extent[1] - extent[0]
    const len = nTick
    const margin = size / len / 2
    extent[0] += margin
    extent[1] -= margin
  } // If axis has labels [1, 2, 3, 4]. Bands on the axis are
  // |---1---|---2---|---3---|---4---|.
  // So the displayed ticks and splitLine/splitArea should between
  // each data item, otherwise cause misleading (e.g., split tow bars
  // of a single data item when there are two bar series).
  // Also consider if tickCategoryInterval > 0 and onBand, ticks and
  // splitLine/spliteArea should layout appropriately corresponding
  // to displayed labels. (So we should not use `getBandWidth` in this
  // case).

  function fixOnBandTicksCoords (axis, ticksCoords, alignWithLabel, clamp) {
    const ticksLen = ticksCoords.length

    if (!axis.onBand || alignWithLabel || !ticksLen) {
      return
    }

    const axisExtent = axis.getExtent()
    let last
    let diffSize

    if (ticksLen === 1) {
      ticksCoords[0].coord = axisExtent[0]
      last = ticksCoords[1] = {
        coord: axisExtent[0]
      }
    } else {
      const crossLen = ticksCoords[ticksLen - 1].tickValue - ticksCoords[0].tickValue
      const shift_1 = (ticksCoords[ticksLen - 1].coord - ticksCoords[0].coord) / crossLen
      each(ticksCoords, function (ticksItem) {
        ticksItem.coord -= shift_1 / 2
      })
      const dataExtent = axis.scale.getExtent()
      diffSize = 1 + dataExtent[1] - ticksCoords[ticksLen - 1].tickValue
      last = {
        coord: ticksCoords[ticksLen - 1].coord + shift_1 * diffSize
      }
      ticksCoords.push(last)
    }

    const inverse = axisExtent[0] > axisExtent[1] // Handling clamp.

    if (littleThan(ticksCoords[0].coord, axisExtent[0])) {
      clamp ? ticksCoords[0].coord = axisExtent[0] : ticksCoords.shift()
    }

    if (clamp && littleThan(axisExtent[0], ticksCoords[0].coord)) {
      ticksCoords.unshift({
        coord: axisExtent[0]
      })
    }

    if (littleThan(axisExtent[1], last.coord)) {
      clamp ? last.coord = axisExtent[1] : ticksCoords.pop()
    }

    if (clamp && littleThan(last.coord, axisExtent[1])) {
      ticksCoords.push({
        coord: axisExtent[1]
      })
    }

    function littleThan (a, b) {
      // Avoid rounding error cause calculated tick coord different with extent.
      // It may cause an extra unecessary tick added.
      a = round(a)
      b = round(b)
      return inverse ? a > b : a < b
    }
  }

  // Should use `ComponentModel.extend` or `class XXXX extend ComponentModel` to create class.
  // Then use `registerComponentModel` in `install` parameter when `use` this extension. For example:
  // class Bar3DModel extends ComponentModel {}
  // export function install(registers) { regsiters.registerComponentModel(Bar3DModel); }
  // echarts.use(install);

  function extendComponentModel (proto) {
    const Model = ComponentModel.extend(proto)
    ComponentModel.registerClass(Model)
    return Model
  }
  function extendComponentView (proto) {
    const View = ComponentView.extend(proto)
    ComponentView.registerClass(View)
    return View
  }
  function extendSeriesModel (proto) {
    const Model = SeriesModel.extend(proto)
    SeriesModel.registerClass(Model)
    return Model
  }
  function extendChartView (proto) {
    const View = ChartView.extend(proto)
    ChartView.registerClass(View)
    return View
  }

  const PI2$6 = Math.PI * 2
  const CMD$3 = PathProxy.CMD
  const DEFAULT_SEARCH_SPACE = ['top', 'right', 'bottom', 'left']

  function getCandidateAnchor (pos, distance, rect, outPt, outDir) {
    const width = rect.width
    const height = rect.height

    switch (pos) {
      case 'top':
        outPt.set(rect.x + width / 2, rect.y - distance)
        outDir.set(0, -1)
        break

      case 'bottom':
        outPt.set(rect.x + width / 2, rect.y + height + distance)
        outDir.set(0, 1)
        break

      case 'left':
        outPt.set(rect.x - distance, rect.y + height / 2)
        outDir.set(-1, 0)
        break

      case 'right':
        outPt.set(rect.x + width + distance, rect.y + height / 2)
        outDir.set(1, 0)
        break
    }
  }

  function projectPointToArc (cx, cy, r, startAngle, endAngle, anticlockwise, x, y, out) {
    x -= cx
    y -= cy
    const d = Math.sqrt(x * x + y * y)
    x /= d
    y /= d // Intersect point.

    const ox = x * r + cx
    const oy = y * r + cy

    if (Math.abs(startAngle - endAngle) % PI2$6 < 1e-4) {
      // Is a circle
      out[0] = ox
      out[1] = oy
      return d - r
    }

    if (anticlockwise) {
      const tmp = startAngle
      startAngle = normalizeRadian(endAngle)
      endAngle = normalizeRadian(tmp)
    } else {
      startAngle = normalizeRadian(startAngle)
      endAngle = normalizeRadian(endAngle)
    }

    if (startAngle > endAngle) {
      endAngle += PI2$6
    }

    let angle = Math.atan2(y, x)

    if (angle < 0) {
      angle += PI2$6
    }

    if (angle >= startAngle && angle <= endAngle || angle + PI2$6 >= startAngle && angle + PI2$6 <= endAngle) {
      // Project point is on the arc.
      out[0] = ox
      out[1] = oy
      return d - r
    }

    const x1 = r * Math.cos(startAngle) + cx
    const y1 = r * Math.sin(startAngle) + cy
    const x2 = r * Math.cos(endAngle) + cx
    const y2 = r * Math.sin(endAngle) + cy
    const d1 = (x1 - x) * (x1 - x) + (y1 - y) * (y1 - y)
    const d2 = (x2 - x) * (x2 - x) + (y2 - y) * (y2 - y)

    if (d1 < d2) {
      out[0] = x1
      out[1] = y1
      return Math.sqrt(d1)
    } else {
      out[0] = x2
      out[1] = y2
      return Math.sqrt(d2)
    }
  }

  function projectPointToLine (x1, y1, x2, y2, x, y, out, limitToEnds) {
    const dx = x - x1
    const dy = y - y1
    let dx1 = x2 - x1
    let dy1 = y2 - y1
    const lineLen = Math.sqrt(dx1 * dx1 + dy1 * dy1)
    dx1 /= lineLen
    dy1 /= lineLen // dot product

    const projectedLen = dx * dx1 + dy * dy1
    let t = projectedLen / lineLen

    if (limitToEnds) {
      t = Math.min(Math.max(t, 0), 1)
    }

    t *= lineLen
    const ox = out[0] = x1 + t * dx1
    const oy = out[1] = y1 + t * dy1
    return Math.sqrt((ox - x) * (ox - x) + (oy - y) * (oy - y))
  }

  function projectPointToRect (x1, y1, width, height, x, y, out) {
    if (width < 0) {
      x1 = x1 + width
      width = -width
    }

    if (height < 0) {
      y1 = y1 + height
      height = -height
    }

    const x2 = x1 + width
    const y2 = y1 + height
    const ox = out[0] = Math.min(Math.max(x, x1), x2)
    const oy = out[1] = Math.min(Math.max(y, y1), y2)
    return Math.sqrt((ox - x) * (ox - x) + (oy - y) * (oy - y))
  }

  const tmpPt = []

  function nearestPointOnRect (pt, rect, out) {
    const dist = projectPointToRect(rect.x, rect.y, rect.width, rect.height, pt.x, pt.y, tmpPt)
    out.set(tmpPt[0], tmpPt[1])
    return dist
  }
  /**
     * Calculate min distance corresponding point.
     * This method won't evaluate if point is in the path.
     */

  function nearestPointOnPath (pt, path, out) {
    let xi = 0
    let yi = 0
    let x0 = 0
    let y0 = 0
    let x1
    let y1
    let minDist = Infinity
    const data = path.data
    const x = pt.x
    const y = pt.y

    for (let i = 0; i < data.length;) {
      const cmd = data[i++]

      if (i === 1) {
        xi = data[i]
        yi = data[i + 1]
        x0 = xi
        y0 = yi
      }

      let d = minDist

      switch (cmd) {
        case CMD$3.M:
          // moveTo 命令重新创建一个新的 subpath, 并且更新新的起点
          // 在 closePath 的时候使用
          x0 = data[i++]
          y0 = data[i++]
          xi = x0
          yi = y0
          break

        case CMD$3.L:
          d = projectPointToLine(xi, yi, data[i], data[i + 1], x, y, tmpPt, true)
          xi = data[i++]
          yi = data[i++]
          break

        case CMD$3.C:
          d = cubicProjectPoint(xi, yi, data[i++], data[i++], data[i++], data[i++], data[i], data[i + 1], x, y, tmpPt)
          xi = data[i++]
          yi = data[i++]
          break

        case CMD$3.Q:
          d = quadraticProjectPoint(xi, yi, data[i++], data[i++], data[i], data[i + 1], x, y, tmpPt)
          xi = data[i++]
          yi = data[i++]
          break

        case CMD$3.A:
          // TODO Arc 判断的开销比较大
          var cx = data[i++]
          var cy = data[i++]
          var rx = data[i++]
          var ry = data[i++]
          var theta = data[i++]
          var dTheta = data[i++] // TODO Arc 旋转

          i += 1
          var anticlockwise = !!(1 - data[i++])
          x1 = Math.cos(theta) * rx + cx
          y1 = Math.sin(theta) * ry + cy // 不是直接使用 arc 命令

          if (i <= 1) {
            // 第一个命令起点还未定义
            x0 = x1
            y0 = y1
          } // zr 使用scale来模拟椭圆, 这里也对x做一定的缩放

          var _x = (x - cx) * ry / rx + cx

          d = projectPointToArc(cx, cy, ry, theta, theta + dTheta, anticlockwise, _x, y, tmpPt)
          xi = Math.cos(theta + dTheta) * rx + cx
          yi = Math.sin(theta + dTheta) * ry + cy
          break

        case CMD$3.R:
          x0 = xi = data[i++]
          y0 = yi = data[i++]
          var width = data[i++]
          var height = data[i++]
          d = projectPointToRect(x0, y0, width, height, x, y, tmpPt)
          break

        case CMD$3.Z:
          d = projectPointToLine(xi, yi, x0, y0, x, y, tmpPt, true)
          xi = x0
          yi = y0
          break
      }

      if (d < minDist) {
        minDist = d
        out.set(tmpPt[0], tmpPt[1])
      }
    }

    return minDist
  } // Temporal varible for intermediate usage.

  const pt0 = new Point()
  const pt1 = new Point()
  const pt2 = new Point()
  const dir = new Point()
  const dir2 = new Point()
  /**
     * Calculate a proper guide line based on the label position and graphic element definition
     * @param label
     * @param labelRect
     * @param target
     * @param targetRect
     */

  function updateLabelLinePoints (target, labelLineModel) {
    if (!target) {
      return
    }

    const labelLine = target.getTextGuideLine()
    const label = target.getTextContent() // Needs to create text guide in each charts.

    if (!(label && labelLine)) {
      return
    }

    const labelGuideConfig = target.textGuideLineConfig || {}
    const points = [[0, 0], [0, 0], [0, 0]]
    const searchSpace = labelGuideConfig.candidates || DEFAULT_SEARCH_SPACE
    const labelRect = label.getBoundingRect().clone()
    labelRect.applyTransform(label.getComputedTransform())
    let minDist = Infinity
    const anchorPoint = labelGuideConfig.anchor
    const targetTransform = target.getComputedTransform()
    const targetInversedTransform = targetTransform && invert([], targetTransform)
    const len = labelLineModel.get('length2') || 0

    if (anchorPoint) {
      pt2.copy(anchorPoint)
    }

    for (let i = 0; i < searchSpace.length; i++) {
      const candidate = searchSpace[i]
      getCandidateAnchor(candidate, 0, labelRect, pt0, dir)
      Point.scaleAndAdd(pt1, pt0, dir, len) // Transform to target coord space.

      pt1.transform(targetInversedTransform) // Note: getBoundingRect will ensure the `path` being created.

      const boundingRect = target.getBoundingRect()
      const dist = anchorPoint ? anchorPoint.distance(pt1) : target instanceof Path ? nearestPointOnPath(pt1, target.path, pt2) : nearestPointOnRect(pt1, boundingRect, pt2) // TODO pt2 is in the path

      if (dist < minDist) {
        minDist = dist // Transform back to global space.

        pt1.transform(targetTransform)
        pt2.transform(targetTransform)
        pt2.toArray(points[0])
        pt1.toArray(points[1])
        pt0.toArray(points[2])
      }
    }

    limitTurnAngle(points, labelLineModel.get('minTurnAngle'))
    labelLine.setShape({
      points: points
    })
  } // Temporal variable for the limitTurnAngle function

  const tmpArr = []
  const tmpProjPoint = new Point()
  /**
     * Reduce the line segment attached to the label to limit the turn angle between two segments.
     * @param linePoints
     * @param minTurnAngle Radian of minimum turn angle. 0 - 180
     */

  function limitTurnAngle (linePoints, minTurnAngle) {
    if (!(minTurnAngle <= 180 && minTurnAngle > 0)) {
      return
    }

    minTurnAngle = minTurnAngle / 180 * Math.PI // The line points can be
    //      /pt1----pt2 (label)
    //     /
    // pt0/

    pt0.fromArray(linePoints[0])
    pt1.fromArray(linePoints[1])
    pt2.fromArray(linePoints[2])
    Point.sub(dir, pt0, pt1)
    Point.sub(dir2, pt2, pt1)
    const len1 = dir.len()
    const len2 = dir2.len()

    if (len1 < 1e-3 || len2 < 1e-3) {
      return
    }

    dir.scale(1 / len1)
    dir2.scale(1 / len2)
    const angleCos = dir.dot(dir2)
    const minTurnAngleCos = Math.cos(minTurnAngle)

    if (minTurnAngleCos < angleCos) {
      // Smaller than minTurnAngle
      // Calculate project point of pt0 on pt1-pt2
      const d = projectPointToLine(pt1.x, pt1.y, pt2.x, pt2.y, pt0.x, pt0.y, tmpArr, false)
      tmpProjPoint.fromArray(tmpArr) // Calculate new projected length with limited minTurnAngle and get the new connect point

      tmpProjPoint.scaleAndAdd(dir2, d / Math.tan(Math.PI - minTurnAngle)) // Limit the new calculated connect point between pt1 and pt2.

      const t = pt2.x !== pt1.x ? (tmpProjPoint.x - pt1.x) / (pt2.x - pt1.x) : (tmpProjPoint.y - pt1.y) / (pt2.y - pt1.y)

      if (isNaN(t)) {
        return
      }

      if (t < 0) {
        Point.copy(tmpProjPoint, pt1)
      } else if (t > 1) {
        Point.copy(tmpProjPoint, pt2)
      }

      tmpProjPoint.toArray(linePoints[1])
    }
  }
  /**
     * Limit the angle of line and the surface
     * @param maxSurfaceAngle Radian of minimum turn angle. 0 - 180. 0 is same direction to normal. 180 is opposite
     */

  function limitSurfaceAngle (linePoints, surfaceNormal, maxSurfaceAngle) {
    if (!(maxSurfaceAngle <= 180 && maxSurfaceAngle > 0)) {
      return
    }

    maxSurfaceAngle = maxSurfaceAngle / 180 * Math.PI
    pt0.fromArray(linePoints[0])
    pt1.fromArray(linePoints[1])
    pt2.fromArray(linePoints[2])
    Point.sub(dir, pt1, pt0)
    Point.sub(dir2, pt2, pt1)
    const len1 = dir.len()
    const len2 = dir2.len()

    if (len1 < 1e-3 || len2 < 1e-3) {
      return
    }

    dir.scale(1 / len1)
    dir2.scale(1 / len2)
    const angleCos = dir.dot(surfaceNormal)
    const maxSurfaceAngleCos = Math.cos(maxSurfaceAngle)

    if (angleCos < maxSurfaceAngleCos) {
      // Calculate project point of pt0 on pt1-pt2
      const d = projectPointToLine(pt1.x, pt1.y, pt2.x, pt2.y, pt0.x, pt0.y, tmpArr, false)
      tmpProjPoint.fromArray(tmpArr)
      const HALF_PI = Math.PI / 2
      const angle2 = Math.acos(dir2.dot(surfaceNormal))
      const newAngle = HALF_PI + angle2 - maxSurfaceAngle

      if (newAngle >= HALF_PI) {
        // parallel
        Point.copy(tmpProjPoint, pt2)
      } else {
        // Calculate new projected length with limited minTurnAngle and get the new connect point
        tmpProjPoint.scaleAndAdd(dir2, d / Math.tan(Math.PI / 2 - newAngle)) // Limit the new calculated connect point between pt1 and pt2.

        const t = pt2.x !== pt1.x ? (tmpProjPoint.x - pt1.x) / (pt2.x - pt1.x) : (tmpProjPoint.y - pt1.y) / (pt2.y - pt1.y)

        if (isNaN(t)) {
          return
        }

        if (t < 0) {
          Point.copy(tmpProjPoint, pt1)
        } else if (t > 1) {
          Point.copy(tmpProjPoint, pt2)
        }
      }

      tmpProjPoint.toArray(linePoints[1])
    }
  }

  function setLabelLineState (labelLine, ignore, stateName, stateModel) {
    const isNormal = stateName === 'normal'
    const stateObj = isNormal ? labelLine : labelLine.ensureState(stateName) // Make sure display.

    stateObj.ignore = ignore // Set smooth

    let smooth = stateModel.get('smooth')

    if (smooth && smooth === true) {
      smooth = 0.3
    }

    stateObj.shape = stateObj.shape || {}

    if (smooth > 0) {
      stateObj.shape.smooth = smooth
    }

    const styleObj = stateModel.getModel('lineStyle').getLineStyle()
    isNormal ? labelLine.useStyle(styleObj) : stateObj.style = styleObj
  }

  function buildLabelLinePath (path, shape) {
    const smooth = shape.smooth
    const points = shape.points

    if (!points) {
      return
    }

    path.moveTo(points[0][0], points[0][1])

    if (smooth > 0 && points.length >= 3) {
      const len1 = dist(points[0], points[1])
      const len2 = dist(points[1], points[2])

      if (!len1 || !len2) {
        path.lineTo(points[1][0], points[1][1])
        path.lineTo(points[2][0], points[2][1])
        return
      }

      const moveLen = Math.min(len1, len2) * smooth
      const midPoint0 = lerp([], points[1], points[0], moveLen / len1)
      const midPoint2 = lerp([], points[1], points[2], moveLen / len2)
      const midPoint1 = lerp([], midPoint0, midPoint2, 0.5)
      path.bezierCurveTo(midPoint0[0], midPoint0[1], midPoint0[0], midPoint0[1], midPoint1[0], midPoint1[1])
      path.bezierCurveTo(midPoint2[0], midPoint2[1], midPoint2[0], midPoint2[1], points[2][0], points[2][1])
    } else {
      for (let i = 1; i < points.length; i++) {
        path.lineTo(points[i][0], points[i][1])
      }
    }
  }
  /**
     * Create a label line if necessary and set it's style.
     */

  function setLabelLineStyle (targetEl, statesModels, defaultStyle) {
    let labelLine = targetEl.getTextGuideLine()
    const label = targetEl.getTextContent()

    if (!label) {
      // Not show label line if there is no label.
      if (labelLine) {
        targetEl.removeTextGuideLine()
      }

      return
    }

    const normalModel = statesModels.normal
    const showNormal = normalModel.get('show')
    const labelIgnoreNormal = label.ignore

    for (let i = 0; i < DISPLAY_STATES.length; i++) {
      const stateName = DISPLAY_STATES[i]
      const stateModel = statesModels[stateName]
      const isNormal = stateName === 'normal'

      if (stateModel) {
        const stateShow = stateModel.get('show')
        const isLabelIgnored = isNormal ? labelIgnoreNormal : retrieve2(label.states[stateName] && label.states[stateName].ignore, labelIgnoreNormal)

        if (isLabelIgnored || // Not show when label is not shown in this state.
          !retrieve2(stateShow, showNormal) // Use normal state by default if not set.
        ) {
          const stateObj = isNormal ? labelLine : labelLine && labelLine.states[stateName]

          if (stateObj) {
            stateObj.ignore = true
          }

          continue
        } // Create labelLine if not exists

        if (!labelLine) {
          labelLine = new Polyline()
          targetEl.setTextGuideLine(labelLine) // Reset state of normal because it's new created.
          // NOTE: NORMAL should always been the first!

          if (!isNormal && (labelIgnoreNormal || !showNormal)) {
            setLabelLineState(labelLine, true, 'normal', statesModels.normal)
          } // Use same state proxy.

          if (targetEl.stateProxy) {
            labelLine.stateProxy = targetEl.stateProxy
          }
        }

        setLabelLineState(labelLine, false, stateName, stateModel)
      }
    }

    if (labelLine) {
      defaults(labelLine.style, defaultStyle) // Not fill.

      labelLine.style.fill = null
      const showAbove = normalModel.get('showAbove')
      const labelLineConfig = targetEl.textGuideLineConfig = targetEl.textGuideLineConfig || {}
      labelLineConfig.showAbove = showAbove || false // Custom the buildPath.

      labelLine.buildPath = buildLabelLinePath
    }
  }
  function getLabelLineStatesModels (itemModel, labelLineName) {
    labelLineName = labelLineName || 'labelLine'
    const statesModels = {
      normal: itemModel.getModel(labelLineName)
    }

    for (let i = 0; i < SPECIAL_STATES.length; i++) {
      const stateName = SPECIAL_STATES[i]
      statesModels[stateName] = itemModel.getModel([stateName, labelLineName])
    }

    return statesModels
  }

  function prepareLayoutList (input) {
    const list = []

    for (let i = 0; i < input.length; i++) {
      const rawItem = input[i]

      if (rawItem.defaultAttr.ignore) {
        continue
      }

      const label = rawItem.label
      const transform = label.getComputedTransform() // NOTE: Get bounding rect after getComputedTransform, or label may not been updated by the host el.

      const localRect = label.getBoundingRect()
      const isAxisAligned = !transform || transform[1] < 1e-5 && transform[2] < 1e-5
      const minMargin = label.style.margin || 0
      const globalRect = localRect.clone()
      globalRect.applyTransform(transform)
      globalRect.x -= minMargin / 2
      globalRect.y -= minMargin / 2
      globalRect.width += minMargin
      globalRect.height += minMargin
      const obb = isAxisAligned ? new OrientedBoundingRect(localRect, transform) : null
      list.push({
        label: label,
        labelLine: rawItem.labelLine,
        rect: globalRect,
        localRect: localRect,
        obb: obb,
        priority: rawItem.priority,
        defaultAttr: rawItem.defaultAttr,
        layoutOption: rawItem.computedLayoutOption,
        axisAligned: isAxisAligned,
        transform: transform
      })
    }

    return list
  }

  function shiftLayout (list, xyDim, sizeDim, minBound, maxBound, balanceShift) {
    const len = list.length

    if (len < 2) {
      return
    }

    list.sort(function (a, b) {
      return a.rect[xyDim] - b.rect[xyDim]
    })
    let lastPos = 0
    let delta
    let adjusted = false
    let totalShifts = 0

    for (let i = 0; i < len; i++) {
      const item = list[i]
      const rect = item.rect
      delta = rect[xyDim] - lastPos

      if (delta < 0) {
        // shiftForward(i, len, -delta);
        rect[xyDim] -= delta
        item.label[xyDim] -= delta
        adjusted = true
      }

      const shift = Math.max(-delta, 0)
      totalShifts += shift
      lastPos = rect[xyDim] + rect[sizeDim]
    }

    if (totalShifts > 0 && balanceShift) {
      // Shift back to make the distribution more equally.
      shiftList(-totalShifts / len, 0, len)
    } // TODO bleedMargin?

    const first = list[0]
    const last = list[len - 1]
    let minGap
    let maxGap
    updateMinMaxGap() // If ends exceed two bounds, squeeze at most 80%, then take the gap of two bounds.

    minGap < 0 && squeezeGaps(-minGap, 0.8)
    maxGap < 0 && squeezeGaps(maxGap, 0.8)
    updateMinMaxGap()
    takeBoundsGap(minGap, maxGap, 1)
    takeBoundsGap(maxGap, minGap, -1) // Handle bailout when there is not enough space.

    updateMinMaxGap()

    if (minGap < 0) {
      squeezeWhenBailout(-minGap)
    }

    if (maxGap < 0) {
      squeezeWhenBailout(maxGap)
    }

    function updateMinMaxGap () {
      minGap = first.rect[xyDim] - minBound
      maxGap = maxBound - last.rect[xyDim] - last.rect[sizeDim]
    }

    function takeBoundsGap (gapThisBound, gapOtherBound, moveDir) {
      if (gapThisBound < 0) {
        // Move from other gap if can.
        const moveFromMaxGap = Math.min(gapOtherBound, -gapThisBound)

        if (moveFromMaxGap > 0) {
          shiftList(moveFromMaxGap * moveDir, 0, len)
          const remained = moveFromMaxGap + gapThisBound

          if (remained < 0) {
            squeezeGaps(-remained * moveDir, 1)
          }
        } else {
          squeezeGaps(-gapThisBound * moveDir, 1)
        }
      }
    }

    function shiftList (delta, start, end) {
      if (delta !== 0) {
        adjusted = true
      }

      for (let i = start; i < end; i++) {
        const item = list[i]
        const rect = item.rect
        rect[xyDim] += delta
        item.label[xyDim] += delta
      }
    } // Squeeze gaps if the labels exceed margin.

    function squeezeGaps (delta, maxSqeezePercent) {
      const gaps = []
      let totalGaps = 0

      for (var i = 1; i < len; i++) {
        const prevItemRect = list[i - 1].rect
        const gap = Math.max(list[i].rect[xyDim] - prevItemRect[xyDim] - prevItemRect[sizeDim], 0)
        gaps.push(gap)
        totalGaps += gap
      }

      if (!totalGaps) {
        return
      }

      const squeezePercent = Math.min(Math.abs(delta) / totalGaps, maxSqeezePercent)

      if (delta > 0) {
        for (var i = 0; i < len - 1; i++) {
          // Distribute the shift delta to all gaps.
          var movement = gaps[i] * squeezePercent // Forward

          shiftList(movement, 0, i + 1)
        }
      } else {
        // Backward
        for (var i = len - 1; i > 0; i--) {
          // Distribute the shift delta to all gaps.
          var movement = gaps[i - 1] * squeezePercent
          shiftList(-movement, i, len)
        }
      }
    }
    /**
       * Squeeze to allow overlap if there is no more space available.
       * Let other overlapping strategy like hideOverlap do the job instead of keep exceeding the bounds.
       */

    function squeezeWhenBailout (delta) {
      const dir = delta < 0 ? -1 : 1
      delta = Math.abs(delta)
      const moveForEachLabel = Math.ceil(delta / (len - 1))

      for (let i = 0; i < len - 1; i++) {
        if (dir > 0) {
          // Forward
          shiftList(moveForEachLabel, 0, i + 1)
        } else {
          // Backward
          shiftList(-moveForEachLabel, len - i - 1, len)
        }

        delta -= moveForEachLabel

        if (delta <= 0) {
          return
        }
      }
    }

    return adjusted
  }
  /**
     * Adjust labels on x direction to avoid overlap.
     */

  function shiftLayoutOnX (list, leftBound, rightBound, // If average the shifts on all labels and add them to 0
    // TODO: Not sure if should enable it.
    // Pros: The angle of lines will distribute more equally
    // Cons: In some layout. It may not what user wanted. like in pie. the label of last sector is usually changed unexpectedly.
    balanceShift) {
    return shiftLayout(list, 'x', 'width', leftBound, rightBound, balanceShift)
  }
  /**
     * Adjust labels on y direction to avoid overlap.
     */

  function shiftLayoutOnY (list, topBound, bottomBound, // If average the shifts on all labels and add them to 0
    balanceShift) {
    return shiftLayout(list, 'y', 'height', topBound, bottomBound, balanceShift)
  }
  function hideOverlap (labelList) {
    const displayedLabels = [] // TODO, render overflow visible first, put in the displayedLabels.

    labelList.sort(function (a, b) {
      return b.priority - a.priority
    })
    const globalRect = new BoundingRect(0, 0, 0, 0)

    function hideEl (el) {
      if (!el.ignore) {
        // Show on emphasis.
        const emphasisState = el.ensureState('emphasis')

        if (emphasisState.ignore == null) {
          emphasisState.ignore = false
        }
      }

      el.ignore = true
    }

    for (let i = 0; i < labelList.length; i++) {
      const labelItem = labelList[i]
      const isAxisAligned = labelItem.axisAligned
      const localRect = labelItem.localRect
      const transform = labelItem.transform
      const label = labelItem.label
      const labelLine = labelItem.labelLine
      globalRect.copy(labelItem.rect) // Add a threshold because layout may be aligned precisely.

      globalRect.width -= 0.1
      globalRect.height -= 0.1
      globalRect.x += 0.05
      globalRect.y += 0.05
      let obb = labelItem.obb
      let overlapped = false

      for (let j = 0; j < displayedLabels.length; j++) {
        const existsTextCfg = displayedLabels[j] // Fast rejection.

        if (!globalRect.intersect(existsTextCfg.rect)) {
          continue
        }

        if (isAxisAligned && existsTextCfg.axisAligned) {
          // Is overlapped
          overlapped = true
          break
        }

        if (!existsTextCfg.obb) {
          // If self is not axis aligned. But other is.
          existsTextCfg.obb = new OrientedBoundingRect(existsTextCfg.localRect, existsTextCfg.transform)
        }

        if (!obb) {
          // If self is axis aligned. But other is not.
          obb = new OrientedBoundingRect(localRect, transform)
        }

        if (obb.intersect(existsTextCfg.obb)) {
          overlapped = true
          break
        }
      } // TODO Callback to determine if this overlap should be handled?

      if (overlapped) {
        hideEl(label)
        labelLine && hideEl(labelLine)
      } else {
        label.attr('ignore', labelItem.defaultAttr.ignore)
        labelLine && labelLine.attr('ignore', labelItem.defaultAttr.labelGuideIgnore)
        displayedLabels.push(labelItem)
      }
    }
  }

  function cloneArr (points) {
    if (points) {
      const newPoints = []

      for (let i = 0; i < points.length; i++) {
        newPoints.push(points[i].slice())
      }

      return newPoints
    }
  }

  function prepareLayoutCallbackParams (labelItem, hostEl) {
    const label = labelItem.label
    const labelLine = hostEl && hostEl.getTextGuideLine()
    return {
      dataIndex: labelItem.dataIndex,
      dataType: labelItem.dataType,
      seriesIndex: labelItem.seriesModel.seriesIndex,
      text: labelItem.label.style.text,
      rect: labelItem.hostRect,
      labelRect: labelItem.rect,
      // x: labelAttr.x,
      // y: labelAttr.y,
      align: label.style.align,
      verticalAlign: label.style.verticalAlign,
      labelLinePoints: cloneArr(labelLine && labelLine.shape.points)
    }
  }

  const LABEL_OPTION_TO_STYLE_KEYS = ['align', 'verticalAlign', 'width', 'height', 'fontSize']
  const dummyTransformable = new Transformable()
  const labelLayoutInnerStore = makeInner()
  const labelLineAnimationStore = makeInner()

  function extendWithKeys (target, source, keys) {
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i]

      if (source[key] != null) {
        target[key] = source[key]
      }
    }
  }

  const LABEL_LAYOUT_PROPS = ['x', 'y', 'rotation']

  const LabelManager =
    /** @class */
    (function () {
      function LabelManager () {
        this._labelList = []
        this._chartViewList = []
      }

      LabelManager.prototype.clearLabels = function () {
        this._labelList = []
        this._chartViewList = []
      }
      /**
       * Add label to manager
       */

      LabelManager.prototype._addLabel = function (dataIndex, dataType, seriesModel, label, layoutOption) {
        const labelStyle = label.style
        const hostEl = label.__hostTarget
        const textConfig = hostEl.textConfig || {} // TODO: If label is in other state.

        const labelTransform = label.getComputedTransform()
        const labelRect = label.getBoundingRect().plain()
        BoundingRect.applyTransform(labelRect, labelRect, labelTransform)

        if (labelTransform) {
          dummyTransformable.setLocalTransform(labelTransform)
        } else {
          // Identity transform.
          dummyTransformable.x = dummyTransformable.y = dummyTransformable.rotation = dummyTransformable.originX = dummyTransformable.originY = 0
          dummyTransformable.scaleX = dummyTransformable.scaleY = 1
        }

        const host = label.__hostTarget
        let hostRect

        if (host) {
          hostRect = host.getBoundingRect().plain()
          const transform = host.getComputedTransform()
          BoundingRect.applyTransform(hostRect, hostRect, transform)
        }

        const labelGuide = hostRect && host.getTextGuideLine()

        this._labelList.push({
          label: label,
          labelLine: labelGuide,
          seriesModel: seriesModel,
          dataIndex: dataIndex,
          dataType: dataType,
          layoutOption: layoutOption,
          computedLayoutOption: null,
          rect: labelRect,
          hostRect: hostRect,
          // Label with lower priority will be hidden when overlapped
          // Use rect size as default priority
          priority: hostRect ? hostRect.width * hostRect.height : 0,
          // Save default label attributes.
          // For restore if developers want get back to default value in callback.
          defaultAttr: {
            ignore: label.ignore,
            labelGuideIgnore: labelGuide && labelGuide.ignore,
            x: dummyTransformable.x,
            y: dummyTransformable.y,
            scaleX: dummyTransformable.scaleX,
            scaleY: dummyTransformable.scaleY,
            rotation: dummyTransformable.rotation,
            style: {
              x: labelStyle.x,
              y: labelStyle.y,
              align: labelStyle.align,
              verticalAlign: labelStyle.verticalAlign,
              width: labelStyle.width,
              height: labelStyle.height,
              fontSize: labelStyle.fontSize
            },
            cursor: label.cursor,
            attachedPos: textConfig.position,
            attachedRot: textConfig.rotation
          }
        })
      }

      LabelManager.prototype.addLabelsOfSeries = function (chartView) {
        const _this = this

        this._chartViewList.push(chartView)

        const seriesModel = chartView.__model
        const layoutOption = seriesModel.get('labelLayout')
        /**
         * Ignore layouting if it's not specified anything.
         */

        if (!(isFunction(layoutOption) || keys(layoutOption).length)) {
          return
        }

        chartView.group.traverse(function (child) {
          if (child.ignore) {
            return true // Stop traverse descendants.
          } // Only support label being hosted on graphic elements.

          const textEl = child.getTextContent()
          const ecData = getECData(child) // Can only attach the text on the element with dataIndex

          if (textEl && !textEl.disableLabelLayout) {
            _this._addLabel(ecData.dataIndex, ecData.dataType, seriesModel, textEl, layoutOption)
          }
        })
      }

      LabelManager.prototype.updateLayoutConfig = function (api) {
        const width = api.getWidth()
        const height = api.getHeight()

        function createDragHandler (el, labelLineModel) {
          return function () {
            updateLabelLinePoints(el, labelLineModel)
          }
        }

        for (let i = 0; i < this._labelList.length; i++) {
          const labelItem = this._labelList[i]
          const label = labelItem.label
          const hostEl = label.__hostTarget
          const defaultLabelAttr = labelItem.defaultAttr
          let layoutOption = void 0 // TODO A global layout option?

          if (isFunction(labelItem.layoutOption)) {
            layoutOption = labelItem.layoutOption(prepareLayoutCallbackParams(labelItem, hostEl))
          } else {
            layoutOption = labelItem.layoutOption
          }

          layoutOption = layoutOption || {}
          labelItem.computedLayoutOption = layoutOption
          const degreeToRadian = Math.PI / 180 // TODO hostEl should always exists.
          // Or label should not have parent because the x, y is all in global space.

          if (hostEl) {
            hostEl.setTextConfig({
              // Force to set local false.
              local: false,
              // Ignore position and rotation config on the host el if x or y is changed.
              position: layoutOption.x != null || layoutOption.y != null ? null : defaultLabelAttr.attachedPos,
              // Ignore rotation config on the host el if rotation is changed.
              rotation: layoutOption.rotate != null ? layoutOption.rotate * degreeToRadian : defaultLabelAttr.attachedRot,
              offset: [layoutOption.dx || 0, layoutOption.dy || 0]
            })
          }

          let needsUpdateLabelLine = false

          if (layoutOption.x != null) {
            // TODO width of chart view.
            label.x = parsePercent$1(layoutOption.x, width)
            label.setStyle('x', 0) // Ignore movement in style. TODO: origin.

            needsUpdateLabelLine = true
          } else {
            label.x = defaultLabelAttr.x
            label.setStyle('x', defaultLabelAttr.style.x)
          }

          if (layoutOption.y != null) {
            // TODO height of chart view.
            label.y = parsePercent$1(layoutOption.y, height)
            label.setStyle('y', 0) // Ignore movement in style.

            needsUpdateLabelLine = true
          } else {
            label.y = defaultLabelAttr.y
            label.setStyle('y', defaultLabelAttr.style.y)
          }

          if (layoutOption.labelLinePoints) {
            const guideLine = hostEl.getTextGuideLine()

            if (guideLine) {
              guideLine.setShape({
                points: layoutOption.labelLinePoints
              }) // Not update

              needsUpdateLabelLine = false
            }
          }

          const labelLayoutStore = labelLayoutInnerStore(label)
          labelLayoutStore.needsUpdateLabelLine = needsUpdateLabelLine
          label.rotation = layoutOption.rotate != null ? layoutOption.rotate * degreeToRadian : defaultLabelAttr.rotation
          label.scaleX = defaultLabelAttr.scaleX
          label.scaleY = defaultLabelAttr.scaleY

          for (let k = 0; k < LABEL_OPTION_TO_STYLE_KEYS.length; k++) {
            const key = LABEL_OPTION_TO_STYLE_KEYS[k]
            label.setStyle(key, layoutOption[key] != null ? layoutOption[key] : defaultLabelAttr.style[key])
          }

          if (layoutOption.draggable) {
            label.draggable = true
            label.cursor = 'move'

            if (hostEl) {
              let hostModel = labelItem.seriesModel

              if (labelItem.dataIndex != null) {
                const data = labelItem.seriesModel.getData(labelItem.dataType)
                hostModel = data.getItemModel(labelItem.dataIndex)
              }

              label.on('drag', createDragHandler(hostEl, hostModel.getModel('labelLine')))
            }
          } else {
            // TODO Other drag functions?
            label.off('drag')
            label.cursor = defaultLabelAttr.cursor
          }
        }
      }

      LabelManager.prototype.layout = function (api) {
        const width = api.getWidth()
        const height = api.getHeight()
        const labelList = prepareLayoutList(this._labelList)
        const labelsNeedsAdjustOnX = filter(labelList, function (item) {
          return item.layoutOption.moveOverlap === 'shiftX'
        })
        const labelsNeedsAdjustOnY = filter(labelList, function (item) {
          return item.layoutOption.moveOverlap === 'shiftY'
        })
        shiftLayoutOnX(labelsNeedsAdjustOnX, 0, width)
        shiftLayoutOnY(labelsNeedsAdjustOnY, 0, height)
        const labelsNeedsHideOverlap = filter(labelList, function (item) {
          return item.layoutOption.hideOverlap
        })
        hideOverlap(labelsNeedsHideOverlap)
      }
      /**
       * Process all labels. Not only labels with layoutOption.
       */

      LabelManager.prototype.processLabelsOverall = function () {
        const _this = this

        each(this._chartViewList, function (chartView) {
          const seriesModel = chartView.__model
          const ignoreLabelLineUpdate = chartView.ignoreLabelLineUpdate
          const animationEnabled = seriesModel.isAnimationEnabled()
          chartView.group.traverse(function (child) {
            if (child.ignore && !child.forceLabelAnimation) {
              return true // Stop traverse descendants.
            }

            let needsUpdateLabelLine = !ignoreLabelLineUpdate
            const label = child.getTextContent()

            if (!needsUpdateLabelLine && label) {
              needsUpdateLabelLine = labelLayoutInnerStore(label).needsUpdateLabelLine
            }

            if (needsUpdateLabelLine) {
              _this._updateLabelLine(child, seriesModel)
            }

            if (animationEnabled) {
              _this._animateLabels(child, seriesModel)
            }
          })
        })
      }

      LabelManager.prototype._updateLabelLine = function (el, seriesModel) {
        // Only support label being hosted on graphic elements.
        const textEl = el.getTextContent() // Update label line style.

        const ecData = getECData(el)
        const dataIndex = ecData.dataIndex // Only support labelLine on the labels represent data.

        if (textEl && dataIndex != null) {
          const data = seriesModel.getData(ecData.dataType)
          const itemModel = data.getItemModel(dataIndex)
          const defaultStyle = {}
          const visualStyle = data.getItemVisual(dataIndex, 'style')
          const visualType = data.getVisual('drawType') // Default to be same with main color

          defaultStyle.stroke = visualStyle[visualType]
          const labelLineModel = itemModel.getModel('labelLine')
          setLabelLineStyle(el, getLabelLineStatesModels(itemModel), defaultStyle)
          updateLabelLinePoints(el, labelLineModel)
        }
      }

      LabelManager.prototype._animateLabels = function (el, seriesModel) {
        const textEl = el.getTextContent()
        const guideLine = el.getTextGuideLine() // Animate

        if (textEl && // `forceLabelAnimation` has the highest priority
        (el.forceLabelAnimation || !textEl.ignore && !textEl.invisible && !el.disableLabelAnimation && !isElementRemoved(el))) {
          var layoutStore = labelLayoutInnerStore(textEl)
          var oldLayout = layoutStore.oldLayout
          const ecData = getECData(el)
          const dataIndex = ecData.dataIndex
          const newProps = {
            x: textEl.x,
            y: textEl.y,
            rotation: textEl.rotation
          }
          const data = seriesModel.getData(ecData.dataType)

          if (!oldLayout) {
            textEl.attr(newProps) // Disable fade in animation if value animation is enabled.

            if (!labelInner(textEl).valueAnimation) {
              const oldOpacity = retrieve2(textEl.style.opacity, 1) // Fade in animation

              textEl.style.opacity = 0
              initProps(textEl, {
                style: {
                  opacity: oldOpacity
                }
              }, seriesModel, dataIndex)
            }
          } else {
            textEl.attr(oldLayout) // Make sure the animation from is in the right status.

            const prevStates = el.prevStates

            if (prevStates) {
              if (indexOf(prevStates, 'select') >= 0) {
                textEl.attr(layoutStore.oldLayoutSelect)
              }

              if (indexOf(prevStates, 'emphasis') >= 0) {
                textEl.attr(layoutStore.oldLayoutEmphasis)
              }
            }

            updateProps(textEl, newProps, seriesModel, dataIndex)
          }

          layoutStore.oldLayout = newProps

          if (textEl.states.select) {
            const layoutSelect = layoutStore.oldLayoutSelect = {}
            extendWithKeys(layoutSelect, newProps, LABEL_LAYOUT_PROPS)
            extendWithKeys(layoutSelect, textEl.states.select, LABEL_LAYOUT_PROPS)
          }

          if (textEl.states.emphasis) {
            const layoutEmphasis = layoutStore.oldLayoutEmphasis = {}
            extendWithKeys(layoutEmphasis, newProps, LABEL_LAYOUT_PROPS)
            extendWithKeys(layoutEmphasis, textEl.states.emphasis, LABEL_LAYOUT_PROPS)
          }

          animateLabelValue(textEl, dataIndex, data, seriesModel, seriesModel)
        }

        if (guideLine && !guideLine.ignore && !guideLine.invisible) {
          var layoutStore = labelLineAnimationStore(guideLine)
          var oldLayout = layoutStore.oldLayout
          const newLayout = {
            points: guideLine.shape.points
          }

          if (!oldLayout) {
            guideLine.setShape(newLayout)
            guideLine.style.strokePercent = 0
            initProps(guideLine, {
              style: {
                strokePercent: 1
              }
            }, seriesModel)
          } else {
            guideLine.attr({
              shape: oldLayout
            })
            updateProps(guideLine, {
              shape: newLayout
            }, seriesModel)
          }

          layoutStore.oldLayout = newLayout
        }
      }

      return LabelManager
    }())

  const getLabelManager = makeInner()
  function installLabelLayout (registers) {
    registers.registerUpdateLifecycle('series:beforeupdate', function (ecModel, api, params) {
      // TODO api provide an namespace that can save stuff per instance
      let labelManager = getLabelManager(api).labelManager

      if (!labelManager) {
        labelManager = getLabelManager(api).labelManager = new LabelManager()
      }

      labelManager.clearLabels()
    })
    registers.registerUpdateLifecycle('series:layoutlabels', function (ecModel, api, params) {
      const labelManager = getLabelManager(api).labelManager
      params.updatedSeries.forEach(function (series) {
        labelManager.addLabelsOfSeries(api.getViewOfSeriesModel(series))
      })
      labelManager.updateLayoutConfig(api)
      labelManager.layout(api)
      labelManager.processLabelsOverall()
    })
  }

  const mathSin$4 = Math.sin
  const mathCos$4 = Math.cos
  const PI$4 = Math.PI
  const PI2$7 = Math.PI * 2
  const degree = 180 / PI$4
  const SVGPathRebuilder = (function () {
    function SVGPathRebuilder () {
    }
    SVGPathRebuilder.prototype.reset = function (precision) {
      this._start = true
      this._d = []
      this._str = ''
      this._p = Math.pow(10, precision || 4)
    }
    SVGPathRebuilder.prototype.moveTo = function (x, y) {
      this._add('M', x, y)
    }
    SVGPathRebuilder.prototype.lineTo = function (x, y) {
      this._add('L', x, y)
    }
    SVGPathRebuilder.prototype.bezierCurveTo = function (x, y, x2, y2, x3, y3) {
      this._add('C', x, y, x2, y2, x3, y3)
    }
    SVGPathRebuilder.prototype.quadraticCurveTo = function (x, y, x2, y2) {
      this._add('Q', x, y, x2, y2)
    }
    SVGPathRebuilder.prototype.arc = function (cx, cy, r, startAngle, endAngle, anticlockwise) {
      this.ellipse(cx, cy, r, r, 0, startAngle, endAngle, anticlockwise)
    }
    SVGPathRebuilder.prototype.ellipse = function (cx, cy, rx, ry, psi, startAngle, endAngle, anticlockwise) {
      const dTheta = endAngle - startAngle
      const clockwise = !anticlockwise
      const dThetaPositive = Math.abs(dTheta)
      const isCircle = isAroundZero$1(dThetaPositive - PI2$7) ||
                (clockwise ? dTheta >= PI2$7 : -dTheta >= PI2$7)
      const unifiedTheta = dTheta > 0 ? dTheta % PI2$7 : (dTheta % PI2$7 + PI2$7)
      let large = false
      if (isCircle) {
        large = true
      } else if (isAroundZero$1(dThetaPositive)) {
        large = false
      } else {
        large = (unifiedTheta >= PI$4) === !!clockwise
      }
      const x0 = cx + rx * mathCos$4(startAngle)
      const y0 = cy + ry * mathSin$4(startAngle)
      if (this._start) {
        this._add('M', x0, y0)
      }
      const xRot = Math.round(psi * degree)
      if (isCircle) {
        const p = 1 / this._p
        const dTheta_1 = (clockwise ? 1 : -1) * (PI2$7 - p)
        this._add('A', rx, ry, xRot, 1, +clockwise, cx + rx * mathCos$4(startAngle + dTheta_1), cy + ry * mathSin$4(startAngle + dTheta_1))
        if (p > 1e-2) {
          this._add('A', rx, ry, xRot, 0, +clockwise, x0, y0)
        }
      } else {
        const x = cx + rx * mathCos$4(endAngle)
        const y = cy + ry * mathSin$4(endAngle)
        this._add('A', rx, ry, xRot, +large, +clockwise, x, y)
      }
    }
    SVGPathRebuilder.prototype.rect = function (x, y, w, h) {
      this._add('M', x, y)
      this._add('l', w, 0)
      this._add('l', 0, h)
      this._add('l', -w, 0)
      this._add('Z')
    }
    SVGPathRebuilder.prototype.closePath = function () {
      if (this._d.length > 0) {
        this._add('Z')
      }
    }
    SVGPathRebuilder.prototype._add = function (cmd, a, b, c, d, e, f, g, h) {
      const vals = []
      const p = this._p
      for (let i = 1; i < arguments.length; i++) {
        const val = arguments[i]
        if (isNaN(val)) {
          this._invalid = true
          return
        }
        vals.push(Math.round(val * p) / p)
      }
      this._d.push(cmd + vals.join(' '))
      this._start = cmd === 'Z'
    }
    SVGPathRebuilder.prototype.generateStr = function () {
      this._str = this._invalid ? '' : this._d.join('')
      this._d = []
    }
    SVGPathRebuilder.prototype.getStr = function () {
      return this._str
    }
    return SVGPathRebuilder
  }())

  const NONE = 'none'
  const mathRound$1 = Math.round
  function pathHasFill (style) {
    const fill = style.fill
    return fill != null && fill !== NONE
  }
  function pathHasStroke (style) {
    const stroke = style.stroke
    return stroke != null && stroke !== NONE
  }
  const strokeProps = ['lineCap', 'miterLimit', 'lineJoin']
  const svgStrokeProps = map(strokeProps, function (prop) { return 'stroke-' + prop.toLowerCase() })
  function mapStyleToAttrs (updateAttr, style, el, forceUpdate) {
    const opacity = style.opacity == null ? 1 : style.opacity
    if (el instanceof ZRImage) {
      updateAttr('opacity', opacity)
      return
    }
    if (pathHasFill(style)) {
      const fill = normalizeColor(style.fill)
      updateAttr('fill', fill.color)
      const fillOpacity = style.fillOpacity != null
        ? style.fillOpacity * fill.opacity * opacity
        : fill.opacity * opacity
      if (forceUpdate || fillOpacity < 1) {
        updateAttr('fill-opacity', fillOpacity)
      }
    } else {
      updateAttr('fill', NONE)
    }
    if (pathHasStroke(style)) {
      const stroke = normalizeColor(style.stroke)
      updateAttr('stroke', stroke.color)
      const strokeScale = style.strokeNoScale
        ? el.getLineScale()
        : 1
      const strokeWidth = (strokeScale ? (style.lineWidth || 0) / strokeScale : 0)
      const strokeOpacity = style.strokeOpacity != null
        ? style.strokeOpacity * stroke.opacity * opacity
        : stroke.opacity * opacity
      const strokeFirst = style.strokeFirst
      if (forceUpdate || strokeWidth !== 1) {
        updateAttr('stroke-width', strokeWidth)
      }
      if (forceUpdate || strokeFirst) {
        updateAttr('paint-order', strokeFirst ? 'stroke' : 'fill')
      }
      if (forceUpdate || strokeOpacity < 1) {
        updateAttr('stroke-opacity', strokeOpacity)
      }
      if (style.lineDash) {
        const _a = getLineDash(el); const lineDash = _a[0]; let lineDashOffset = _a[1]
        if (lineDash) {
          lineDashOffset = mathRound$1(lineDashOffset || 0)
          updateAttr('stroke-dasharray', lineDash.join(','))
          if (lineDashOffset || forceUpdate) {
            updateAttr('stroke-dashoffset', lineDashOffset)
          }
        }
      } else if (forceUpdate) {
        updateAttr('stroke-dasharray', NONE)
      }
      for (let i = 0; i < strokeProps.length; i++) {
        const propName = strokeProps[i]
        if (forceUpdate || style[propName] !== DEFAULT_PATH_STYLE[propName]) {
          const val = style[propName] || DEFAULT_PATH_STYLE[propName]
          val && updateAttr(svgStrokeProps[i], val)
        }
      }
    } else if (forceUpdate) {
      updateAttr('stroke', NONE)
    }
  }

  const SVGNS = 'http://www.w3.org/2000/svg'
  const XLINKNS = 'http://www.w3.org/1999/xlink'
  const XMLNS = 'http://www.w3.org/2000/xmlns/'
  const XML_NAMESPACE = 'http://www.w3.org/XML/1998/namespace'
  function createElement (name) {
    return document.createElementNS(SVGNS, name)
  }
  function createVNode (tag, key, attrs, children, text) {
    return {
      tag: tag,
      attrs: attrs || {},
      children: children,
      text: text,
      key: key
    }
  }
  function createElementOpen (name, attrs) {
    const attrsStr = []
    if (attrs) {
      for (const key in attrs) {
        const val = attrs[key]
        let part = key
        if (val === false) {
          continue
        } else if (val !== true && val != null) {
          part += '="' + val + '"'
        }
        attrsStr.push(part)
      }
    }
    return '<' + name + ' ' + attrsStr.join(' ') + '>'
  }
  function createElementClose (name) {
    return '</' + name + '>'
  }
  function vNodeToString (el, opts) {
    opts = opts || {}
    const S = opts.newline ? '\n' : ''
    function convertElToString (el) {
      const children = el.children; const tag = el.tag; const attrs = el.attrs
      return createElementOpen(tag, attrs) +
                (el.text || '') +
                (children ? '' + S + map(children, function (child) { return convertElToString(child) }).join(S) + S : '') +
                createElementClose(tag)
    }
    return convertElToString(el)
  }
  function getCssString (selectorNodes, animationNodes, opts) {
    opts = opts || {}
    const S = opts.newline ? '\n' : ''
    const bracketBegin = ' {' + S
    const bracketEnd = S + '}'
    const selectors = map(keys(selectorNodes), function (className) {
      return className + bracketBegin + map(keys(selectorNodes[className]), function (attrName) {
        return attrName + ':' + selectorNodes[className][attrName] + ';'
      }).join(S) + bracketEnd
    }).join(S)
    const animations = map(keys(animationNodes), function (animationName) {
      return '@keyframes ' + animationName + bracketBegin + map(keys(animationNodes[animationName]), function (percent) {
        return percent + bracketBegin + map(keys(animationNodes[animationName][percent]), function (attrName) {
          let val = animationNodes[animationName][percent][attrName]
          if (attrName === 'd') {
            val = 'path("' + val + '")'
          }
          return attrName + ':' + val + ';'
        }).join(S) + bracketEnd
      }).join(S) + bracketEnd
    }).join(S)
    if (!selectors && !animations) {
      return ''
    }
    return ['<![CDATA[', selectors, animations, ']]>'].join(S)
  }
  function createBrushScope (zrId) {
    return {
      zrId: zrId,
      shadowCache: {},
      patternCache: {},
      gradientCache: {},
      clipPathCache: {},
      defs: {},
      cssNodes: {},
      cssAnims: {},
      cssClassIdx: 0,
      cssAnimIdx: 0,
      shadowIdx: 0,
      gradientIdx: 0,
      patternIdx: 0,
      clipPathIdx: 0
    }
  }
  function createSVGVNode (width, height, children, useViewBox) {
    return createVNode('svg', 'root', {
      width: width,
      height: height,
      xmlns: SVGNS,
      'xmlns:xlink': XLINKNS,
      version: '1.1',
      baseProfile: 'full',
      viewBox: useViewBox ? '0 0 ' + width + ' ' + height : false
    }, children)
  }

  const EASING_MAP = {
    cubicIn: '0.32,0,0.67,0',
    cubicOut: '0.33,1,0.68,1',
    cubicInOut: '0.65,0,0.35,1',
    quadraticIn: '0.11,0,0.5,0',
    quadraticOut: '0.5,1,0.89,1',
    quadraticInOut: '0.45,0,0.55,1',
    quarticIn: '0.5,0,0.75,0',
    quarticOut: '0.25,1,0.5,1',
    quarticInOut: '0.76,0,0.24,1',
    quinticIn: '0.64,0,0.78,0',
    quinticOut: '0.22,1,0.36,1',
    quinticInOut: '0.83,0,0.17,1',
    sinusoidalIn: '0.12,0,0.39,0',
    sinusoidalOut: '0.61,1,0.88,1',
    sinusoidalInOut: '0.37,0,0.63,1',
    exponentialIn: '0.7,0,0.84,0',
    exponentialOut: '0.16,1,0.3,1',
    exponentialInOut: '0.87,0,0.13,1',
    circularIn: '0.55,0,1,0.45',
    circularOut: '0,0.55,0.45,1',
    circularInOut: '0.85,0,0.15,1'
  }
  const transformOriginKey = 'transform-origin'
  function buildPathString (el, kfShape, path) {
    const shape = extend({}, el.shape)
    extend(shape, kfShape)
    el.buildPath(path, shape)
    const svgPathBuilder = new SVGPathRebuilder()
    svgPathBuilder.reset(getPathPrecision(el))
    path.rebuildPath(svgPathBuilder, 1)
    svgPathBuilder.generateStr()
    return svgPathBuilder.getStr()
  }
  function setTransformOrigin (target, transform) {
    const originX = transform.originX; const originY = transform.originY
    if (originX || originY) {
      target[transformOriginKey] = originX + 'px ' + originY + 'px'
    }
  }
  const ANIMATE_STYLE_MAP = {
    fill: 'fill',
    opacity: 'opacity',
    lineWidth: 'stroke-width',
    lineDashOffset: 'stroke-dashoffset'
  }
  function addAnimation (cssAnim, scope) {
    const animationName = scope.zrId + '-ani-' + scope.cssAnimIdx++
    scope.cssAnims[animationName] = cssAnim
    return animationName
  }
  function createCompoundPathCSSAnimation (el, attrs, scope) {
    const paths = el.shape.paths
    const composedAnim = {}
    let cssAnimationCfg
    let cssAnimationName
    each(paths, function (path) {
      const subScope = createBrushScope(scope.zrId)
      subScope.animation = true
      createCSSAnimation(path, {}, subScope, true)
      const cssAnims = subScope.cssAnims
      const cssNodes = subScope.cssNodes
      const animNames = keys(cssAnims)
      const len = animNames.length
      if (!len) {
        return
      }
      cssAnimationName = animNames[len - 1]
      const lastAnim = cssAnims[cssAnimationName]
      for (const percent in lastAnim) {
        const kf = lastAnim[percent]
        composedAnim[percent] = composedAnim[percent] || { d: '' }
        composedAnim[percent].d += kf.d || ''
      }
      for (const className in cssNodes) {
        const val = cssNodes[className].animation
        if (val.indexOf(cssAnimationName) >= 0) {
          cssAnimationCfg = val
        }
      }
    })
    if (!cssAnimationCfg) {
      return
    }
    attrs.d = false
    const animationName = addAnimation(composedAnim, scope)
    return cssAnimationCfg.replace(cssAnimationName, animationName)
  }
  function getEasingFunc (easing) {
    return isString(easing)
      ? EASING_MAP[easing]
        ? 'cubic-bezier(' + EASING_MAP[easing] + ')'
        : createCubicEasingFunc(easing) ? easing : ''
      : ''
  }
  function createCSSAnimation (el, attrs, scope, onlyShape) {
    const animators = el.animators
    const len = animators.length
    const cssAnimations = []
    if (el instanceof CompoundPath) {
      var animationCfg = createCompoundPathCSSAnimation(el, attrs, scope)
      if (animationCfg) {
        cssAnimations.push(animationCfg)
      } else if (!len) {
        return
      }
    } else if (!len) {
      return
    }
    const groupAnimators = {}
    for (let i = 0; i < len; i++) {
      const animator = animators[i]
      const cfgArr = [animator.getMaxTime() / 1000 + 's']
      const easing = getEasingFunc(animator.getClip().easing)
      const delay = animator.getDelay()
      if (easing) {
        cfgArr.push(easing)
      } else {
        cfgArr.push('linear')
      }
      if (delay) {
        cfgArr.push(delay / 1000 + 's')
      }
      if (animator.getLoop()) {
        cfgArr.push('infinite')
      }
      const cfg = cfgArr.join(' ')
      groupAnimators[cfg] = groupAnimators[cfg] || [cfg, []]
      groupAnimators[cfg][1].push(animator)
    }
    function createSingleCSSAnimation (groupAnimator) {
      const animators = groupAnimator[1]
      const len = animators.length
      const transformKfs = {}
      const shapeKfs = {}
      const finalKfs = {}
      const animationTimingFunctionAttrName = 'animation-timing-function'
      function saveAnimatorTrackToCssKfs (animator, cssKfs, toCssAttrName) {
        const tracks = animator.getTracks()
        const maxTime = animator.getMaxTime()
        for (let k = 0; k < tracks.length; k++) {
          const track = tracks[k]
          if (track.needsAnimate()) {
            const kfs = track.keyframes
            let attrName = track.propName
            toCssAttrName && (attrName = toCssAttrName(attrName))
            if (attrName) {
              for (let i = 0; i < kfs.length; i++) {
                const kf = kfs[i]
                const percent = Math.round(kf.time / maxTime * 100) + '%'
                const kfEasing = getEasingFunc(kf.easing)
                const rawValue = kf.rawValue
                if (isString(rawValue) || isNumber(rawValue)) {
                  cssKfs[percent] = cssKfs[percent] || {}
                  cssKfs[percent][attrName] = kf.rawValue
                  if (kfEasing) {
                    cssKfs[percent][animationTimingFunctionAttrName] = kfEasing
                  }
                }
              }
            }
          }
        }
      }
      for (var i = 0; i < len; i++) {
        var animator = animators[i]
        var targetProp = animator.targetName
        if (!targetProp) {
          !onlyShape && saveAnimatorTrackToCssKfs(animator, transformKfs)
        } else if (targetProp === 'shape') {
          saveAnimatorTrackToCssKfs(animator, shapeKfs)
        }
      }
      for (var percent in transformKfs) {
        const transform = {}
        copyTransform(transform, el)
        extend(transform, transformKfs[percent])
        const str = getSRTTransformString(transform)
        var timingFunction = transformKfs[percent][animationTimingFunctionAttrName]
        finalKfs[percent] = str
          ? {
              transform: str
            }
          : {}
        setTransformOrigin(finalKfs[percent], transform)
        if (timingFunction) {
          finalKfs[percent][animationTimingFunctionAttrName] = timingFunction
        }
      }
      let path
      let canAnimateShape = true
      for (var percent in shapeKfs) {
        finalKfs[percent] = finalKfs[percent] || {}
        const isFirst = !path
        var timingFunction = shapeKfs[percent][animationTimingFunctionAttrName]
        if (isFirst) {
          path = new PathProxy()
        }
        const len_1 = path.len()
        path.reset()
        finalKfs[percent].d = buildPathString(el, shapeKfs[percent], path)
        const newLen = path.len()
        if (!isFirst && len_1 !== newLen) {
          canAnimateShape = false
          break
        }
        if (timingFunction) {
          finalKfs[percent][animationTimingFunctionAttrName] = timingFunction
        }
      }
      if (!canAnimateShape) {
        for (var percent in finalKfs) {
          delete finalKfs[percent].d
        }
      }
      if (!onlyShape) {
        for (var i = 0; i < len; i++) {
          var animator = animators[i]
          var targetProp = animator.targetName
          if (targetProp === 'style') {
            saveAnimatorTrackToCssKfs(animator, finalKfs, function (propName) { return ANIMATE_STYLE_MAP[propName] })
          }
        }
      }
      const percents = keys(finalKfs)
      let allTransformOriginSame = true
      let transformOrigin
      for (var i = 1; i < percents.length; i++) {
        const p0 = percents[i - 1]
        const p1 = percents[i]
        if (finalKfs[p0][transformOriginKey] !== finalKfs[p1][transformOriginKey]) {
          allTransformOriginSame = false
          break
        }
        transformOrigin = finalKfs[p0][transformOriginKey]
      }
      if (allTransformOriginSame && transformOrigin) {
        for (var percent in finalKfs) {
          if (finalKfs[percent][transformOriginKey]) {
            delete finalKfs[percent][transformOriginKey]
          }
        }
        attrs[transformOriginKey] = transformOrigin
      }
      if (filter(percents, function (percent) { return keys(finalKfs[percent]).length > 0 }).length) {
        const animationName = addAnimation(finalKfs, scope)
        return animationName + ' ' + groupAnimator[0] + ' both'
      }
    }
    for (const key in groupAnimators) {
      var animationCfg = createSingleCSSAnimation(groupAnimators[key])
      if (animationCfg) {
        cssAnimations.push(animationCfg)
      }
    }
    if (cssAnimations.length) {
      const className = scope.zrId + '-cls-' + scope.cssClassIdx++
      scope.cssNodes['.' + className] = {
        animation: cssAnimations.join(',')
      }
      attrs.class = className
    }
  }

  const round$2 = Math.round
  function isImageLike$1 (val) {
    return val && isString(val.src)
  }
  function isCanvasLike (val) {
    return val && isFunction(val.toDataURL)
  }
  function setStyleAttrs (attrs, style, el, scope) {
    mapStyleToAttrs(function (key, val) {
      const isFillStroke = key === 'fill' || key === 'stroke'
      if (isFillStroke && isGradient(val)) {
        setGradient(style, attrs, key, scope)
      } else if (isFillStroke && isPattern(val)) {
        setPattern(el, attrs, key, scope)
      } else {
        attrs[key] = val
      }
    }, style, el, false)
    setShadow(el, attrs, scope)
  }
  function noRotateScale (m) {
    return isAroundZero$1(m[0] - 1) &&
            isAroundZero$1(m[1]) &&
            isAroundZero$1(m[2]) &&
            isAroundZero$1(m[3] - 1)
  }
  function noTranslate (m) {
    return isAroundZero$1(m[4]) && isAroundZero$1(m[5])
  }
  function setTransform (attrs, m, compress) {
    if (m && !(noTranslate(m) && noRotateScale(m))) {
      const mul = compress ? 10 : 1e4
      attrs.transform = noRotateScale(m)
        ? 'translate(' + round$2(m[4] * mul) / mul + ' ' + round$2(m[5] * mul) / mul + ')'
        : getMatrixStr(m)
    }
  }
  function convertPolyShape (shape, attrs, mul) {
    const points = shape.points
    const strArr = []
    for (let i = 0; i < points.length; i++) {
      strArr.push(round$2(points[i][0] * mul) / mul)
      strArr.push(round$2(points[i][1] * mul) / mul)
    }
    attrs.points = strArr.join(' ')
  }
  function validatePolyShape (shape) {
    return !shape.smooth
  }
  function createAttrsConvert (desc) {
    const normalizedDesc = map(desc, function (item) {
      return (typeof item === 'string' ? [item, item] : item)
    })
    return function (shape, attrs, mul) {
      for (let i = 0; i < normalizedDesc.length; i++) {
        const item = normalizedDesc[i]
        const val = shape[item[0]]
        if (val != null) {
          attrs[item[1]] = round$2(val * mul) / mul
        }
      }
    }
  }
  const buitinShapesDef = {
    circle: [createAttrsConvert(['cx', 'cy', 'r'])],
    polyline: [convertPolyShape, validatePolyShape],
    polygon: [convertPolyShape, validatePolyShape]
  }
  function hasShapeAnimation (el) {
    const animators = el.animators
    for (let i = 0; i < animators.length; i++) {
      if (animators[i].targetName === 'shape') {
        return true
      }
    }
    return false
  }
  function brushSVGPath (el, scope) {
    const style = el.style
    const shape = el.shape
    const builtinShpDef = buitinShapesDef[el.type]
    const attrs = {}
    const needsAnimate = scope.animation
    let svgElType = 'path'
    const strokePercent = el.style.strokePercent
    const precision = (scope.compress && getPathPrecision(el)) || 4
    if (builtinShpDef &&
            !scope.willUpdate &&
            !(builtinShpDef[1] && !builtinShpDef[1](shape)) &&
            !(needsAnimate && hasShapeAnimation(el)) &&
            !(strokePercent < 1)) {
      svgElType = el.type
      const mul = Math.pow(10, precision)
      builtinShpDef[0](shape, attrs, mul)
    } else {
      if (!el.path) {
        el.createPathProxy()
      }
      const path = el.path
      if (el.shapeChanged()) {
        path.beginPath()
        el.buildPath(path, el.shape)
        el.pathUpdated()
      }
      const pathVersion = path.getVersion()
      const elExt = el
      let svgPathBuilder = elExt.__svgPathBuilder
      if (elExt.__svgPathVersion !== pathVersion ||
                !svgPathBuilder ||
                strokePercent !== elExt.__svgPathStrokePercent) {
        if (!svgPathBuilder) {
          svgPathBuilder = elExt.__svgPathBuilder = new SVGPathRebuilder()
        }
        svgPathBuilder.reset(precision)
        path.rebuildPath(svgPathBuilder, strokePercent)
        svgPathBuilder.generateStr()
        elExt.__svgPathVersion = pathVersion
        elExt.__svgPathStrokePercent = strokePercent
      }
      attrs.d = svgPathBuilder.getStr()
    }
    setTransform(attrs, el.transform)
    setStyleAttrs(attrs, style, el, scope)
    scope.animation && createCSSAnimation(el, attrs, scope)
    return createVNode(svgElType, el.id + '', attrs)
  }
  function brushSVGImage (el, scope) {
    const style = el.style
    let image = style.image
    if (image && !isString(image)) {
      if (isImageLike$1(image)) {
        image = image.src
      } else if (isCanvasLike(image)) {
        image = image.toDataURL()
      }
    }
    if (!image) {
      return
    }
    const x = style.x || 0
    const y = style.y || 0
    const dw = style.width
    const dh = style.height
    const attrs = {
      href: image,
      width: dw,
      height: dh
    }
    if (x) {
      attrs.x = x
    }
    if (y) {
      attrs.y = y
    }
    setTransform(attrs, el.transform)
    setStyleAttrs(attrs, style, el, scope)
    scope.animation && createCSSAnimation(el, attrs, scope)
    return createVNode('image', el.id + '', attrs)
  }
  function brushSVGTSpan (el, scope) {
    const style = el.style
    let text = style.text
    text != null && (text += '')
    if (!text || isNaN(style.x) || isNaN(style.y)) {
      return
    }
    const font = style.font || DEFAULT_FONT
    const x = style.x || 0
    const y = adjustTextY(style.y || 0, getLineHeight(font), style.textBaseline)
    const textAlign = TEXT_ALIGN_TO_ANCHOR[style.textAlign] ||
            style.textAlign
    const attrs = {
      'dominant-baseline': 'central',
      'text-anchor': textAlign
    }
    if (hasSeparateFont(style)) {
      let separatedFontStr = ''
      const fontStyle = style.fontStyle
      const fontSize = parseFontSize(style.fontSize)
      if (!parseFloat(fontSize)) {
        return
      }
      const fontFamily = style.fontFamily || DEFAULT_FONT_FAMILY
      const fontWeight = style.fontWeight
      separatedFontStr += 'font-size:' + fontSize + ';font-family:' + fontFamily + ';'
      if (fontStyle && fontStyle !== 'normal') {
        separatedFontStr += 'font-style:' + fontStyle + ';'
      }
      if (fontWeight && fontWeight !== 'normal') {
        separatedFontStr += 'font-weight:' + fontWeight + ';'
      }
      attrs.style = separatedFontStr
    } else {
      attrs.style = 'font: ' + font
    }
    if (text.match(/\s/)) {
      attrs['xml:space'] = 'preserve'
    }
    if (x) {
      attrs.x = x
    }
    if (y) {
      attrs.y = y
    }
    setTransform(attrs, el.transform)
    setStyleAttrs(attrs, style, el, scope)
    scope.animation && createCSSAnimation(el, attrs, scope)
    return createVNode('text', el.id + '', attrs, undefined, text)
  }
  function brush$1 (el, scope) {
    if (el instanceof Path) {
      return brushSVGPath(el, scope)
    } else if (el instanceof ZRImage) {
      return brushSVGImage(el, scope)
    } else if (el instanceof TSpan) {
      return brushSVGTSpan(el, scope)
    }
  }
  function setShadow (el, attrs, scope) {
    const style = el.style
    if (hasShadow(style)) {
      const shadowKey = getShadowKey(el)
      const shadowCache = scope.shadowCache
      let shadowId = shadowCache[shadowKey]
      if (!shadowId) {
        const globalScale = el.getGlobalScale()
        const scaleX = globalScale[0]
        const scaleY = globalScale[1]
        if (!scaleX || !scaleY) {
          return
        }
        const offsetX = style.shadowOffsetX || 0
        const offsetY = style.shadowOffsetY || 0
        const blur_1 = style.shadowBlur
        const _a = normalizeColor(style.shadowColor); const opacity = _a.opacity; const color = _a.color
        const stdDx = blur_1 / 2 / scaleX
        const stdDy = blur_1 / 2 / scaleY
        const stdDeviation = stdDx + ' ' + stdDy
        shadowId = scope.zrId + '-s' + scope.shadowIdx++
        scope.defs[shadowId] = createVNode('filter', shadowId, {
          id: shadowId,
          x: '-100%',
          y: '-100%',
          width: '300%',
          height: '300%'
        }, [
          createVNode('feDropShadow', '', {
            dx: offsetX / scaleX,
            dy: offsetY / scaleY,
            stdDeviation: stdDeviation,
            'flood-color': color,
            'flood-opacity': opacity
          })
        ])
        shadowCache[shadowKey] = shadowId
      }
      attrs.filter = getIdURL(shadowId)
    }
  }
  function setGradient (style, attrs, target, scope) {
    const val = style[target]
    let gradientTag
    const gradientAttrs = {
      gradientUnits: val.global
        ? 'userSpaceOnUse'
        : 'objectBoundingBox'
    }
    if (isLinearGradient(val)) {
      gradientTag = 'linearGradient'
      gradientAttrs.x1 = val.x
      gradientAttrs.y1 = val.y
      gradientAttrs.x2 = val.x2
      gradientAttrs.y2 = val.y2
    } else if (isRadialGradient(val)) {
      gradientTag = 'radialGradient'
      gradientAttrs.cx = retrieve2(val.x, 0.5)
      gradientAttrs.cy = retrieve2(val.y, 0.5)
      gradientAttrs.r = retrieve2(val.r, 0.5)
    } else {
      if ('development' !== 'production') {
        logError('Illegal gradient type.')
      }
      return
    }
    const colors = val.colorStops
    const colorStops = []
    for (let i = 0, len = colors.length; i < len; ++i) {
      const offset = round4(colors[i].offset) * 100 + '%'
      const stopColor = colors[i].color
      const _a = normalizeColor(stopColor); const color = _a.color; const opacity = _a.opacity
      const stopsAttrs = {
        offset: offset
      }
      stopsAttrs['stop-color'] = color
      if (opacity < 1) {
        stopsAttrs['stop-opacity'] = opacity
      }
      colorStops.push(createVNode('stop', i + '', stopsAttrs))
    }
    const gradientVNode = createVNode(gradientTag, '', gradientAttrs, colorStops)
    const gradientKey = vNodeToString(gradientVNode)
    const gradientCache = scope.gradientCache
    let gradientId = gradientCache[gradientKey]
    if (!gradientId) {
      gradientId = scope.zrId + '-g' + scope.gradientIdx++
      gradientCache[gradientKey] = gradientId
      gradientAttrs.id = gradientId
      scope.defs[gradientId] = createVNode(gradientTag, gradientId, gradientAttrs, colorStops)
    }
    attrs[target] = getIdURL(gradientId)
  }
  function setPattern (el, attrs, target, scope) {
    const val = el.style[target]
    const patternAttrs = {
      patternUnits: 'userSpaceOnUse'
    }
    let child
    if (isImagePattern(val)) {
      let imageWidth_1 = val.imageWidth
      let imageHeight_1 = val.imageHeight
      let imageSrc = void 0
      const patternImage = val.image
      if (isString(patternImage)) {
        imageSrc = patternImage
      } else if (isImageLike$1(patternImage)) {
        imageSrc = patternImage.src
      } else if (isCanvasLike(patternImage)) {
        imageSrc = patternImage.toDataURL()
      }
      if (typeof Image === 'undefined') {
        const errMsg = 'Image width/height must been given explictly in svg-ssr renderer.'
        assert(imageWidth_1, errMsg)
        assert(imageHeight_1, errMsg)
      } else if (imageWidth_1 == null || imageHeight_1 == null) {
        const setSizeToVNode_1 = function (vNode, img) {
          if (vNode) {
            const svgEl = vNode.elm
            const width = (vNode.attrs.width = imageWidth_1 || img.width)
            const height = (vNode.attrs.height = imageHeight_1 || img.height)
            if (svgEl) {
              svgEl.setAttribute('width', width)
              svgEl.setAttribute('height', height)
            }
          }
        }
        const createdImage = createOrUpdateImage(imageSrc, null, el, function (img) {
          setSizeToVNode_1(patternVNode, img)
          setSizeToVNode_1(child, img)
        })
        if (createdImage && createdImage.width && createdImage.height) {
          imageWidth_1 = imageWidth_1 || createdImage.width
          imageHeight_1 = imageHeight_1 || createdImage.height
        }
      }
      child = createVNode('image', 'img', {
        href: imageSrc,
        width: imageWidth_1,
        height: imageHeight_1
      })
      patternAttrs.width = imageWidth_1
      patternAttrs.height = imageHeight_1
    } else if (val.svgElement) {
      child = clone(val.svgElement)
      patternAttrs.width = val.svgWidth
      patternAttrs.height = val.svgHeight
    }
    if (!child) {
      return
    }
    patternAttrs.patternTransform = getSRTTransformString(val)
    var patternVNode = createVNode('pattern', '', patternAttrs, [child])
    const patternKey = vNodeToString(patternVNode)
    const patternCache = scope.patternCache
    let patternId = patternCache[patternKey]
    if (!patternId) {
      patternId = scope.zrId + '-p' + scope.patternIdx++
      patternCache[patternKey] = patternId
      patternAttrs.id = patternId
      patternVNode = scope.defs[patternId] = createVNode('pattern', patternId, patternAttrs, [child])
    }
    attrs[target] = getIdURL(patternId)
  }
  function setClipPath (clipPath, attrs, scope) {
    const clipPathCache = scope.clipPathCache; const defs = scope.defs
    let clipPathId = clipPathCache[clipPath.id]
    if (!clipPathId) {
      clipPathId = scope.zrId + '-c' + scope.clipPathIdx++
      const clipPathAttrs = {
        id: clipPathId
      }
      clipPathCache[clipPath.id] = clipPathId
      defs[clipPathId] = createVNode('clipPath', clipPathId, clipPathAttrs, [brushSVGPath(clipPath, scope)])
    }
    attrs['clip-path'] = getIdURL(clipPathId)
  }

  function createTextNode (text) {
    return document.createTextNode(text)
  }
  function insertBefore (parentNode, newNode, referenceNode) {
    parentNode.insertBefore(newNode, referenceNode)
  }
  function removeChild (node, child) {
    node.removeChild(child)
  }
  function appendChild (node, child) {
    node.appendChild(child)
  }
  function parentNode (node) {
    return node.parentNode
  }
  function nextSibling (node) {
    return node.nextSibling
  }
  function setTextContent (node, text) {
    node.textContent = text
  }

  const colonChar = 58
  const xChar = 120
  const emptyNode = createVNode('', '')
  function isUndef (s) {
    return s === undefined
  }
  function isDef (s) {
    return s !== undefined
  }
  function createKeyToOldIdx (children, beginIdx, endIdx) {
    const map = {}
    for (let i = beginIdx; i <= endIdx; ++i) {
      const key = children[i].key
      if (key !== undefined) {
        if ('development' !== 'production') {
          if (map[key] != null) {
            console.error('Duplicate key ' + key)
          }
        }
        map[key] = i
      }
    }
    return map
  }
  function sameVnode (vnode1, vnode2) {
    const isSameKey = vnode1.key === vnode2.key
    const isSameTag = vnode1.tag === vnode2.tag
    return isSameTag && isSameKey
  }
  function createElm (vnode) {
    let i
    const children = vnode.children
    const tag = vnode.tag
    if (isDef(tag)) {
      const elm = (vnode.elm = createElement(tag))
      updateAttrs(emptyNode, vnode)
      if (isArray(children)) {
        for (i = 0; i < children.length; ++i) {
          const ch = children[i]
          if (ch != null) {
            appendChild(elm, createElm(ch))
          }
        }
      } else if (isDef(vnode.text) && !isObject(vnode.text)) {
        appendChild(elm, createTextNode(vnode.text))
      }
    } else {
      vnode.elm = createTextNode(vnode.text)
    }
    return vnode.elm
  }
  function addVnodes (parentElm, before, vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      const ch = vnodes[startIdx]
      if (ch != null) {
        insertBefore(parentElm, createElm(ch), before)
      }
    }
  }
  function removeVnodes (parentElm, vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      const ch = vnodes[startIdx]
      if (ch != null) {
        if (isDef(ch.tag)) {
          const parent_1 = parentNode(ch.elm)
          removeChild(parent_1, ch.elm)
        } else {
          removeChild(parentElm, ch.elm)
        }
      }
    }
  }
  function updateAttrs (oldVnode, vnode) {
    let key
    const elm = vnode.elm
    const oldAttrs = oldVnode && oldVnode.attrs || {}
    const attrs = vnode.attrs || {}
    if (oldAttrs === attrs) {
      return
    }
    for (key in attrs) {
      const cur = attrs[key]
      const old = oldAttrs[key]
      if (old !== cur) {
        if (cur === true) {
          elm.setAttribute(key, '')
        } else if (cur === false) {
          elm.removeAttribute(key)
        } else {
          if (key.charCodeAt(0) !== xChar) {
            elm.setAttribute(key, cur)
          } else if (key === 'xmlns:xlink' || key === 'xmlns') {
            elm.setAttributeNS(XMLNS, key, cur)
          } else if (key.charCodeAt(3) === colonChar) {
            elm.setAttributeNS(XML_NAMESPACE, key, cur)
          } else if (key.charCodeAt(5) === colonChar) {
            elm.setAttributeNS(XLINKNS, key, cur)
          } else {
            elm.setAttribute(key, cur)
          }
        }
      }
    }
    for (key in oldAttrs) {
      if (!(key in attrs)) {
        elm.removeAttribute(key)
      }
    }
  }
  function updateChildren (parentElm, oldCh, newCh) {
    let oldStartIdx = 0
    let newStartIdx = 0
    let oldEndIdx = oldCh.length - 1
    let oldStartVnode = oldCh[0]
    let oldEndVnode = oldCh[oldEndIdx]
    let newEndIdx = newCh.length - 1
    let newStartVnode = newCh[0]
    let newEndVnode = newCh[newEndIdx]
    let oldKeyToIdx
    let idxInOld
    let elmToMove
    let before
    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (oldStartVnode == null) {
        oldStartVnode = oldCh[++oldStartIdx]
      } else if (oldEndVnode == null) {
        oldEndVnode = oldCh[--oldEndIdx]
      } else if (newStartVnode == null) {
        newStartVnode = newCh[++newStartIdx]
      } else if (newEndVnode == null) {
        newEndVnode = newCh[--newEndIdx]
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode)
        oldStartVnode = oldCh[++oldStartIdx]
        newStartVnode = newCh[++newStartIdx]
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode)
        oldEndVnode = oldCh[--oldEndIdx]
        newEndVnode = newCh[--newEndIdx]
      } else if (sameVnode(oldStartVnode, newEndVnode)) {
        patchVnode(oldStartVnode, newEndVnode)
        insertBefore(parentElm, oldStartVnode.elm, nextSibling(oldEndVnode.elm))
        oldStartVnode = oldCh[++oldStartIdx]
        newEndVnode = newCh[--newEndIdx]
      } else if (sameVnode(oldEndVnode, newStartVnode)) {
        patchVnode(oldEndVnode, newStartVnode)
        insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm)
        oldEndVnode = oldCh[--oldEndIdx]
        newStartVnode = newCh[++newStartIdx]
      } else {
        if (isUndef(oldKeyToIdx)) {
          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx)
        }
        idxInOld = oldKeyToIdx[newStartVnode.key]
        if (isUndef(idxInOld)) {
          insertBefore(parentElm, createElm(newStartVnode), oldStartVnode.elm)
        } else {
          elmToMove = oldCh[idxInOld]
          if (elmToMove.tag !== newStartVnode.tag) {
            insertBefore(parentElm, createElm(newStartVnode), oldStartVnode.elm)
          } else {
            patchVnode(elmToMove, newStartVnode)
            oldCh[idxInOld] = undefined
            insertBefore(parentElm, elmToMove.elm, oldStartVnode.elm)
          }
        }
        newStartVnode = newCh[++newStartIdx]
      }
    }
    if (oldStartIdx <= oldEndIdx || newStartIdx <= newEndIdx) {
      if (oldStartIdx > oldEndIdx) {
        before = newCh[newEndIdx + 1] == null ? null : newCh[newEndIdx + 1].elm
        addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx)
      } else {
        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx)
      }
    }
  }
  function patchVnode (oldVnode, vnode) {
    const elm = (vnode.elm = oldVnode.elm)
    const oldCh = oldVnode.children
    const ch = vnode.children
    if (oldVnode === vnode) {
      return
    }
    updateAttrs(oldVnode, vnode)
    if (isUndef(vnode.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch) {
          updateChildren(elm, oldCh, ch)
        }
      } else if (isDef(ch)) {
        if (isDef(oldVnode.text)) {
          setTextContent(elm, '')
        }
        addVnodes(elm, null, ch, 0, ch.length - 1)
      } else if (isDef(oldCh)) {
        removeVnodes(elm, oldCh, 0, oldCh.length - 1)
      } else if (isDef(oldVnode.text)) {
        setTextContent(elm, '')
      }
    } else if (oldVnode.text !== vnode.text) {
      if (isDef(oldCh)) {
        removeVnodes(elm, oldCh, 0, oldCh.length - 1)
      }
      setTextContent(elm, vnode.text)
    }
  }
  function patch (oldVnode, vnode) {
    if (sameVnode(oldVnode, vnode)) {
      patchVnode(oldVnode, vnode)
    } else {
      const elm = oldVnode.elm
      const parent_2 = parentNode(elm)
      createElm(vnode)
      if (parent_2 !== null) {
        insertBefore(parent_2, vnode.elm, nextSibling(elm))
        removeVnodes(parent_2, [oldVnode], 0, 0)
      }
    }
    return vnode
  }

  let svgId = 0
  const SVGPainter = (function () {
    function SVGPainter (root, storage, opts) {
      this.type = 'svg'
      this.refreshHover = createMethodNotSupport('refreshHover')
      this.configLayer = createMethodNotSupport('configLayer')
      this.storage = storage
      this._opts = opts = extend({}, opts)
      this.root = root
      this._id = 'zr' + svgId++
      this._oldVNode = createSVGVNode(opts.width, opts.height)
      if (root && !opts.ssr) {
        const viewport = this._viewport = document.createElement('div')
        viewport.style.cssText = 'position:relative;overflow:hidden'
        const svgDom = this._svgDom = this._oldVNode.elm = createElement('svg')
        updateAttrs(null, this._oldVNode)
        viewport.appendChild(svgDom)
        root.appendChild(viewport)
      }
      this.resize(opts.width, opts.height)
    }
    SVGPainter.prototype.getType = function () {
      return this.type
    }
    SVGPainter.prototype.getViewportRoot = function () {
      return this._viewport
    }
    SVGPainter.prototype.getViewportRootOffset = function () {
      const viewportRoot = this.getViewportRoot()
      if (viewportRoot) {
        return {
          offsetLeft: viewportRoot.offsetLeft || 0,
          offsetTop: viewportRoot.offsetTop || 0
        }
      }
    }
    SVGPainter.prototype.getSvgDom = function () {
      return this._svgDom
    }
    SVGPainter.prototype.refresh = function () {
      if (this.root) {
        const vnode = this.renderToVNode({
          willUpdate: true
        })
        vnode.attrs.style = 'position:absolute;left:0;top:0;user-select:none'
        patch(this._oldVNode, vnode)
        this._oldVNode = vnode
      }
    }
    SVGPainter.prototype.renderOneToVNode = function (el) {
      return brush$1(el, createBrushScope(this._id))
    }
    SVGPainter.prototype.renderToVNode = function (opts) {
      opts = opts || {}
      const list = this.storage.getDisplayList(true)
      const bgColor = this._backgroundColor
      const width = this._width
      const height = this._height
      const scope = createBrushScope(this._id)
      scope.animation = opts.animation
      scope.willUpdate = opts.willUpdate
      scope.compress = opts.compress
      const children = []
      if (bgColor && bgColor !== 'none') {
        const _a = normalizeColor(bgColor); const color = _a.color; const opacity = _a.opacity
        this._bgVNode = createVNode('rect', 'bg', {
          width: width,
          height: height,
          x: '0',
          y: '0',
          id: '0',
          fill: color,
          'fill-opacity': opacity
        })
        children.push(this._bgVNode)
      } else {
        this._bgVNode = null
      }
      const mainVNode = !opts.compress
        ? (this._mainVNode = createVNode('g', 'main', {}, []))
        : null
      this._paintList(list, scope, mainVNode ? mainVNode.children : children)
      mainVNode && children.push(mainVNode)
      const defs = map(keys(scope.defs), function (id) { return scope.defs[id] })
      if (defs.length) {
        children.push(createVNode('defs', 'defs', {}, defs))
      }
      if (opts.animation) {
        const animationCssStr = getCssString(scope.cssNodes, scope.cssAnims, { newline: true })
        if (animationCssStr) {
          const styleNode = createVNode('style', 'stl', {}, [], animationCssStr)
          children.push(styleNode)
        }
      }
      return createSVGVNode(width, height, children, opts.useViewBox)
    }
    SVGPainter.prototype.renderToString = function (opts) {
      opts = opts || {}
      return vNodeToString(this.renderToVNode({
        animation: retrieve2(opts.cssAnimation, true),
        willUpdate: false,
        compress: true,
        useViewBox: retrieve2(opts.useViewBox, true)
      }), { newline: true })
    }
    SVGPainter.prototype.setBackgroundColor = function (backgroundColor) {
      this._backgroundColor = backgroundColor
      const bgVNode = this._bgVNode
      if (bgVNode && bgVNode.elm) {
        const _a = normalizeColor(backgroundColor); const color = _a.color; const opacity = _a.opacity
        bgVNode.elm.setAttribute('fill', color)
        if (opacity < 1) {
          bgVNode.elm.setAttribute('fill-opacity', opacity)
        }
      }
    }
    SVGPainter.prototype.getSvgRoot = function () {
      return this._mainVNode && this._mainVNode.elm
    }
    SVGPainter.prototype._paintList = function (list, scope, out) {
      const listLen = list.length
      const clipPathsGroupsStack = []
      let clipPathsGroupsStackDepth = 0
      let currentClipPathGroup
      let prevClipPaths
      let clipGroupNodeIdx = 0
      for (let i = 0; i < listLen; i++) {
        const displayable = list[i]
        if (!displayable.invisible) {
          const clipPaths = displayable.__clipPaths
          const len = clipPaths && clipPaths.length || 0
          const prevLen = prevClipPaths && prevClipPaths.length || 0
          let lca = void 0
          for (lca = Math.max(len - 1, prevLen - 1); lca >= 0; lca--) {
            if (clipPaths && prevClipPaths &&
                            clipPaths[lca] === prevClipPaths[lca]) {
              break
            }
          }
          for (let i_1 = prevLen - 1; i_1 > lca; i_1--) {
            clipPathsGroupsStackDepth--
            currentClipPathGroup = clipPathsGroupsStack[clipPathsGroupsStackDepth - 1]
          }
          for (let i_2 = lca + 1; i_2 < len; i_2++) {
            const groupAttrs = {}
            setClipPath(clipPaths[i_2], groupAttrs, scope)
            const g = createVNode('g', 'clip-g-' + clipGroupNodeIdx++, groupAttrs, []);
            (currentClipPathGroup ? currentClipPathGroup.children : out).push(g)
            clipPathsGroupsStack[clipPathsGroupsStackDepth++] = g
            currentClipPathGroup = g
          }
          prevClipPaths = clipPaths
          const ret = brush$1(displayable, scope)
          if (ret) {
            (currentClipPathGroup ? currentClipPathGroup.children : out).push(ret)
          }
        }
      }
    }
    SVGPainter.prototype.resize = function (width, height) {
      const opts = this._opts
      const root = this.root
      const viewport = this._viewport
      width != null && (opts.width = width)
      height != null && (opts.height = height)
      if (root && viewport) {
        viewport.style.display = 'none'
        width = getSize(root, 0, opts)
        height = getSize(root, 1, opts)
        viewport.style.display = ''
      }
      if (this._width !== width || this._height !== height) {
        this._width = width
        this._height = height
        if (viewport) {
          const viewportStyle = viewport.style
          viewportStyle.width = width + 'px'
          viewportStyle.height = height + 'px'
        }
        const svgDom = this._svgDom
        if (svgDom) {
          svgDom.setAttribute('width', width)
          svgDom.setAttribute('height', height)
        }
      }
    }
    SVGPainter.prototype.getWidth = function () {
      return this._width
    }
    SVGPainter.prototype.getHeight = function () {
      return this._height
    }
    SVGPainter.prototype.dispose = function () {
      if (this.root) {
        this.root.innerHTML = ''
      }
      this._svgDom =
                this._viewport =
                    this.storage =
                        this._oldVNode =
                            this._bgVNode =
                                this._mainVNode = null
    }
    SVGPainter.prototype.clear = function () {
      if (this._svgDom) {
        this._svgDom.innerHTML = null
      }
      this._oldVNode = null
    }
    SVGPainter.prototype.toDataURL = function (base64) {
      let str = encodeURIComponent(this.renderToString())
      const prefix = 'data:image/svg+xml;'
      if (base64) {
        str = encodeBase64(str)
        return str && prefix + 'base64,' + str
      }
      return prefix + 'charset=UTF-8,' + str
    }
    return SVGPainter
  }())
  function createMethodNotSupport (method) {
    return function () {
      if ('development' !== 'production') {
        logError('In SVG mode painter not support method "' + method + '"')
      }
    }
  }

  function install (registers) {
    registers.registerPainter('svg', SVGPainter)
  }

  function createDom (id, painter, dpr) {
    const newDom = platformApi.createCanvas()
    const width = painter.getWidth()
    const height = painter.getHeight()
    const newDomStyle = newDom.style
    if (newDomStyle) {
      newDomStyle.position = 'absolute'
      newDomStyle.left = '0'
      newDomStyle.top = '0'
      newDomStyle.width = width + 'px'
      newDomStyle.height = height + 'px'
      newDom.setAttribute('data-zr-dom-id', id)
    }
    newDom.width = width * dpr
    newDom.height = height * dpr
    return newDom
  }
  const Layer = (function (_super) {
    __extends(Layer, _super)
    function Layer (id, painter, dpr) {
      const _this = _super.call(this) || this
      _this.motionBlur = false
      _this.lastFrameAlpha = 0.7
      _this.dpr = 1
      _this.virtual = false
      _this.config = {}
      _this.incremental = false
      _this.zlevel = 0
      _this.maxRepaintRectCount = 5
      _this.__dirty = true
      _this.__firstTimePaint = true
      _this.__used = false
      _this.__drawIndex = 0
      _this.__startIndex = 0
      _this.__endIndex = 0
      _this.__prevStartIndex = null
      _this.__prevEndIndex = null
      let dom
      dpr = dpr || devicePixelRatio
      if (typeof id === 'string') {
        dom = createDom(id, painter, dpr)
      } else if (isObject(id)) {
        dom = id
        id = dom.id
      }
      _this.id = id
      _this.dom = dom
      const domStyle = dom.style
      if (domStyle) {
        disableUserSelect(dom)
        dom.onselectstart = function () { return false }
        domStyle.padding = '0'
        domStyle.margin = '0'
        domStyle.borderWidth = '0'
      }
      _this.painter = painter
      _this.dpr = dpr
      return _this
    }
    Layer.prototype.getElementCount = function () {
      return this.__endIndex - this.__startIndex
    }
    Layer.prototype.afterBrush = function () {
      this.__prevStartIndex = this.__startIndex
      this.__prevEndIndex = this.__endIndex
    }
    Layer.prototype.initContext = function () {
      this.ctx = this.dom.getContext('2d')
      this.ctx.dpr = this.dpr
    }
    Layer.prototype.setUnpainted = function () {
      this.__firstTimePaint = true
    }
    Layer.prototype.createBackBuffer = function () {
      const dpr = this.dpr
      this.domBack = createDom('back-' + this.id, this.painter, dpr)
      this.ctxBack = this.domBack.getContext('2d')
      if (dpr !== 1) {
        this.ctxBack.scale(dpr, dpr)
      }
    }
    Layer.prototype.createRepaintRects = function (displayList, prevList, viewWidth, viewHeight) {
      if (this.__firstTimePaint) {
        this.__firstTimePaint = false
        return null
      }
      const mergedRepaintRects = []
      const maxRepaintRectCount = this.maxRepaintRectCount
      let full = false
      const pendingRect = new BoundingRect(0, 0, 0, 0)
      function addRectToMergePool (rect) {
        if (!rect.isFinite() || rect.isZero()) {
          return
        }
        if (mergedRepaintRects.length === 0) {
          var boundingRect = new BoundingRect(0, 0, 0, 0)
          boundingRect.copy(rect)
          mergedRepaintRects.push(boundingRect)
        } else {
          let isMerged = false
          let minDeltaArea = Infinity
          let bestRectToMergeIdx = 0
          for (let i = 0; i < mergedRepaintRects.length; ++i) {
            const mergedRect = mergedRepaintRects[i]
            if (mergedRect.intersect(rect)) {
              const pendingRect_1 = new BoundingRect(0, 0, 0, 0)
              pendingRect_1.copy(mergedRect)
              pendingRect_1.union(rect)
              mergedRepaintRects[i] = pendingRect_1
              isMerged = true
              break
            } else if (full) {
              pendingRect.copy(rect)
              pendingRect.union(mergedRect)
              const aArea = rect.width * rect.height
              const bArea = mergedRect.width * mergedRect.height
              const pendingArea = pendingRect.width * pendingRect.height
              const deltaArea = pendingArea - aArea - bArea
              if (deltaArea < minDeltaArea) {
                minDeltaArea = deltaArea
                bestRectToMergeIdx = i
              }
            }
          }
          if (full) {
            mergedRepaintRects[bestRectToMergeIdx].union(rect)
            isMerged = true
          }
          if (!isMerged) {
            var boundingRect = new BoundingRect(0, 0, 0, 0)
            boundingRect.copy(rect)
            mergedRepaintRects.push(boundingRect)
          }
          if (!full) {
            full = mergedRepaintRects.length >= maxRepaintRectCount
          }
        }
      }
      for (var i = this.__startIndex; i < this.__endIndex; ++i) {
        var el = displayList[i]
        if (el) {
          var shouldPaint = el.shouldBePainted(viewWidth, viewHeight, true, true)
          var prevRect = el.__isRendered && ((el.__dirty & REDRAW_BIT) || !shouldPaint)
            ? el.getPrevPaintRect()
            : null
          if (prevRect) {
            addRectToMergePool(prevRect)
          }
          const curRect = shouldPaint && ((el.__dirty & REDRAW_BIT) || !el.__isRendered)
            ? el.getPaintRect()
            : null
          if (curRect) {
            addRectToMergePool(curRect)
          }
        }
      }
      for (var i = this.__prevStartIndex; i < this.__prevEndIndex; ++i) {
        var el = prevList[i]
        var shouldPaint = el.shouldBePainted(viewWidth, viewHeight, true, true)
        if (el && (!shouldPaint || !el.__zr) && el.__isRendered) {
          var prevRect = el.getPrevPaintRect()
          if (prevRect) {
            addRectToMergePool(prevRect)
          }
        }
      }
      let hasIntersections
      do {
        hasIntersections = false
        for (var i = 0; i < mergedRepaintRects.length;) {
          if (mergedRepaintRects[i].isZero()) {
            mergedRepaintRects.splice(i, 1)
            continue
          }
          for (let j = i + 1; j < mergedRepaintRects.length;) {
            if (mergedRepaintRects[i].intersect(mergedRepaintRects[j])) {
              hasIntersections = true
              mergedRepaintRects[i].union(mergedRepaintRects[j])
              mergedRepaintRects.splice(j, 1)
            } else {
              j++
            }
          }
          i++
        }
      } while (hasIntersections)
      this._paintRects = mergedRepaintRects
      return mergedRepaintRects
    }
    Layer.prototype.debugGetPaintRects = function () {
      return (this._paintRects || []).slice()
    }
    Layer.prototype.resize = function (width, height) {
      const dpr = this.dpr
      const dom = this.dom
      const domStyle = dom.style
      const domBack = this.domBack
      if (domStyle) {
        domStyle.width = width + 'px'
        domStyle.height = height + 'px'
      }
      dom.width = width * dpr
      dom.height = height * dpr
      if (domBack) {
        domBack.width = width * dpr
        domBack.height = height * dpr
        if (dpr !== 1) {
          this.ctxBack.scale(dpr, dpr)
        }
      }
    }
    Layer.prototype.clear = function (clearAll, clearColor, repaintRects) {
      const dom = this.dom
      const ctx = this.ctx
      const width = dom.width
      const height = dom.height
      clearColor = clearColor || this.clearColor
      const haveMotionBLur = this.motionBlur && !clearAll
      const lastFrameAlpha = this.lastFrameAlpha
      const dpr = this.dpr
      const self = this
      if (haveMotionBLur) {
        if (!this.domBack) {
          this.createBackBuffer()
        }
        this.ctxBack.globalCompositeOperation = 'copy'
        this.ctxBack.drawImage(dom, 0, 0, width / dpr, height / dpr)
      }
      const domBack = this.domBack
      function doClear (x, y, width, height) {
        ctx.clearRect(x, y, width, height)
        if (clearColor && clearColor !== 'transparent') {
          let clearColorGradientOrPattern = void 0
          if (isGradientObject(clearColor)) {
            clearColorGradientOrPattern = clearColor.__canvasGradient ||
                            getCanvasGradient(ctx, clearColor, {
                              x: 0,
                              y: 0,
                              width: width,
                              height: height
                            })
            clearColor.__canvasGradient = clearColorGradientOrPattern
          } else if (isImagePatternObject(clearColor)) {
            clearColorGradientOrPattern = createCanvasPattern(ctx, clearColor, {
              dirty: function () {
                self.setUnpainted()
                self.__painter.refresh()
              }
            })
          }
          ctx.save()
          ctx.fillStyle = clearColorGradientOrPattern || clearColor
          ctx.fillRect(x, y, width, height)
          ctx.restore()
        }
        if (haveMotionBLur) {
          ctx.save()
          ctx.globalAlpha = lastFrameAlpha
          ctx.drawImage(domBack, x, y, width, height)
          ctx.restore()
        }
      }
      if (!repaintRects || haveMotionBLur) {
        doClear(0, 0, width, height)
      } else if (repaintRects.length) {
        each(repaintRects, function (rect) {
          doClear(rect.x * dpr, rect.y * dpr, rect.width * dpr, rect.height * dpr)
        })
      }
    }
    return Layer
  }(Eventful))

  const HOVER_LAYER_ZLEVEL = 1e5
  const CANVAS_ZLEVEL = 314159
  const EL_AFTER_INCREMENTAL_INC = 0.01
  const INCREMENTAL_INC = 0.001
  function isLayerValid (layer) {
    if (!layer) {
      return false
    }
    if (layer.__builtin__) {
      return true
    }
    if (typeof (layer.resize) !== 'function' ||
            typeof (layer.refresh) !== 'function') {
      return false
    }
    return true
  }
  function createRoot (width, height) {
    const domRoot = document.createElement('div')
    domRoot.style.cssText = [
      'position:relative',
      'width:' + width + 'px',
      'height:' + height + 'px',
      'padding:0',
      'margin:0',
      'border-width:0'
    ].join(';') + ';'
    return domRoot
  }
  const CanvasPainter = (function () {
    function CanvasPainter (root, storage, opts, id) {
      this.type = 'canvas'
      this._zlevelList = []
      this._prevDisplayList = []
      this._layers = {}
      this._layerConfig = {}
      this._needsManuallyCompositing = false
      this.type = 'canvas'
      const singleCanvas = !root.nodeName ||
                root.nodeName.toUpperCase() === 'CANVAS'
      this._opts = opts = extend({}, opts || {})
      this.dpr = opts.devicePixelRatio || devicePixelRatio
      this._singleCanvas = singleCanvas
      this.root = root
      const rootStyle = root.style
      if (rootStyle) {
        disableUserSelect(root)
        root.innerHTML = ''
      }
      this.storage = storage
      const zlevelList = this._zlevelList
      this._prevDisplayList = []
      const layers = this._layers
      if (!singleCanvas) {
        this._width = getSize(root, 0, opts)
        this._height = getSize(root, 1, opts)
        const domRoot = this._domRoot = createRoot(this._width, this._height)
        root.appendChild(domRoot)
      } else {
        const rootCanvas = root
        let width = rootCanvas.width
        let height = rootCanvas.height
        if (opts.width != null) {
          width = opts.width
        }
        if (opts.height != null) {
          height = opts.height
        }
        this.dpr = opts.devicePixelRatio || 1
        rootCanvas.width = width * this.dpr
        rootCanvas.height = height * this.dpr
        this._width = width
        this._height = height
        const mainLayer = new Layer(rootCanvas, this, this.dpr)
        mainLayer.__builtin__ = true
        mainLayer.initContext()
        layers[CANVAS_ZLEVEL] = mainLayer
        mainLayer.zlevel = CANVAS_ZLEVEL
        zlevelList.push(CANVAS_ZLEVEL)
        this._domRoot = root
      }
    }
    CanvasPainter.prototype.getType = function () {
      return 'canvas'
    }
    CanvasPainter.prototype.isSingleCanvas = function () {
      return this._singleCanvas
    }
    CanvasPainter.prototype.getViewportRoot = function () {
      return this._domRoot
    }
    CanvasPainter.prototype.getViewportRootOffset = function () {
      const viewportRoot = this.getViewportRoot()
      if (viewportRoot) {
        return {
          offsetLeft: viewportRoot.offsetLeft || 0,
          offsetTop: viewportRoot.offsetTop || 0
        }
      }
    }
    CanvasPainter.prototype.refresh = function (paintAll) {
      const list = this.storage.getDisplayList(true)
      const prevList = this._prevDisplayList
      const zlevelList = this._zlevelList
      this._redrawId = Math.random()
      this._paintList(list, prevList, paintAll, this._redrawId)
      for (let i = 0; i < zlevelList.length; i++) {
        const z = zlevelList[i]
        const layer = this._layers[z]
        if (!layer.__builtin__ && layer.refresh) {
          const clearColor = i === 0 ? this._backgroundColor : null
          layer.refresh(clearColor)
        }
      }
      if (this._opts.useDirtyRect) {
        this._prevDisplayList = list.slice()
      }
      return this
    }
    CanvasPainter.prototype.refreshHover = function () {
      this._paintHoverList(this.storage.getDisplayList(false))
    }
    CanvasPainter.prototype._paintHoverList = function (list) {
      const len = list.length
      let hoverLayer = this._hoverlayer
      hoverLayer && hoverLayer.clear()
      if (!len) {
        return
      }
      const scope = {
        inHover: true,
        viewWidth: this._width,
        viewHeight: this._height
      }
      let ctx
      for (let i = 0; i < len; i++) {
        const el = list[i]
        if (el.__inHover) {
          if (!hoverLayer) {
            hoverLayer = this._hoverlayer = this.getLayer(HOVER_LAYER_ZLEVEL)
          }
          if (!ctx) {
            ctx = hoverLayer.ctx
            ctx.save()
          }
          brush(ctx, el, scope, i === len - 1)
        }
      }
      if (ctx) {
        ctx.restore()
      }
    }
    CanvasPainter.prototype.getHoverLayer = function () {
      return this.getLayer(HOVER_LAYER_ZLEVEL)
    }
    CanvasPainter.prototype.paintOne = function (ctx, el) {
      brushSingle(ctx, el)
    }
    CanvasPainter.prototype._paintList = function (list, prevList, paintAll, redrawId) {
      if (this._redrawId !== redrawId) {
        return
      }
      paintAll = paintAll || false
      this._updateLayerStatus(list)
      const _a = this._doPaintList(list, prevList, paintAll); const finished = _a.finished; const needsRefreshHover = _a.needsRefreshHover
      if (this._needsManuallyCompositing) {
        this._compositeManually()
      }
      if (needsRefreshHover) {
        this._paintHoverList(list)
      }
      if (!finished) {
        const self_1 = this
        requestAnimationFrame$1(function () {
          self_1._paintList(list, prevList, paintAll, redrawId)
        })
      } else {
        this.eachLayer(function (layer) {
          layer.afterBrush && layer.afterBrush()
        })
      }
    }
    CanvasPainter.prototype._compositeManually = function () {
      const ctx = this.getLayer(CANVAS_ZLEVEL).ctx
      const width = this._domRoot.width
      const height = this._domRoot.height
      ctx.clearRect(0, 0, width, height)
      this.eachBuiltinLayer(function (layer) {
        if (layer.virtual) {
          ctx.drawImage(layer.dom, 0, 0, width, height)
        }
      })
    }
    CanvasPainter.prototype._doPaintList = function (list, prevList, paintAll) {
      const _this = this
      const layerList = []
      const useDirtyRect = this._opts.useDirtyRect
      for (let zi = 0; zi < this._zlevelList.length; zi++) {
        const zlevel = this._zlevelList[zi]
        const layer = this._layers[zlevel]
        if (layer.__builtin__ &&
                    layer !== this._hoverlayer &&
                    (layer.__dirty || paintAll)) {
          layerList.push(layer)
        }
      }
      let finished = true
      let needsRefreshHover = false
      const _loop_1 = function (k) {
        const layer = layerList[k]
        const ctx = layer.ctx
        const repaintRects = useDirtyRect &&
                    layer.createRepaintRects(list, prevList, this_1._width, this_1._height)
        let start = paintAll ? layer.__startIndex : layer.__drawIndex
        const useTimer = !paintAll && layer.incremental && Date.now
        const startTime = useTimer && Date.now()
        const clearColor = layer.zlevel === this_1._zlevelList[0]
          ? this_1._backgroundColor
          : null
        if (layer.__startIndex === layer.__endIndex) {
          layer.clear(false, clearColor, repaintRects)
        } else if (start === layer.__startIndex) {
          const firstEl = list[start]
          if (!firstEl.incremental || !firstEl.notClear || paintAll) {
            layer.clear(false, clearColor, repaintRects)
          }
        }
        if (start === -1) {
          console.error('For some unknown reason. drawIndex is -1')
          start = layer.__startIndex
        }
        let i
        const repaint = function (repaintRect) {
          const scope = {
            inHover: false,
            allClipped: false,
            prevEl: null,
            viewWidth: _this._width,
            viewHeight: _this._height
          }
          for (i = start; i < layer.__endIndex; i++) {
            const el = list[i]
            if (el.__inHover) {
              needsRefreshHover = true
            }
            _this._doPaintEl(el, layer, useDirtyRect, repaintRect, scope, i === layer.__endIndex - 1)
            if (useTimer) {
              const dTime = Date.now() - startTime
              if (dTime > 15) {
                break
              }
            }
          }
          if (scope.prevElClipPaths) {
            ctx.restore()
          }
        }
        if (repaintRects) {
          if (repaintRects.length === 0) {
            i = layer.__endIndex
          } else {
            const dpr = this_1.dpr
            for (let r = 0; r < repaintRects.length; ++r) {
              const rect = repaintRects[r]
              ctx.save()
              ctx.beginPath()
              ctx.rect(rect.x * dpr, rect.y * dpr, rect.width * dpr, rect.height * dpr)
              ctx.clip()
              repaint(rect)
              ctx.restore()
            }
          }
        } else {
          ctx.save()
          repaint()
          ctx.restore()
        }
        layer.__drawIndex = i
        if (layer.__drawIndex < layer.__endIndex) {
          finished = false
        }
      }
      var this_1 = this
      for (let k = 0; k < layerList.length; k++) {
        _loop_1(k)
      }
      if (env.wxa) {
        each(this._layers, function (layer) {
          if (layer && layer.ctx && layer.ctx.draw) {
            layer.ctx.draw()
          }
        })
      }
      return {
        finished: finished,
        needsRefreshHover: needsRefreshHover
      }
    }
    CanvasPainter.prototype._doPaintEl = function (el, currentLayer, useDirtyRect, repaintRect, scope, isLast) {
      const ctx = currentLayer.ctx
      if (useDirtyRect) {
        const paintRect = el.getPaintRect()
        if (!repaintRect || paintRect && paintRect.intersect(repaintRect)) {
          brush(ctx, el, scope, isLast)
          el.setPrevPaintRect(paintRect)
        }
      } else {
        brush(ctx, el, scope, isLast)
      }
    }
    CanvasPainter.prototype.getLayer = function (zlevel, virtual) {
      if (this._singleCanvas && !this._needsManuallyCompositing) {
        zlevel = CANVAS_ZLEVEL
      }
      let layer = this._layers[zlevel]
      if (!layer) {
        layer = new Layer('zr_' + zlevel, this, this.dpr)
        layer.zlevel = zlevel
        layer.__builtin__ = true
        if (this._layerConfig[zlevel]) {
          merge(layer, this._layerConfig[zlevel], true)
        } else if (this._layerConfig[zlevel - EL_AFTER_INCREMENTAL_INC]) {
          merge(layer, this._layerConfig[zlevel - EL_AFTER_INCREMENTAL_INC], true)
        }
        if (virtual) {
          layer.virtual = virtual
        }
        this.insertLayer(zlevel, layer)
        layer.initContext()
      }
      return layer
    }
    CanvasPainter.prototype.insertLayer = function (zlevel, layer) {
      const layersMap = this._layers
      const zlevelList = this._zlevelList
      const len = zlevelList.length
      const domRoot = this._domRoot
      let prevLayer = null
      let i = -1
      if (layersMap[zlevel]) {
        if ('development' !== 'production') {
          logError('ZLevel ' + zlevel + ' has been used already')
        }
        return
      }
      if (!isLayerValid(layer)) {
        if ('development' !== 'production') {
          logError('Layer of zlevel ' + zlevel + ' is not valid')
        }
        return
      }
      if (len > 0 && zlevel > zlevelList[0]) {
        for (i = 0; i < len - 1; i++) {
          if (zlevelList[i] < zlevel &&
                        zlevelList[i + 1] > zlevel) {
            break
          }
        }
        prevLayer = layersMap[zlevelList[i]]
      }
      zlevelList.splice(i + 1, 0, zlevel)
      layersMap[zlevel] = layer
      if (!layer.virtual) {
        if (prevLayer) {
          const prevDom = prevLayer.dom
          if (prevDom.nextSibling) {
            domRoot.insertBefore(layer.dom, prevDom.nextSibling)
          } else {
            domRoot.appendChild(layer.dom)
          }
        } else {
          if (domRoot.firstChild) {
            domRoot.insertBefore(layer.dom, domRoot.firstChild)
          } else {
            domRoot.appendChild(layer.dom)
          }
        }
      }
      layer.__painter = this
    }
    CanvasPainter.prototype.eachLayer = function (cb, context) {
      const zlevelList = this._zlevelList
      for (let i = 0; i < zlevelList.length; i++) {
        const z = zlevelList[i]
        cb.call(context, this._layers[z], z)
      }
    }
    CanvasPainter.prototype.eachBuiltinLayer = function (cb, context) {
      const zlevelList = this._zlevelList
      for (let i = 0; i < zlevelList.length; i++) {
        const z = zlevelList[i]
        const layer = this._layers[z]
        if (layer.__builtin__) {
          cb.call(context, layer, z)
        }
      }
    }
    CanvasPainter.prototype.eachOtherLayer = function (cb, context) {
      const zlevelList = this._zlevelList
      for (let i = 0; i < zlevelList.length; i++) {
        const z = zlevelList[i]
        const layer = this._layers[z]
        if (!layer.__builtin__) {
          cb.call(context, layer, z)
        }
      }
    }
    CanvasPainter.prototype.getLayers = function () {
      return this._layers
    }
    CanvasPainter.prototype._updateLayerStatus = function (list) {
      this.eachBuiltinLayer(function (layer, z) {
        layer.__dirty = layer.__used = false
      })
      function updatePrevLayer (idx) {
        if (prevLayer) {
          if (prevLayer.__endIndex !== idx) {
            prevLayer.__dirty = true
          }
          prevLayer.__endIndex = idx
        }
      }
      if (this._singleCanvas) {
        for (let i_1 = 1; i_1 < list.length; i_1++) {
          var el = list[i_1]
          if (el.zlevel !== list[i_1 - 1].zlevel || el.incremental) {
            this._needsManuallyCompositing = true
            break
          }
        }
      }
      var prevLayer = null
      let incrementalLayerCount = 0
      let prevZlevel
      let i
      for (i = 0; i < list.length; i++) {
        var el = list[i]
        const zlevel = el.zlevel
        let layer = void 0
        if (prevZlevel !== zlevel) {
          prevZlevel = zlevel
          incrementalLayerCount = 0
        }
        if (el.incremental) {
          layer = this.getLayer(zlevel + INCREMENTAL_INC, this._needsManuallyCompositing)
          layer.incremental = true
          incrementalLayerCount = 1
        } else {
          layer = this.getLayer(zlevel + (incrementalLayerCount > 0 ? EL_AFTER_INCREMENTAL_INC : 0), this._needsManuallyCompositing)
        }
        if (!layer.__builtin__) {
          logError('ZLevel ' + zlevel + ' has been used by unkown layer ' + layer.id)
        }
        if (layer !== prevLayer) {
          layer.__used = true
          if (layer.__startIndex !== i) {
            layer.__dirty = true
          }
          layer.__startIndex = i
          if (!layer.incremental) {
            layer.__drawIndex = i
          } else {
            layer.__drawIndex = -1
          }
          updatePrevLayer(i)
          prevLayer = layer
        }
        if ((el.__dirty & REDRAW_BIT) && !el.__inHover) {
          layer.__dirty = true
          if (layer.incremental && layer.__drawIndex < 0) {
            layer.__drawIndex = i
          }
        }
      }
      updatePrevLayer(i)
      this.eachBuiltinLayer(function (layer, z) {
        if (!layer.__used && layer.getElementCount() > 0) {
          layer.__dirty = true
          layer.__startIndex = layer.__endIndex = layer.__drawIndex = 0
        }
        if (layer.__dirty && layer.__drawIndex < 0) {
          layer.__drawIndex = layer.__startIndex
        }
      })
    }
    CanvasPainter.prototype.clear = function () {
      this.eachBuiltinLayer(this._clearLayer)
      return this
    }
    CanvasPainter.prototype._clearLayer = function (layer) {
      layer.clear()
    }
    CanvasPainter.prototype.setBackgroundColor = function (backgroundColor) {
      this._backgroundColor = backgroundColor
      each(this._layers, function (layer) {
        layer.setUnpainted()
      })
    }
    CanvasPainter.prototype.configLayer = function (zlevel, config) {
      if (config) {
        const layerConfig = this._layerConfig
        if (!layerConfig[zlevel]) {
          layerConfig[zlevel] = config
        } else {
          merge(layerConfig[zlevel], config, true)
        }
        for (let i = 0; i < this._zlevelList.length; i++) {
          const _zlevel = this._zlevelList[i]
          if (_zlevel === zlevel || _zlevel === zlevel + EL_AFTER_INCREMENTAL_INC) {
            const layer = this._layers[_zlevel]
            merge(layer, layerConfig[zlevel], true)
          }
        }
      }
    }
    CanvasPainter.prototype.delLayer = function (zlevel) {
      const layers = this._layers
      const zlevelList = this._zlevelList
      const layer = layers[zlevel]
      if (!layer) {
        return
      }
      layer.dom.parentNode.removeChild(layer.dom)
      delete layers[zlevel]
      zlevelList.splice(indexOf(zlevelList, zlevel), 1)
    }
    CanvasPainter.prototype.resize = function (width, height) {
      if (!this._domRoot.style) {
        if (width == null || height == null) {
          return
        }
        this._width = width
        this._height = height
        this.getLayer(CANVAS_ZLEVEL).resize(width, height)
      } else {
        const domRoot = this._domRoot
        domRoot.style.display = 'none'
        const opts = this._opts
        const root = this.root
        width != null && (opts.width = width)
        height != null && (opts.height = height)
        width = getSize(root, 0, opts)
        height = getSize(root, 1, opts)
        domRoot.style.display = ''
        if (this._width !== width || height !== this._height) {
          domRoot.style.width = width + 'px'
          domRoot.style.height = height + 'px'
          for (const id in this._layers) {
            if (this._layers.hasOwnProperty(id)) {
              this._layers[id].resize(width, height)
            }
          }
          this.refresh(true)
        }
        this._width = width
        this._height = height
      }
      return this
    }
    CanvasPainter.prototype.clearLayer = function (zlevel) {
      const layer = this._layers[zlevel]
      if (layer) {
        layer.clear()
      }
    }
    CanvasPainter.prototype.dispose = function () {
      this.root.innerHTML = ''
      this.root =
                this.storage =
                    this._domRoot =
                        this._layers = null
    }
    CanvasPainter.prototype.getRenderedCanvas = function (opts) {
      opts = opts || {}
      if (this._singleCanvas && !this._compositeManually) {
        return this._layers[CANVAS_ZLEVEL].dom
      }
      const imageLayer = new Layer('image', this, opts.pixelRatio || this.dpr)
      imageLayer.initContext()
      imageLayer.clear(false, opts.backgroundColor || this._backgroundColor)
      const ctx = imageLayer.ctx
      if (opts.pixelRatio <= this.dpr) {
        this.refresh()
        const width_1 = imageLayer.dom.width
        const height_1 = imageLayer.dom.height
        this.eachLayer(function (layer) {
          if (layer.__builtin__) {
            ctx.drawImage(layer.dom, 0, 0, width_1, height_1)
          } else if (layer.renderToCanvas) {
            ctx.save()
            layer.renderToCanvas(ctx)
            ctx.restore()
          }
        })
      } else {
        const scope = {
          inHover: false,
          viewWidth: this._width,
          viewHeight: this._height
        }
        const displayList = this.storage.getDisplayList(true)
        for (let i = 0, len = displayList.length; i < len; i++) {
          const el = displayList[i]
          brush(ctx, el, scope, i === len - 1)
        }
      }
      return imageLayer.dom
    }
    CanvasPainter.prototype.getWidth = function () {
      return this._width
    }
    CanvasPainter.prototype.getHeight = function () {
      return this._height
    }
    return CanvasPainter
  }())

  function install$1 (registers) {
    registers.registerPainter('canvas', CanvasPainter)
  }

  const LineSeriesModel =
    /** @class */
    (function (_super) {
      __extends(LineSeriesModel, _super)

      function LineSeriesModel () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = LineSeriesModel.type
        _this.hasSymbolVisual = true
        return _this
      }

      LineSeriesModel.prototype.getInitialData = function (option) {
        if ('development' !== 'production') {
          const coordSys = option.coordinateSystem

          if (coordSys !== 'polar' && coordSys !== 'cartesian2d') {
            throw new Error('Line not support coordinateSystem besides cartesian and polar')
          }
        }

        return createSeriesData(null, this, {
          useEncodeDefaulter: true
        })
      }

      LineSeriesModel.prototype.getLegendIcon = function (opt) {
        const group = new Group()
        const line = createSymbol('line', 0, opt.itemHeight / 2, opt.itemWidth, 0, opt.lineStyle.stroke, false)
        group.add(line)
        line.setStyle(opt.lineStyle)
        const visualType = this.getData().getVisual('symbol')
        const visualRotate = this.getData().getVisual('symbolRotate')
        const symbolType = visualType === 'none' ? 'circle' : visualType // Symbol size is 80% when there is a line

        const size = opt.itemHeight * 0.8
        const symbol = createSymbol(symbolType, (opt.itemWidth - size) / 2, (opt.itemHeight - size) / 2, size, size, opt.itemStyle.fill)
        group.add(symbol)
        symbol.setStyle(opt.itemStyle)
        const symbolRotate = opt.iconRotate === 'inherit' ? visualRotate : opt.iconRotate || 0
        symbol.rotation = symbolRotate * Math.PI / 180
        symbol.setOrigin([opt.itemWidth / 2, opt.itemHeight / 2])

        if (symbolType.indexOf('empty') > -1) {
          symbol.style.stroke = symbol.style.fill
          symbol.style.fill = '#fff'
          symbol.style.lineWidth = 2
        }

        return group
      }

      LineSeriesModel.type = 'series.line'
      LineSeriesModel.dependencies = ['grid', 'polar']
      LineSeriesModel.defaultOption = {
        // zlevel: 0,
        z: 3,
        coordinateSystem: 'cartesian2d',
        legendHoverLink: true,
        clip: true,
        label: {
          position: 'top'
        },
        // itemStyle: {
        // },
        endLabel: {
          show: false,
          valueAnimation: true,
          distance: 8
        },
        lineStyle: {
          width: 2,
          type: 'solid'
        },
        emphasis: {
          scale: true
        },
        // areaStyle: {
        // origin of areaStyle. Valid values:
        // `'auto'/null/undefined`: from axisLine to data
        // `'start'`: from min to data
        // `'end'`: from data to max
        // origin: 'auto'
        // },
        // false, 'start', 'end', 'middle'
        step: false,
        // Disabled if step is true
        smooth: false,
        smoothMonotone: null,
        symbol: 'emptyCircle',
        symbolSize: 4,
        symbolRotate: null,
        showSymbol: true,
        // `false`: follow the label interval strategy.
        // `true`: show all symbols.
        // `'auto'`: If possible, show all symbols, otherwise
        //           follow the label interval strategy.
        showAllSymbol: 'auto',
        // Whether to connect break point.
        connectNulls: false,
        // Sampling for large data. Can be: 'average', 'max', 'min', 'sum', 'lttb'.
        sampling: 'none',
        animationEasing: 'linear',
        // Disable progressive
        progressive: 0,
        hoverLayerThreshold: Infinity,
        universalTransition: {
          divideShape: 'clone'
        },
        triggerLineEvent: false
      }
      return LineSeriesModel
    }(SeriesModel))

  /**
     * @return label string. Not null/undefined
     */

  function getDefaultLabel (data, dataIndex) {
    const labelDims = data.mapDimensionsAll('defaultedLabel')
    const len = labelDims.length // Simple optimization (in lots of cases, label dims length is 1)

    if (len === 1) {
      const rawVal = retrieveRawValue(data, dataIndex, labelDims[0])
      return rawVal != null ? rawVal + '' : null
    } else if (len) {
      const vals = []

      for (let i = 0; i < labelDims.length; i++) {
        vals.push(retrieveRawValue(data, dataIndex, labelDims[i]))
      }

      return vals.join(' ')
    }
  }
  function getDefaultInterpolatedLabel (data, interpolatedValue) {
    const labelDims = data.mapDimensionsAll('defaultedLabel')

    if (!isArray(interpolatedValue)) {
      return interpolatedValue + ''
    }

    const vals = []

    for (let i = 0; i < labelDims.length; i++) {
      const dimIndex = data.getDimensionIndex(labelDims[i])

      if (dimIndex >= 0) {
        vals.push(interpolatedValue[dimIndex])
      }
    }

    return vals.join(' ')
  }

  const Symbol =
    /** @class */
    (function (_super) {
      __extends(Symbol, _super)

      function Symbol (data, idx, seriesScope, opts) {
        const _this = _super.call(this) || this

        _this.updateData(data, idx, seriesScope, opts)

        return _this
      }

      Symbol.prototype._createSymbol = function (symbolType, data, idx, symbolSize, keepAspect) {
        // Remove paths created before
        this.removeAll() // let symbolPath = createSymbol(
        //     symbolType, -0.5, -0.5, 1, 1, color
        // );
        // If width/height are set too small (e.g., set to 1) on ios10
        // and macOS Sierra, a circle stroke become a rect, no matter what
        // the scale is set. So we set width/height as 2. See #4150.

        const symbolPath = createSymbol(symbolType, -1, -1, 2, 2, null, keepAspect)
        symbolPath.attr({
          z2: 100,
          culling: true,
          scaleX: symbolSize[0] / 2,
          scaleY: symbolSize[1] / 2
        }) // Rewrite drift method

        symbolPath.drift = driftSymbol
        this._symbolType = symbolType
        this.add(symbolPath)
      }
      /**
       * Stop animation
       * @param {boolean} toLastFrame
       */

      Symbol.prototype.stopSymbolAnimation = function (toLastFrame) {
        this.childAt(0).stopAnimation(null, toLastFrame)
      }

      Symbol.prototype.getSymbolType = function () {
        return this._symbolType
      }
      /**
       * FIXME:
       * Caution: This method breaks the encapsulation of this module,
       * but it indeed brings convenience. So do not use the method
       * unless you detailedly know all the implements of `Symbol`,
       * especially animation.
       *
       * Get symbol path element.
       */

      Symbol.prototype.getSymbolPath = function () {
        return this.childAt(0)
      }
      /**
       * Highlight symbol
       */

      Symbol.prototype.highlight = function () {
        enterEmphasis(this.childAt(0))
      }
      /**
       * Downplay symbol
       */

      Symbol.prototype.downplay = function () {
        leaveEmphasis(this.childAt(0))
      }
      /**
       * @param {number} zlevel
       * @param {number} z
       */

      Symbol.prototype.setZ = function (zlevel, z) {
        const symbolPath = this.childAt(0)
        symbolPath.zlevel = zlevel
        symbolPath.z = z
      }

      Symbol.prototype.setDraggable = function (draggable, hasCursorOption) {
        const symbolPath = this.childAt(0)
        symbolPath.draggable = draggable
        symbolPath.cursor = !hasCursorOption && draggable ? 'move' : symbolPath.cursor
      }
      /**
       * Update symbol properties
       */

      Symbol.prototype.updateData = function (data, idx, seriesScope, opts) {
        this.silent = false
        const symbolType = data.getItemVisual(idx, 'symbol') || 'circle'
        const seriesModel = data.hostModel
        const symbolSize = Symbol.getSymbolSize(data, idx)
        const isInit = symbolType !== this._symbolType
        const disableAnimation = opts && opts.disableAnimation

        if (isInit) {
          const keepAspect = data.getItemVisual(idx, 'symbolKeepAspect')

          this._createSymbol(symbolType, data, idx, symbolSize, keepAspect)
        } else {
          var symbolPath = this.childAt(0)
          symbolPath.silent = false
          var target = {
            scaleX: symbolSize[0] / 2,
            scaleY: symbolSize[1] / 2
          }
          disableAnimation ? symbolPath.attr(target) : updateProps(symbolPath, target, seriesModel, idx)
          saveOldStyle(symbolPath)
        }

        this._updateCommon(data, idx, symbolSize, seriesScope, opts)

        if (isInit) {
          var symbolPath = this.childAt(0)

          if (!disableAnimation) {
            var target = {
              scaleX: this._sizeX,
              scaleY: this._sizeY,
              style: {
                // Always fadeIn. Because it has fadeOut animation when symbol is removed..
                opacity: symbolPath.style.opacity
              }
            }
            symbolPath.scaleX = symbolPath.scaleY = 0
            symbolPath.style.opacity = 0
            initProps(symbolPath, target, seriesModel, idx)
          }
        }

        if (disableAnimation) {
          // Must stop leave transition manually if don't call initProps or updateProps.
          this.childAt(0).stopAnimation('leave')
        }
      }

      Symbol.prototype._updateCommon = function (data, idx, symbolSize, seriesScope, opts) {
        const symbolPath = this.childAt(0)
        const seriesModel = data.hostModel
        let emphasisItemStyle
        let blurItemStyle
        let selectItemStyle
        let focus
        let blurScope
        let emphasisDisabled
        let labelStatesModels
        let hoverScale
        let cursorStyle

        if (seriesScope) {
          emphasisItemStyle = seriesScope.emphasisItemStyle
          blurItemStyle = seriesScope.blurItemStyle
          selectItemStyle = seriesScope.selectItemStyle
          focus = seriesScope.focus
          blurScope = seriesScope.blurScope
          labelStatesModels = seriesScope.labelStatesModels
          hoverScale = seriesScope.hoverScale
          cursorStyle = seriesScope.cursorStyle
          emphasisDisabled = seriesScope.emphasisDisabled
        }

        if (!seriesScope || data.hasItemOption) {
          const itemModel = seriesScope && seriesScope.itemModel ? seriesScope.itemModel : data.getItemModel(idx)
          const emphasisModel = itemModel.getModel('emphasis')
          emphasisItemStyle = emphasisModel.getModel('itemStyle').getItemStyle()
          selectItemStyle = itemModel.getModel(['select', 'itemStyle']).getItemStyle()
          blurItemStyle = itemModel.getModel(['blur', 'itemStyle']).getItemStyle()
          focus = emphasisModel.get('focus')
          blurScope = emphasisModel.get('blurScope')
          emphasisDisabled = emphasisModel.get('disabled')
          labelStatesModels = getLabelStatesModels(itemModel)
          hoverScale = emphasisModel.getShallow('scale')
          cursorStyle = itemModel.getShallow('cursor')
        }

        const symbolRotate = data.getItemVisual(idx, 'symbolRotate')
        symbolPath.attr('rotation', (symbolRotate || 0) * Math.PI / 180 || 0)
        const symbolOffset = normalizeSymbolOffset(data.getItemVisual(idx, 'symbolOffset'), symbolSize)

        if (symbolOffset) {
          symbolPath.x = symbolOffset[0]
          symbolPath.y = symbolOffset[1]
        }

        cursorStyle && symbolPath.attr('cursor', cursorStyle)
        const symbolStyle = data.getItemVisual(idx, 'style')
        const visualColor = symbolStyle.fill

        if (symbolPath instanceof ZRImage) {
          const pathStyle = symbolPath.style
          symbolPath.useStyle(extend({
            // TODO other properties like x, y ?
            image: pathStyle.image,
            x: pathStyle.x,
            y: pathStyle.y,
            width: pathStyle.width,
            height: pathStyle.height
          }, symbolStyle))
        } else {
          if (symbolPath.__isEmptyBrush) {
            // fill and stroke will be swapped if it's empty.
            // So we cloned a new style to avoid it affecting the original style in visual storage.
            // TODO Better implementation. No empty logic!
            symbolPath.useStyle(extend({}, symbolStyle))
          } else {
            symbolPath.useStyle(symbolStyle)
          } // Disable decal because symbol scale will been applied on the decal.

          symbolPath.style.decal = null
          symbolPath.setColor(visualColor, opts && opts.symbolInnerColor)
          symbolPath.style.strokeNoScale = true
        }

        const liftZ = data.getItemVisual(idx, 'liftZ')
        const z2Origin = this._z2

        if (liftZ != null) {
          if (z2Origin == null) {
            this._z2 = symbolPath.z2
            symbolPath.z2 += liftZ
          }
        } else if (z2Origin != null) {
          symbolPath.z2 = z2Origin
          this._z2 = null
        }

        const useNameLabel = opts && opts.useNameLabel
        setLabelStyle(symbolPath, labelStatesModels, {
          labelFetcher: seriesModel,
          labelDataIndex: idx,
          defaultText: getLabelDefaultText,
          inheritColor: visualColor,
          defaultOpacity: symbolStyle.opacity
        }) // Do not execute util needed.

        function getLabelDefaultText (idx) {
          return useNameLabel ? data.getName(idx) : getDefaultLabel(data, idx)
        }

        this._sizeX = symbolSize[0] / 2
        this._sizeY = symbolSize[1] / 2
        const emphasisState = symbolPath.ensureState('emphasis')
        emphasisState.style = emphasisItemStyle
        symbolPath.ensureState('select').style = selectItemStyle
        symbolPath.ensureState('blur').style = blurItemStyle

        if (hoverScale) {
          const scaleRatio = Math.max(isNumber(hoverScale) ? hoverScale : 1.1, 3 / this._sizeY)
          emphasisState.scaleX = this._sizeX * scaleRatio
          emphasisState.scaleY = this._sizeY * scaleRatio
        }

        this.setSymbolScale(1)
        toggleHoverEmphasis(this, focus, blurScope, emphasisDisabled)
      }

      Symbol.prototype.setSymbolScale = function (scale) {
        this.scaleX = this.scaleY = scale
      }

      Symbol.prototype.fadeOut = function (cb, seriesModel, opt) {
        const symbolPath = this.childAt(0)
        const dataIndex = getECData(this).dataIndex
        const animationOpt = opt && opt.animation // Avoid mistaken hover when fading out

        this.silent = symbolPath.silent = true // Not show text when animating

        if (opt && opt.fadeLabel) {
          const textContent = symbolPath.getTextContent()

          if (textContent) {
            removeElement(textContent, {
              style: {
                opacity: 0
              }
            }, seriesModel, {
              dataIndex: dataIndex,
              removeOpt: animationOpt,
              cb: function () {
                symbolPath.removeTextContent()
              }
            })
          }
        } else {
          symbolPath.removeTextContent()
        }

        removeElement(symbolPath, {
          style: {
            opacity: 0
          },
          scaleX: 0,
          scaleY: 0
        }, seriesModel, {
          dataIndex: dataIndex,
          cb: cb,
          removeOpt: animationOpt
        })
      }

      Symbol.getSymbolSize = function (data, idx) {
        return normalizeSymbolSize(data.getItemVisual(idx, 'symbolSize'))
      }

      return Symbol
    }(Group))

  function driftSymbol (dx, dy) {
    this.parent.drift(dx, dy)
  }

  function symbolNeedsDraw (data, point, idx, opt) {
    return point && !isNaN(point[0]) && !isNaN(point[1]) && !(opt.isIgnore && opt.isIgnore(idx)) && // We do not set clipShape on group, because it will cut part of
      // the symbol element shape. We use the same clip shape here as
      // the line clip.
      !(opt.clipShape && !opt.clipShape.contain(point[0], point[1])) && data.getItemVisual(idx, 'symbol') !== 'none'
  }

  function normalizeUpdateOpt (opt) {
    if (opt != null && !isObject(opt)) {
      opt = {
        isIgnore: opt
      }
    }

    return opt || {}
  }

  function makeSeriesScope (data) {
    const seriesModel = data.hostModel
    const emphasisModel = seriesModel.getModel('emphasis')
    return {
      emphasisItemStyle: emphasisModel.getModel('itemStyle').getItemStyle(),
      blurItemStyle: seriesModel.getModel(['blur', 'itemStyle']).getItemStyle(),
      selectItemStyle: seriesModel.getModel(['select', 'itemStyle']).getItemStyle(),
      focus: emphasisModel.get('focus'),
      blurScope: emphasisModel.get('blurScope'),
      emphasisDisabled: emphasisModel.get('disabled'),
      hoverScale: emphasisModel.get('scale'),
      labelStatesModels: getLabelStatesModels(seriesModel),
      cursorStyle: seriesModel.get('cursor')
    }
  }

  const SymbolDraw =
    /** @class */
    (function () {
      function SymbolDraw (SymbolCtor) {
        this.group = new Group()
        this._SymbolCtor = SymbolCtor || Symbol
      }
      /**
       * Update symbols draw by new data
       */

      SymbolDraw.prototype.updateData = function (data, opt) {
        // Remove progressive els.
        this._progressiveEls = null
        opt = normalizeUpdateOpt(opt)
        const group = this.group
        const seriesModel = data.hostModel
        const oldData = this._data
        const SymbolCtor = this._SymbolCtor
        const disableAnimation = opt.disableAnimation
        const seriesScope = makeSeriesScope(data)
        const symbolUpdateOpt = {
          disableAnimation: disableAnimation
        }

        const getSymbolPoint = opt.getSymbolPoint || function (idx) {
          return data.getItemLayout(idx)
        } // There is no oldLineData only when first rendering or switching from
        // stream mode to normal mode, where previous elements should be removed.

        if (!oldData) {
          group.removeAll()
        }

        data.diff(oldData).add(function (newIdx) {
          const point = getSymbolPoint(newIdx)

          if (symbolNeedsDraw(data, point, newIdx, opt)) {
            const symbolEl = new SymbolCtor(data, newIdx, seriesScope, symbolUpdateOpt)
            symbolEl.setPosition(point)
            data.setItemGraphicEl(newIdx, symbolEl)
            group.add(symbolEl)
          }
        }).update(function (newIdx, oldIdx) {
          let symbolEl = oldData.getItemGraphicEl(oldIdx)
          const point = getSymbolPoint(newIdx)

          if (!symbolNeedsDraw(data, point, newIdx, opt)) {
            group.remove(symbolEl)
            return
          }

          const newSymbolType = data.getItemVisual(newIdx, 'symbol') || 'circle'
          const oldSymbolType = symbolEl && symbolEl.getSymbolType && symbolEl.getSymbolType()

          if (!symbolEl || // Create a new if symbol type changed.
          oldSymbolType && oldSymbolType !== newSymbolType) {
            group.remove(symbolEl)
            symbolEl = new SymbolCtor(data, newIdx, seriesScope, symbolUpdateOpt)
            symbolEl.setPosition(point)
          } else {
            symbolEl.updateData(data, newIdx, seriesScope, symbolUpdateOpt)
            const target = {
              x: point[0],
              y: point[1]
            }
            disableAnimation ? symbolEl.attr(target) : updateProps(symbolEl, target, seriesModel)
          } // Add back

          group.add(symbolEl)
          data.setItemGraphicEl(newIdx, symbolEl)
        }).remove(function (oldIdx) {
          const el = oldData.getItemGraphicEl(oldIdx)
          el && el.fadeOut(function () {
            group.remove(el)
          }, seriesModel)
        }).execute()
        this._getSymbolPoint = getSymbolPoint
        this._data = data
      }

      SymbolDraw.prototype.updateLayout = function () {
        const _this = this

        const data = this._data

        if (data) {
          // Not use animation
          data.eachItemGraphicEl(function (el, idx) {
            const point = _this._getSymbolPoint(idx)

            el.setPosition(point)
            el.markRedraw()
          })
        }
      }

      SymbolDraw.prototype.incrementalPrepareUpdate = function (data) {
        this._seriesScope = makeSeriesScope(data)
        this._data = null
        this.group.removeAll()
      }
      /**
       * Update symbols draw by new data
       */

      SymbolDraw.prototype.incrementalUpdate = function (taskParams, data, opt) {
        // Clear
        this._progressiveEls = []
        opt = normalizeUpdateOpt(opt)

        function updateIncrementalAndHover (el) {
          if (!el.isGroup) {
            el.incremental = true
            el.ensureState('emphasis').hoverLayer = true
          }
        }

        for (let idx = taskParams.start; idx < taskParams.end; idx++) {
          const point = data.getItemLayout(idx)

          if (symbolNeedsDraw(data, point, idx, opt)) {
            const el = new this._SymbolCtor(data, idx, this._seriesScope)
            el.traverse(updateIncrementalAndHover)
            el.setPosition(point)
            this.group.add(el)
            data.setItemGraphicEl(idx, el)

            this._progressiveEls.push(el)
          }
        }
      }

      SymbolDraw.prototype.eachRendered = function (cb) {
        traverseElements(this._progressiveEls || this.group, cb)
      }

      SymbolDraw.prototype.remove = function (enableAnimation) {
        const group = this.group
        const data = this._data // Incremental model do not have this._data.

        if (data && enableAnimation) {
          data.eachItemGraphicEl(function (el) {
            el.fadeOut(function () {
              group.remove(el)
            }, data.hostModel)
          })
        } else {
          group.removeAll()
        }
      }
      return SymbolDraw
    }())

  function prepareDataCoordInfo (coordSys, data, valueOrigin) {
    const baseAxis = coordSys.getBaseAxis()
    const valueAxis = coordSys.getOtherAxis(baseAxis)
    const valueStart = getValueStart(valueAxis, valueOrigin)
    const baseAxisDim = baseAxis.dim
    const valueAxisDim = valueAxis.dim
    const valueDim = data.mapDimension(valueAxisDim)
    const baseDim = data.mapDimension(baseAxisDim)
    const baseDataOffset = valueAxisDim === 'x' || valueAxisDim === 'radius' ? 1 : 0
    const dims = map(coordSys.dimensions, function (coordDim) {
      return data.mapDimension(coordDim)
    })
    let stacked = false
    const stackResultDim = data.getCalculationInfo('stackResultDimension')

    if (isDimensionStacked(data, dims[0]
      /*, dims[1] */
    )) {
      // jshint ignore:line
      stacked = true
      dims[0] = stackResultDim
    }

    if (isDimensionStacked(data, dims[1]
      /*, dims[0] */
    )) {
      // jshint ignore:line
      stacked = true
      dims[1] = stackResultDim
    }

    return {
      dataDimsForPoint: dims,
      valueStart: valueStart,
      valueAxisDim: valueAxisDim,
      baseAxisDim: baseAxisDim,
      stacked: !!stacked,
      valueDim: valueDim,
      baseDim: baseDim,
      baseDataOffset: baseDataOffset,
      stackedOverDimension: data.getCalculationInfo('stackedOverDimension')
    }
  }

  function getValueStart (valueAxis, valueOrigin) {
    let valueStart = 0
    const extent = valueAxis.scale.getExtent()

    if (valueOrigin === 'start') {
      valueStart = extent[0]
    } else if (valueOrigin === 'end') {
      valueStart = extent[1]
    } // If origin is specified as a number, use it as
    // valueStart directly
    else if (isNumber(valueOrigin) && !isNaN(valueOrigin)) {
      valueStart = valueOrigin
    } // auto
    else {
      // Both positive
      if (extent[0] > 0) {
        valueStart = extent[0]
      } // Both negative
      else if (extent[1] < 0) {
        valueStart = extent[1]
      } // If is one positive, and one negative, onZero shall be true
    }

    return valueStart
  }

  function getStackedOnPoint (dataCoordInfo, coordSys, data, idx) {
    let value = NaN

    if (dataCoordInfo.stacked) {
      value = data.get(data.getCalculationInfo('stackedOverDimension'), idx)
    }

    if (isNaN(value)) {
      value = dataCoordInfo.valueStart
    }

    const baseDataOffset = dataCoordInfo.baseDataOffset
    const stackedData = []
    stackedData[baseDataOffset] = data.get(dataCoordInfo.baseDim, idx)
    stackedData[1 - baseDataOffset] = value
    return coordSys.dataToPoint(stackedData)
  }

  function diffData (oldData, newData) {
    const diffResult = []
    newData.diff(oldData).add(function (idx) {
      diffResult.push({
        cmd: '+',
        idx: idx
      })
    }).update(function (newIdx, oldIdx) {
      diffResult.push({
        cmd: '=',
        idx: oldIdx,
        idx1: newIdx
      })
    }).remove(function (idx) {
      diffResult.push({
        cmd: '-',
        idx: idx
      })
    }).execute()
    return diffResult
  }

  function lineAnimationDiff (oldData, newData, oldStackedOnPoints, newStackedOnPoints, oldCoordSys, newCoordSys, oldValueOrigin, newValueOrigin) {
    const diff = diffData(oldData, newData) // let newIdList = newData.mapArray(newData.getId);
    // let oldIdList = oldData.mapArray(oldData.getId);
    // convertToIntId(newIdList, oldIdList);
    // // FIXME One data ?
    // diff = arrayDiff(oldIdList, newIdList);

    const currPoints = []
    const nextPoints = [] // Points for stacking base line

    const currStackedPoints = []
    const nextStackedPoints = []
    const status = []
    const sortedIndices = []
    const rawIndices = []
    const newDataOldCoordInfo = prepareDataCoordInfo(oldCoordSys, newData, oldValueOrigin) // const oldDataNewCoordInfo = prepareDataCoordInfo(newCoordSys, oldData, newValueOrigin);

    const oldPoints = oldData.getLayout('points') || []
    const newPoints = newData.getLayout('points') || []

    for (var i = 0; i < diff.length; i++) {
      const diffItem = diff[i]
      let pointAdded = true
      let oldIdx2 = void 0
      let newIdx2 = void 0 // FIXME, animation is not so perfect when dataZoom window moves fast
      // Which is in case remvoing or add more than one data in the tail or head

      switch (diffItem.cmd) {
        case '=':
          oldIdx2 = diffItem.idx * 2
          newIdx2 = diffItem.idx1 * 2
          var currentX = oldPoints[oldIdx2]
          var currentY = oldPoints[oldIdx2 + 1]
          var nextX = newPoints[newIdx2]
          var nextY = newPoints[newIdx2 + 1] // If previous data is NaN, use next point directly

          if (isNaN(currentX) || isNaN(currentY)) {
            currentX = nextX
            currentY = nextY
          }

          currPoints.push(currentX, currentY)
          nextPoints.push(nextX, nextY)
          currStackedPoints.push(oldStackedOnPoints[oldIdx2], oldStackedOnPoints[oldIdx2 + 1])
          nextStackedPoints.push(newStackedOnPoints[newIdx2], newStackedOnPoints[newIdx2 + 1])
          rawIndices.push(newData.getRawIndex(diffItem.idx1))
          break

        case '+':
          var newIdx = diffItem.idx
          var newDataDimsForPoint = newDataOldCoordInfo.dataDimsForPoint
          var oldPt = oldCoordSys.dataToPoint([newData.get(newDataDimsForPoint[0], newIdx), newData.get(newDataDimsForPoint[1], newIdx)])
          newIdx2 = newIdx * 2
          currPoints.push(oldPt[0], oldPt[1])
          nextPoints.push(newPoints[newIdx2], newPoints[newIdx2 + 1])
          var stackedOnPoint = getStackedOnPoint(newDataOldCoordInfo, oldCoordSys, newData, newIdx)
          currStackedPoints.push(stackedOnPoint[0], stackedOnPoint[1])
          nextStackedPoints.push(newStackedOnPoints[newIdx2], newStackedOnPoints[newIdx2 + 1])
          rawIndices.push(newData.getRawIndex(newIdx))
          break

        case '-':
          pointAdded = false
      } // Original indices

      if (pointAdded) {
        status.push(diffItem)
        sortedIndices.push(sortedIndices.length)
      }
    } // Diff result may be crossed if all items are changed
    // Sort by data index

    sortedIndices.sort(function (a, b) {
      return rawIndices[a] - rawIndices[b]
    })
    const len = currPoints.length
    const sortedCurrPoints = createFloat32Array(len)
    const sortedNextPoints = createFloat32Array(len)
    const sortedCurrStackedPoints = createFloat32Array(len)
    const sortedNextStackedPoints = createFloat32Array(len)
    const sortedStatus = []

    for (var i = 0; i < sortedIndices.length; i++) {
      const idx = sortedIndices[i]
      const i2 = i * 2
      const idx2 = idx * 2
      sortedCurrPoints[i2] = currPoints[idx2]
      sortedCurrPoints[i2 + 1] = currPoints[idx2 + 1]
      sortedNextPoints[i2] = nextPoints[idx2]
      sortedNextPoints[i2 + 1] = nextPoints[idx2 + 1]
      sortedCurrStackedPoints[i2] = currStackedPoints[idx2]
      sortedCurrStackedPoints[i2 + 1] = currStackedPoints[idx2 + 1]
      sortedNextStackedPoints[i2] = nextStackedPoints[idx2]
      sortedNextStackedPoints[i2 + 1] = nextStackedPoints[idx2 + 1]
      sortedStatus[i] = status[idx]
    }

    return {
      current: sortedCurrPoints,
      next: sortedNextPoints,
      stackedOnCurrent: sortedCurrStackedPoints,
      stackedOnNext: sortedNextStackedPoints,
      status: sortedStatus
    }
  }

  const mathMin$5 = Math.min
  const mathMax$5 = Math.max

  function isPointNull (x, y) {
    return isNaN(x) || isNaN(y)
  }
  /**
     * Draw smoothed line in non-monotone, in may cause undesired curve in extreme
     * situations. This should be used when points are non-monotone neither in x or
     * y dimension.
     */

  function drawSegment (ctx, points, start, segLen, allLen, dir, smooth, smoothMonotone, connectNulls) {
    let prevX
    let prevY
    let cpx0
    let cpy0
    let cpx1
    let cpy1
    let idx = start
    let k = 0

    for (; k < segLen; k++) {
      let x = points[idx * 2]
      let y = points[idx * 2 + 1]

      if (idx >= allLen || idx < 0) {
        break
      }

      if (isPointNull(x, y)) {
        if (connectNulls) {
          idx += dir
          continue
        }

        break
      }

      if (idx === start) {
        ctx[dir > 0 ? 'moveTo' : 'lineTo'](x, y)
        cpx0 = x
        cpy0 = y
      } else {
        let dx = x - prevX
        let dy = y - prevY // Ignore tiny segment.

        if (dx * dx + dy * dy < 0.5) {
          idx += dir
          continue
        }

        if (smooth > 0) {
          let nextIdx = idx + dir
          let nextX = points[nextIdx * 2]
          let nextY = points[nextIdx * 2 + 1] // Ignore duplicate point

          while (nextX === x && nextY === y && k < segLen) {
            k++
            nextIdx += dir
            idx += dir
            nextX = points[nextIdx * 2]
            nextY = points[nextIdx * 2 + 1]
            x = points[idx * 2]
            y = points[idx * 2 + 1]
            dx = x - prevX
            dy = y - prevY
          }

          let tmpK = k + 1

          if (connectNulls) {
            // Find next point not null
            while (isPointNull(nextX, nextY) && tmpK < segLen) {
              tmpK++
              nextIdx += dir
              nextX = points[nextIdx * 2]
              nextY = points[nextIdx * 2 + 1]
            }
          }

          let ratioNextSeg = 0.5
          let vx = 0
          let vy = 0
          let nextCpx0 = void 0
          let nextCpy0 = void 0 // Is last point

          if (tmpK >= segLen || isPointNull(nextX, nextY)) {
            cpx1 = x
            cpy1 = y
          } else {
            vx = nextX - prevX
            vy = nextY - prevY
            const dx0 = x - prevX
            const dx1 = nextX - x
            const dy0 = y - prevY
            const dy1 = nextY - y
            let lenPrevSeg = void 0
            let lenNextSeg = void 0

            if (smoothMonotone === 'x') {
              lenPrevSeg = Math.abs(dx0)
              lenNextSeg = Math.abs(dx1)
              const dir_1 = vx > 0 ? 1 : -1
              cpx1 = x - dir_1 * lenPrevSeg * smooth
              cpy1 = y
              nextCpx0 = x + dir_1 * lenNextSeg * smooth
              nextCpy0 = y
            } else if (smoothMonotone === 'y') {
              lenPrevSeg = Math.abs(dy0)
              lenNextSeg = Math.abs(dy1)
              const dir_2 = vy > 0 ? 1 : -1
              cpx1 = x
              cpy1 = y - dir_2 * lenPrevSeg * smooth
              nextCpx0 = x
              nextCpy0 = y + dir_2 * lenNextSeg * smooth
            } else {
              lenPrevSeg = Math.sqrt(dx0 * dx0 + dy0 * dy0)
              lenNextSeg = Math.sqrt(dx1 * dx1 + dy1 * dy1) // Use ratio of seg length

              ratioNextSeg = lenNextSeg / (lenNextSeg + lenPrevSeg)
              cpx1 = x - vx * smooth * (1 - ratioNextSeg)
              cpy1 = y - vy * smooth * (1 - ratioNextSeg) // cp0 of next segment

              nextCpx0 = x + vx * smooth * ratioNextSeg
              nextCpy0 = y + vy * smooth * ratioNextSeg // Smooth constraint between point and next point.
              // Avoid exceeding extreme after smoothing.

              nextCpx0 = mathMin$5(nextCpx0, mathMax$5(nextX, x))
              nextCpy0 = mathMin$5(nextCpy0, mathMax$5(nextY, y))
              nextCpx0 = mathMax$5(nextCpx0, mathMin$5(nextX, x))
              nextCpy0 = mathMax$5(nextCpy0, mathMin$5(nextY, y)) // Reclaculate cp1 based on the adjusted cp0 of next seg.

              vx = nextCpx0 - x
              vy = nextCpy0 - y
              cpx1 = x - vx * lenPrevSeg / lenNextSeg
              cpy1 = y - vy * lenPrevSeg / lenNextSeg // Smooth constraint between point and prev point.
              // Avoid exceeding extreme after smoothing.

              cpx1 = mathMin$5(cpx1, mathMax$5(prevX, x))
              cpy1 = mathMin$5(cpy1, mathMax$5(prevY, y))
              cpx1 = mathMax$5(cpx1, mathMin$5(prevX, x))
              cpy1 = mathMax$5(cpy1, mathMin$5(prevY, y)) // Adjust next cp0 again.

              vx = x - cpx1
              vy = y - cpy1
              nextCpx0 = x + vx * lenNextSeg / lenPrevSeg
              nextCpy0 = y + vy * lenNextSeg / lenPrevSeg
            }
          }

          ctx.bezierCurveTo(cpx0, cpy0, cpx1, cpy1, x, y)
          cpx0 = nextCpx0
          cpy0 = nextCpy0
        } else {
          ctx.lineTo(x, y)
        }
      }

      prevX = x
      prevY = y
      idx += dir
    }

    return k
  }

  const ECPolylineShape =
    /** @class */
    (function () {
      function ECPolylineShape () {
        this.smooth = 0
        this.smoothConstraint = true
      }

      return ECPolylineShape
    }())

  const ECPolyline =
    /** @class */
    (function (_super) {
      __extends(ECPolyline, _super)

      function ECPolyline (opts) {
        const _this = _super.call(this, opts) || this

        _this.type = 'ec-polyline'
        return _this
      }

      ECPolyline.prototype.getDefaultStyle = function () {
        return {
          stroke: '#000',
          fill: null
        }
      }

      ECPolyline.prototype.getDefaultShape = function () {
        return new ECPolylineShape()
      }

      ECPolyline.prototype.buildPath = function (ctx, shape) {
        const points = shape.points
        let i = 0
        let len = points.length / 2 // const result = getBoundingBox(points, shape.smoothConstraint);

        if (shape.connectNulls) {
          // Must remove first and last null values avoid draw error in polygon
          for (; len > 0; len--) {
            if (!isPointNull(points[len * 2 - 2], points[len * 2 - 1])) {
              break
            }
          }

          for (; i < len; i++) {
            if (!isPointNull(points[i * 2], points[i * 2 + 1])) {
              break
            }
          }
        }

        while (i < len) {
          i += drawSegment(ctx, points, i, len, len, 1, shape.smooth, shape.smoothMonotone, shape.connectNulls) + 1
        }
      }

      ECPolyline.prototype.getPointOn = function (xOrY, dim) {
        if (!this.path) {
          this.createPathProxy()
          this.buildPath(this.path, this.shape)
        }

        const path = this.path
        const data = path.data
        const CMD = PathProxy.CMD
        let x0
        let y0
        const isDimX = dim === 'x'
        const roots = []

        for (let i = 0; i < data.length;) {
          const cmd = data[i++]
          let x = void 0
          let y = void 0
          let x2 = void 0
          let y2 = void 0
          let x3 = void 0
          let y3 = void 0
          let t = void 0

          switch (cmd) {
            case CMD.M:
              x0 = data[i++]
              y0 = data[i++]
              break

            case CMD.L:
              x = data[i++]
              y = data[i++]
              t = isDimX ? (xOrY - x0) / (x - x0) : (xOrY - y0) / (y - y0)

              if (t <= 1 && t >= 0) {
                var val = isDimX ? (y - y0) * t + y0 : (x - x0) * t + x0
                return isDimX ? [xOrY, val] : [val, xOrY]
              }

              x0 = x
              y0 = y
              break

            case CMD.C:
              x = data[i++]
              y = data[i++]
              x2 = data[i++]
              y2 = data[i++]
              x3 = data[i++]
              y3 = data[i++]
              var nRoot = isDimX ? cubicRootAt(x0, x, x2, x3, xOrY, roots) : cubicRootAt(y0, y, y2, y3, xOrY, roots)

              if (nRoot > 0) {
                for (let i_1 = 0; i_1 < nRoot; i_1++) {
                  const t_1 = roots[i_1]

                  if (t_1 <= 1 && t_1 >= 0) {
                    var val = isDimX ? cubicAt(y0, y, y2, y3, t_1) : cubicAt(x0, x, x2, x3, t_1)
                    return isDimX ? [xOrY, val] : [val, xOrY]
                  }
                }
              }

              x0 = x3
              y0 = y3
              break
          }
        }
      }

      return ECPolyline
    }(Path))

  const ECPolygonShape =
    /** @class */
    (function (_super) {
      __extends(ECPolygonShape, _super)

      function ECPolygonShape () {
        return _super !== null && _super.apply(this, arguments) || this
      }

      return ECPolygonShape
    }(ECPolylineShape))

  const ECPolygon =
    /** @class */
    (function (_super) {
      __extends(ECPolygon, _super)

      function ECPolygon (opts) {
        const _this = _super.call(this, opts) || this

        _this.type = 'ec-polygon'
        return _this
      }

      ECPolygon.prototype.getDefaultShape = function () {
        return new ECPolygonShape()
      }

      ECPolygon.prototype.buildPath = function (ctx, shape) {
        const points = shape.points
        const stackedOnPoints = shape.stackedOnPoints
        let i = 0
        let len = points.length / 2
        const smoothMonotone = shape.smoothMonotone

        if (shape.connectNulls) {
          // Must remove first and last null values avoid draw error in polygon
          for (; len > 0; len--) {
            if (!isPointNull(points[len * 2 - 2], points[len * 2 - 1])) {
              break
            }
          }

          for (; i < len; i++) {
            if (!isPointNull(points[i * 2], points[i * 2 + 1])) {
              break
            }
          }
        }

        while (i < len) {
          const k = drawSegment(ctx, points, i, len, len, 1, shape.smooth, smoothMonotone, shape.connectNulls)
          drawSegment(ctx, stackedOnPoints, i + k - 1, k, len, -1, shape.stackedOnSmooth, smoothMonotone, shape.connectNulls)
          i += k + 1
          ctx.closePath()
        }
      }

      return ECPolygon
    }(Path))

  function createGridClipPath (cartesian, hasAnimation, seriesModel, done, during) {
    const rect = cartesian.getArea()
    let x = rect.x
    let y = rect.y
    let width = rect.width
    let height = rect.height
    const lineWidth = seriesModel.get(['lineStyle', 'width']) || 2 // Expand the clip path a bit to avoid the border is clipped and looks thinner

    x -= lineWidth / 2
    y -= lineWidth / 2
    width += lineWidth
    height += lineWidth // fix: https://github.com/apache/incubator-echarts/issues/11369

    x = Math.floor(x)
    width = Math.round(width)
    const clipPath = new Rect({
      shape: {
        x: x,
        y: y,
        width: width,
        height: height
      }
    })

    if (hasAnimation) {
      const baseAxis = cartesian.getBaseAxis()
      const isHorizontal = baseAxis.isHorizontal()
      const isAxisInversed = baseAxis.inverse

      if (isHorizontal) {
        if (isAxisInversed) {
          clipPath.shape.x += width
        }

        clipPath.shape.width = 0
      } else {
        if (!isAxisInversed) {
          clipPath.shape.y += height
        }

        clipPath.shape.height = 0
      }

      const duringCb = isFunction(during)
        ? function (percent) {
          during(percent, clipPath)
        }
        : null
      initProps(clipPath, {
        shape: {
          width: width,
          height: height,
          x: x,
          y: y
        }
      }, seriesModel, null, done, duringCb)
    }

    return clipPath
  }

  function createPolarClipPath (polar, hasAnimation, seriesModel) {
    const sectorArea = polar.getArea() // Avoid float number rounding error for symbol on the edge of axis extent.

    const r0 = round(sectorArea.r0, 1)
    const r = round(sectorArea.r, 1)
    const clipPath = new Sector({
      shape: {
        cx: round(polar.cx, 1),
        cy: round(polar.cy, 1),
        r0: r0,
        r: r,
        startAngle: sectorArea.startAngle,
        endAngle: sectorArea.endAngle,
        clockwise: sectorArea.clockwise
      }
    })

    if (hasAnimation) {
      const isRadial = polar.getBaseAxis().dim === 'angle'

      if (isRadial) {
        clipPath.shape.endAngle = sectorArea.startAngle
      } else {
        clipPath.shape.r = r0
      }

      initProps(clipPath, {
        shape: {
          endAngle: sectorArea.endAngle,
          r: r
        }
      }, seriesModel)
    }

    return clipPath
  }

  function createClipPath (coordSys, hasAnimation, seriesModel, done, during) {
    if (!coordSys) {
      return null
    } else if (coordSys.type === 'polar') {
      return createPolarClipPath(coordSys, hasAnimation, seriesModel)
    } else if (coordSys.type === 'cartesian2d') {
      return createGridClipPath(coordSys, hasAnimation, seriesModel, done, during)
    }

    return null
  }

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

  /**
     * AUTO-GENERATED FILE. DO NOT MODIFY.
     */

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
  function isCoordinateSystemType (coordSys, type) {
    return coordSys.type === type
  }

  function isPointsSame (points1, points2) {
    if (points1.length !== points2.length) {
      return
    }

    for (let i = 0; i < points1.length; i++) {
      if (points1[i] !== points2[i]) {
        return
      }
    }

    return true
  }

  function bboxFromPoints (points) {
    let minX = Infinity
    let minY = Infinity
    let maxX = -Infinity
    let maxY = -Infinity

    for (let i = 0; i < points.length;) {
      const x = points[i++]
      const y = points[i++]

      if (!isNaN(x)) {
        minX = Math.min(x, minX)
        maxX = Math.max(x, maxX)
      }

      if (!isNaN(y)) {
        minY = Math.min(y, minY)
        maxY = Math.max(y, maxY)
      }
    }

    return [[minX, minY], [maxX, maxY]]
  }

  function getBoundingDiff (points1, points2) {
    const _a = bboxFromPoints(points1)
    const min1 = _a[0]
    const max1 = _a[1]

    const _b = bboxFromPoints(points2)
    const min2 = _b[0]
    const max2 = _b[1] // Get a max value from each corner of two boundings.

    return Math.max(Math.abs(min1[0] - min2[0]), Math.abs(min1[1] - min2[1]), Math.abs(max1[0] - max2[0]), Math.abs(max1[1] - max2[1]))
  }

  function getSmooth (smooth) {
    return isNumber(smooth) ? smooth : smooth ? 0.5 : 0
  }

  function getStackedOnPoints (coordSys, data, dataCoordInfo) {
    if (!dataCoordInfo.valueDim) {
      return []
    }

    const len = data.count()
    const points = createFloat32Array(len * 2)

    for (let idx = 0; idx < len; idx++) {
      const pt = getStackedOnPoint(dataCoordInfo, coordSys, data, idx)
      points[idx * 2] = pt[0]
      points[idx * 2 + 1] = pt[1]
    }

    return points
  }

  function turnPointsIntoStep (points, coordSys, stepTurnAt, connectNulls) {
    const baseAxis = coordSys.getBaseAxis()
    const baseIndex = baseAxis.dim === 'x' || baseAxis.dim === 'radius' ? 0 : 1
    const stepPoints = []
    let i = 0
    const stepPt = []
    const pt = []
    const nextPt = []
    const filteredPoints = []

    if (connectNulls) {
      for (i = 0; i < points.length; i += 2) {
        if (!isNaN(points[i]) && !isNaN(points[i + 1])) {
          filteredPoints.push(points[i], points[i + 1])
        }
      }

      points = filteredPoints
    }

    for (i = 0; i < points.length - 2; i += 2) {
      nextPt[0] = points[i + 2]
      nextPt[1] = points[i + 3]
      pt[0] = points[i]
      pt[1] = points[i + 1]
      stepPoints.push(pt[0], pt[1])

      switch (stepTurnAt) {
        case 'end':
          stepPt[baseIndex] = nextPt[baseIndex]
          stepPt[1 - baseIndex] = pt[1 - baseIndex]
          stepPoints.push(stepPt[0], stepPt[1])
          break

        case 'middle':
          var middle = (pt[baseIndex] + nextPt[baseIndex]) / 2
          var stepPt2 = []
          stepPt[baseIndex] = stepPt2[baseIndex] = middle
          stepPt[1 - baseIndex] = pt[1 - baseIndex]
          stepPt2[1 - baseIndex] = nextPt[1 - baseIndex]
          stepPoints.push(stepPt[0], stepPt[1])
          stepPoints.push(stepPt2[0], stepPt2[1])
          break

        default:
          // default is start
          stepPt[baseIndex] = pt[baseIndex]
          stepPt[1 - baseIndex] = nextPt[1 - baseIndex]
          stepPoints.push(stepPt[0], stepPt[1])
      }
    } // Last points

    stepPoints.push(points[i++], points[i++])
    return stepPoints
  }
  /**
     * Clip color stops to edge. Avoid creating too large gradients.
     * Which may lead to blurry when GPU acceleration is enabled. See #15680
     *
     * The stops has been sorted from small to large.
     */

  function clipColorStops (colorStops, maxSize) {
    const newColorStops = []
    const len = colorStops.length // coord will always < 0 in prevOutOfRangeColorStop.

    let prevOutOfRangeColorStop
    let prevInRangeColorStop

    function lerpStop (stop0, stop1, clippedCoord) {
      const coord0 = stop0.coord
      const p = (clippedCoord - coord0) / (stop1.coord - coord0)
      const color = lerp$1(p, [stop0.color, stop1.color])
      return {
        coord: clippedCoord,
        color: color
      }
    }

    for (let i = 0; i < len; i++) {
      const stop_1 = colorStops[i]
      const coord = stop_1.coord

      if (coord < 0) {
        prevOutOfRangeColorStop = stop_1
      } else if (coord > maxSize) {
        if (prevInRangeColorStop) {
          newColorStops.push(lerpStop(prevInRangeColorStop, stop_1, maxSize))
        } else if (prevOutOfRangeColorStop) {
          // If there are two stops and coord range is between these two stops
          newColorStops.push(lerpStop(prevOutOfRangeColorStop, stop_1, 0), lerpStop(prevOutOfRangeColorStop, stop_1, maxSize))
        } // All following stop will be out of range. So just ignore them.

        break
      } else {
        if (prevOutOfRangeColorStop) {
          newColorStops.push(lerpStop(prevOutOfRangeColorStop, stop_1, 0)) // Reset

          prevOutOfRangeColorStop = null
        }

        newColorStops.push(stop_1)
        prevInRangeColorStop = stop_1
      }
    }

    return newColorStops
  }

  function getVisualGradient (data, coordSys, api) {
    const visualMetaList = data.getVisual('visualMeta')

    if (!visualMetaList || !visualMetaList.length || !data.count()) {
      // When data.count() is 0, gradient range can not be calculated.
      return
    }

    if (coordSys.type !== 'cartesian2d') {
      if ('development' !== 'production') {
        console.warn('Visual map on line style is only supported on cartesian2d.')
      }

      return
    }

    let coordDim
    let visualMeta

    for (let i = visualMetaList.length - 1; i >= 0; i--) {
      const dimInfo = data.getDimensionInfo(visualMetaList[i].dimension)
      coordDim = dimInfo && dimInfo.coordDim // Can only be x or y

      if (coordDim === 'x' || coordDim === 'y') {
        visualMeta = visualMetaList[i]
        break
      }
    }

    if (!visualMeta) {
      if ('development' !== 'production') {
        console.warn('Visual map on line style only support x or y dimension.')
      }

      return
    } // If the area to be rendered is bigger than area defined by LinearGradient,
    // the canvas spec prescribes that the color of the first stop and the last
    // stop should be used. But if two stops are added at offset 0, in effect
    // browsers use the color of the second stop to render area outside
    // LinearGradient. So we can only infinitesimally extend area defined in
    // LinearGradient to render `outerColors`.

    const axis = coordSys.getAxis(coordDim) // dataToCoord mapping may not be linear, but must be monotonic.

    const colorStops = map(visualMeta.stops, function (stop) {
      // offset will be calculated later.
      return {
        coord: axis.toGlobalCoord(axis.dataToCoord(stop.value)),
        color: stop.color
      }
    })
    const stopLen = colorStops.length
    const outerColors = visualMeta.outerColors.slice()

    if (stopLen && colorStops[0].coord > colorStops[stopLen - 1].coord) {
      colorStops.reverse()
      outerColors.reverse()
    }

    const colorStopsInRange = clipColorStops(colorStops, coordDim === 'x' ? api.getWidth() : api.getHeight())
    const inRangeStopLen = colorStopsInRange.length

    if (!inRangeStopLen && stopLen) {
      // All stops are out of range. All will be the same color.
      return colorStops[0].coord < 0 ? outerColors[1] ? outerColors[1] : colorStops[stopLen - 1].color : outerColors[0] ? outerColors[0] : colorStops[0].color
    }

    const tinyExtent = 10 // Arbitrary value: 10px

    const minCoord = colorStopsInRange[0].coord - tinyExtent
    const maxCoord = colorStopsInRange[inRangeStopLen - 1].coord + tinyExtent
    const coordSpan = maxCoord - minCoord

    if (coordSpan < 1e-3) {
      return 'transparent'
    }

    each(colorStopsInRange, function (stop) {
      stop.offset = (stop.coord - minCoord) / coordSpan
    })
    colorStopsInRange.push({
      // NOTE: inRangeStopLen may still be 0 if stoplen is zero.
      offset: inRangeStopLen ? colorStopsInRange[inRangeStopLen - 1].offset : 0.5,
      color: outerColors[1] || 'transparent'
    })
    colorStopsInRange.unshift({
      offset: inRangeStopLen ? colorStopsInRange[0].offset : 0.5,
      color: outerColors[0] || 'transparent'
    })
    const gradient = new LinearGradient(0, 0, 0, 0, colorStopsInRange, true)
    gradient[coordDim] = minCoord
    gradient[coordDim + '2'] = maxCoord
    return gradient
  }

  function getIsIgnoreFunc (seriesModel, data, coordSys) {
    const showAllSymbol = seriesModel.get('showAllSymbol')
    const isAuto = showAllSymbol === 'auto'

    if (showAllSymbol && !isAuto) {
      return
    }

    const categoryAxis = coordSys.getAxesByScale('ordinal')[0]

    if (!categoryAxis) {
      return
    } // Note that category label interval strategy might bring some weird effect
    // in some scenario: users may wonder why some of the symbols are not
    // displayed. So we show all symbols as possible as we can.

    if (isAuto && // Simplify the logic, do not determine label overlap here.
      canShowAllSymbolForCategory(categoryAxis, data)) {
      return
    } // Otherwise follow the label interval strategy on category axis.

    const categoryDataDim = data.mapDimension(categoryAxis.dim)
    const labelMap = {}
    each(categoryAxis.getViewLabels(), function (labelItem) {
      const ordinalNumber = categoryAxis.scale.getRawOrdinalNumber(labelItem.tickValue)
      labelMap[ordinalNumber] = 1
    })
    return function (dataIndex) {
      return !labelMap.hasOwnProperty(data.get(categoryDataDim, dataIndex))
    }
  }

  function canShowAllSymbolForCategory (categoryAxis, data) {
    // In mose cases, line is monotonous on category axis, and the label size
    // is close with each other. So we check the symbol size and some of the
    // label size alone with the category axis to estimate whether all symbol
    // can be shown without overlap.
    const axisExtent = categoryAxis.getExtent()
    let availSize = Math.abs(axisExtent[1] - axisExtent[0]) / categoryAxis.scale.count()
    isNaN(availSize) && (availSize = 0) // 0/0 is NaN.
    // Sampling some points, max 5.

    const dataLen = data.count()
    const step = Math.max(1, Math.round(dataLen / 5))

    for (let dataIndex = 0; dataIndex < dataLen; dataIndex += step) {
      if (Symbol.getSymbolSize(data, dataIndex // Only for cartesian, where `isHorizontal` exists.
      )[categoryAxis.isHorizontal() ? 1 : 0] * // Empirical number
        1.5 > availSize) {
        return false
      }
    }

    return true
  }

  function isPointNull$1 (x, y) {
    return isNaN(x) || isNaN(y)
  }

  function getLastIndexNotNull (points) {
    let len = points.length / 2

    for (; len > 0; len--) {
      if (!isPointNull$1(points[len * 2 - 2], points[len * 2 - 1])) {
        break
      }
    }

    return len - 1
  }

  function getPointAtIndex (points, idx) {
    return [points[idx * 2], points[idx * 2 + 1]]
  }

  function getIndexRange (points, xOrY, dim) {
    const len = points.length / 2
    const dimIdx = dim === 'x' ? 0 : 1
    let a
    let b
    let prevIndex = 0
    let nextIndex = -1

    for (let i = 0; i < len; i++) {
      b = points[i * 2 + dimIdx]

      if (isNaN(b) || isNaN(points[i * 2 + 1 - dimIdx])) {
        continue
      }

      if (i === 0) {
        a = b
        continue
      }

      if (a <= xOrY && b >= xOrY || a >= xOrY && b <= xOrY) {
        nextIndex = i
        break
      }

      prevIndex = i
      a = b
    }

    return {
      range: [prevIndex, nextIndex],
      t: (xOrY - a) / (b - a)
    }
  }

  function anyStateShowEndLabel (seriesModel) {
    if (seriesModel.get(['endLabel', 'show'])) {
      return true
    }

    for (let i = 0; i < SPECIAL_STATES.length; i++) {
      if (seriesModel.get([SPECIAL_STATES[i], 'endLabel', 'show'])) {
        return true
      }
    }

    return false
  }

  function createLineClipPath (lineView, coordSys, hasAnimation, seriesModel) {
    if (isCoordinateSystemType(coordSys, 'cartesian2d')) {
      const endLabelModel_1 = seriesModel.getModel('endLabel')
      const valueAnimation_1 = endLabelModel_1.get('valueAnimation')
      const data_1 = seriesModel.getData()
      const labelAnimationRecord_1 = {
        lastFrameIndex: 0
      }
      const during = anyStateShowEndLabel(seriesModel)
        ? function (percent, clipRect) {
          lineView._endLabelOnDuring(percent, clipRect, data_1, labelAnimationRecord_1, valueAnimation_1, endLabelModel_1, coordSys)
        }
        : null
      const isHorizontal = coordSys.getBaseAxis().isHorizontal()
      const clipPath = createGridClipPath(coordSys, hasAnimation, seriesModel, function () {
        const endLabel = lineView._endLabel

        if (endLabel && hasAnimation) {
          if (labelAnimationRecord_1.originalX != null) {
            endLabel.attr({
              x: labelAnimationRecord_1.originalX,
              y: labelAnimationRecord_1.originalY
            })
          }
        }
      }, during) // Expand clip shape to avoid clipping when line value exceeds axis

      if (!seriesModel.get('clip', true)) {
        const rectShape = clipPath.shape
        const expandSize = Math.max(rectShape.width, rectShape.height)

        if (isHorizontal) {
          rectShape.y -= expandSize
          rectShape.height += expandSize * 2
        } else {
          rectShape.x -= expandSize
          rectShape.width += expandSize * 2
        }
      } // Set to the final frame. To make sure label layout is right.

      if (during) {
        during(1, clipPath)
      }

      return clipPath
    } else {
      if ('development' !== 'production') {
        if (seriesModel.get(['endLabel', 'show'])) {
          console.warn('endLabel is not supported for lines in polar systems.')
        }
      }

      return createPolarClipPath(coordSys, hasAnimation, seriesModel)
    }
  }

  function getEndLabelStateSpecified (endLabelModel, coordSys) {
    const baseAxis = coordSys.getBaseAxis()
    const isHorizontal = baseAxis.isHorizontal()
    const isBaseInversed = baseAxis.inverse
    const align = isHorizontal ? isBaseInversed ? 'right' : 'left' : 'center'
    const verticalAlign = isHorizontal ? 'middle' : isBaseInversed ? 'top' : 'bottom'
    return {
      normal: {
        align: endLabelModel.get('align') || align,
        verticalAlign: endLabelModel.get('verticalAlign') || verticalAlign
      }
    }
  }

  const LineView =
    /** @class */
    (function (_super) {
      __extends(LineView, _super)

      function LineView () {
        return _super !== null && _super.apply(this, arguments) || this
      }

      LineView.prototype.init = function () {
        const lineGroup = new Group()
        const symbolDraw = new SymbolDraw()
        this.group.add(symbolDraw.group)
        this._symbolDraw = symbolDraw
        this._lineGroup = lineGroup
      }

      LineView.prototype.render = function (seriesModel, ecModel, api) {
        const _this = this

        const coordSys = seriesModel.coordinateSystem
        const group = this.group
        const data = seriesModel.getData()
        const lineStyleModel = seriesModel.getModel('lineStyle')
        const areaStyleModel = seriesModel.getModel('areaStyle')
        let points = data.getLayout('points') || []
        const isCoordSysPolar = coordSys.type === 'polar'
        const prevCoordSys = this._coordSys
        const symbolDraw = this._symbolDraw
        let polyline = this._polyline
        let polygon = this._polygon
        const lineGroup = this._lineGroup
        const hasAnimation = seriesModel.get('animation')
        const isAreaChart = !areaStyleModel.isEmpty()
        const valueOrigin = areaStyleModel.get('origin')
        const dataCoordInfo = prepareDataCoordInfo(coordSys, data, valueOrigin)
        let stackedOnPoints = isAreaChart && getStackedOnPoints(coordSys, data, dataCoordInfo)
        const showSymbol = seriesModel.get('showSymbol')
        const connectNulls = seriesModel.get('connectNulls')
        const isIgnoreFunc = showSymbol && !isCoordSysPolar && getIsIgnoreFunc(seriesModel, data, coordSys) // Remove temporary symbols

        const oldData = this._data
        oldData && oldData.eachItemGraphicEl(function (el, idx) {
          if (el.__temp) {
            group.remove(el)
            oldData.setItemGraphicEl(idx, null)
          }
        }) // Remove previous created symbols if showSymbol changed to false

        if (!showSymbol) {
          symbolDraw.remove()
        }

        group.add(lineGroup) // FIXME step not support polar

        const step = !isCoordSysPolar ? seriesModel.get('step') : false
        let clipShapeForSymbol

        if (coordSys && coordSys.getArea && seriesModel.get('clip', true)) {
          clipShapeForSymbol = coordSys.getArea() // Avoid float number rounding error for symbol on the edge of axis extent.
          // See #7913 and `test/dataZoom-clip.html`.

          if (clipShapeForSymbol.width != null) {
            clipShapeForSymbol.x -= 0.1
            clipShapeForSymbol.y -= 0.1
            clipShapeForSymbol.width += 0.2
            clipShapeForSymbol.height += 0.2
          } else if (clipShapeForSymbol.r0) {
            clipShapeForSymbol.r0 -= 0.5
            clipShapeForSymbol.r += 0.5
          }
        }

        this._clipShapeForSymbol = clipShapeForSymbol
        const visualColor = getVisualGradient(data, coordSys, api) || data.getVisual('style')[data.getVisual('drawType')] // Initialization animation or coordinate system changed

        if (!(polyline && prevCoordSys.type === coordSys.type && step === this._step)) {
          showSymbol && symbolDraw.updateData(data, {
            isIgnore: isIgnoreFunc,
            clipShape: clipShapeForSymbol,
            disableAnimation: true,
            getSymbolPoint: function (idx) {
              return [points[idx * 2], points[idx * 2 + 1]]
            }
          })
          hasAnimation && this._initSymbolLabelAnimation(data, coordSys, clipShapeForSymbol)

          if (step) {
            // TODO If stacked series is not step
            points = turnPointsIntoStep(points, coordSys, step, connectNulls)

            if (stackedOnPoints) {
              stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step, connectNulls)
            }
          }

          polyline = this._newPolyline(points)

          if (isAreaChart) {
            polygon = this._newPolygon(points, stackedOnPoints)
          } // If areaStyle is removed
          else if (polygon) {
            lineGroup.remove(polygon)
            polygon = this._polygon = null
          } // NOTE: Must update _endLabel before setClipPath.

          if (!isCoordSysPolar) {
            this._initOrUpdateEndLabel(seriesModel, coordSys, convertToColorString(visualColor))
          }

          lineGroup.setClipPath(createLineClipPath(this, coordSys, true, seriesModel))
        } else {
          if (isAreaChart && !polygon) {
            // If areaStyle is added
            polygon = this._newPolygon(points, stackedOnPoints)
          } else if (polygon && !isAreaChart) {
            // If areaStyle is removed
            lineGroup.remove(polygon)
            polygon = this._polygon = null
          } // NOTE: Must update _endLabel before setClipPath.

          if (!isCoordSysPolar) {
            this._initOrUpdateEndLabel(seriesModel, coordSys, convertToColorString(visualColor))
          } // Update clipPath

          const oldClipPath = lineGroup.getClipPath()

          if (oldClipPath) {
            const newClipPath = createLineClipPath(this, coordSys, false, seriesModel)
            initProps(oldClipPath, {
              shape: newClipPath.shape
            }, seriesModel)
          } else {
            lineGroup.setClipPath(createLineClipPath(this, coordSys, true, seriesModel))
          } // Always update, or it is wrong in the case turning on legend
          // because points are not changed

          showSymbol && symbolDraw.updateData(data, {
            isIgnore: isIgnoreFunc,
            clipShape: clipShapeForSymbol,
            disableAnimation: true,
            getSymbolPoint: function (idx) {
              return [points[idx * 2], points[idx * 2 + 1]]
            }
          }) // In the case data zoom triggerred refreshing frequently
          // Data may not change if line has a category axis. So it should animate nothing

          if (!isPointsSame(this._stackedOnPoints, stackedOnPoints) || !isPointsSame(this._points, points)) {
            if (hasAnimation) {
              this._doUpdateAnimation(data, stackedOnPoints, coordSys, api, step, valueOrigin, connectNulls)
            } else {
              // Not do it in update with animation
              if (step) {
                // TODO If stacked series is not step
                points = turnPointsIntoStep(points, coordSys, step, connectNulls)

                if (stackedOnPoints) {
                  stackedOnPoints = turnPointsIntoStep(stackedOnPoints, coordSys, step, connectNulls)
                }
              }

              polyline.setShape({
                points: points
              })
              polygon && polygon.setShape({
                points: points,
                stackedOnPoints: stackedOnPoints
              })
            }
          }
        }

        const emphasisModel = seriesModel.getModel('emphasis')
        const focus = emphasisModel.get('focus')
        const blurScope = emphasisModel.get('blurScope')
        const emphasisDisabled = emphasisModel.get('disabled')
        polyline.useStyle(defaults( // Use color in lineStyle first
          lineStyleModel.getLineStyle(), {
            fill: 'none',
            stroke: visualColor,
            lineJoin: 'bevel'
          }))
        setStatesStylesFromModel(polyline, seriesModel, 'lineStyle')

        if (polyline.style.lineWidth > 0 && seriesModel.get(['emphasis', 'lineStyle', 'width']) === 'bolder') {
          const emphasisLineStyle = polyline.getState('emphasis').style
          emphasisLineStyle.lineWidth = +polyline.style.lineWidth + 1
        } // Needs seriesIndex for focus

        getECData(polyline).seriesIndex = seriesModel.seriesIndex
        toggleHoverEmphasis(polyline, focus, blurScope, emphasisDisabled)
        const smooth = getSmooth(seriesModel.get('smooth'))
        const smoothMonotone = seriesModel.get('smoothMonotone')
        polyline.setShape({
          smooth: smooth,
          smoothMonotone: smoothMonotone,
          connectNulls: connectNulls
        })

        if (polygon) {
          const stackedOnSeries = data.getCalculationInfo('stackedOnSeries')
          let stackedOnSmooth = 0
          polygon.useStyle(defaults(areaStyleModel.getAreaStyle(), {
            fill: visualColor,
            opacity: 0.7,
            lineJoin: 'bevel',
            decal: data.getVisual('style').decal
          }))

          if (stackedOnSeries) {
            stackedOnSmooth = getSmooth(stackedOnSeries.get('smooth'))
          }

          polygon.setShape({
            smooth: smooth,
            stackedOnSmooth: stackedOnSmooth,
            smoothMonotone: smoothMonotone,
            connectNulls: connectNulls
          })
          setStatesStylesFromModel(polygon, seriesModel, 'areaStyle') // Needs seriesIndex for focus

          getECData(polygon).seriesIndex = seriesModel.seriesIndex
          toggleHoverEmphasis(polygon, focus, blurScope, emphasisDisabled)
        }

        const changePolyState = function (toState) {
          _this._changePolyState(toState)
        }

        data.eachItemGraphicEl(function (el) {
          // Switch polyline / polygon state if element changed its state.
          el && (el.onHoverStateChange = changePolyState)
        })
        this._polyline.onHoverStateChange = changePolyState
        this._data = data // Save the coordinate system for transition animation when data changed

        this._coordSys = coordSys
        this._stackedOnPoints = stackedOnPoints
        this._points = points
        this._step = step
        this._valueOrigin = valueOrigin

        if (seriesModel.get('triggerLineEvent')) {
          this.packEventData(seriesModel, polyline)
          polygon && this.packEventData(seriesModel, polygon)
        }
      }

      LineView.prototype.packEventData = function (seriesModel, el) {
        getECData(el).eventData = {
          componentType: 'series',
          componentSubType: 'line',
          componentIndex: seriesModel.componentIndex,
          seriesIndex: seriesModel.seriesIndex,
          seriesName: seriesModel.name,
          seriesType: 'line'
        }
      }

      LineView.prototype.highlight = function (seriesModel, ecModel, api, payload) {
        const data = seriesModel.getData()
        const dataIndex = queryDataIndex(data, payload)

        this._changePolyState('emphasis')

        if (!(dataIndex instanceof Array) && dataIndex != null && dataIndex >= 0) {
          const points = data.getLayout('points')
          let symbol = data.getItemGraphicEl(dataIndex)

          if (!symbol) {
            // Create a temporary symbol if it is not exists
            const x = points[dataIndex * 2]
            const y = points[dataIndex * 2 + 1]

            if (isNaN(x) || isNaN(y)) {
              // Null data
              return
            } // fix #11360: should't draw symbol outside clipShapeForSymbol

            if (this._clipShapeForSymbol && !this._clipShapeForSymbol.contain(x, y)) {
              return
            }

            const zlevel = seriesModel.get('zlevel')
            const z = seriesModel.get('z')
            symbol = new Symbol(data, dataIndex)
            symbol.x = x
            symbol.y = y
            symbol.setZ(zlevel, z) // ensure label text of the temporary symbol is in front of line and area polygon

            const symbolLabel = symbol.getSymbolPath().getTextContent()

            if (symbolLabel) {
              symbolLabel.zlevel = zlevel
              symbolLabel.z = z
              symbolLabel.z2 = this._polyline.z2 + 1
            }

            symbol.__temp = true
            data.setItemGraphicEl(dataIndex, symbol) // Stop scale animation

            symbol.stopSymbolAnimation(true)
            this.group.add(symbol)
          }

          symbol.highlight()
        } else {
          // Highlight whole series
          ChartView.prototype.highlight.call(this, seriesModel, ecModel, api, payload)
        }
      }

      LineView.prototype.downplay = function (seriesModel, ecModel, api, payload) {
        const data = seriesModel.getData()
        const dataIndex = queryDataIndex(data, payload)

        this._changePolyState('normal')

        if (dataIndex != null && dataIndex >= 0) {
          const symbol = data.getItemGraphicEl(dataIndex)

          if (symbol) {
            if (symbol.__temp) {
              data.setItemGraphicEl(dataIndex, null)
              this.group.remove(symbol)
            } else {
              symbol.downplay()
            }
          }
        } else {
          // FIXME
          // can not downplay completely.
          // Downplay whole series
          ChartView.prototype.downplay.call(this, seriesModel, ecModel, api, payload)
        }
      }

      LineView.prototype._changePolyState = function (toState) {
        const polygon = this._polygon
        setStatesFlag(this._polyline, toState)
        polygon && setStatesFlag(polygon, toState)
      }

      LineView.prototype._newPolyline = function (points) {
        let polyline = this._polyline // Remove previous created polyline

        if (polyline) {
          this._lineGroup.remove(polyline)
        }

        polyline = new ECPolyline({
          shape: {
            points: points
          },
          segmentIgnoreThreshold: 2,
          z2: 10
        })

        this._lineGroup.add(polyline)

        this._polyline = polyline
        return polyline
      }

      LineView.prototype._newPolygon = function (points, stackedOnPoints) {
        let polygon = this._polygon // Remove previous created polygon

        if (polygon) {
          this._lineGroup.remove(polygon)
        }

        polygon = new ECPolygon({
          shape: {
            points: points,
            stackedOnPoints: stackedOnPoints
          },
          segmentIgnoreThreshold: 2
        })

        this._lineGroup.add(polygon)

        this._polygon = polygon
        return polygon
      }

      LineView.prototype._initSymbolLabelAnimation = function (data, coordSys, clipShape) {
        let isHorizontalOrRadial
        let isCoordSysPolar
        const baseAxis = coordSys.getBaseAxis()
        const isAxisInverse = baseAxis.inverse

        if (coordSys.type === 'cartesian2d') {
          isHorizontalOrRadial = baseAxis.isHorizontal()
          isCoordSysPolar = false
        } else if (coordSys.type === 'polar') {
          isHorizontalOrRadial = baseAxis.dim === 'angle'
          isCoordSysPolar = true
        }

        const seriesModel = data.hostModel
        let seriesDuration = seriesModel.get('animationDuration')

        if (isFunction(seriesDuration)) {
          seriesDuration = seriesDuration(null)
        }

        const seriesDalay = seriesModel.get('animationDelay') || 0
        const seriesDalayValue = isFunction(seriesDalay) ? seriesDalay(null) : seriesDalay
        data.eachItemGraphicEl(function (symbol, idx) {
          const el = symbol

          if (el) {
            const point = [symbol.x, symbol.y]
            let start = void 0
            let end = void 0
            let current = void 0

            if (clipShape) {
              if (isCoordSysPolar) {
                const polarClip = clipShape
                const coord = coordSys.pointToCoord(point)

                if (isHorizontalOrRadial) {
                  start = polarClip.startAngle
                  end = polarClip.endAngle
                  current = -coord[1] / 180 * Math.PI
                } else {
                  start = polarClip.r0
                  end = polarClip.r
                  current = coord[0]
                }
              } else {
                const gridClip = clipShape

                if (isHorizontalOrRadial) {
                  start = gridClip.x
                  end = gridClip.x + gridClip.width
                  current = symbol.x
                } else {
                  start = gridClip.y + gridClip.height
                  end = gridClip.y
                  current = symbol.y
                }
              }
            }

            let ratio = end === start ? 0 : (current - start) / (end - start)

            if (isAxisInverse) {
              ratio = 1 - ratio
            }

            const delay = isFunction(seriesDalay) ? seriesDalay(idx) : seriesDuration * ratio + seriesDalayValue
            const symbolPath = el.getSymbolPath()
            const text = symbolPath.getTextContent()
            el.attr({
              scaleX: 0,
              scaleY: 0
            })
            el.animateTo({
              scaleX: 1,
              scaleY: 1
            }, {
              duration: 200,
              setToFinal: true,
              delay: delay
            })

            if (text) {
              text.animateFrom({
                style: {
                  opacity: 0
                }
              }, {
                duration: 300,
                delay: delay
              })
            }

            symbolPath.disableLabelAnimation = true
          }
        })
      }

      LineView.prototype._initOrUpdateEndLabel = function (seriesModel, coordSys, inheritColor) {
        const endLabelModel = seriesModel.getModel('endLabel')

        if (anyStateShowEndLabel(seriesModel)) {
          const data_2 = seriesModel.getData()
          const polyline = this._polyline // series may be filtered.

          const points = data_2.getLayout('points')

          if (!points) {
            polyline.removeTextContent()
            this._endLabel = null
            return
          }

          let endLabel = this._endLabel

          if (!endLabel) {
            endLabel = this._endLabel = new ZRText({
              z2: 200 // should be higher than item symbol

            })
            endLabel.ignoreClip = true
            polyline.setTextContent(this._endLabel)
            polyline.disableLabelAnimation = true
          } // Find last non-NaN data to display data

          const dataIndex = getLastIndexNotNull(points)

          if (dataIndex >= 0) {
            setLabelStyle(polyline, getLabelStatesModels(seriesModel, 'endLabel'), {
              inheritColor: inheritColor,
              labelFetcher: seriesModel,
              labelDataIndex: dataIndex,
              defaultText: function (dataIndex, opt, interpolatedValue) {
                return interpolatedValue != null ? getDefaultInterpolatedLabel(data_2, interpolatedValue) : getDefaultLabel(data_2, dataIndex)
              },
              enableTextSetter: true
            }, getEndLabelStateSpecified(endLabelModel, coordSys))
            polyline.textConfig.position = null
          }
        } else if (this._endLabel) {
          this._polyline.removeTextContent()

          this._endLabel = null
        }
      }

      LineView.prototype._endLabelOnDuring = function (percent, clipRect, data, animationRecord, valueAnimation, endLabelModel, coordSys) {
        const endLabel = this._endLabel
        const polyline = this._polyline

        if (endLabel) {
          // NOTE: Don't remove percent < 1. percent === 1 means the first frame during render.
          // The label is not prepared at this time.
          if (percent < 1 && animationRecord.originalX == null) {
            animationRecord.originalX = endLabel.x
            animationRecord.originalY = endLabel.y
          }

          const points = data.getLayout('points')
          const seriesModel = data.hostModel
          const connectNulls = seriesModel.get('connectNulls')
          const precision = endLabelModel.get('precision')
          const distance = endLabelModel.get('distance') || 0
          const baseAxis = coordSys.getBaseAxis()
          const isHorizontal = baseAxis.isHorizontal()
          const isBaseInversed = baseAxis.inverse
          const clipShape = clipRect.shape
          const xOrY = isBaseInversed ? isHorizontal ? clipShape.x : clipShape.y + clipShape.height : isHorizontal ? clipShape.x + clipShape.width : clipShape.y
          const distanceX = (isHorizontal ? distance : 0) * (isBaseInversed ? -1 : 1)
          const distanceY = (isHorizontal ? 0 : -distance) * (isBaseInversed ? -1 : 1)
          const dim = isHorizontal ? 'x' : 'y'
          const dataIndexRange = getIndexRange(points, xOrY, dim)
          const indices = dataIndexRange.range
          const diff = indices[1] - indices[0]
          let value = void 0

          if (diff >= 1) {
            // diff > 1 && connectNulls, which is on the null data.
            if (diff > 1 && !connectNulls) {
              var pt = getPointAtIndex(points, indices[0])
              endLabel.attr({
                x: pt[0] + distanceX,
                y: pt[1] + distanceY
              })
              valueAnimation && (value = seriesModel.getRawValue(indices[0]))
            } else {
              var pt = polyline.getPointOn(xOrY, dim)
              pt && endLabel.attr({
                x: pt[0] + distanceX,
                y: pt[1] + distanceY
              })
              const startValue = seriesModel.getRawValue(indices[0])
              const endValue = seriesModel.getRawValue(indices[1])
              valueAnimation && (value = interpolateRawValues(data, precision, startValue, endValue, dataIndexRange.t))
            }

            animationRecord.lastFrameIndex = indices[0]
          } else {
            // If diff <= 0, which is the range is not found(Include NaN)
            // Choose the first point or last point.
            const idx = percent === 1 || animationRecord.lastFrameIndex > 0 ? indices[0] : 0
            var pt = getPointAtIndex(points, idx)
            valueAnimation && (value = seriesModel.getRawValue(idx))
            endLabel.attr({
              x: pt[0] + distanceX,
              y: pt[1] + distanceY
            })
          }

          if (valueAnimation) {
            labelInner(endLabel).setLabelText(value)
          }
        }
      }
      /**
       * @private
       */
      // FIXME Two value axis

      LineView.prototype._doUpdateAnimation = function (data, stackedOnPoints, coordSys, api, step, valueOrigin, connectNulls) {
        const polyline = this._polyline
        const polygon = this._polygon
        const seriesModel = data.hostModel
        const diff = lineAnimationDiff(this._data, data, this._stackedOnPoints, stackedOnPoints, this._coordSys, coordSys, this._valueOrigin)
        let current = diff.current
        let stackedOnCurrent = diff.stackedOnCurrent
        let next = diff.next
        let stackedOnNext = diff.stackedOnNext

        if (step) {
          // TODO If stacked series is not step
          current = turnPointsIntoStep(diff.current, coordSys, step, connectNulls)
          stackedOnCurrent = turnPointsIntoStep(diff.stackedOnCurrent, coordSys, step, connectNulls)
          next = turnPointsIntoStep(diff.next, coordSys, step, connectNulls)
          stackedOnNext = turnPointsIntoStep(diff.stackedOnNext, coordSys, step, connectNulls)
        } // Don't apply animation if diff is large.
        // For better result and avoid memory explosion problems like
        // https://github.com/apache/incubator-echarts/issues/12229

        if (getBoundingDiff(current, next) > 3000 || polygon && getBoundingDiff(stackedOnCurrent, stackedOnNext) > 3000) {
          polyline.stopAnimation()
          polyline.setShape({
            points: next
          })

          if (polygon) {
            polygon.stopAnimation()
            polygon.setShape({
              points: next,
              stackedOnPoints: stackedOnNext
            })
          }

          return
        }

        polyline.shape.__points = diff.current
        polyline.shape.points = current
        const target = {
          shape: {
            points: next
          }
        } // Also animate the original points.
        // If points reference is changed when turning into step line.

        if (diff.current !== current) {
          target.shape.__points = diff.next
        } // Stop previous animation.

        polyline.stopAnimation()
        updateProps(polyline, target, seriesModel)

        if (polygon) {
          polygon.setShape({
            // Reuse the points with polyline.
            points: current,
            stackedOnPoints: stackedOnCurrent
          })
          polygon.stopAnimation()
          updateProps(polygon, {
            shape: {
              stackedOnPoints: stackedOnNext
            }
          }, seriesModel) // If use attr directly in updateProps.

          if (polyline.shape.points !== polygon.shape.points) {
            polygon.shape.points = polyline.shape.points
          }
        }

        const updatedDataInfo = []
        const diffStatus = diff.status

        for (let i = 0; i < diffStatus.length; i++) {
          const cmd = diffStatus[i].cmd

          if (cmd === '=') {
            const el = data.getItemGraphicEl(diffStatus[i].idx1)

            if (el) {
              updatedDataInfo.push({
                el: el,
                ptIdx: i // Index of points

              })
            }
          }
        }

        if (polyline.animators && polyline.animators.length) {
          polyline.animators[0].during(function () {
            polygon && polygon.dirtyShape()
            const points = polyline.shape.__points

            for (let i = 0; i < updatedDataInfo.length; i++) {
              const el = updatedDataInfo[i].el
              const offset = updatedDataInfo[i].ptIdx * 2
              el.x = points[offset]
              el.y = points[offset + 1]
              el.markRedraw()
            }
          })
        }
      }

      LineView.prototype.remove = function (ecModel) {
        const group = this.group
        const oldData = this._data

        this._lineGroup.removeAll()

        this._symbolDraw.remove(true) // Remove temporary created elements when highlighting

        oldData && oldData.eachItemGraphicEl(function (el, idx) {
          if (el.__temp) {
            group.remove(el)
            oldData.setItemGraphicEl(idx, null)
          }
        })
        this._polyline = this._polygon = this._coordSys = this._points = this._stackedOnPoints = this._endLabel = this._data = null
      }

      LineView.type = 'line'
      return LineView
    }(ChartView))

  function pointsLayout (seriesType, forceStoreInTypedArray) {
    return {
      seriesType: seriesType,
      plan: createRenderPlanner(),
      reset: function (seriesModel) {
        const data = seriesModel.getData()
        const coordSys = seriesModel.coordinateSystem
        const pipelineContext = seriesModel.pipelineContext
        const useTypedArray = forceStoreInTypedArray || pipelineContext.large

        if (!coordSys) {
          return
        }

        const dims = map(coordSys.dimensions, function (dim) {
          return data.mapDimension(dim)
        }).slice(0, 2)
        const dimLen = dims.length
        const stackResultDim = data.getCalculationInfo('stackResultDimension')

        if (isDimensionStacked(data, dims[0])) {
          dims[0] = stackResultDim
        }

        if (isDimensionStacked(data, dims[1])) {
          dims[1] = stackResultDim
        }

        const store = data.getStore()
        const dimIdx0 = data.getDimensionIndex(dims[0])
        const dimIdx1 = data.getDimensionIndex(dims[1])
        return dimLen && {
          progress: function (params, data) {
            const segCount = params.end - params.start
            const points = useTypedArray && createFloat32Array(segCount * dimLen)
            const tmpIn = []
            const tmpOut = []

            for (let i = params.start, offset = 0; i < params.end; i++) {
              let point = void 0

              if (dimLen === 1) {
                const x = store.get(dimIdx0, i) // NOTE: Make sure the second parameter is null to use default strategy.

                point = coordSys.dataToPoint(x, null, tmpOut)
              } else {
                tmpIn[0] = store.get(dimIdx0, i)
                tmpIn[1] = store.get(dimIdx1, i) // Let coordinate system to handle the NaN data.

                point = coordSys.dataToPoint(tmpIn, null, tmpOut)
              }

              if (useTypedArray) {
                points[offset++] = point[0]
                points[offset++] = point[1]
              } else {
                data.setItemLayout(i, point.slice())
              }
            }

            useTypedArray && data.setLayout('points', points)
          }
        }
      }
    }
  }

  const samplers = {
    average: function (frame) {
      let sum = 0
      let count = 0

      for (let i = 0; i < frame.length; i++) {
        if (!isNaN(frame[i])) {
          sum += frame[i]
          count++
        }
      } // Return NaN if count is 0

      return count === 0 ? NaN : sum / count
    },
    sum: function (frame) {
      let sum = 0

      for (let i = 0; i < frame.length; i++) {
        // Ignore NaN
        sum += frame[i] || 0
      }

      return sum
    },
    max: function (frame) {
      let max = -Infinity

      for (let i = 0; i < frame.length; i++) {
        frame[i] > max && (max = frame[i])
      } // NaN will cause illegal axis extent.

      return isFinite(max) ? max : NaN
    },
    min: function (frame) {
      let min = Infinity

      for (let i = 0; i < frame.length; i++) {
        frame[i] < min && (min = frame[i])
      } // NaN will cause illegal axis extent.

      return isFinite(min) ? min : NaN
    },
    // TODO
    // Median
    nearest: function (frame) {
      return frame[0]
    }
  }

  const indexSampler = function (frame) {
    return Math.round(frame.length / 2)
  }

  function dataSample (seriesType) {
    return {
      seriesType: seriesType,
      // FIXME:TS never used, so comment it
      // modifyOutputEnd: true,
      reset: function (seriesModel, ecModel, api) {
        const data = seriesModel.getData()
        const sampling = seriesModel.get('sampling')
        const coordSys = seriesModel.coordinateSystem
        const count = data.count() // Only cartesian2d support down sampling. Disable it when there is few data.

        if (count > 10 && coordSys.type === 'cartesian2d' && sampling) {
          const baseAxis = coordSys.getBaseAxis()
          const valueAxis = coordSys.getOtherAxis(baseAxis)
          const extent = baseAxis.getExtent()
          const dpr = api.getDevicePixelRatio() // Coordinste system has been resized

          const size = Math.abs(extent[1] - extent[0]) * (dpr || 1)
          const rate = Math.round(count / size)

          if (isFinite(rate) && rate > 1) {
            if (sampling === 'lttb') {
              seriesModel.setData(data.lttbDownSample(data.mapDimension(valueAxis.dim), 1 / rate))
            }

            let sampler = void 0

            if (isString(sampling)) {
              sampler = samplers[sampling]
            } else if (isFunction(sampling)) {
              sampler = sampling
            }

            if (sampler) {
              // Only support sample the first dim mapped from value axis.
              seriesModel.setData(data.downSample(data.mapDimension(valueAxis.dim), 1 / rate, sampler, indexSampler))
            }
          }
        }
      }
    }
  }

  function install$2 (registers) {
    registers.registerChartView(LineView)
    registers.registerSeriesModel(LineSeriesModel)
    registers.registerLayout(pointsLayout('line', true))
    registers.registerVisual({
      seriesType: 'line',
      reset: function (seriesModel) {
        const data = seriesModel.getData() // Visual coding for legend

        const lineStyle = seriesModel.getModel('lineStyle').getLineStyle()

        if (lineStyle && !lineStyle.stroke) {
          // Fill in visual should be palette color if
          // has color callback
          lineStyle.stroke = data.getVisual('style').fill
        }

        data.setVisual('legendLineStyle', lineStyle)
      }
    }) // Down sample after filter

    registers.registerProcessor(registers.PRIORITY.PROCESSOR.STATISTIC, dataSample('line'))
  }

  const BaseBarSeriesModel =
    /** @class */
    (function (_super) {
      __extends(BaseBarSeriesModel, _super)

      function BaseBarSeriesModel () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = BaseBarSeriesModel.type
        return _this
      }

      BaseBarSeriesModel.prototype.getInitialData = function (option, ecModel) {
        return createSeriesData(null, this, {
          useEncodeDefaulter: true
        })
      }

      BaseBarSeriesModel.prototype.getMarkerPosition = function (value) {
        const coordSys = this.coordinateSystem

        if (coordSys && coordSys.clampData) {
          // PENDING if clamp ?
          const pt = coordSys.dataToPoint(coordSys.clampData(value))
          const data = this.getData()
          const offset = data.getLayout('offset')
          const size = data.getLayout('size')
          const offsetIndex = coordSys.getBaseAxis().isHorizontal() ? 0 : 1
          pt[offsetIndex] += offset + size / 2
          return pt
        }

        return [NaN, NaN]
      }

      BaseBarSeriesModel.type = 'series.__base_bar__'
      BaseBarSeriesModel.defaultOption = {
        // zlevel: 0,
        z: 2,
        coordinateSystem: 'cartesian2d',
        legendHoverLink: true,
        // stack: null
        // Cartesian coordinate system
        // xAxisIndex: 0,
        // yAxisIndex: 0,
        barMinHeight: 0,
        barMinAngle: 0,
        // cursor: null,
        large: false,
        largeThreshold: 400,
        progressive: 3e3,
        progressiveChunkMode: 'mod'
      }
      return BaseBarSeriesModel
    }(SeriesModel))

  SeriesModel.registerClass(BaseBarSeriesModel)

  const BarSeriesModel =
    /** @class */
    (function (_super) {
      __extends(BarSeriesModel, _super)

      function BarSeriesModel () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = BarSeriesModel.type
        return _this
      }

      BarSeriesModel.prototype.getInitialData = function () {
        return createSeriesData(null, this, {
          useEncodeDefaulter: true,
          createInvertedIndices: !!this.get('realtimeSort', true) || null
        })
      }
      /**
       * @override
       */

      BarSeriesModel.prototype.getProgressive = function () {
        // Do not support progressive in normal mode.
        return this.get('large') ? this.get('progressive') : false
      }
      /**
       * @override
       */

      BarSeriesModel.prototype.getProgressiveThreshold = function () {
        // Do not support progressive in normal mode.
        let progressiveThreshold = this.get('progressiveThreshold')
        const largeThreshold = this.get('largeThreshold')

        if (largeThreshold > progressiveThreshold) {
          progressiveThreshold = largeThreshold
        }

        return progressiveThreshold
      }

      BarSeriesModel.prototype.brushSelector = function (dataIndex, data, selectors) {
        return selectors.rect(data.getItemLayout(dataIndex))
      }

      BarSeriesModel.type = 'series.bar'
      BarSeriesModel.dependencies = ['grid', 'polar']
      BarSeriesModel.defaultOption = inheritDefaultOption(BaseBarSeriesModel.defaultOption, {
        // If clipped
        // Only available on cartesian2d
        clip: true,
        roundCap: false,
        showBackground: false,
        backgroundStyle: {
          color: 'rgba(180, 180, 180, 0.2)',
          borderColor: null,
          borderWidth: 0,
          borderType: 'solid',
          borderRadius: 0,
          shadowBlur: 0,
          shadowColor: null,
          shadowOffsetX: 0,
          shadowOffsetY: 0,
          opacity: 1
        },
        select: {
          itemStyle: {
            borderColor: '#212121'
          }
        },
        realtimeSort: false
      })
      return BarSeriesModel
    }(BaseBarSeriesModel))

  /**
     * Sausage: similar to sector, but have half circle on both sides
     */

  const SausageShape =
    /** @class */
    (function () {
      function SausageShape () {
        this.cx = 0
        this.cy = 0
        this.r0 = 0
        this.r = 0
        this.startAngle = 0
        this.endAngle = Math.PI * 2
        this.clockwise = true
      }

      return SausageShape
    }())

  const SausagePath =
    /** @class */
    (function (_super) {
      __extends(SausagePath, _super)

      function SausagePath (opts) {
        const _this = _super.call(this, opts) || this

        _this.type = 'sausage'
        return _this
      }

      SausagePath.prototype.getDefaultShape = function () {
        return new SausageShape()
      }

      SausagePath.prototype.buildPath = function (ctx, shape) {
        const cx = shape.cx
        const cy = shape.cy
        const r0 = Math.max(shape.r0 || 0, 0)
        const r = Math.max(shape.r, 0)
        const dr = (r - r0) * 0.5
        const rCenter = r0 + dr
        let startAngle = shape.startAngle
        const endAngle = shape.endAngle
        const clockwise = shape.clockwise
        const PI2 = Math.PI * 2
        const lessThanCircle = clockwise ? endAngle - startAngle < PI2 : startAngle - endAngle < PI2

        if (!lessThanCircle) {
          // Normalize angles
          startAngle = endAngle - (clockwise ? PI2 : -PI2)
        }

        const unitStartX = Math.cos(startAngle)
        const unitStartY = Math.sin(startAngle)
        const unitEndX = Math.cos(endAngle)
        const unitEndY = Math.sin(endAngle)

        if (lessThanCircle) {
          ctx.moveTo(unitStartX * r0 + cx, unitStartY * r0 + cy)
          ctx.arc(unitStartX * rCenter + cx, unitStartY * rCenter + cy, dr, -Math.PI + startAngle, startAngle, !clockwise)
        } else {
          ctx.moveTo(unitStartX * r + cx, unitStartY * r + cy)
        }

        ctx.arc(cx, cy, r, startAngle, endAngle, !clockwise)
        ctx.arc(unitEndX * rCenter + cx, unitEndY * rCenter + cy, dr, endAngle - Math.PI * 2, endAngle - Math.PI, !clockwise)

        if (r0 !== 0) {
          ctx.arc(cx, cy, r0, endAngle, startAngle, clockwise)
        } // ctx.closePath();
      }

      return SausagePath
    }(Path))

  function createSectorCalculateTextPosition (positionMapping, opts) {
    opts = opts || {}
    const isRoundCap = opts.isRoundCap
    return function (out, opts, boundingRect) {
      const textPosition = opts.position

      if (!textPosition || textPosition instanceof Array) {
        return calculateTextPosition(out, opts, boundingRect)
      }

      const mappedSectorPosition = positionMapping(textPosition)
      const distance = opts.distance != null ? opts.distance : 5
      const sector = this.shape
      const cx = sector.cx
      const cy = sector.cy
      const r = sector.r
      const r0 = sector.r0
      const middleR = (r + r0) / 2
      const startAngle = sector.startAngle
      const endAngle = sector.endAngle
      const middleAngle = (startAngle + endAngle) / 2
      const extraDist = isRoundCap ? Math.abs(r - r0) / 2 : 0
      const mathCos = Math.cos
      const mathSin = Math.sin // base position: top-left

      let x = cx + r * mathCos(startAngle)
      let y = cy + r * mathSin(startAngle)
      let textAlign = 'left'
      let textVerticalAlign = 'top'

      switch (mappedSectorPosition) {
        case 'startArc':
          x = cx + (r0 - distance) * mathCos(middleAngle)
          y = cy + (r0 - distance) * mathSin(middleAngle)
          textAlign = 'center'
          textVerticalAlign = 'top'
          break

        case 'insideStartArc':
          x = cx + (r0 + distance) * mathCos(middleAngle)
          y = cy + (r0 + distance) * mathSin(middleAngle)
          textAlign = 'center'
          textVerticalAlign = 'bottom'
          break

        case 'startAngle':
          x = cx + middleR * mathCos(startAngle) + adjustAngleDistanceX(startAngle, distance + extraDist, false)
          y = cy + middleR * mathSin(startAngle) + adjustAngleDistanceY(startAngle, distance + extraDist, false)
          textAlign = 'right'
          textVerticalAlign = 'middle'
          break

        case 'insideStartAngle':
          x = cx + middleR * mathCos(startAngle) + adjustAngleDistanceX(startAngle, -distance + extraDist, false)
          y = cy + middleR * mathSin(startAngle) + adjustAngleDistanceY(startAngle, -distance + extraDist, false)
          textAlign = 'left'
          textVerticalAlign = 'middle'
          break

        case 'middle':
          x = cx + middleR * mathCos(middleAngle)
          y = cy + middleR * mathSin(middleAngle)
          textAlign = 'center'
          textVerticalAlign = 'middle'
          break

        case 'endArc':
          x = cx + (r + distance) * mathCos(middleAngle)
          y = cy + (r + distance) * mathSin(middleAngle)
          textAlign = 'center'
          textVerticalAlign = 'bottom'
          break

        case 'insideEndArc':
          x = cx + (r - distance) * mathCos(middleAngle)
          y = cy + (r - distance) * mathSin(middleAngle)
          textAlign = 'center'
          textVerticalAlign = 'top'
          break

        case 'endAngle':
          x = cx + middleR * mathCos(endAngle) + adjustAngleDistanceX(endAngle, distance + extraDist, true)
          y = cy + middleR * mathSin(endAngle) + adjustAngleDistanceY(endAngle, distance + extraDist, true)
          textAlign = 'left'
          textVerticalAlign = 'middle'
          break

        case 'insideEndAngle':
          x = cx + middleR * mathCos(endAngle) + adjustAngleDistanceX(endAngle, -distance + extraDist, true)
          y = cy + middleR * mathSin(endAngle) + adjustAngleDistanceY(endAngle, -distance + extraDist, true)
          textAlign = 'right'
          textVerticalAlign = 'middle'
          break

        default:
          return calculateTextPosition(out, opts, boundingRect)
      }

      out = out || {}
      out.x = x
      out.y = y
      out.align = textAlign
      out.verticalAlign = textVerticalAlign
      return out
    }
  }
  function setSectorTextRotation (sector, textPosition, positionMapping, rotateType) {
    if (isNumber(rotateType)) {
      // user-set rotation
      sector.setTextConfig({
        rotation: rotateType
      })
      return
    } else if (isArray(textPosition)) {
      // user-set position, use 0 as auto rotation
      sector.setTextConfig({
        rotation: 0
      })
      return
    }

    const shape = sector.shape
    const startAngle = shape.clockwise ? shape.startAngle : shape.endAngle
    const endAngle = shape.clockwise ? shape.endAngle : shape.startAngle
    const middleAngle = (startAngle + endAngle) / 2
    let anchorAngle
    const mappedSectorPosition = positionMapping(textPosition)

    switch (mappedSectorPosition) {
      case 'startArc':
      case 'insideStartArc':
      case 'middle':
      case 'insideEndArc':
      case 'endArc':
        anchorAngle = middleAngle
        break

      case 'startAngle':
      case 'insideStartAngle':
        anchorAngle = startAngle
        break

      case 'endAngle':
      case 'insideEndAngle':
        anchorAngle = endAngle
        break

      default:
        sector.setTextConfig({
          rotation: 0
        })
        return
    }

    let rotate = Math.PI * 1.5 - anchorAngle
    /**
       * TODO: labels with rotate > Math.PI / 2 should be rotate another
       * half round flipped to increase readability. However, only middle
       * position supports this for now, because in other positions, the
       * anchor point is not at the center of the text, so the positions
       * after rotating is not as expected.
       */

    if (mappedSectorPosition === 'middle' && rotate > Math.PI / 2 && rotate < Math.PI * 1.5) {
      rotate -= Math.PI
    }

    sector.setTextConfig({
      rotation: rotate
    })
  }

  function adjustAngleDistanceX (angle, distance, isEnd) {
    return distance * Math.sin(angle) * (isEnd ? -1 : 1)
  }

  function adjustAngleDistanceY (angle, distance, isEnd) {
    return distance * Math.cos(angle) * (isEnd ? 1 : -1)
  }

  const mathMax$6 = Math.max
  const mathMin$6 = Math.min

  function getClipArea (coord, data) {
    const coordSysClipArea = coord.getArea && coord.getArea()

    if (isCoordinateSystemType(coord, 'cartesian2d')) {
      const baseAxis = coord.getBaseAxis() // When boundaryGap is false or using time axis. bar may exceed the grid.
      // We should not clip this part.
      // See test/bar2.html

      if (baseAxis.type !== 'category' || !baseAxis.onBand) {
        const expandWidth = data.getLayout('bandWidth')

        if (baseAxis.isHorizontal()) {
          coordSysClipArea.x -= expandWidth
          coordSysClipArea.width += expandWidth * 2
        } else {
          coordSysClipArea.y -= expandWidth
          coordSysClipArea.height += expandWidth * 2
        }
      }
    }

    return coordSysClipArea
  }

  const BarView =
    /** @class */
    (function (_super) {
      __extends(BarView, _super)

      function BarView () {
        const _this = _super.call(this) || this

        _this.type = BarView.type
        _this._isFirstFrame = true
        return _this
      }

      BarView.prototype.render = function (seriesModel, ecModel, api, payload) {
        this._model = seriesModel

        this._removeOnRenderedListener(api)

        this._updateDrawMode(seriesModel)

        const coordinateSystemType = seriesModel.get('coordinateSystem')

        if (coordinateSystemType === 'cartesian2d' || coordinateSystemType === 'polar') {
          // Clear previously rendered progressive elements.
          this._progressiveEls = null
          this._isLargeDraw ? this._renderLarge(seriesModel, ecModel, api) : this._renderNormal(seriesModel, ecModel, api, payload)
        } else if ('development' !== 'production') {
          warn('Only cartesian2d and polar supported for bar.')
        }
      }

      BarView.prototype.incrementalPrepareRender = function (seriesModel) {
        this._clear()

        this._updateDrawMode(seriesModel) // incremental also need to clip, otherwise might be overlow.
        // But must not set clip in each frame, otherwise all of the children will be marked redraw.

        this._updateLargeClip(seriesModel)
      }

      BarView.prototype.incrementalRender = function (params, seriesModel) {
        // Reset
        this._progressiveEls = [] // Do not support progressive in normal mode.

        this._incrementalRenderLarge(params, seriesModel)
      }

      BarView.prototype.eachRendered = function (cb) {
        traverseElements(this._progressiveEls || this.group, cb)
      }

      BarView.prototype._updateDrawMode = function (seriesModel) {
        const isLargeDraw = seriesModel.pipelineContext.large

        if (this._isLargeDraw == null || isLargeDraw !== this._isLargeDraw) {
          this._isLargeDraw = isLargeDraw

          this._clear()
        }
      }

      BarView.prototype._renderNormal = function (seriesModel, ecModel, api, payload) {
        const group = this.group
        const data = seriesModel.getData()
        const oldData = this._data
        const coord = seriesModel.coordinateSystem
        const baseAxis = coord.getBaseAxis()
        let isHorizontalOrRadial

        if (coord.type === 'cartesian2d') {
          isHorizontalOrRadial = baseAxis.isHorizontal()
        } else if (coord.type === 'polar') {
          isHorizontalOrRadial = baseAxis.dim === 'angle'
        }

        const animationModel = seriesModel.isAnimationEnabled() ? seriesModel : null
        const realtimeSortCfg = shouldRealtimeSort(seriesModel, coord)

        if (realtimeSortCfg) {
          this._enableRealtimeSort(realtimeSortCfg, data, api)
        }

        const needsClip = seriesModel.get('clip', true) || realtimeSortCfg
        const coordSysClipArea = getClipArea(coord, data) // If there is clipPath created in large mode. Remove it.

        group.removeClipPath() // We don't use clipPath in normal mode because we needs a perfect animation
        // And don't want the label are clipped.

        const roundCap = seriesModel.get('roundCap', true)
        const drawBackground = seriesModel.get('showBackground', true)
        const backgroundModel = seriesModel.getModel('backgroundStyle')
        const barBorderRadius = backgroundModel.get('borderRadius') || 0
        const bgEls = []
        const oldBgEls = this._backgroundEls
        const isInitSort = payload && payload.isInitSort
        const isChangeOrder = payload && payload.type === 'changeAxisOrder'

        function createBackground (dataIndex) {
          const bgLayout = getLayout[coord.type](data, dataIndex)
          const bgEl = createBackgroundEl(coord, isHorizontalOrRadial, bgLayout)
          bgEl.useStyle(backgroundModel.getItemStyle()) // Only cartesian2d support borderRadius.

          if (coord.type === 'cartesian2d') {
            bgEl.setShape('r', barBorderRadius)
          }

          bgEls[dataIndex] = bgEl
          return bgEl
        }
        data.diff(oldData).add(function (dataIndex) {
          const itemModel = data.getItemModel(dataIndex)
          const layout = getLayout[coord.type](data, dataIndex, itemModel)

          if (drawBackground) {
            createBackground(dataIndex)
          } // If dataZoom in filteMode: 'empty', the baseValue can be set as NaN in "axisProxy".

          if (!data.hasValue(dataIndex) || !isValidLayout[coord.type](layout)) {
            return
          }

          let isClipped = false

          if (needsClip) {
            // Clip will modify the layout params.
            // And return a boolean to determine if the shape are fully clipped.
            isClipped = clip[coord.type](coordSysClipArea, layout)
          }

          const el = elementCreator[coord.type](seriesModel, data, dataIndex, layout, isHorizontalOrRadial, animationModel, baseAxis.model, false, roundCap)

          if (realtimeSortCfg) {
            /**
             * Force label animation because even if the element is
             * ignored because it's clipped, it may not be clipped after
             * changing order. Then, if not using forceLabelAnimation,
             * the label animation was never started, in which case,
             * the label will be the final value and doesn't have label
             * animation.
             */
            el.forceLabelAnimation = true
          }

          updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, coord.type === 'polar')

          if (isInitSort) {
            el.attr({
              shape: layout
            })
          } else if (realtimeSortCfg) {
            updateRealtimeAnimation(realtimeSortCfg, animationModel, el, layout, dataIndex, isHorizontalOrRadial, false, false)
          } else {
            initProps(el, {
              shape: layout
            }, seriesModel, dataIndex)
          }

          data.setItemGraphicEl(dataIndex, el)
          group.add(el)
          el.ignore = isClipped
        }).update(function (newIndex, oldIndex) {
          const itemModel = data.getItemModel(newIndex)
          const layout = getLayout[coord.type](data, newIndex, itemModel)

          if (drawBackground) {
            let bgEl = void 0

            if (oldBgEls.length === 0) {
              bgEl = createBackground(oldIndex)
            } else {
              bgEl = oldBgEls[oldIndex]
              bgEl.useStyle(backgroundModel.getItemStyle()) // Only cartesian2d support borderRadius.

              if (coord.type === 'cartesian2d') {
                bgEl.setShape('r', barBorderRadius)
              }

              bgEls[newIndex] = bgEl
            }

            const bgLayout = getLayout[coord.type](data, newIndex)
            const shape = createBackgroundShape(isHorizontalOrRadial, bgLayout, coord)
            updateProps(bgEl, {
              shape: shape
            }, animationModel, newIndex)
          }

          let el = oldData.getItemGraphicEl(oldIndex)

          if (!data.hasValue(newIndex) || !isValidLayout[coord.type](layout)) {
            group.remove(el)
            return
          }

          let isClipped = false

          if (needsClip) {
            isClipped = clip[coord.type](coordSysClipArea, layout)

            if (isClipped) {
              group.remove(el)
            }
          }

          if (!el) {
            el = elementCreator[coord.type](seriesModel, data, newIndex, layout, isHorizontalOrRadial, animationModel, baseAxis.model, !!el, roundCap)
          } else {
            saveOldStyle(el)
          }

          if (realtimeSortCfg) {
            el.forceLabelAnimation = true
          }

          if (isChangeOrder) {
            const textEl = el.getTextContent()

            if (textEl) {
              const labelInnerStore = labelInner(textEl)

              if (labelInnerStore.prevValue != null) {
                /**
                 * Set preValue to be value so that no new label
                 * should be started, otherwise, it will take a full
                 * `animationDurationUpdate` time to finish the
                 * animation, which is not expected.
                 */
                labelInnerStore.prevValue = labelInnerStore.value
              }
            }
          } // Not change anything if only order changed.
          // Especially not change label.
          else {
            updateStyle(el, data, newIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, coord.type === 'polar')
          }

          if (isInitSort) {
            el.attr({
              shape: layout
            })
          } else if (realtimeSortCfg) {
            updateRealtimeAnimation(realtimeSortCfg, animationModel, el, layout, newIndex, isHorizontalOrRadial, true, isChangeOrder)
          } else {
            updateProps(el, {
              shape: layout
            }, seriesModel, newIndex, null)
          }

          data.setItemGraphicEl(newIndex, el)
          el.ignore = isClipped
          group.add(el)
        }).remove(function (dataIndex) {
          const el = oldData.getItemGraphicEl(dataIndex)
          el && removeElementWithFadeOut(el, seriesModel, dataIndex)
        }).execute()
        const bgGroup = this._backgroundGroup || (this._backgroundGroup = new Group())
        bgGroup.removeAll()

        for (let i = 0; i < bgEls.length; ++i) {
          bgGroup.add(bgEls[i])
        }

        group.add(bgGroup)
        this._backgroundEls = bgEls
        this._data = data
      }

      BarView.prototype._renderLarge = function (seriesModel, ecModel, api) {
        this._clear()

        createLarge(seriesModel, this.group)

        this._updateLargeClip(seriesModel)
      }

      BarView.prototype._incrementalRenderLarge = function (params, seriesModel) {
        this._removeBackground()

        createLarge(seriesModel, this.group, this._progressiveEls, true)
      }

      BarView.prototype._updateLargeClip = function (seriesModel) {
        // Use clipPath in large mode.
        const clipPath = seriesModel.get('clip', true) && createClipPath(seriesModel.coordinateSystem, false, seriesModel)
        const group = this.group

        if (clipPath) {
          group.setClipPath(clipPath)
        } else {
          group.removeClipPath()
        }
      }

      BarView.prototype._enableRealtimeSort = function (realtimeSortCfg, data, api) {
        const _this = this // If no data in the first frame, wait for data to initSort

        if (!data.count()) {
          return
        }

        const baseAxis = realtimeSortCfg.baseAxis

        if (this._isFirstFrame) {
          this._dispatchInitSort(data, realtimeSortCfg, api)

          this._isFirstFrame = false
        } else {
          const orderMapping_1 = function (idx) {
            const el = data.getItemGraphicEl(idx)
            const shape = el && el.shape
            return shape && // The result should be consistent with the initial sort by data value.
            // Do not support the case that both positive and negative exist.
            Math.abs(baseAxis.isHorizontal() ? shape.height : shape.width) || // If data is NaN, shape.xxx may be NaN, so use || 0 here in case
            0
          }

          this._onRendered = function () {
            _this._updateSortWithinSameData(data, orderMapping_1, baseAxis, api)
          }

          api.getZr().on('rendered', this._onRendered)
        }
      }

      BarView.prototype._dataSort = function (data, baseAxis, orderMapping) {
        const info = []
        data.each(data.mapDimension(baseAxis.dim), function (ordinalNumber, dataIdx) {
          let mappedValue = orderMapping(dataIdx)
          mappedValue = mappedValue == null ? NaN : mappedValue
          info.push({
            dataIndex: dataIdx,
            mappedValue: mappedValue,
            ordinalNumber: ordinalNumber
          })
        })
        info.sort(function (a, b) {
          // If NaN, it will be treated as min val.
          return b.mappedValue - a.mappedValue
        })
        return {
          ordinalNumbers: map(info, function (item) {
            return item.ordinalNumber
          })
        }
      }

      BarView.prototype._isOrderChangedWithinSameData = function (data, orderMapping, baseAxis) {
        const scale = baseAxis.scale
        const ordinalDataDim = data.mapDimension(baseAxis.dim)
        let lastValue = Number.MAX_VALUE

        for (let tickNum = 0, len = scale.getOrdinalMeta().categories.length; tickNum < len; ++tickNum) {
          const rawIdx = data.rawIndexOf(ordinalDataDim, scale.getRawOrdinalNumber(tickNum))
          const value = rawIdx < 0 // If some tick have no bar, the tick will be treated as min.
            ? Number.MIN_VALUE // PENDING: if dataZoom on baseAxis exits, is it a performance issue?
            : orderMapping(data.indexOfRawIndex(rawIdx))

          if (value > lastValue) {
            return true
          }

          lastValue = value
        }

        return false
      }
      /*
       * Consider the case when A and B changed order, whose representing
       * bars are both out of sight, we don't wish to trigger reorder action
       * as long as the order in the view doesn't change.
       */

      BarView.prototype._isOrderDifferentInView = function (orderInfo, baseAxis) {
        const scale = baseAxis.scale
        const extent = scale.getExtent()
        let tickNum = Math.max(0, extent[0])
        const tickMax = Math.min(extent[1], scale.getOrdinalMeta().categories.length - 1)

        for (; tickNum <= tickMax; ++tickNum) {
          if (orderInfo.ordinalNumbers[tickNum] !== scale.getRawOrdinalNumber(tickNum)) {
            return true
          }
        }
      }

      BarView.prototype._updateSortWithinSameData = function (data, orderMapping, baseAxis, api) {
        if (!this._isOrderChangedWithinSameData(data, orderMapping, baseAxis)) {
          return
        }

        const sortInfo = this._dataSort(data, baseAxis, orderMapping)

        if (this._isOrderDifferentInView(sortInfo, baseAxis)) {
          this._removeOnRenderedListener(api)

          api.dispatchAction({
            type: 'changeAxisOrder',
            componentType: baseAxis.dim + 'Axis',
            axisId: baseAxis.index,
            sortInfo: sortInfo
          })
        }
      }

      BarView.prototype._dispatchInitSort = function (data, realtimeSortCfg, api) {
        const baseAxis = realtimeSortCfg.baseAxis

        const sortResult = this._dataSort(data, baseAxis, function (dataIdx) {
          return data.get(data.mapDimension(realtimeSortCfg.otherAxis.dim), dataIdx)
        })

        api.dispatchAction({
          type: 'changeAxisOrder',
          componentType: baseAxis.dim + 'Axis',
          isInitSort: true,
          axisId: baseAxis.index,
          sortInfo: sortResult
        })
      }

      BarView.prototype.remove = function (ecModel, api) {
        this._clear(this._model)

        this._removeOnRenderedListener(api)
      }

      BarView.prototype.dispose = function (ecModel, api) {
        this._removeOnRenderedListener(api)
      }

      BarView.prototype._removeOnRenderedListener = function (api) {
        if (this._onRendered) {
          api.getZr().off('rendered', this._onRendered)
          this._onRendered = null
        }
      }

      BarView.prototype._clear = function (model) {
        const group = this.group
        const data = this._data

        if (model && model.isAnimationEnabled() && data && !this._isLargeDraw) {
          this._removeBackground()

          this._backgroundEls = []
          data.eachItemGraphicEl(function (el) {
            removeElementWithFadeOut(el, model, getECData(el).dataIndex)
          })
        } else {
          group.removeAll()
        }

        this._data = null
        this._isFirstFrame = true
      }

      BarView.prototype._removeBackground = function () {
        this.group.remove(this._backgroundGroup)
        this._backgroundGroup = null
      }

      BarView.type = 'bar'
      return BarView
    }(ChartView))

  var clip = {
    cartesian2d: function (coordSysBoundingRect, layout) {
      const signWidth = layout.width < 0 ? -1 : 1
      const signHeight = layout.height < 0 ? -1 : 1 // Needs positive width and height

      if (signWidth < 0) {
        layout.x += layout.width
        layout.width = -layout.width
      }

      if (signHeight < 0) {
        layout.y += layout.height
        layout.height = -layout.height
      }

      const coordSysX2 = coordSysBoundingRect.x + coordSysBoundingRect.width
      const coordSysY2 = coordSysBoundingRect.y + coordSysBoundingRect.height
      const x = mathMax$6(layout.x, coordSysBoundingRect.x)
      const x2 = mathMin$6(layout.x + layout.width, coordSysX2)
      const y = mathMax$6(layout.y, coordSysBoundingRect.y)
      const y2 = mathMin$6(layout.y + layout.height, coordSysY2)
      const xClipped = x2 < x
      const yClipped = y2 < y // When xClipped or yClipped, the element will be marked as `ignore`.
      // But we should also place the element at the edge of the coord sys bounding rect.
      // Beause if data changed and the bar show again, its transition animaiton
      // will begin at this place.

      layout.x = xClipped && x > coordSysX2 ? x2 : x
      layout.y = yClipped && y > coordSysY2 ? y2 : y
      layout.width = xClipped ? 0 : x2 - x
      layout.height = yClipped ? 0 : y2 - y // Reverse back

      if (signWidth < 0) {
        layout.x += layout.width
        layout.width = -layout.width
      }

      if (signHeight < 0) {
        layout.y += layout.height
        layout.height = -layout.height
      }

      return xClipped || yClipped
    },
    polar: function (coordSysClipArea, layout) {
      const signR = layout.r0 <= layout.r ? 1 : -1 // Make sure r is larger than r0

      if (signR < 0) {
        var tmp = layout.r
        layout.r = layout.r0
        layout.r0 = tmp
      }

      const r = mathMin$6(layout.r, coordSysClipArea.r)
      const r0 = mathMax$6(layout.r0, coordSysClipArea.r0)
      layout.r = r
      layout.r0 = r0
      const clipped = r - r0 < 0 // Reverse back

      if (signR < 0) {
        var tmp = layout.r
        layout.r = layout.r0
        layout.r0 = tmp
      }

      return clipped
    }
  }
  var elementCreator = {
    cartesian2d: function (seriesModel, data, newIndex, layout, isHorizontal, animationModel, axisModel, isUpdate, roundCap) {
      const rect = new Rect({
        shape: extend({}, layout),
        z2: 1
      })
      rect.__dataIndex = newIndex
      rect.name = 'item'

      if (animationModel) {
        const rectShape = rect.shape
        const animateProperty = isHorizontal ? 'height' : 'width'
        rectShape[animateProperty] = 0
      }

      return rect
    },
    polar: function (seriesModel, data, newIndex, layout, isRadial, animationModel, axisModel, isUpdate, roundCap) {
      const ShapeClass = !isRadial && roundCap ? SausagePath : Sector
      const sector = new ShapeClass({
        shape: layout,
        z2: 1
      })
      sector.name = 'item'
      const positionMap = createPolarPositionMapping(isRadial)
      sector.calculateTextPosition = createSectorCalculateTextPosition(positionMap, {
        isRoundCap: ShapeClass === SausagePath
      }) // Animation

      if (animationModel) {
        const sectorShape = sector.shape
        const animateProperty = isRadial ? 'r' : 'endAngle'
        const animateTarget = {}
        sectorShape[animateProperty] = isRadial ? 0 : layout.startAngle
        animateTarget[animateProperty] = layout[animateProperty];
        (isUpdate ? updateProps : initProps)(sector, {
          shape: animateTarget // __value: typeof dataValue === 'string' ? parseInt(dataValue, 10) : dataValue

        }, animationModel)
      }

      return sector
    }
  }

  function shouldRealtimeSort (seriesModel, coordSys) {
    const realtimeSortOption = seriesModel.get('realtimeSort', true)
    const baseAxis = coordSys.getBaseAxis()

    if ('development' !== 'production') {
      if (realtimeSortOption) {
        if (baseAxis.type !== 'category') {
          warn('`realtimeSort` will not work because this bar series is not based on a category axis.')
        }

        if (coordSys.type !== 'cartesian2d') {
          warn('`realtimeSort` will not work because this bar series is not on cartesian2d.')
        }
      }
    }

    if (realtimeSortOption && baseAxis.type === 'category' && coordSys.type === 'cartesian2d') {
      return {
        baseAxis: baseAxis,
        otherAxis: coordSys.getOtherAxis(baseAxis)
      }
    }
  }

  function updateRealtimeAnimation (realtimeSortCfg, seriesAnimationModel, el, layout, newIndex, isHorizontal, isUpdate, isChangeOrder) {
    let seriesTarget
    let axisTarget

    if (isHorizontal) {
      axisTarget = {
        x: layout.x,
        width: layout.width
      }
      seriesTarget = {
        y: layout.y,
        height: layout.height
      }
    } else {
      axisTarget = {
        y: layout.y,
        height: layout.height
      }
      seriesTarget = {
        x: layout.x,
        width: layout.width
      }
    }

    if (!isChangeOrder) {
      // Keep the original growth animation if only axis order changed.
      // Not start a new animation.
      (isUpdate ? updateProps : initProps)(el, {
        shape: seriesTarget
      }, seriesAnimationModel, newIndex, null)
    }

    const axisAnimationModel = seriesAnimationModel ? realtimeSortCfg.baseAxis.model : null;
    (isUpdate ? updateProps : initProps)(el, {
      shape: axisTarget
    }, axisAnimationModel, newIndex)
  }

  function checkPropertiesNotValid (obj, props) {
    for (let i = 0; i < props.length; i++) {
      if (!isFinite(obj[props[i]])) {
        return true
      }
    }

    return false
  }

  const rectPropties = ['x', 'y', 'width', 'height']
  const polarPropties = ['cx', 'cy', 'r', 'startAngle', 'endAngle']
  var isValidLayout = {
    cartesian2d: function (layout) {
      return !checkPropertiesNotValid(layout, rectPropties)
    },
    polar: function (layout) {
      return !checkPropertiesNotValid(layout, polarPropties)
    }
  }
  var getLayout = {
    // itemModel is only used to get borderWidth, which is not needed
    // when calculating bar background layout.
    cartesian2d: function (data, dataIndex, itemModel) {
      const layout = data.getItemLayout(dataIndex)
      const fixedLineWidth = itemModel ? getLineWidth(itemModel, layout) : 0 // fix layout with lineWidth

      const signX = layout.width > 0 ? 1 : -1
      const signY = layout.height > 0 ? 1 : -1
      return {
        x: layout.x + signX * fixedLineWidth / 2,
        y: layout.y + signY * fixedLineWidth / 2,
        width: layout.width - signX * fixedLineWidth,
        height: layout.height - signY * fixedLineWidth
      }
    },
    polar: function (data, dataIndex, itemModel) {
      const layout = data.getItemLayout(dataIndex)
      return {
        cx: layout.cx,
        cy: layout.cy,
        r0: layout.r0,
        r: layout.r,
        startAngle: layout.startAngle,
        endAngle: layout.endAngle,
        clockwise: layout.clockwise
      }
    }
  }

  function isZeroOnPolar (layout) {
    return layout.startAngle != null && layout.endAngle != null && layout.startAngle === layout.endAngle
  }

  function createPolarPositionMapping (isRadial) {
    return (function (isRadial) {
      const arcOrAngle = isRadial ? 'Arc' : 'Angle'
      return function (position) {
        switch (position) {
          case 'start':
          case 'insideStart':
          case 'end':
          case 'insideEnd':
            return position + arcOrAngle

          default:
            return position
        }
      }
    }(isRadial))
  }

  function updateStyle (el, data, dataIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, isPolar) {
    const style = data.getItemVisual(dataIndex, 'style')

    if (!isPolar) {
      el.setShape('r', itemModel.get(['itemStyle', 'borderRadius']) || 0)
    }

    el.useStyle(style)
    const cursorStyle = itemModel.getShallow('cursor')
    cursorStyle && el.attr('cursor', cursorStyle)
    const labelPositionOutside = isPolar ? isHorizontalOrRadial ? layout.r >= layout.r0 ? 'endArc' : 'startArc' : layout.endAngle >= layout.startAngle ? 'endAngle' : 'startAngle' : isHorizontalOrRadial ? layout.height >= 0 ? 'bottom' : 'top' : layout.width >= 0 ? 'right' : 'left'
    const labelStatesModels = getLabelStatesModels(itemModel)
    setLabelStyle(el, labelStatesModels, {
      labelFetcher: seriesModel,
      labelDataIndex: dataIndex,
      defaultText: getDefaultLabel(seriesModel.getData(), dataIndex),
      inheritColor: style.fill,
      defaultOpacity: style.opacity,
      defaultOutsidePosition: labelPositionOutside
    })
    const label = el.getTextContent()

    if (isPolar && label) {
      const position = itemModel.get(['label', 'position'])
      el.textConfig.inside = position === 'middle' ? true : null
      setSectorTextRotation(el, position === 'outside' ? labelPositionOutside : position, createPolarPositionMapping(isHorizontalOrRadial), itemModel.get(['label', 'rotate']))
    }

    setLabelValueAnimation(label, labelStatesModels, seriesModel.getRawValue(dataIndex), function (value) {
      return getDefaultInterpolatedLabel(data, value)
    })
    const emphasisModel = itemModel.getModel(['emphasis'])
    toggleHoverEmphasis(el, emphasisModel.get('focus'), emphasisModel.get('blurScope'), emphasisModel.get('disabled'))
    setStatesStylesFromModel(el, itemModel)

    if (isZeroOnPolar(layout)) {
      el.style.fill = 'none'
      el.style.stroke = 'none'
      each(el.states, function (state) {
        if (state.style) {
          state.style.fill = state.style.stroke = 'none'
        }
      })
    }
  } // In case width or height are too small.

  function getLineWidth (itemModel, rawLayout) {
    // Has no border.
    const borderColor = itemModel.get(['itemStyle', 'borderColor'])

    if (!borderColor || borderColor === 'none') {
      return 0
    }

    const lineWidth = itemModel.get(['itemStyle', 'borderWidth']) || 0 // width or height may be NaN for empty data

    const width = isNaN(rawLayout.width) ? Number.MAX_VALUE : Math.abs(rawLayout.width)
    const height = isNaN(rawLayout.height) ? Number.MAX_VALUE : Math.abs(rawLayout.height)
    return Math.min(lineWidth, width, height)
  }

  const LagePathShape =
    /** @class */
    (function () {
      function LagePathShape () {}

      return LagePathShape
    }())

  const LargePath =
    /** @class */
    (function (_super) {
      __extends(LargePath, _super)

      function LargePath (opts) {
        const _this = _super.call(this, opts) || this

        _this.type = 'largeBar'
        return _this
      }

      LargePath.prototype.getDefaultShape = function () {
        return new LagePathShape()
      }

      LargePath.prototype.buildPath = function (ctx, shape) {
        // Drawing lines is more efficient than drawing
        // a whole line or drawing rects.
        const points = shape.points
        const baseDimIdx = this.baseDimIdx
        const valueDimIdx = 1 - this.baseDimIdx
        const startPoint = []
        const size = []
        const barWidth = this.barWidth

        for (let i = 0; i < points.length; i += 3) {
          size[baseDimIdx] = barWidth
          size[valueDimIdx] = points[i + 2]
          startPoint[baseDimIdx] = points[i + baseDimIdx]
          startPoint[valueDimIdx] = points[i + valueDimIdx]
          ctx.rect(startPoint[0], startPoint[1], size[0], size[1])
        }
      }

      return LargePath
    }(Path))

  function createLarge (seriesModel, group, progressiveEls, incremental) {
    // TODO support polar
    const data = seriesModel.getData()
    const baseDimIdx = data.getLayout('valueAxisHorizontal') ? 1 : 0
    const largeDataIndices = data.getLayout('largeDataIndices')
    const barWidth = data.getLayout('size')
    const backgroundModel = seriesModel.getModel('backgroundStyle')
    const bgPoints = data.getLayout('largeBackgroundPoints')

    if (bgPoints) {
      const bgEl = new LargePath({
        shape: {
          points: bgPoints
        },
        incremental: !!incremental,
        silent: true,
        z2: 0
      })
      bgEl.baseDimIdx = baseDimIdx
      bgEl.largeDataIndices = largeDataIndices
      bgEl.barWidth = barWidth
      bgEl.useStyle(backgroundModel.getItemStyle())
      group.add(bgEl)
      progressiveEls && progressiveEls.push(bgEl)
    }

    const el = new LargePath({
      shape: {
        points: data.getLayout('largePoints')
      },
      incremental: !!incremental,
      z2: 1
    })
    el.baseDimIdx = baseDimIdx
    el.largeDataIndices = largeDataIndices
    el.barWidth = barWidth
    group.add(el)
    el.useStyle(data.getVisual('style')) // Enable tooltip and user mouse/touch event handlers.

    getECData(el).seriesIndex = seriesModel.seriesIndex

    if (!seriesModel.get('silent')) {
      el.on('mousedown', largePathUpdateDataIndex)
      el.on('mousemove', largePathUpdateDataIndex)
    }

    progressiveEls && progressiveEls.push(el)
  } // Use throttle to avoid frequently traverse to find dataIndex.

  var largePathUpdateDataIndex = throttle(function (event) {
    const largePath = this
    const dataIndex = largePathFindDataIndex(largePath, event.offsetX, event.offsetY)
    getECData(largePath).dataIndex = dataIndex >= 0 ? dataIndex : null
  }, 30, false)

  function largePathFindDataIndex (largePath, x, y) {
    const baseDimIdx = largePath.baseDimIdx
    const valueDimIdx = 1 - baseDimIdx
    const points = largePath.shape.points
    const largeDataIndices = largePath.largeDataIndices
    const startPoint = []
    const size = []
    const barWidth = largePath.barWidth

    for (let i = 0, len = points.length / 3; i < len; i++) {
      const ii = i * 3
      size[baseDimIdx] = barWidth
      size[valueDimIdx] = points[ii + 2]
      startPoint[baseDimIdx] = points[ii + baseDimIdx]
      startPoint[valueDimIdx] = points[ii + valueDimIdx]

      if (size[valueDimIdx] < 0) {
        startPoint[valueDimIdx] += size[valueDimIdx]
        size[valueDimIdx] = -size[valueDimIdx]
      }

      if (x >= startPoint[0] && x <= startPoint[0] + size[0] && y >= startPoint[1] && y <= startPoint[1] + size[1]) {
        return largeDataIndices[i]
      }
    }

    return -1
  }

  function createBackgroundShape (isHorizontalOrRadial, layout, coord) {
    if (isCoordinateSystemType(coord, 'cartesian2d')) {
      const rectShape = layout
      var coordLayout = coord.getArea()
      return {
        x: isHorizontalOrRadial ? rectShape.x : coordLayout.x,
        y: isHorizontalOrRadial ? coordLayout.y : rectShape.y,
        width: isHorizontalOrRadial ? rectShape.width : coordLayout.width,
        height: isHorizontalOrRadial ? coordLayout.height : rectShape.height
      }
    } else {
      var coordLayout = coord.getArea()
      const sectorShape = layout
      return {
        cx: coordLayout.cx,
        cy: coordLayout.cy,
        r0: isHorizontalOrRadial ? coordLayout.r0 : sectorShape.r0,
        r: isHorizontalOrRadial ? coordLayout.r : sectorShape.r,
        startAngle: isHorizontalOrRadial ? sectorShape.startAngle : 0,
        endAngle: isHorizontalOrRadial ? sectorShape.endAngle : Math.PI * 2
      }
    }
  }

  function createBackgroundEl (coord, isHorizontalOrRadial, layout) {
    const ElementClz = coord.type === 'polar' ? Sector : Rect
    return new ElementClz({
      shape: createBackgroundShape(isHorizontalOrRadial, layout, coord),
      silent: true,
      z2: 0
    })
  }

  function install$3 (registers) {
    registers.registerChartView(BarView)
    registers.registerSeriesModel(BarSeriesModel)
    registers.registerLayout(registers.PRIORITY.VISUAL.LAYOUT, curry(layout, 'bar')) // Do layout after other overall layout, which can preapre some informations.

    registers.registerLayout(registers.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, createProgressiveLayout('bar')) // Down sample after filter

    registers.registerProcessor(registers.PRIORITY.PROCESSOR.STATISTIC, dataSample('bar'))
    /**
       * @payload
       * @property {string} [componentType=series]
       * @property {number} [dx]
       * @property {number} [dy]
       * @property {number} [zoom]
       * @property {number} [originX]
       * @property {number} [originY]
       */

    registers.registerAction({
      type: 'changeAxisOrder',
      event: 'changeAxisOrder',
      update: 'update'
    }, function (payload, ecModel) {
      const componentType = payload.componentType || 'series'
      ecModel.eachComponent({
        mainType: componentType,
        query: payload
      }, function (componentModel) {
        if (payload.sortInfo) {
          componentModel.axis.setCategorySortInfo(payload.sortInfo)
        }
      })
    })
  }

  const PI2$8 = Math.PI * 2
  const RADIAN = Math.PI / 180

  function getViewRect (seriesModel, api) {
    return getLayoutRect(seriesModel.getBoxLayoutParams(), {
      width: api.getWidth(),
      height: api.getHeight()
    })
  }

  function getBasicPieLayout (seriesModel, api) {
    const viewRect = getViewRect(seriesModel, api)
    let center = seriesModel.get('center')
    let radius = seriesModel.get('radius')

    if (!isArray(radius)) {
      radius = [0, radius]
    }

    if (!isArray(center)) {
      center = [center, center]
    }

    const width = parsePercent$1(viewRect.width, api.getWidth())
    const height = parsePercent$1(viewRect.height, api.getHeight())
    const size = Math.min(width, height)
    const cx = parsePercent$1(center[0], width) + viewRect.x
    const cy = parsePercent$1(center[1], height) + viewRect.y
    const r0 = parsePercent$1(radius[0], size / 2)
    const r = parsePercent$1(radius[1], size / 2)
    return {
      cx: cx,
      cy: cy,
      r0: r0,
      r: r
    }
  }
  function pieLayout (seriesType, ecModel, api) {
    ecModel.eachSeriesByType(seriesType, function (seriesModel) {
      const data = seriesModel.getData()
      const valueDim = data.mapDimension('value')
      const viewRect = getViewRect(seriesModel, api)

      const _a = getBasicPieLayout(seriesModel, api)
      const cx = _a.cx
      const cy = _a.cy
      const r = _a.r
      const r0 = _a.r0

      const startAngle = -seriesModel.get('startAngle') * RADIAN
      const minAngle = seriesModel.get('minAngle') * RADIAN
      let validDataCount = 0
      data.each(valueDim, function (value) {
        !isNaN(value) && validDataCount++
      })
      const sum = data.getSum(valueDim) // Sum may be 0

      let unitRadian = Math.PI / (sum || validDataCount) * 2
      const clockwise = seriesModel.get('clockwise')
      const roseType = seriesModel.get('roseType')
      const stillShowZeroSum = seriesModel.get('stillShowZeroSum') // [0...max]

      const extent = data.getDataExtent(valueDim)
      extent[0] = 0 // In the case some sector angle is smaller than minAngle

      let restAngle = PI2$8
      let valueSumLargerThanMinAngle = 0
      let currentAngle = startAngle
      const dir = clockwise ? 1 : -1
      data.setLayout({
        viewRect: viewRect,
        r: r
      })
      data.each(valueDim, function (value, idx) {
        let angle

        if (isNaN(value)) {
          data.setItemLayout(idx, {
            angle: NaN,
            startAngle: NaN,
            endAngle: NaN,
            clockwise: clockwise,
            cx: cx,
            cy: cy,
            r0: r0,
            r: roseType ? NaN : r
          })
          return
        } // FIXME 兼容 2.0 但是 roseType 是 area 的时候才是这样？

        if (roseType !== 'area') {
          angle = sum === 0 && stillShowZeroSum ? unitRadian : value * unitRadian
        } else {
          angle = PI2$8 / validDataCount
        }

        if (angle < minAngle) {
          angle = minAngle
          restAngle -= minAngle
        } else {
          valueSumLargerThanMinAngle += value
        }

        const endAngle = currentAngle + dir * angle
        data.setItemLayout(idx, {
          angle: angle,
          startAngle: currentAngle,
          endAngle: endAngle,
          clockwise: clockwise,
          cx: cx,
          cy: cy,
          r0: r0,
          r: roseType ? linearMap(value, extent, [r0, r]) : r
        })
        currentAngle = endAngle
      }) // Some sector is constrained by minAngle
      // Rest sectors needs recalculate angle

      if (restAngle < PI2$8 && validDataCount) {
        // Average the angle if rest angle is not enough after all angles is
        // Constrained by minAngle
        if (restAngle <= 1e-3) {
          const angle_1 = PI2$8 / validDataCount
          data.each(valueDim, function (value, idx) {
            if (!isNaN(value)) {
              const layout_1 = data.getItemLayout(idx)
              layout_1.angle = angle_1
              layout_1.startAngle = startAngle + dir * idx * angle_1
              layout_1.endAngle = startAngle + dir * (idx + 1) * angle_1
            }
          })
        } else {
          unitRadian = restAngle / valueSumLargerThanMinAngle
          currentAngle = startAngle
          data.each(valueDim, function (value, idx) {
            if (!isNaN(value)) {
              const layout_2 = data.getItemLayout(idx)
              const angle = layout_2.angle === minAngle ? minAngle : value * unitRadian
              layout_2.startAngle = currentAngle
              layout_2.endAngle = currentAngle + dir * angle
              currentAngle += dir * angle
            }
          })
        }
      }
    })
  }

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

  /**
     * AUTO-GENERATED FILE. DO NOT MODIFY.
     */

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
  function dataFilter (seriesType) {
    return {
      seriesType: seriesType,
      reset: function (seriesModel, ecModel) {
        const legendModels = ecModel.findComponents({
          mainType: 'legend'
        })

        if (!legendModels || !legendModels.length) {
          return
        }

        const data = seriesModel.getData()
        data.filterSelf(function (idx) {
          const name = data.getName(idx) // If in any legend component the status is not selected.

          for (let i = 0; i < legendModels.length; i++) {
            // @ts-ignore FIXME: LegendModel
            if (!legendModels[i].isSelected(name)) {
              return false
            }
          }

          return true
        })
      }
    }
  }

  const RADIAN$1 = Math.PI / 180

  function adjustSingleSide (list, cx, cy, r, dir, viewWidth, viewHeight, viewLeft, viewTop, farthestX) {
    if (list.length < 2) {
      return
    }

    function recalculateXOnSemiToAlignOnEllipseCurve (semi) {
      const rB = semi.rB
      const rB2 = rB * rB

      for (let i = 0; i < semi.list.length; i++) {
        const item = semi.list[i]
        const dy = Math.abs(item.label.y - cy) // horizontal r is always same with original r because x is not changed.

        const rA = r + item.len
        const rA2 = rA * rA // Use ellipse implicit function to calculate x

        const dx = Math.sqrt((1 - Math.abs(dy * dy / rB2)) * rA2)
        const newX = cx + (dx + item.len2) * dir
        const deltaX = newX - item.label.x
        const newTargetWidth = item.targetTextWidth - deltaX * dir // text x is changed, so need to recalculate width.

        constrainTextWidth(item, newTargetWidth, true)
        item.label.x = newX
      }
    } // Adjust X based on the shifted y. Make tight labels aligned on an ellipse curve.

    function recalculateX (items) {
      // Extremes of
      const topSemi = {
        list: [],
        maxY: 0
      }
      const bottomSemi = {
        list: [],
        maxY: 0
      }

      for (let i = 0; i < items.length; i++) {
        if (items[i].labelAlignTo !== 'none') {
          continue
        }

        const item = items[i]
        const semi = item.label.y > cy ? bottomSemi : topSemi
        const dy = Math.abs(item.label.y - cy)

        if (dy >= semi.maxY) {
          const dx = item.label.x - cx - item.len2 * dir // horizontal r is always same with original r because x is not changed.

          const rA = r + item.len // Canculate rB based on the topest / bottemest label.

          const rB = Math.abs(dx) < rA ? Math.sqrt(dy * dy / (1 - dx * dx / rA / rA)) : rA
          semi.rB = rB
          semi.maxY = dy
        }

        semi.list.push(item)
      }

      recalculateXOnSemiToAlignOnEllipseCurve(topSemi)
      recalculateXOnSemiToAlignOnEllipseCurve(bottomSemi)
    }

    const len = list.length

    for (let i = 0; i < len; i++) {
      if (list[i].position === 'outer' && list[i].labelAlignTo === 'labelLine') {
        const dx = list[i].label.x - farthestX
        list[i].linePoints[1][0] += dx
        list[i].label.x = farthestX
      }
    }

    if (shiftLayoutOnY(list, viewTop, viewTop + viewHeight)) {
      recalculateX(list)
    }
  }

  function avoidOverlap (labelLayoutList, cx, cy, r, viewWidth, viewHeight, viewLeft, viewTop) {
    const leftList = []
    const rightList = []
    let leftmostX = Number.MAX_VALUE
    let rightmostX = -Number.MAX_VALUE

    for (var i = 0; i < labelLayoutList.length; i++) {
      var label = labelLayoutList[i].label

      if (isPositionCenter(labelLayoutList[i])) {
        continue
      }

      if (label.x < cx) {
        leftmostX = Math.min(leftmostX, label.x)
        leftList.push(labelLayoutList[i])
      } else {
        rightmostX = Math.max(rightmostX, label.x)
        rightList.push(labelLayoutList[i])
      }
    }

    for (var i = 0; i < labelLayoutList.length; i++) {
      var layout = labelLayoutList[i]

      if (!isPositionCenter(layout) && layout.linePoints) {
        if (layout.labelStyleWidth != null) {
          continue
        }

        var label = layout.label
        var linePoints = layout.linePoints
        let targetTextWidth = void 0

        if (layout.labelAlignTo === 'edge') {
          if (label.x < cx) {
            targetTextWidth = linePoints[2][0] - layout.labelDistance - viewLeft - layout.edgeDistance
          } else {
            targetTextWidth = viewLeft + viewWidth - layout.edgeDistance - linePoints[2][0] - layout.labelDistance
          }
        } else if (layout.labelAlignTo === 'labelLine') {
          if (label.x < cx) {
            targetTextWidth = leftmostX - viewLeft - layout.bleedMargin
          } else {
            targetTextWidth = viewLeft + viewWidth - rightmostX - layout.bleedMargin
          }
        } else {
          if (label.x < cx) {
            targetTextWidth = label.x - viewLeft - layout.bleedMargin
          } else {
            targetTextWidth = viewLeft + viewWidth - label.x - layout.bleedMargin
          }
        }

        layout.targetTextWidth = targetTextWidth
        constrainTextWidth(layout, targetTextWidth)
      }
    }

    adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight, viewLeft, viewTop, rightmostX)
    adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight, viewLeft, viewTop, leftmostX)

    for (var i = 0; i < labelLayoutList.length; i++) {
      var layout = labelLayoutList[i]

      if (!isPositionCenter(layout) && layout.linePoints) {
        var label = layout.label
        var linePoints = layout.linePoints
        const isAlignToEdge = layout.labelAlignTo === 'edge'
        const padding = label.style.padding
        const paddingH = padding ? padding[1] + padding[3] : 0 // textRect.width already contains paddingH if bgColor is set

        const extraPaddingH = label.style.backgroundColor ? 0 : paddingH
        const realTextWidth = layout.rect.width + extraPaddingH
        const dist = linePoints[1][0] - linePoints[2][0]

        if (isAlignToEdge) {
          if (label.x < cx) {
            linePoints[2][0] = viewLeft + layout.edgeDistance + realTextWidth + layout.labelDistance
          } else {
            linePoints[2][0] = viewLeft + viewWidth - layout.edgeDistance - realTextWidth - layout.labelDistance
          }
        } else {
          if (label.x < cx) {
            linePoints[2][0] = label.x + layout.labelDistance
          } else {
            linePoints[2][0] = label.x - layout.labelDistance
          }

          linePoints[1][0] = linePoints[2][0] + dist
        }

        linePoints[1][1] = linePoints[2][1] = label.y
      }
    }
  }
  /**
     * Set max width of each label, and then wrap each label to the max width.
     *
     * @param layout label layout
     * @param availableWidth max width for the label to display
     * @param forceRecalculate recaculate the text layout even if the current width
     * is smaller than `availableWidth`. This is useful when the text was previously
     * wrapped by calling `constrainTextWidth` but now `availableWidth` changed, in
     * which case, previous wrapping should be redo.
     */

  function constrainTextWidth (layout, availableWidth, forceRecalculate) {
    if (forceRecalculate === void 0) {
      forceRecalculate = false
    }

    if (layout.labelStyleWidth != null) {
      // User-defined style.width has the highest priority.
      return
    }

    const label = layout.label
    const style = label.style
    const textRect = layout.rect
    const bgColor = style.backgroundColor
    const padding = style.padding
    const paddingH = padding ? padding[1] + padding[3] : 0
    const overflow = style.overflow // textRect.width already contains paddingH if bgColor is set

    const oldOuterWidth = textRect.width + (bgColor ? 0 : paddingH)

    if (availableWidth < oldOuterWidth || forceRecalculate) {
      const oldHeight = textRect.height

      if (overflow && overflow.match('break')) {
        // Temporarily set background to be null to calculate
        // the bounding box without backgroud.
        label.setStyle('backgroundColor', null) // Set constraining width

        label.setStyle('width', availableWidth - paddingH) // This is the real bounding box of the text without padding

        const innerRect = label.getBoundingRect()
        label.setStyle('width', Math.ceil(innerRect.width))
        label.setStyle('backgroundColor', bgColor)
      } else {
        const availableInnerWidth = availableWidth - paddingH
        const newWidth = availableWidth < oldOuterWidth // Current text is too wide, use `availableWidth` as max width.
          ? availableInnerWidth // Current available width is enough, but the text may have
          // already been wrapped with a smaller available width.
          : forceRecalculate ? availableInnerWidth > layout.unconstrainedWidth // Current available is larger than text width,
          // so don't constrain width (otherwise it may have
          // empty space in the background).
            ? null // Current available is smaller than text width, so
          // use the current available width as constraining
          // width.
            : availableInnerWidth // Current available width is enough, so no need to
          // constrain.
            : null
        label.setStyle('width', newWidth)
      }

      const newRect = label.getBoundingRect()
      textRect.width = newRect.width
      const margin = (label.style.margin || 0) + 2.1
      textRect.height = newRect.height + margin
      textRect.y -= (textRect.height - oldHeight) / 2
    }
  }

  function isPositionCenter (sectorShape) {
    // Not change x for center label
    return sectorShape.position === 'center'
  }

  function pieLabelLayout (seriesModel) {
    const data = seriesModel.getData()
    const labelLayoutList = []
    let cx
    let cy
    let hasLabelRotate = false
    const minShowLabelRadian = (seriesModel.get('minShowLabelAngle') || 0) * RADIAN$1
    const viewRect = data.getLayout('viewRect')
    const r = data.getLayout('r')
    const viewWidth = viewRect.width
    const viewLeft = viewRect.x
    const viewTop = viewRect.y
    const viewHeight = viewRect.height

    function setNotShow (el) {
      el.ignore = true
    }

    function isLabelShown (label) {
      if (!label.ignore) {
        return true
      }

      for (const key in label.states) {
        if (label.states[key].ignore === false) {
          return true
        }
      }

      return false
    }

    data.each(function (idx) {
      const sector = data.getItemGraphicEl(idx)
      const sectorShape = sector.shape
      const label = sector.getTextContent()
      const labelLine = sector.getTextGuideLine()
      const itemModel = data.getItemModel(idx)
      const labelModel = itemModel.getModel('label') // Use position in normal or emphasis

      const labelPosition = labelModel.get('position') || itemModel.get(['emphasis', 'label', 'position'])
      const labelDistance = labelModel.get('distanceToLabelLine')
      const labelAlignTo = labelModel.get('alignTo')
      const edgeDistance = parsePercent$1(labelModel.get('edgeDistance'), viewWidth)
      const bleedMargin = labelModel.get('bleedMargin')
      const labelLineModel = itemModel.getModel('labelLine')
      let labelLineLen = labelLineModel.get('length')
      labelLineLen = parsePercent$1(labelLineLen, viewWidth)
      let labelLineLen2 = labelLineModel.get('length2')
      labelLineLen2 = parsePercent$1(labelLineLen2, viewWidth)

      if (Math.abs(sectorShape.endAngle - sectorShape.startAngle) < minShowLabelRadian) {
        each(label.states, setNotShow)
        label.ignore = true
        return
      }

      if (!isLabelShown(label)) {
        return
      }

      const midAngle = (sectorShape.startAngle + sectorShape.endAngle) / 2
      const nx = Math.cos(midAngle)
      const ny = Math.sin(midAngle)
      let textX
      let textY
      let linePoints
      let textAlign
      cx = sectorShape.cx
      cy = sectorShape.cy
      const isLabelInside = labelPosition === 'inside' || labelPosition === 'inner'

      if (labelPosition === 'center') {
        textX = sectorShape.cx
        textY = sectorShape.cy
        textAlign = 'center'
      } else {
        const x1 = (isLabelInside ? (sectorShape.r + sectorShape.r0) / 2 * nx : sectorShape.r * nx) + cx
        const y1 = (isLabelInside ? (sectorShape.r + sectorShape.r0) / 2 * ny : sectorShape.r * ny) + cy
        textX = x1 + nx * 3
        textY = y1 + ny * 3

        if (!isLabelInside) {
          // For roseType
          const x2 = x1 + nx * (labelLineLen + r - sectorShape.r)
          const y2 = y1 + ny * (labelLineLen + r - sectorShape.r)
          const x3 = x2 + (nx < 0 ? -1 : 1) * labelLineLen2
          const y3 = y2

          if (labelAlignTo === 'edge') {
            // Adjust textX because text align of edge is opposite
            textX = nx < 0 ? viewLeft + edgeDistance : viewLeft + viewWidth - edgeDistance
          } else {
            textX = x3 + (nx < 0 ? -labelDistance : labelDistance)
          }

          textY = y3
          linePoints = [[x1, y1], [x2, y2], [x3, y3]]
        }

        textAlign = isLabelInside ? 'center' : labelAlignTo === 'edge' ? nx > 0 ? 'right' : 'left' : nx > 0 ? 'left' : 'right'
      }

      const PI = Math.PI
      let labelRotate = 0
      const rotate = labelModel.get('rotate')

      if (isNumber(rotate)) {
        labelRotate = rotate * (PI / 180)
      } else if (labelPosition === 'center') {
        labelRotate = 0
      } else if (rotate === 'radial' || rotate === true) {
        const radialAngle = nx < 0 ? -midAngle + PI : -midAngle
        labelRotate = radialAngle
      } else if (rotate === 'tangential' && labelPosition !== 'outside' && labelPosition !== 'outer') {
        let rad = Math.atan2(nx, ny)

        if (rad < 0) {
          rad = PI * 2 + rad
        }

        const isDown = ny > 0

        if (isDown) {
          rad = PI + rad
        }

        labelRotate = rad - PI
      }

      hasLabelRotate = !!labelRotate
      label.x = textX
      label.y = textY
      label.rotation = labelRotate
      label.setStyle({
        verticalAlign: 'middle'
      }) // Not sectorShape the inside label

      if (!isLabelInside) {
        const textRect = label.getBoundingRect().clone()
        textRect.applyTransform(label.getComputedTransform()) // Text has a default 1px stroke. Exclude this.

        const margin = (label.style.margin || 0) + 2.1
        textRect.y -= margin / 2
        textRect.height += margin
        labelLayoutList.push({
          label: label,
          labelLine: labelLine,
          position: labelPosition,
          len: labelLineLen,
          len2: labelLineLen2,
          minTurnAngle: labelLineModel.get('minTurnAngle'),
          maxSurfaceAngle: labelLineModel.get('maxSurfaceAngle'),
          surfaceNormal: new Point(nx, ny),
          linePoints: linePoints,
          textAlign: textAlign,
          labelDistance: labelDistance,
          labelAlignTo: labelAlignTo,
          edgeDistance: edgeDistance,
          bleedMargin: bleedMargin,
          rect: textRect,
          unconstrainedWidth: textRect.width,
          labelStyleWidth: label.style.width
        })
      } else {
        label.setStyle({
          align: textAlign
        })
        const selectState = label.states.select

        if (selectState) {
          selectState.x += label.x
          selectState.y += label.y
        }
      }

      sector.setTextConfig({
        inside: isLabelInside
      })
    })

    if (!hasLabelRotate && seriesModel.get('avoidLabelOverlap')) {
      avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight, viewLeft, viewTop)
    }

    for (let i = 0; i < labelLayoutList.length; i++) {
      const layout = labelLayoutList[i]
      const label = layout.label
      const labelLine = layout.labelLine
      const notShowLabel = isNaN(label.x) || isNaN(label.y)

      if (label) {
        label.setStyle({
          align: layout.textAlign
        })

        if (notShowLabel) {
          each(label.states, setNotShow)
          label.ignore = true
        }

        const selectState = label.states.select

        if (selectState) {
          selectState.x += label.x
          selectState.y += label.y
        }
      }

      if (labelLine) {
        const linePoints = layout.linePoints

        if (notShowLabel || !linePoints) {
          each(labelLine.states, setNotShow)
          labelLine.ignore = true
        } else {
          limitTurnAngle(linePoints, layout.minTurnAngle)
          limitSurfaceAngle(linePoints, layout.surfaceNormal, layout.maxSurfaceAngle)
          labelLine.setShape({
            points: linePoints
          }) // Set the anchor to the midpoint of sector

          label.__hostTarget.textGuideLineConfig = {
            anchor: new Point(linePoints[0][0], linePoints[0][1])
          }
        }
      }
    }
  }

  function getSectorCornerRadius (model, shape, zeroIfNull) {
    let cornerRadius = model.get('borderRadius')

    if (cornerRadius == null) {
      return zeroIfNull
        ? {
            cornerRadius: 0
          }
        : null
    }

    if (!isArray(cornerRadius)) {
      cornerRadius = [cornerRadius, cornerRadius, cornerRadius, cornerRadius]
    }

    const dr = Math.abs(shape.r || 0 - shape.r0 || 0)
    return {
      cornerRadius: map(cornerRadius, function (cr) {
        return parsePercent(cr, dr)
      })
    }
  }

  /**
     * Piece of pie including Sector, Label, LabelLine
     */

  const PiePiece =
    /** @class */
    (function (_super) {
      __extends(PiePiece, _super)

      function PiePiece (data, idx, startAngle) {
        const _this = _super.call(this) || this

        _this.z2 = 2
        const text = new ZRText()

        _this.setTextContent(text)

        _this.updateData(data, idx, startAngle, true)

        return _this
      }

      PiePiece.prototype.updateData = function (data, idx, startAngle, firstCreate) {
        const sector = this
        const seriesModel = data.hostModel
        const itemModel = data.getItemModel(idx)
        const emphasisModel = itemModel.getModel('emphasis')
        const layout = data.getItemLayout(idx) // cornerRadius & innerCornerRadius doesn't exist in the item layout. Use `0` if null value is specified.
        // see `setItemLayout` in `pieLayout.ts`.

        const sectorShape = extend(getSectorCornerRadius(itemModel.getModel('itemStyle'), layout, true), layout) // Ignore NaN data.

        if (isNaN(sectorShape.startAngle)) {
          // Use NaN shape to avoid drawing shape.
          sector.setShape(sectorShape)
          return
        }

        if (firstCreate) {
          sector.setShape(sectorShape)
          const animationType = seriesModel.getShallow('animationType')

          if (seriesModel.ecModel.ssr) {
            // Use scale animation in SSR mode(opacity?)
            // Because CSS SVG animation doesn't support very customized shape animation.
            initProps(sector, {
              scaleX: 0,
              scaleY: 0
            }, seriesModel, {
              dataIndex: idx,
              isFrom: true
            })
            sector.originX = sectorShape.cx
            sector.originY = sectorShape.cy
          } else if (animationType === 'scale') {
            sector.shape.r = layout.r0
            initProps(sector, {
              shape: {
                r: layout.r
              }
            }, seriesModel, idx)
          } // Expansion
          else {
            if (startAngle != null) {
              sector.setShape({
                startAngle: startAngle,
                endAngle: startAngle
              })
              initProps(sector, {
                shape: {
                  startAngle: layout.startAngle,
                  endAngle: layout.endAngle
                }
              }, seriesModel, idx)
            } else {
              sector.shape.endAngle = layout.startAngle
              updateProps(sector, {
                shape: {
                  endAngle: layout.endAngle
                }
              }, seriesModel, idx)
            }
          }
        } else {
          saveOldStyle(sector) // Transition animation from the old shape

          updateProps(sector, {
            shape: sectorShape
          }, seriesModel, idx)
        }

        sector.useStyle(data.getItemVisual(idx, 'style'))
        setStatesStylesFromModel(sector, itemModel)
        const midAngle = (layout.startAngle + layout.endAngle) / 2
        const offset = seriesModel.get('selectedOffset')
        const dx = Math.cos(midAngle) * offset
        const dy = Math.sin(midAngle) * offset
        const cursorStyle = itemModel.getShallow('cursor')
        cursorStyle && sector.attr('cursor', cursorStyle)

        this._updateLabel(seriesModel, data, idx)

        sector.ensureState('emphasis').shape = extend({
          r: layout.r + (emphasisModel.get('scale') ? emphasisModel.get('scaleSize') || 0 : 0)
        }, getSectorCornerRadius(emphasisModel.getModel('itemStyle'), layout))
        extend(sector.ensureState('select'), {
          x: dx,
          y: dy,
          shape: getSectorCornerRadius(itemModel.getModel(['select', 'itemStyle']), layout)
        })
        extend(sector.ensureState('blur'), {
          shape: getSectorCornerRadius(itemModel.getModel(['blur', 'itemStyle']), layout)
        })
        const labelLine = sector.getTextGuideLine()
        const labelText = sector.getTextContent()
        labelLine && extend(labelLine.ensureState('select'), {
          x: dx,
          y: dy
        }) // TODO: needs dx, dy in zrender?

        extend(labelText.ensureState('select'), {
          x: dx,
          y: dy
        })
        toggleHoverEmphasis(this, emphasisModel.get('focus'), emphasisModel.get('blurScope'), emphasisModel.get('disabled'))
      }

      PiePiece.prototype._updateLabel = function (seriesModel, data, idx) {
        const sector = this
        const itemModel = data.getItemModel(idx)
        const labelLineModel = itemModel.getModel('labelLine')
        const style = data.getItemVisual(idx, 'style')
        const visualColor = style && style.fill
        const visualOpacity = style && style.opacity
        setLabelStyle(sector, getLabelStatesModels(itemModel), {
          labelFetcher: data.hostModel,
          labelDataIndex: idx,
          inheritColor: visualColor,
          defaultOpacity: visualOpacity,
          defaultText: seriesModel.getFormattedLabel(idx, 'normal') || data.getName(idx)
        })
        const labelText = sector.getTextContent() // Set textConfig on sector.

        sector.setTextConfig({
          // reset position, rotation
          position: null,
          rotation: null
        }) // Make sure update style on labelText after setLabelStyle.
        // Because setLabelStyle will replace a new style on it.

        labelText.attr({
          z2: 10
        })
        const labelPosition = seriesModel.get(['label', 'position'])

        if (labelPosition !== 'outside' && labelPosition !== 'outer') {
          sector.removeTextGuideLine()
        } else {
          let polyline = this.getTextGuideLine()

          if (!polyline) {
            polyline = new Polyline()
            this.setTextGuideLine(polyline)
          } // Default use item visual color

          setLabelLineStyle(this, getLabelLineStatesModels(itemModel), {
            stroke: visualColor,
            opacity: retrieve3(labelLineModel.get(['lineStyle', 'opacity']), visualOpacity, 1)
          })
        }
      }

      return PiePiece
    }(Sector)) // Pie view

  const PieView =
    /** @class */
    (function (_super) {
      __extends(PieView, _super)

      function PieView () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.ignoreLabelLineUpdate = true
        return _this
      }

      PieView.prototype.render = function (seriesModel, ecModel, api, payload) {
        const data = seriesModel.getData()
        const oldData = this._data
        const group = this.group
        let startAngle // First render

        if (!oldData && data.count() > 0) {
          let shape = data.getItemLayout(0)

          for (let s = 1; isNaN(shape && shape.startAngle) && s < data.count(); ++s) {
            shape = data.getItemLayout(s)
          }

          if (shape) {
            startAngle = shape.startAngle
          }
        } // remove empty-circle if it exists

        if (this._emptyCircleSector) {
          group.remove(this._emptyCircleSector)
        } // when all data are filtered, show lightgray empty circle

        if (data.count() === 0 && seriesModel.get('showEmptyCircle')) {
          const sector = new Sector({
            shape: getBasicPieLayout(seriesModel, api)
          })
          sector.useStyle(seriesModel.getModel('emptyCircleStyle').getItemStyle())
          this._emptyCircleSector = sector
          group.add(sector)
        }

        data.diff(oldData).add(function (idx) {
          const piePiece = new PiePiece(data, idx, startAngle)
          data.setItemGraphicEl(idx, piePiece)
          group.add(piePiece)
        }).update(function (newIdx, oldIdx) {
          const piePiece = oldData.getItemGraphicEl(oldIdx)
          piePiece.updateData(data, newIdx, startAngle)
          piePiece.off('click')
          group.add(piePiece)
          data.setItemGraphicEl(newIdx, piePiece)
        }).remove(function (idx) {
          const piePiece = oldData.getItemGraphicEl(idx)
          removeElementWithFadeOut(piePiece, seriesModel, idx)
        }).execute()
        pieLabelLayout(seriesModel) // Always use initial animation.

        if (seriesModel.get('animationTypeUpdate') !== 'expansion') {
          this._data = data
        }
      }

      PieView.prototype.dispose = function () {}

      PieView.prototype.containPoint = function (point, seriesModel) {
        const data = seriesModel.getData()
        const itemLayout = data.getItemLayout(0)

        if (itemLayout) {
          const dx = point[0] - itemLayout.cx
          const dy = point[1] - itemLayout.cy
          const radius = Math.sqrt(dx * dx + dy * dy)
          return radius <= itemLayout.r && radius >= itemLayout.r0
        }
      }

      PieView.type = 'pie'
      return PieView
    }(ChartView))

  /**
     * [Usage]:
     * (1)
     * createListSimply(seriesModel, ['value']);
     * (2)
     * createListSimply(seriesModel, {
     *     coordDimensions: ['value'],
     *     dimensionsCount: 5
     * });
     */

  function createSeriesDataSimply (seriesModel, opt, nameList) {
    opt = isArray(opt) && {
      coordDimensions: opt
    } || extend({
      encodeDefine: seriesModel.getEncode()
    }, opt)
    const source = seriesModel.getSource()
    const dimensions = prepareSeriesDataSchema(source, opt).dimensions
    const list = new SeriesData(dimensions, seriesModel)
    list.initData(source, nameList)
    return list
  }

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

  /**
     * AUTO-GENERATED FILE. DO NOT MODIFY.
     */

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

  /**
     * LegendVisualProvider is an bridge that pick encoded color from data and
     * provide to the legend component.
     */
  const LegendVisualProvider =
    /** @class */
    (function () {
      function LegendVisualProvider ( // Function to get data after filtered. It stores all the encoding info
        getDataWithEncodedVisual, // Function to get raw data before filtered.
        getRawData) {
        this._getDataWithEncodedVisual = getDataWithEncodedVisual
        this._getRawData = getRawData
      }

      LegendVisualProvider.prototype.getAllNames = function () {
        const rawData = this._getRawData() // We find the name from the raw data. In case it's filtered by the legend component.
        // Normally, the name can be found in rawData, but can't be found in filtered data will display as gray.

        return rawData.mapArray(rawData.getName)
      }

      LegendVisualProvider.prototype.containName = function (name) {
        const rawData = this._getRawData()

        return rawData.indexOfName(name) >= 0
      }

      LegendVisualProvider.prototype.indexOfName = function (name) {
        // Only get data when necessary.
        // Because LegendVisualProvider constructor may be new in the stage that data is not prepared yet.
        // Invoking Series#getData immediately will throw an error.
        const dataWithEncodedVisual = this._getDataWithEncodedVisual()

        return dataWithEncodedVisual.indexOfName(name)
      }

      LegendVisualProvider.prototype.getItemVisual = function (dataIndex, key) {
        // Get encoded visual properties from final filtered data.
        const dataWithEncodedVisual = this._getDataWithEncodedVisual()

        return dataWithEncodedVisual.getItemVisual(dataIndex, key)
      }

      return LegendVisualProvider
    }())

  const PieSeriesModel =
    /** @class */
    (function (_super) {
      __extends(PieSeriesModel, _super)

      function PieSeriesModel () {
        return _super !== null && _super.apply(this, arguments) || this
      }
      /**
       * @overwrite
       */

      PieSeriesModel.prototype.init = function (option) {
        _super.prototype.init.apply(this, arguments) // Enable legend selection for each data item
        // Use a function instead of direct access because data reference may changed

        this.legendVisualProvider = new LegendVisualProvider(bind(this.getData, this), bind(this.getRawData, this))

        this._defaultLabelLine(option)
      }
      /**
       * @overwrite
       */

      PieSeriesModel.prototype.mergeOption = function () {
        _super.prototype.mergeOption.apply(this, arguments)
      }
      /**
       * @overwrite
       */

      PieSeriesModel.prototype.getInitialData = function () {
        return createSeriesDataSimply(this, {
          coordDimensions: ['value'],
          encodeDefaulter: curry(makeSeriesEncodeForNameBased, this)
        })
      }
      /**
       * @overwrite
       */

      PieSeriesModel.prototype.getDataParams = function (dataIndex) {
        const data = this.getData()

        const params = _super.prototype.getDataParams.call(this, dataIndex) // FIXME toFixed?

        const valueList = []
        data.each(data.mapDimension('value'), function (value) {
          valueList.push(value)
        })
        params.percent = getPercentWithPrecision(valueList, dataIndex, data.hostModel.get('percentPrecision'))
        params.$vars.push('percent')
        return params
      }

      PieSeriesModel.prototype._defaultLabelLine = function (option) {
        // Extend labelLine emphasis
        defaultEmphasis(option, 'labelLine', ['show'])
        const labelLineNormalOpt = option.labelLine
        const labelLineEmphasisOpt = option.emphasis.labelLine // Not show label line if `label.normal.show = false`

        labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.show
        labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.emphasis.label.show
      }

      PieSeriesModel.type = 'series.pie'
      PieSeriesModel.defaultOption = {
        // zlevel: 0,
        z: 2,
        legendHoverLink: true,
        colorBy: 'data',
        // 默认全局居中
        center: ['50%', '50%'],
        radius: [0, '75%'],
        // 默认顺时针
        clockwise: true,
        startAngle: 90,
        // 最小角度改为0
        minAngle: 0,
        // If the angle of a sector less than `minShowLabelAngle`,
        // the label will not be displayed.
        minShowLabelAngle: 0,
        // 选中时扇区偏移量
        selectedOffset: 10,
        // 选择模式，默认关闭，可选single，multiple
        // selectedMode: false,
        // 南丁格尔玫瑰图模式，'radius'（半径） | 'area'（面积）
        // roseType: null,
        percentPrecision: 2,
        // If still show when all data zero.
        stillShowZeroSum: true,
        // cursor: null,
        left: 0,
        top: 0,
        right: 0,
        bottom: 0,
        width: null,
        height: null,
        label: {
          // color: 'inherit',
          // If rotate around circle
          rotate: 0,
          show: true,
          overflow: 'truncate',
          // 'outer', 'inside', 'center'
          position: 'outer',
          // 'none', 'labelLine', 'edge'. Works only when position is 'outer'
          alignTo: 'none',
          // Closest distance between label and chart edge.
          // Works only position is 'outer' and alignTo is 'edge'.
          edgeDistance: '25%',
          // Works only position is 'outer' and alignTo is not 'edge'.
          bleedMargin: 10,
          // Distance between text and label line.
          distanceToLabelLine: 5 // formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调
          // 默认使用全局文本样式，详见TEXTSTYLE
          // distance: 当position为inner时有效，为label位置到圆心的距离与圆半径(环状图为内外半径和)的比例系数

        },
        // Enabled when label.normal.position is 'outer'
        labelLine: {
          show: true,
          // 引导线两段中的第一段长度
          length: 15,
          // 引导线两段中的第二段长度
          length2: 15,
          smooth: false,
          minTurnAngle: 90,
          maxSurfaceAngle: 90,
          lineStyle: {
            // color: 各异,
            width: 1,
            type: 'solid'
          }
        },
        itemStyle: {
          borderWidth: 1,
          borderJoin: 'round'
        },
        showEmptyCircle: true,
        emptyCircleStyle: {
          color: 'lightgray',
          opacity: 1
        },
        labelLayout: {
          // Hide the overlapped label.
          hideOverlap: true
        },
        emphasis: {
          scale: true,
          scaleSize: 5
        },
        // If use strategy to avoid label overlapping
        avoidLabelOverlap: true,
        // Animation type. Valid values: expansion, scale
        animationType: 'expansion',
        animationDuration: 1000,
        // Animation type when update. Valid values: transition, expansion
        animationTypeUpdate: 'transition',
        animationEasingUpdate: 'cubicInOut',
        animationDurationUpdate: 500,
        animationEasing: 'cubicInOut'
      }
      return PieSeriesModel
    }(SeriesModel))

  function negativeDataFilter (seriesType) {
    return {
      seriesType: seriesType,
      reset: function (seriesModel, ecModel) {
        const data = seriesModel.getData()
        data.filterSelf(function (idx) {
          // handle negative value condition
          const valueDim = data.mapDimension('value')
          const curValue = data.get(valueDim, idx)

          if (isNumber(curValue) && !isNaN(curValue) && curValue < 0) {
            return false
          }

          return true
        })
      }
    }
  }

  function install$4 (registers) {
    registers.registerChartView(PieView)
    registers.registerSeriesModel(PieSeriesModel)
    createLegacyDataSelectAction('pie', registers.registerAction)
    registers.registerLayout(curry(pieLayout, 'pie'))
    registers.registerProcessor(dataFilter('pie'))
    registers.registerProcessor(negativeDataFilter('pie'))
  }

  const ScatterSeriesModel =
    /** @class */
    (function (_super) {
      __extends(ScatterSeriesModel, _super)

      function ScatterSeriesModel () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = ScatterSeriesModel.type
        _this.hasSymbolVisual = true
        return _this
      }

      ScatterSeriesModel.prototype.getInitialData = function (option, ecModel) {
        return createSeriesData(null, this, {
          useEncodeDefaulter: true
        })
      }

      ScatterSeriesModel.prototype.getProgressive = function () {
        const progressive = this.option.progressive

        if (progressive == null) {
          // PENDING
          return this.option.large ? 5e3 : this.get('progressive')
        }

        return progressive
      }

      ScatterSeriesModel.prototype.getProgressiveThreshold = function () {
        const progressiveThreshold = this.option.progressiveThreshold

        if (progressiveThreshold == null) {
          // PENDING
          return this.option.large ? 1e4 : this.get('progressiveThreshold')
        }

        return progressiveThreshold
      }

      ScatterSeriesModel.prototype.brushSelector = function (dataIndex, data, selectors) {
        return selectors.point(data.getItemLayout(dataIndex))
      }

      ScatterSeriesModel.prototype.getZLevelKey = function () {
        // Each progressive series has individual key.
        return this.getData().count() > this.getProgressiveThreshold() ? this.id : ''
      }

      ScatterSeriesModel.type = 'series.scatter'
      ScatterSeriesModel.dependencies = ['grid', 'polar', 'geo', 'singleAxis', 'calendar']
      ScatterSeriesModel.defaultOption = {
        coordinateSystem: 'cartesian2d',
        // zlevel: 0,
        z: 2,
        legendHoverLink: true,
        symbolSize: 10,
        // symbolRotate: null,  // 图形旋转控制
        large: false,
        // Available when large is true
        largeThreshold: 2000,
        // cursor: null,
        itemStyle: {
          opacity: 0.8 // color: 各异

        },
        emphasis: {
          scale: true
        },
        // If clip the overflow graphics
        // Works on cartesian / polar series
        clip: true,
        select: {
          itemStyle: {
            borderColor: '#212121'
          }
        },
        universalTransition: {
          divideShape: 'clone'
        } // progressive: null

      }
      return ScatterSeriesModel
    }(SeriesModel))

  const BOOST_SIZE_THRESHOLD = 4

  const LargeSymbolPathShape =
    /** @class */
    (function () {
      function LargeSymbolPathShape () {}

      return LargeSymbolPathShape
    }())

  const LargeSymbolPath =
    /** @class */
    (function (_super) {
      __extends(LargeSymbolPath, _super)

      function LargeSymbolPath (opts) {
        const _this = _super.call(this, opts) || this

        _this._off = 0
        _this.hoverDataIdx = -1
        return _this
      }

      LargeSymbolPath.prototype.getDefaultShape = function () {
        return new LargeSymbolPathShape()
      }

      LargeSymbolPath.prototype.reset = function () {
        this.notClear = false
        this._off = 0
      }

      LargeSymbolPath.prototype.buildPath = function (path, shape) {
        const points = shape.points
        const size = shape.size
        const symbolProxy = this.symbolProxy
        const symbolProxyShape = symbolProxy.shape
        const ctx = path.getContext ? path.getContext() : path
        const canBoost = ctx && size[0] < BOOST_SIZE_THRESHOLD
        const softClipShape = this.softClipShape
        let i // Do draw in afterBrush.

        if (canBoost) {
          this._ctx = ctx
          return
        }

        this._ctx = null

        for (i = this._off; i < points.length;) {
          const x = points[i++]
          const y = points[i++]

          if (isNaN(x) || isNaN(y)) {
            continue
          }

          if (softClipShape && !softClipShape.contain(x, y)) {
            continue
          }

          symbolProxyShape.x = x - size[0] / 2
          symbolProxyShape.y = y - size[1] / 2
          symbolProxyShape.width = size[0]
          symbolProxyShape.height = size[1]
          symbolProxy.buildPath(path, symbolProxyShape, true)
        }

        if (this.incremental) {
          this._off = i
          this.notClear = true
        }
      }

      LargeSymbolPath.prototype.afterBrush = function () {
        const shape = this.shape
        const points = shape.points
        const size = shape.size
        const ctx = this._ctx
        const softClipShape = this.softClipShape
        let i

        if (!ctx) {
          return
        } // PENDING If style or other canvas status changed?

        for (i = this._off; i < points.length;) {
          const x = points[i++]
          const y = points[i++]

          if (isNaN(x) || isNaN(y)) {
            continue
          }

          if (softClipShape && !softClipShape.contain(x, y)) {
            continue
          } // fillRect is faster than building a rect path and draw.
          // And it support light globalCompositeOperation.

          ctx.fillRect(x - size[0] / 2, y - size[1] / 2, size[0], size[1])
        }

        if (this.incremental) {
          this._off = i
          this.notClear = true
        }
      }

      LargeSymbolPath.prototype.findDataIndex = function (x, y) {
        // TODO ???
        // Consider transform
        const shape = this.shape
        const points = shape.points
        const size = shape.size
        const w = Math.max(size[0], 4)
        const h = Math.max(size[1], 4) // Not consider transform
        // Treat each element as a rect
        // top down traverse

        for (let idx = points.length / 2 - 1; idx >= 0; idx--) {
          const i = idx * 2
          const x0 = points[i] - w / 2
          const y0 = points[i + 1] - h / 2

          if (x >= x0 && y >= y0 && x <= x0 + w && y <= y0 + h) {
            return idx
          }
        }

        return -1
      }

      LargeSymbolPath.prototype.contain = function (x, y) {
        const localPos = this.transformCoordToLocal(x, y)
        const rect = this.getBoundingRect()
        x = localPos[0]
        y = localPos[1]

        if (rect.contain(x, y)) {
          // Cache found data index.
          const dataIdx = this.hoverDataIdx = this.findDataIndex(x, y)
          return dataIdx >= 0
        }

        this.hoverDataIdx = -1
        return false
      }

      LargeSymbolPath.prototype.getBoundingRect = function () {
        // Ignore stroke for large symbol draw.
        let rect = this._rect

        if (!rect) {
          const shape = this.shape
          const points = shape.points
          const size = shape.size
          const w = size[0]
          const h = size[1]
          let minX = Infinity
          let minY = Infinity
          let maxX = -Infinity
          let maxY = -Infinity

          for (let i = 0; i < points.length;) {
            const x = points[i++]
            const y = points[i++]
            minX = Math.min(x, minX)
            maxX = Math.max(x, maxX)
            minY = Math.min(y, minY)
            maxY = Math.max(y, maxY)
          }

          rect = this._rect = new BoundingRect(minX - w / 2, minY - h / 2, maxX - minX + w, maxY - minY + h)
        }

        return rect
      }

      return LargeSymbolPath
    }(Path))

  const LargeSymbolDraw =
    /** @class */
    (function () {
      function LargeSymbolDraw () {
        this.group = new Group()
      }
      /**
       * Update symbols draw by new data
       */

      LargeSymbolDraw.prototype.updateData = function (data, opt) {
        this._clear()

        const symbolEl = this._create()

        symbolEl.setShape({
          points: data.getLayout('points')
        })

        this._setCommon(symbolEl, data, opt)
      }

      LargeSymbolDraw.prototype.updateLayout = function (data) {
        let points = data.getLayout('points')
        this.group.eachChild(function (child) {
          if (child.startIndex != null) {
            const len = (child.endIndex - child.startIndex) * 2
            const byteOffset = child.startIndex * 4 * 2
            points = new Float32Array(points.buffer, byteOffset, len)
          }

          child.setShape('points', points) // Reset draw cursor.

          child.reset()
        })
      }

      LargeSymbolDraw.prototype.incrementalPrepareUpdate = function (data) {
        this._clear()
      }

      LargeSymbolDraw.prototype.incrementalUpdate = function (taskParams, data, opt) {
        const lastAdded = this._newAdded[0]
        const points = data.getLayout('points')
        const oldPoints = lastAdded && lastAdded.shape.points // Merging the exists. Each element has 1e4 points.
        // Consider the performance balance between too much elements and too much points in one shape(may affect hover optimization)

        if (oldPoints && oldPoints.length < 2e4) {
          const oldLen = oldPoints.length
          const newPoints = new Float32Array(oldLen + points.length) // Concat two array

          newPoints.set(oldPoints)
          newPoints.set(points, oldLen) // Update endIndex

          lastAdded.endIndex = taskParams.end
          lastAdded.setShape({
            points: newPoints
          })
        } else {
          // Clear
          this._newAdded = []

          const symbolEl = this._create()

          symbolEl.startIndex = taskParams.start
          symbolEl.endIndex = taskParams.end
          symbolEl.incremental = true
          symbolEl.setShape({
            points: points
          })

          this._setCommon(symbolEl, data, opt)
        }
      }

      LargeSymbolDraw.prototype.eachRendered = function (cb) {
        this._newAdded[0] && cb(this._newAdded[0])
      }

      LargeSymbolDraw.prototype._create = function () {
        const symbolEl = new LargeSymbolPath({
          cursor: 'default'
        })
        this.group.add(symbolEl)

        this._newAdded.push(symbolEl)

        return symbolEl
      }

      LargeSymbolDraw.prototype._setCommon = function (symbolEl, data, opt) {
        const hostModel = data.hostModel
        opt = opt || {}
        const size = data.getVisual('symbolSize')
        symbolEl.setShape('size', size instanceof Array ? size : [size, size])
        symbolEl.softClipShape = opt.clipShape || null // Create symbolProxy to build path for each data

        symbolEl.symbolProxy = createSymbol(data.getVisual('symbol'), 0, 0, 0, 0) // Use symbolProxy setColor method

        symbolEl.setColor = symbolEl.symbolProxy.setColor
        const extrudeShadow = symbolEl.shape.size[0] < BOOST_SIZE_THRESHOLD
        symbolEl.useStyle( // Draw shadow when doing fillRect is extremely slow.
          hostModel.getModel('itemStyle').getItemStyle(extrudeShadow ? ['color', 'shadowBlur', 'shadowColor'] : ['color']))
        const globalStyle = data.getVisual('style')
        const visualColor = globalStyle && globalStyle.fill

        if (visualColor) {
          symbolEl.setColor(visualColor)
        }

        const ecData = getECData(symbolEl) // Enable tooltip
        // PENDING May have performance issue when path is extremely large

        ecData.seriesIndex = hostModel.seriesIndex
        symbolEl.on('mousemove', function (e) {
          ecData.dataIndex = null
          const dataIndex = symbolEl.hoverDataIdx

          if (dataIndex >= 0) {
            // Provide dataIndex for tooltip
            ecData.dataIndex = dataIndex + (symbolEl.startIndex || 0)
          }
        })
      }

      LargeSymbolDraw.prototype.remove = function () {
        this._clear()
      }

      LargeSymbolDraw.prototype._clear = function () {
        this._newAdded = []
        this.group.removeAll()
      }

      return LargeSymbolDraw
    }())

  const ScatterView =
    /** @class */
    (function (_super) {
      __extends(ScatterView, _super)

      function ScatterView () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = ScatterView.type
        return _this
      }

      ScatterView.prototype.render = function (seriesModel, ecModel, api) {
        const data = seriesModel.getData()

        const symbolDraw = this._updateSymbolDraw(data, seriesModel)

        symbolDraw.updateData(data, {
          // TODO
          // If this parameter should be a shape or a bounding volume
          // shape will be more general.
          // But bounding volume like bounding rect will be much faster in the contain calculation
          clipShape: this._getClipShape(seriesModel)
        })
        this._finished = true
      }

      ScatterView.prototype.incrementalPrepareRender = function (seriesModel, ecModel, api) {
        const data = seriesModel.getData()

        const symbolDraw = this._updateSymbolDraw(data, seriesModel)

        symbolDraw.incrementalPrepareUpdate(data)
        this._finished = false
      }

      ScatterView.prototype.incrementalRender = function (taskParams, seriesModel, ecModel) {
        this._symbolDraw.incrementalUpdate(taskParams, seriesModel.getData(), {
          clipShape: this._getClipShape(seriesModel)
        })

        this._finished = taskParams.end === seriesModel.getData().count()
      }

      ScatterView.prototype.updateTransform = function (seriesModel, ecModel, api) {
        const data = seriesModel.getData() // Must mark group dirty and make sure the incremental layer will be cleared
        // PENDING

        this.group.dirty()

        if (!this._finished || data.count() > 1e4) {
          return {
            update: true
          }
        } else {
          const res = pointsLayout('').reset(seriesModel, ecModel, api)

          if (res.progress) {
            res.progress({
              start: 0,
              end: data.count(),
              count: data.count()
            }, data)
          }

          this._symbolDraw.updateLayout(data)
        }
      }

      ScatterView.prototype.eachRendered = function (cb) {
        this._symbolDraw && this._symbolDraw.eachRendered(cb)
      }

      ScatterView.prototype._getClipShape = function (seriesModel) {
        const coordSys = seriesModel.coordinateSystem
        const clipArea = coordSys && coordSys.getArea && coordSys.getArea()
        return seriesModel.get('clip', true) ? clipArea : null
      }

      ScatterView.prototype._updateSymbolDraw = function (data, seriesModel) {
        let symbolDraw = this._symbolDraw
        const pipelineContext = seriesModel.pipelineContext
        const isLargeDraw = pipelineContext.large

        if (!symbolDraw || isLargeDraw !== this._isLargeDraw) {
          symbolDraw && symbolDraw.remove()
          symbolDraw = this._symbolDraw = isLargeDraw ? new LargeSymbolDraw() : new SymbolDraw()
          this._isLargeDraw = isLargeDraw
          this.group.removeAll()
        }

        this.group.add(symbolDraw.group)
        return symbolDraw
      }

      ScatterView.prototype.remove = function (ecModel, api) {
        this._symbolDraw && this._symbolDraw.remove(true)
        this._symbolDraw = null
      }

      ScatterView.prototype.dispose = function () {}

      ScatterView.type = 'scatter'
      return ScatterView
    }(ChartView))

  const GridModel =
    /** @class */
    (function (_super) {
      __extends(GridModel, _super)

      function GridModel () {
        return _super !== null && _super.apply(this, arguments) || this
      }

      GridModel.type = 'grid'
      GridModel.dependencies = ['xAxis', 'yAxis']
      GridModel.layoutMode = 'box'
      GridModel.defaultOption = {
        show: false,
        // zlevel: 0,
        z: 0,
        left: '10%',
        top: 60,
        right: '10%',
        bottom: 70,
        // If grid size contain label
        containLabel: false,
        // width: {totalWidth} - left - right,
        // height: {totalHeight} - top - bottom,
        backgroundColor: 'rgba(0,0,0,0)',
        borderWidth: 1,
        borderColor: '#ccc'
      }
      return GridModel
    }(ComponentModel))

  const CartesianAxisModel =
    /** @class */
    (function (_super) {
      __extends(CartesianAxisModel, _super)

      function CartesianAxisModel () {
        return _super !== null && _super.apply(this, arguments) || this
      }

      CartesianAxisModel.prototype.getCoordSysModel = function () {
        return this.getReferringComponents('grid', SINGLE_REFERRING).models[0]
      }

      CartesianAxisModel.type = 'cartesian2dAxis'
      return CartesianAxisModel
    }(ComponentModel))
  mixin(CartesianAxisModel, AxisModelCommonMixin)

  const defaultOption = {
    show: true,
    // zlevel: 0,
    z: 0,
    // Inverse the axis.
    inverse: false,
    // Axis name displayed.
    name: '',
    // 'start' | 'middle' | 'end'
    nameLocation: 'end',
    // By degree. By default auto rotate by nameLocation.
    nameRotate: null,
    nameTruncate: {
      maxWidth: null,
      ellipsis: '...',
      placeholder: '.'
    },
    // Use global text style by default.
    nameTextStyle: {},
    // The gap between axisName and axisLine.
    nameGap: 15,
    // Default `false` to support tooltip.
    silent: false,
    // Default `false` to avoid legacy user event listener fail.
    triggerEvent: false,
    tooltip: {
      show: false
    },
    axisPointer: {},
    axisLine: {
      show: true,
      onZero: true,
      onZeroAxisIndex: null,
      lineStyle: {
        color: '#6E7079',
        width: 1,
        type: 'solid'
      },
      // The arrow at both ends the the axis.
      symbol: ['none', 'none'],
      symbolSize: [10, 15]
    },
    axisTick: {
      show: true,
      // Whether axisTick is inside the grid or outside the grid.
      inside: false,
      // The length of axisTick.
      length: 5,
      lineStyle: {
        width: 1
      }
    },
    axisLabel: {
      show: true,
      // Whether axisLabel is inside the grid or outside the grid.
      inside: false,
      rotate: 0,
      // true | false | null/undefined (auto)
      showMinLabel: null,
      // true | false | null/undefined (auto)
      showMaxLabel: null,
      margin: 8,
      // formatter: null,
      fontSize: 12
    },
    splitLine: {
      show: true,
      lineStyle: {
        color: ['#E0E6F1'],
        width: 1,
        type: 'solid'
      }
    },
    splitArea: {
      show: false,
      areaStyle: {
        color: ['rgba(250,250,250,0.2)', 'rgba(210,219,238,0.2)']
      }
    }
  }
  const categoryAxis = merge({
    // The gap at both ends of the axis. For categoryAxis, boolean.
    boundaryGap: true,
    // Set false to faster category collection.
    deduplication: null,
    // splitArea: {
    // show: false
    // },
    splitLine: {
      show: false
    },
    axisTick: {
      // If tick is align with label when boundaryGap is true
      alignWithLabel: false,
      interval: 'auto'
    },
    axisLabel: {
      interval: 'auto'
    }
  }, defaultOption)
  const valueAxis = merge({
    boundaryGap: [0, 0],
    axisLine: {
      // Not shown when other axis is categoryAxis in cartesian
      show: 'auto'
    },
    axisTick: {
      // Not shown when other axis is categoryAxis in cartesian
      show: 'auto'
    },
    // TODO
    // min/max: [30, datamin, 60] or [20, datamin] or [datamin, 60]
    splitNumber: 5,
    minorTick: {
      // Minor tick, not available for cateogry axis.
      show: false,
      // Split number of minor ticks. The value should be in range of (0, 100)
      splitNumber: 5,
      // Lenght of minor tick
      length: 3,
      // Line style
      lineStyle: {// Default to be same with axisTick
      }
    },
    minorSplitLine: {
      show: false,
      lineStyle: {
        color: '#F4F7FD',
        width: 1
      }
    }
  }, defaultOption)
  const timeAxis = merge({
    splitNumber: 6,
    axisLabel: {
      // To eliminate labels that are not nice
      showMinLabel: false,
      showMaxLabel: false,
      rich: {
        primary: {
          fontWeight: 'bold'
        }
      }
    },
    splitLine: {
      show: false
    }
  }, valueAxis)
  const logAxis = defaults({
    logBase: 10
  }, valueAxis)
  const axisDefault = {
    category: categoryAxis,
    value: valueAxis,
    time: timeAxis,
    log: logAxis
  }

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

  /**
     * AUTO-GENERATED FILE. DO NOT MODIFY.
     */

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
  const AXIS_TYPES = {
    value: 1,
    category: 1,
    time: 1,
    log: 1
  }

  /**
     * Generate sub axis model class
     * @param axisName 'x' 'y' 'radius' 'angle' 'parallel' ...
     */

  function axisModelCreator (registers, axisName, BaseAxisModelClass, extraDefaultOption) {
    each(AXIS_TYPES, function (v, axisType) {
      const defaultOption = merge(merge({}, axisDefault[axisType], true), extraDefaultOption, true)

      const AxisModel =
        /** @class */
        (function (_super) {
          __extends(AxisModel, _super)

          function AxisModel () {
            const _this = _super !== null && _super.apply(this, arguments) || this

            _this.type = axisName + 'Axis.' + axisType
            return _this
          }

          AxisModel.prototype.mergeDefaultAndTheme = function (option, ecModel) {
            const layoutMode = fetchLayoutMode(this)
            const inputPositionParams = layoutMode ? getLayoutParams(option) : {}
            const themeModel = ecModel.getTheme()
            merge(option, themeModel.get(axisType + 'Axis'))
            merge(option, this.getDefaultOption())
            option.type = getAxisType(option)

            if (layoutMode) {
              mergeLayoutParam(option, inputPositionParams, layoutMode)
            }
          }

          AxisModel.prototype.optionUpdated = function () {
            const thisOption = this.option

            if (thisOption.type === 'category') {
              this.__ordinalMeta = OrdinalMeta.createByAxisModel(this)
            }
          }
          /**
           * Should not be called before all of 'getInitailData' finished.
           * Because categories are collected during initializing data.
           */

          AxisModel.prototype.getCategories = function (rawData) {
            const option = this.option // FIXME
            // warning if called before all of 'getInitailData' finished.

            if (option.type === 'category') {
              if (rawData) {
                return option.data
              }

              return this.__ordinalMeta.categories
            }
          }

          AxisModel.prototype.getOrdinalMeta = function () {
            return this.__ordinalMeta
          }

          AxisModel.type = axisName + 'Axis.' + axisType
          AxisModel.defaultOption = defaultOption
          return AxisModel
        }(BaseAxisModelClass))

      registers.registerComponentModel(AxisModel)
    })
    registers.registerSubTypeDefaulter(axisName + 'Axis', getAxisType)
  }

  function getAxisType (option) {
    // Default axis with data is category axis
    return option.type || (option.data ? 'category' : 'value')
  }

  const Cartesian =
    /** @class */
    (function () {
      function Cartesian (name) {
        this.type = 'cartesian'
        this._dimList = []
        this._axes = {}
        this.name = name || ''
      }

      Cartesian.prototype.getAxis = function (dim) {
        return this._axes[dim]
      }

      Cartesian.prototype.getAxes = function () {
        return map(this._dimList, function (dim) {
          return this._axes[dim]
        }, this)
      }

      Cartesian.prototype.getAxesByScale = function (scaleType) {
        scaleType = scaleType.toLowerCase()
        return filter(this.getAxes(), function (axis) {
          return axis.scale.type === scaleType
        })
      }

      Cartesian.prototype.addAxis = function (axis) {
        const dim = axis.dim
        this._axes[dim] = axis

        this._dimList.push(dim)
      }

      return Cartesian
    }())

  const cartesian2DDimensions = ['x', 'y']

  function canCalculateAffineTransform (scale) {
    return scale.type === 'interval' || scale.type === 'time'
  }

  const Cartesian2D =
    /** @class */
    (function (_super) {
      __extends(Cartesian2D, _super)

      function Cartesian2D () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = 'cartesian2d'
        _this.dimensions = cartesian2DDimensions
        return _this
      }
      /**
       * Calculate an affine transform matrix if two axes are time or value.
       * It's mainly for accelartion on the large time series data.
       */

      Cartesian2D.prototype.calcAffineTransform = function () {
        this._transform = this._invTransform = null
        const xAxisScale = this.getAxis('x').scale
        const yAxisScale = this.getAxis('y').scale

        if (!canCalculateAffineTransform(xAxisScale) || !canCalculateAffineTransform(yAxisScale)) {
          return
        }

        const xScaleExtent = xAxisScale.getExtent()
        const yScaleExtent = yAxisScale.getExtent()
        const start = this.dataToPoint([xScaleExtent[0], yScaleExtent[0]])
        const end = this.dataToPoint([xScaleExtent[1], yScaleExtent[1]])
        const xScaleSpan = xScaleExtent[1] - xScaleExtent[0]
        const yScaleSpan = yScaleExtent[1] - yScaleExtent[0]

        if (!xScaleSpan || !yScaleSpan) {
          return
        } // Accelerate data to point calculation on the special large time series data.

        const scaleX = (end[0] - start[0]) / xScaleSpan
        const scaleY = (end[1] - start[1]) / yScaleSpan
        const translateX = start[0] - xScaleExtent[0] * scaleX
        const translateY = start[1] - yScaleExtent[0] * scaleY
        const m = this._transform = [scaleX, 0, 0, scaleY, translateX, translateY]
        this._invTransform = invert([], m)
      }
      /**
       * Base axis will be used on stacking.
       */

      Cartesian2D.prototype.getBaseAxis = function () {
        return this.getAxesByScale('ordinal')[0] || this.getAxesByScale('time')[0] || this.getAxis('x')
      }

      Cartesian2D.prototype.containPoint = function (point) {
        const axisX = this.getAxis('x')
        const axisY = this.getAxis('y')
        return axisX.contain(axisX.toLocalCoord(point[0])) && axisY.contain(axisY.toLocalCoord(point[1]))
      }

      Cartesian2D.prototype.containData = function (data) {
        return this.getAxis('x').containData(data[0]) && this.getAxis('y').containData(data[1])
      }

      Cartesian2D.prototype.containZone = function (data1, data2) {
        const zoneDiag1 = this.dataToPoint(data1)
        const zoneDiag2 = this.dataToPoint(data2)
        const area = this.getArea()
        const zone = new BoundingRect(zoneDiag1[0], zoneDiag1[1], zoneDiag2[0] - zoneDiag1[0], zoneDiag2[1] - zoneDiag1[1])
        return area.intersect(zone)
      }

      Cartesian2D.prototype.dataToPoint = function (data, clamp, out) {
        out = out || []
        const xVal = data[0]
        const yVal = data[1] // Fast path

        if (this._transform && // It's supported that if data is like `[Inifity, 123]`, where only Y pixel calculated.
        xVal != null && isFinite(xVal) && yVal != null && isFinite(yVal)) {
          return applyTransform(out, data, this._transform)
        }

        const xAxis = this.getAxis('x')
        const yAxis = this.getAxis('y')
        out[0] = xAxis.toGlobalCoord(xAxis.dataToCoord(xVal, clamp))
        out[1] = yAxis.toGlobalCoord(yAxis.dataToCoord(yVal, clamp))
        return out
      }

      Cartesian2D.prototype.clampData = function (data, out) {
        const xScale = this.getAxis('x').scale
        const yScale = this.getAxis('y').scale
        const xAxisExtent = xScale.getExtent()
        const yAxisExtent = yScale.getExtent()
        const x = xScale.parse(data[0])
        const y = yScale.parse(data[1])
        out = out || []
        out[0] = Math.min(Math.max(Math.min(xAxisExtent[0], xAxisExtent[1]), x), Math.max(xAxisExtent[0], xAxisExtent[1]))
        out[1] = Math.min(Math.max(Math.min(yAxisExtent[0], yAxisExtent[1]), y), Math.max(yAxisExtent[0], yAxisExtent[1]))
        return out
      }

      Cartesian2D.prototype.pointToData = function (point, clamp) {
        const out = []

        if (this._invTransform) {
          return applyTransform(out, point, this._invTransform)
        }

        const xAxis = this.getAxis('x')
        const yAxis = this.getAxis('y')
        out[0] = xAxis.coordToData(xAxis.toLocalCoord(point[0]), clamp)
        out[1] = yAxis.coordToData(yAxis.toLocalCoord(point[1]), clamp)
        return out
      }

      Cartesian2D.prototype.getOtherAxis = function (axis) {
        return this.getAxis(axis.dim === 'x' ? 'y' : 'x')
      }
      /**
       * Get rect area of cartesian.
       * Area will have a contain function to determine if a point is in the coordinate system.
       */

      Cartesian2D.prototype.getArea = function () {
        const xExtent = this.getAxis('x').getGlobalExtent()
        const yExtent = this.getAxis('y').getGlobalExtent()
        const x = Math.min(xExtent[0], xExtent[1])
        const y = Math.min(yExtent[0], yExtent[1])
        const width = Math.max(xExtent[0], xExtent[1]) - x
        const height = Math.max(yExtent[0], yExtent[1]) - y
        return new BoundingRect(x, y, width, height)
      }

      return Cartesian2D
    }(Cartesian))

  const Axis2D =
    /** @class */
    (function (_super) {
      __extends(Axis2D, _super)

      function Axis2D (dim, scale, coordExtent, axisType, position) {
        const _this = _super.call(this, dim, scale, coordExtent) || this
        /**
         * Index of axis, can be used as key
         * Injected outside.
         */

        _this.index = 0
        _this.type = axisType || 'value'
        _this.position = position || 'bottom'
        return _this
      }

      Axis2D.prototype.isHorizontal = function () {
        const position = this.position
        return position === 'top' || position === 'bottom'
      }
      /**
       * Each item cooresponds to this.getExtent(), which
       * means globalExtent[0] may greater than globalExtent[1],
       * unless `asc` is input.
       *
       * @param {boolean} [asc]
       * @return {Array.<number>}
       */

      Axis2D.prototype.getGlobalExtent = function (asc) {
        const ret = this.getExtent()
        ret[0] = this.toGlobalCoord(ret[0])
        ret[1] = this.toGlobalCoord(ret[1])
        asc && ret[0] > ret[1] && ret.reverse()
        return ret
      }

      Axis2D.prototype.pointToData = function (point, clamp) {
        return this.coordToData(this.toLocalCoord(point[this.dim === 'x' ? 0 : 1]), clamp)
      }
      /**
       * Set ordinalSortInfo
       * @param info new OrdinalSortInfo
       */

      Axis2D.prototype.setCategorySortInfo = function (info) {
        if (this.type !== 'category') {
          return false
        }

        this.model.option.categorySortInfo = info
        this.scale.setSortInfo(info)
      }

      return Axis2D
    }(Axis))

  /**
     * Can only be called after coordinate system creation stage.
     * (Can be called before coordinate system update stage).
     */

  function layout$1 (gridModel, axisModel, opt) {
    opt = opt || {}
    const grid = gridModel.coordinateSystem
    const axis = axisModel.axis
    const layout = {}
    const otherAxisOnZeroOf = axis.getAxesOnZeroOf()[0]
    const rawAxisPosition = axis.position
    const axisPosition = otherAxisOnZeroOf ? 'onZero' : rawAxisPosition
    const axisDim = axis.dim
    const rect = grid.getRect()
    const rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height]
    const idx = {
      left: 0,
      right: 1,
      top: 0,
      bottom: 1,
      onZero: 2
    }
    const axisOffset = axisModel.get('offset') || 0
    const posBound = axisDim === 'x' ? [rectBound[2] - axisOffset, rectBound[3] + axisOffset] : [rectBound[0] - axisOffset, rectBound[1] + axisOffset]

    if (otherAxisOnZeroOf) {
      const onZeroCoord = otherAxisOnZeroOf.toGlobalCoord(otherAxisOnZeroOf.dataToCoord(0))
      posBound[idx.onZero] = Math.max(Math.min(onZeroCoord, posBound[1]), posBound[0])
    } // Axis position

    layout.position = [axisDim === 'y' ? posBound[idx[axisPosition]] : rectBound[0], axisDim === 'x' ? posBound[idx[axisPosition]] : rectBound[3]] // Axis rotation

    layout.rotation = Math.PI / 2 * (axisDim === 'x' ? 0 : 1) // Tick and label direction, x y is axisDim

    const dirMap = {
      top: -1,
      bottom: 1,
      left: -1,
      right: 1
    }
    layout.labelDirection = layout.tickDirection = layout.nameDirection = dirMap[rawAxisPosition]
    layout.labelOffset = otherAxisOnZeroOf ? posBound[idx[rawAxisPosition]] - posBound[idx.onZero] : 0

    if (axisModel.get(['axisTick', 'inside'])) {
      layout.tickDirection = -layout.tickDirection
    }

    if (retrieve(opt.labelInside, axisModel.get(['axisLabel', 'inside']))) {
      layout.labelDirection = -layout.labelDirection
    } // Special label rotation

    const labelRotate = axisModel.get(['axisLabel', 'rotate'])
    layout.labelRotate = axisPosition === 'top' ? -labelRotate : labelRotate // Over splitLine and splitArea

    layout.z2 = 1
    return layout
  }
  function isCartesian2DSeries (seriesModel) {
    return seriesModel.get('coordinateSystem') === 'cartesian2d'
  }
  function findAxisModels (seriesModel) {
    const axisModelMap = {
      xAxisModel: null,
      yAxisModel: null
    }
    each(axisModelMap, function (v, key) {
      const axisType = key.replace(/Model$/, '')
      const axisModel = seriesModel.getReferringComponents(axisType, SINGLE_REFERRING).models[0]

      if ('development' !== 'production') {
        if (!axisModel) {
          throw new Error(axisType + ' "' + retrieve3(seriesModel.get(axisType + 'Index'), seriesModel.get(axisType + 'Id'), 0) + '" not found')
        }
      }

      axisModelMap[key] = axisModel
    })
    return axisModelMap
  }

  const mathLog$1 = Math.log
  function alignScaleTicks (scale, axisModel, alignToScale) {
    const intervalScaleProto = IntervalScale.prototype // NOTE: There is a precondition for log scale  here:
    // In log scale we store _interval and _extent of exponent value.
    // So if we use the method of InternalScale to set/get these data.
    // It process the exponent value, which is linear and what we want here.

    const alignToTicks = intervalScaleProto.getTicks.call(alignToScale)
    const alignToNicedTicks = intervalScaleProto.getTicks.call(alignToScale, true)
    const alignToSplitNumber = alignToTicks.length - 1
    const alignToInterval = intervalScaleProto.getInterval.call(alignToScale)
    const scaleExtent = getScaleExtent(scale, axisModel)
    let rawExtent = scaleExtent.extent
    const isMinFixed = scaleExtent.fixMin
    const isMaxFixed = scaleExtent.fixMax

    if (scale.type === 'log') {
      const logBase = mathLog$1(scale.base)
      rawExtent = [mathLog$1(rawExtent[0]) / logBase, mathLog$1(rawExtent[1]) / logBase]
    }

    scale.setExtent(rawExtent[0], rawExtent[1])
    scale.calcNiceExtent({
      splitNumber: alignToSplitNumber,
      fixMin: isMinFixed,
      fixMax: isMaxFixed
    })
    const extent = intervalScaleProto.getExtent.call(scale) // Need to update the rawExtent.
    // Because value in rawExtent may be not parsed. e.g. 'dataMin', 'dataMax'

    if (isMinFixed) {
      rawExtent[0] = extent[0]
    }

    if (isMaxFixed) {
      rawExtent[1] = extent[1]
    }

    let interval = intervalScaleProto.getInterval.call(scale)
    let min = rawExtent[0]
    let max = rawExtent[1]

    if (isMinFixed && isMaxFixed) {
      // User set min, max, divide to get new interval
      interval = (max - min) / alignToSplitNumber
    } else if (isMinFixed) {
      max = rawExtent[0] + interval * alignToSplitNumber // User set min, expand extent on the other side

      while (max < rawExtent[1] && isFinite(max) && isFinite(rawExtent[1])) {
        interval = increaseInterval(interval)
        max = rawExtent[0] + interval * alignToSplitNumber
      }
    } else if (isMaxFixed) {
      // User set max, expand extent on the other side
      min = rawExtent[1] - interval * alignToSplitNumber

      while (min > rawExtent[0] && isFinite(min) && isFinite(rawExtent[0])) {
        interval = increaseInterval(interval)
        min = rawExtent[1] - interval * alignToSplitNumber
      }
    } else {
      const nicedSplitNumber = scale.getTicks().length - 1

      if (nicedSplitNumber > alignToSplitNumber) {
        interval = increaseInterval(interval)
      }

      const range = interval * alignToSplitNumber
      max = Math.ceil(rawExtent[1] / interval) * interval
      min = round(max - range) // Not change the result that crossing zero.

      if (min < 0 && rawExtent[0] >= 0) {
        min = 0
        max = round(range)
      } else if (max > 0 && rawExtent[1] <= 0) {
        max = 0
        min = -round(range)
      }
    } // Adjust min, max based on the extent of alignTo. When min or max is set in alignTo scale

    const t0 = (alignToTicks[0].value - alignToNicedTicks[0].value) / alignToInterval
    const t1 = (alignToTicks[alignToSplitNumber].value - alignToNicedTicks[alignToSplitNumber].value) / alignToInterval // NOTE: Must in setExtent -> setInterval -> setNiceExtent order.

    intervalScaleProto.setExtent.call(scale, min + interval * t0, max + interval * t1)
    intervalScaleProto.setInterval.call(scale, interval)

    if (t0 || t1) {
      intervalScaleProto.setNiceExtent.call(scale, min + interval, max - interval)
    }

    if ('development' !== 'production') {
      const ticks = intervalScaleProto.getTicks.call(scale)

      if (ticks[1] && (!isValueNice(interval) || getPrecisionSafe(ticks[1].value) > getPrecisionSafe(interval))) {
        warn( // eslint-disable-next-line
          "The ticks may be not readable when set min: " + axisModel.get('min') + ", max: " + axisModel.get('max') + " and alignTicks: true");
      }
    }
  }

  const Grid =
    /** @class */
    (function () {
      function Grid (gridModel, ecModel, api) {
        // FIXME:TS where used (different from registered type 'cartesian2d')?
        this.type = 'grid'
        this._coordsMap = {}
        this._coordsList = []
        this._axesMap = {}
        this._axesList = []
        this.axisPointerEnabled = true
        this.dimensions = cartesian2DDimensions

        this._initCartesian(gridModel, ecModel, api)

        this.model = gridModel
      }

      Grid.prototype.getRect = function () {
        return this._rect
      }

      Grid.prototype.update = function (ecModel, api) {
        const axesMap = this._axesMap

        this._updateScale(ecModel, this.model)

        function updateAxisTicks (axes) {
          let alignTo // Axis is added in order of axisIndex.

          const axesIndices = keys(axes)
          const len = axesIndices.length

          if (!len) {
            return
          }

          const axisNeedsAlign = [] // Process once and calculate the ticks for those don't use alignTicks.

          for (let i = len - 1; i >= 0; i--) {
            const idx = +axesIndices[i] // Convert to number.

            const axis = axes[idx]
            const model = axis.model
            const scale = axis.scale

            if ( // Only value and log axis without interval support alignTicks.
              isIntervalOrLogScale(scale) && model.get('alignTicks') && model.get('interval') == null) {
              axisNeedsAlign.push(axis)
            } else {
              niceScaleExtent(scale, model)

              if (isIntervalOrLogScale(scale)) {
                // Can only align to interval or log axis.
                alignTo = axis
              }
            }
          }
          // PENDING. Should we find the axis that both set interval, min, max and align to this one?

          if (axisNeedsAlign.length) {
            if (!alignTo) {
              alignTo = axisNeedsAlign.pop()
              niceScaleExtent(alignTo.scale, alignTo.model)
            }

            each(axisNeedsAlign, function (axis) {
              alignScaleTicks(axis.scale, axis.model, alignTo.scale)
            })
          }
        }

        updateAxisTicks(axesMap.x)
        updateAxisTicks(axesMap.y) // Key: axisDim_axisIndex, value: boolean, whether onZero target.

        const onZeroRecords = {}
        each(axesMap.x, function (xAxis) {
          fixAxisOnZero(axesMap, 'y', xAxis, onZeroRecords)
        })
        each(axesMap.y, function (yAxis) {
          fixAxisOnZero(axesMap, 'x', yAxis, onZeroRecords)
        }) // Resize again if containLabel is enabled
        // FIXME It may cause getting wrong grid size in data processing stage

        this.resize(this.model, api)
      }
      /**
       * Resize the grid
       */

      Grid.prototype.resize = function (gridModel, api, ignoreContainLabel) {
        const boxLayoutParams = gridModel.getBoxLayoutParams()
        const isContainLabel = !ignoreContainLabel && gridModel.get('containLabel')
        const gridRect = getLayoutRect(boxLayoutParams, {
          width: api.getWidth(),
          height: api.getHeight()
        })
        this._rect = gridRect
        const axesList = this._axesList
        adjustAxes() // Minus label size

        if (isContainLabel) {
          each(axesList, function (axis) {
            if (!axis.model.get(['axisLabel', 'inside'])) {
              const labelUnionRect = estimateLabelUnionRect(axis)

              if (labelUnionRect) {
                const dim = axis.isHorizontal() ? 'height' : 'width'
                const margin = axis.model.get(['axisLabel', 'margin'])
                gridRect[dim] -= labelUnionRect[dim] + margin

                if (axis.position === 'top') {
                  gridRect.y += labelUnionRect.height + margin
                } else if (axis.position === 'left') {
                  gridRect.x += labelUnionRect.width + margin
                }
              }
            }
          })
          adjustAxes()
        }

        each(this._coordsList, function (coord) {
          // Calculate affine matrix to accelerate the data to point transform.
          // If all the axes scales are time or value.
          coord.calcAffineTransform()
        })

        function adjustAxes () {
          each(axesList, function (axis) {
            const isHorizontal = axis.isHorizontal()
            const extent = isHorizontal ? [0, gridRect.width] : [0, gridRect.height]
            const idx = axis.inverse ? 1 : 0
            axis.setExtent(extent[idx], extent[1 - idx])
            updateAxisTransform(axis, isHorizontal ? gridRect.x : gridRect.y)
          })
        }
      }

      Grid.prototype.getAxis = function (dim, axisIndex) {
        const axesMapOnDim = this._axesMap[dim]

        if (axesMapOnDim != null) {
          return axesMapOnDim[axisIndex || 0]
        }
      }

      Grid.prototype.getAxes = function () {
        return this._axesList.slice()
      }

      Grid.prototype.getCartesian = function (xAxisIndex, yAxisIndex) {
        if (xAxisIndex != null && yAxisIndex != null) {
          const key = 'x' + xAxisIndex + 'y' + yAxisIndex
          return this._coordsMap[key]
        }

        if (isObject(xAxisIndex)) {
          yAxisIndex = xAxisIndex.yAxisIndex
          xAxisIndex = xAxisIndex.xAxisIndex
        }

        for (let i = 0, coordList = this._coordsList; i < coordList.length; i++) {
          if (coordList[i].getAxis('x').index === xAxisIndex || coordList[i].getAxis('y').index === yAxisIndex) {
            return coordList[i]
          }
        }
      }

      Grid.prototype.getCartesians = function () {
        return this._coordsList.slice()
      }
      /**
       * @implements
       */

      Grid.prototype.convertToPixel = function (ecModel, finder, value) {
        const target = this._findConvertTarget(finder)

        return target.cartesian ? target.cartesian.dataToPoint(value) : target.axis ? target.axis.toGlobalCoord(target.axis.dataToCoord(value)) : null
      }
      /**
       * @implements
       */

      Grid.prototype.convertFromPixel = function (ecModel, finder, value) {
        const target = this._findConvertTarget(finder)

        return target.cartesian ? target.cartesian.pointToData(value) : target.axis ? target.axis.coordToData(target.axis.toLocalCoord(value)) : null
      }

      Grid.prototype._findConvertTarget = function (finder) {
        const seriesModel = finder.seriesModel
        const xAxisModel = finder.xAxisModel || seriesModel && seriesModel.getReferringComponents('xAxis', SINGLE_REFERRING).models[0]
        const yAxisModel = finder.yAxisModel || seriesModel && seriesModel.getReferringComponents('yAxis', SINGLE_REFERRING).models[0]
        const gridModel = finder.gridModel
        const coordsList = this._coordsList
        let cartesian
        let axis

        if (seriesModel) {
          cartesian = seriesModel.coordinateSystem
          indexOf(coordsList, cartesian) < 0 && (cartesian = null)
        } else if (xAxisModel && yAxisModel) {
          cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex)
        } else if (xAxisModel) {
          axis = this.getAxis('x', xAxisModel.componentIndex)
        } else if (yAxisModel) {
          axis = this.getAxis('y', yAxisModel.componentIndex)
        } // Lowest priority.
        else if (gridModel) {
          const grid = gridModel.coordinateSystem

          if (grid === this) {
            cartesian = this._coordsList[0]
          }
        }

        return {
          cartesian: cartesian,
          axis: axis
        }
      }
      /**
       * @implements
       */

      Grid.prototype.containPoint = function (point) {
        const coord = this._coordsList[0]

        if (coord) {
          return coord.containPoint(point)
        }
      }
      /**
       * Initialize cartesian coordinate systems
       */

      Grid.prototype._initCartesian = function (gridModel, ecModel, api) {
        const _this = this

        const grid = this
        const axisPositionUsed = {
          left: false,
          right: false,
          top: false,
          bottom: false
        }
        const axesMap = {
          x: {},
          y: {}
        }
        const axesCount = {
          x: 0,
          y: 0
        } /// Create axis

        ecModel.eachComponent('xAxis', createAxisCreator('x'), this)
        ecModel.eachComponent('yAxis', createAxisCreator('y'), this)

        if (!axesCount.x || !axesCount.y) {
          // Roll back when there no either x or y axis
          this._axesMap = {}
          this._axesList = []
          return
        }

        this._axesMap = axesMap /// Create cartesian2d

        each(axesMap.x, function (xAxis, xAxisIndex) {
          each(axesMap.y, function (yAxis, yAxisIndex) {
            const key = 'x' + xAxisIndex + 'y' + yAxisIndex
            const cartesian = new Cartesian2D(key)
            cartesian.master = _this
            cartesian.model = gridModel
            _this._coordsMap[key] = cartesian

            _this._coordsList.push(cartesian)

            cartesian.addAxis(xAxis)
            cartesian.addAxis(yAxis)
          })
        })

        function createAxisCreator (dimName) {
          return function (axisModel, idx) {
            if (!isAxisUsedInTheGrid(axisModel, gridModel)) {
              return
            }

            let axisPosition = axisModel.get('position')

            if (dimName === 'x') {
              // Fix position
              if (axisPosition !== 'top' && axisPosition !== 'bottom') {
                // Default bottom of X
                axisPosition = axisPositionUsed.bottom ? 'top' : 'bottom'
              }
            } else {
              // Fix position
              if (axisPosition !== 'left' && axisPosition !== 'right') {
                // Default left of Y
                axisPosition = axisPositionUsed.left ? 'right' : 'left'
              }
            }

            axisPositionUsed[axisPosition] = true
            const axis = new Axis2D(dimName, createScaleByModel(axisModel), [0, 0], axisModel.get('type'), axisPosition)
            const isCategory = axis.type === 'category'
            axis.onBand = isCategory && axisModel.get('boundaryGap')
            axis.inverse = axisModel.get('inverse') // Inject axis into axisModel

            axisModel.axis = axis // Inject axisModel into axis

            axis.model = axisModel // Inject grid info axis

            axis.grid = grid // Index of axis, can be used as key

            axis.index = idx

            grid._axesList.push(axis)

            axesMap[dimName][idx] = axis
            axesCount[dimName]++
          }
        }
      }
      /**
       * Update cartesian properties from series.
       */

      Grid.prototype._updateScale = function (ecModel, gridModel) {
        // Reset scale
        each(this._axesList, function (axis) {
          axis.scale.setExtent(Infinity, -Infinity)

          if (axis.type === 'category') {
            const categorySortInfo = axis.model.get('categorySortInfo')
            axis.scale.setSortInfo(categorySortInfo)
          }
        })
        ecModel.eachSeries(function (seriesModel) {
          if (isCartesian2DSeries(seriesModel)) {
            const axesModelMap = findAxisModels(seriesModel)
            const xAxisModel = axesModelMap.xAxisModel
            const yAxisModel = axesModelMap.yAxisModel

            if (!isAxisUsedInTheGrid(xAxisModel, gridModel) || !isAxisUsedInTheGrid(yAxisModel, gridModel)) {
              return
            }

            const cartesian = this.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex)
            const data = seriesModel.getData()
            const xAxis = cartesian.getAxis('x')
            const yAxis = cartesian.getAxis('y')
            unionExtent(data, xAxis)
            unionExtent(data, yAxis)
          }
        }, this)

        function unionExtent (data, axis) {
          each(getDataDimensionsOnAxis(data, axis.dim), function (dim) {
            axis.scale.unionExtentFromData(data, dim)
          })
        }
      }
      /**
       * @param dim 'x' or 'y' or 'auto' or null/undefined
       */

      Grid.prototype.getTooltipAxes = function (dim) {
        const baseAxes = []
        const otherAxes = []
        each(this.getCartesians(), function (cartesian) {
          const baseAxis = dim != null && dim !== 'auto' ? cartesian.getAxis(dim) : cartesian.getBaseAxis()
          const otherAxis = cartesian.getOtherAxis(baseAxis)
          indexOf(baseAxes, baseAxis) < 0 && baseAxes.push(baseAxis)
          indexOf(otherAxes, otherAxis) < 0 && otherAxes.push(otherAxis)
        })
        return {
          baseAxes: baseAxes,
          otherAxes: otherAxes
        }
      }

      Grid.create = function (ecModel, api) {
        const grids = []
        ecModel.eachComponent('grid', function (gridModel, idx) {
          const grid = new Grid(gridModel, ecModel, api)
          grid.name = 'grid_' + idx // dataSampling requires axis extent, so resize
          // should be performed in create stage.

          grid.resize(gridModel, api, true)
          gridModel.coordinateSystem = grid
          grids.push(grid)
        }) // Inject the coordinateSystems into seriesModel

        ecModel.eachSeries(function (seriesModel) {
          if (!isCartesian2DSeries(seriesModel)) {
            return
          }

          const axesModelMap = findAxisModels(seriesModel)
          const xAxisModel = axesModelMap.xAxisModel
          const yAxisModel = axesModelMap.yAxisModel
          const gridModel = xAxisModel.getCoordSysModel()

          if ('development' !== 'production') {
            if (!gridModel) {
              throw new Error('Grid "' + retrieve3(xAxisModel.get('gridIndex'), xAxisModel.get('gridId'), 0) + '" not found')
            }

            if (xAxisModel.getCoordSysModel() !== yAxisModel.getCoordSysModel()) {
              throw new Error('xAxis and yAxis must use the same grid')
            }
          }

          const grid = gridModel.coordinateSystem
          seriesModel.coordinateSystem = grid.getCartesian(xAxisModel.componentIndex, yAxisModel.componentIndex)
        })
        return grids
      } // For deciding which dimensions to use when creating list data

      Grid.dimensions = cartesian2DDimensions
      return Grid
    }())
    /**
     * Check if the axis is used in the specified grid.
     */

  function isAxisUsedInTheGrid (axisModel, gridModel) {
    return axisModel.getCoordSysModel() === gridModel
  }

  function fixAxisOnZero (axesMap, otherAxisDim, axis, // Key: see `getOnZeroRecordKey`
    onZeroRecords) {
    axis.getAxesOnZeroOf = function () {
      // TODO: onZero of multiple axes.
      return otherAxisOnZeroOf ? [otherAxisOnZeroOf] : []
    } // onZero can not be enabled in these two situations:
    // 1. When any other axis is a category axis.
    // 2. When no axis is cross 0 point.

    const otherAxes = axesMap[otherAxisDim]
    let otherAxisOnZeroOf
    const axisModel = axis.model
    const onZero = axisModel.get(['axisLine', 'onZero'])
    const onZeroAxisIndex = axisModel.get(['axisLine', 'onZeroAxisIndex'])

    if (!onZero) {
      return
    } // If target axis is specified.

    if (onZeroAxisIndex != null) {
      if (canOnZeroToAxis(otherAxes[onZeroAxisIndex])) {
        otherAxisOnZeroOf = otherAxes[onZeroAxisIndex]
      }
    } else {
      // Find the first available other axis.
      for (const idx in otherAxes) {
        if (otherAxes.hasOwnProperty(idx) && canOnZeroToAxis(otherAxes[idx]) && // Consider that two Y axes on one value axis,
          // if both onZero, the two Y axes overlap.
          !onZeroRecords[getOnZeroRecordKey(otherAxes[idx])]) {
          otherAxisOnZeroOf = otherAxes[idx]
          break
        }
      }
    }

    if (otherAxisOnZeroOf) {
      onZeroRecords[getOnZeroRecordKey(otherAxisOnZeroOf)] = true
    }

    function getOnZeroRecordKey (axis) {
      return axis.dim + '_' + axis.index
    }
  }

  function canOnZeroToAxis (axis) {
    return axis && axis.type !== 'category' && axis.type !== 'time' && ifAxisCrossZero(axis)
  }

  function updateAxisTransform (axis, coordBase) {
    const axisExtent = axis.getExtent()
    const axisExtentSum = axisExtent[0] + axisExtent[1] // Fast transform

    axis.toGlobalCoord = axis.dim === 'x'
      ? function (coord) {
        return coord + coordBase
      }
      : function (coord) {
        return axisExtentSum - coord + coordBase
      }
    axis.toLocalCoord = axis.dim === 'x'
      ? function (coord) {
        return coord - coordBase
      }
      : function (coord) {
        return axisExtentSum - coord + coordBase
      }
  }

  const PI$5 = Math.PI
  /**
     * A final axis is translated and rotated from a "standard axis".
     * So opt.position and opt.rotation is required.
     *
     * A standard axis is and axis from [0, 0] to [0, axisExtent[1]],
     * for example: (0, 0) ------------> (0, 50)
     *
     * nameDirection or tickDirection or labelDirection is 1 means tick
     * or label is below the standard axis, whereas is -1 means above
     * the standard axis. labelOffset means offset between label and axis,
     * which is useful when 'onZero', where axisLabel is in the grid and
     * label in outside grid.
     *
     * Tips: like always,
     * positive rotation represents anticlockwise, and negative rotation
     * represents clockwise.
     * The direction of position coordinate is the same as the direction
     * of screen coordinate.
     *
     * Do not need to consider axis 'inverse', which is auto processed by
     * axis extent.
     */

  const AxisBuilder =
    /** @class */
    (function () {
      function AxisBuilder (axisModel, opt) {
        this.group = new Group()
        this.opt = opt
        this.axisModel = axisModel // Default value

        defaults(opt, {
          labelOffset: 0,
          nameDirection: 1,
          tickDirection: 1,
          labelDirection: 1,
          silent: true,
          handleAutoShown: function () {
            return true
          }
        }) // FIXME Not use a seperate text group?

        const transformGroup = new Group({
          x: opt.position[0],
          y: opt.position[1],
          rotation: opt.rotation
        }) // this.group.add(transformGroup);
        // this._transformGroup = transformGroup;

        transformGroup.updateTransform()
        this._transformGroup = transformGroup
      }

      AxisBuilder.prototype.hasBuilder = function (name) {
        return !!builders[name]
      }

      AxisBuilder.prototype.add = function (name) {
        builders[name](this.opt, this.axisModel, this.group, this._transformGroup)
      }

      AxisBuilder.prototype.getGroup = function () {
        return this.group
      }

      AxisBuilder.innerTextLayout = function (axisRotation, textRotation, direction) {
        const rotationDiff = remRadian(textRotation - axisRotation)
        let textAlign
        let textVerticalAlign

        if (isRadianAroundZero(rotationDiff)) {
          // Label is parallel with axis line.
          textVerticalAlign = direction > 0 ? 'top' : 'bottom'
          textAlign = 'center'
        } else if (isRadianAroundZero(rotationDiff - PI$5)) {
          // Label is inverse parallel with axis line.
          textVerticalAlign = direction > 0 ? 'bottom' : 'top'
          textAlign = 'center'
        } else {
          textVerticalAlign = 'middle'

          if (rotationDiff > 0 && rotationDiff < PI$5) {
            textAlign = direction > 0 ? 'right' : 'left'
          } else {
            textAlign = direction > 0 ? 'left' : 'right'
          }
        }

        return {
          rotation: rotationDiff,
          textAlign: textAlign,
          textVerticalAlign: textVerticalAlign
        }
      }

      AxisBuilder.makeAxisEventDataBase = function (axisModel) {
        const eventData = {
          componentType: axisModel.mainType,
          componentIndex: axisModel.componentIndex
        }
        eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex
        return eventData
      }

      AxisBuilder.isLabelSilent = function (axisModel) {
        const tooltipOpt = axisModel.get('tooltip')
        return axisModel.get('silent') || // Consider mouse cursor, add these restrictions.
        !(axisModel.get('triggerEvent') || tooltipOpt && tooltipOpt.show)
      }

      return AxisBuilder
    }())
  var builders = {
    axisLine: function (opt, axisModel, group, transformGroup) {
      let shown = axisModel.get(['axisLine', 'show'])

      if (shown === 'auto' && opt.handleAutoShown) {
        shown = opt.handleAutoShown('axisLine')
      }

      if (!shown) {
        return
      }

      const extent = axisModel.axis.getExtent()
      const matrix = transformGroup.transform
      const pt1 = [extent[0], 0]
      const pt2 = [extent[1], 0]

      if (matrix) {
        applyTransform(pt1, pt1, matrix)
        applyTransform(pt2, pt2, matrix)
      }

      const lineStyle = extend({
        lineCap: 'round'
      }, axisModel.getModel(['axisLine', 'lineStyle']).getLineStyle())
      const line = new Line({
        // Id for animation
        subPixelOptimize: true,
        shape: {
          x1: pt1[0],
          y1: pt1[1],
          x2: pt2[0],
          y2: pt2[1]
        },
        style: lineStyle,
        strokeContainThreshold: opt.strokeContainThreshold || 5,
        silent: true,
        z2: 1
      })
      line.anid = 'line'
      group.add(line)
      let arrows = axisModel.get(['axisLine', 'symbol'])

      if (arrows != null) {
        let arrowSize = axisModel.get(['axisLine', 'symbolSize'])

        if (isString(arrows)) {
          // Use the same arrow for start and end point
          arrows = [arrows, arrows]
        }

        if (isString(arrowSize) || isNumber(arrowSize)) {
          // Use the same size for width and height
          arrowSize = [arrowSize, arrowSize]
        }

        const arrowOffset = normalizeSymbolOffset(axisModel.get(['axisLine', 'symbolOffset']) || 0, arrowSize)
        const symbolWidth_1 = arrowSize[0]
        const symbolHeight_1 = arrowSize[1]
        each([{
          rotate: opt.rotation + Math.PI / 2,
          offset: arrowOffset[0],
          r: 0
        }, {
          rotate: opt.rotation - Math.PI / 2,
          offset: arrowOffset[1],
          r: Math.sqrt((pt1[0] - pt2[0]) * (pt1[0] - pt2[0]) + (pt1[1] - pt2[1]) * (pt1[1] - pt2[1]))
        }], function (point, index) {
          if (arrows[index] !== 'none' && arrows[index] != null) {
            const symbol = createSymbol(arrows[index], -symbolWidth_1 / 2, -symbolHeight_1 / 2, symbolWidth_1, symbolHeight_1, lineStyle.stroke, true) // Calculate arrow position with offset

            const r = point.r + point.offset
            symbol.attr({
              rotation: point.rotate,
              x: pt1[0] + r * Math.cos(opt.rotation),
              y: pt1[1] - r * Math.sin(opt.rotation),
              silent: true,
              z2: 11
            })
            group.add(symbol)
          }
        })
      }
    },
    axisTickLabel: function (opt, axisModel, group, transformGroup) {
      const ticksEls = buildAxisMajorTicks(group, transformGroup, axisModel, opt)
      const labelEls = buildAxisLabel(group, transformGroup, axisModel, opt)
      fixMinMaxLabelShow(axisModel, labelEls, ticksEls)
      buildAxisMinorTicks(group, transformGroup, axisModel, opt.tickDirection) // This bit fixes the label overlap issue for the time chart.
      // See https://github.com/apache/echarts/issues/14266 for more.

      if (axisModel.get(['axisLabel', 'hideOverlap'])) {
        const labelList = prepareLayoutList(map(labelEls, function (label) {
          return {
            label: label,
            priority: label.z2,
            defaultAttr: {
              ignore: label.ignore
            }
          }
        }))
        hideOverlap(labelList)
      }
    },
    axisName: function (opt, axisModel, group, transformGroup) {
      const name = retrieve(opt.axisName, axisModel.get('name'))

      if (!name) {
        return
      }

      const nameLocation = axisModel.get('nameLocation')
      const nameDirection = opt.nameDirection
      const textStyleModel = axisModel.getModel('nameTextStyle')
      const gap = axisModel.get('nameGap') || 0
      const extent = axisModel.axis.getExtent()
      const gapSignal = extent[0] > extent[1] ? -1 : 1
      const pos = [nameLocation === 'start' ? extent[0] - gapSignal * gap : nameLocation === 'end' ? extent[1] + gapSignal * gap : (extent[0] + extent[1]) / 2, // Reuse labelOffset.
        isNameLocationCenter(nameLocation) ? opt.labelOffset + nameDirection * gap : 0]
      let labelLayout
      let nameRotation = axisModel.get('nameRotate')

      if (nameRotation != null) {
        nameRotation = nameRotation * PI$5 / 180 // To radian.
      }

      let axisNameAvailableWidth

      if (isNameLocationCenter(nameLocation)) {
        labelLayout = AxisBuilder.innerTextLayout(opt.rotation, nameRotation != null ? nameRotation : opt.rotation, // Adapt to axis.
          nameDirection)
      } else {
        labelLayout = endTextLayout(opt.rotation, nameLocation, nameRotation || 0, extent)
        axisNameAvailableWidth = opt.axisNameAvailableWidth

        if (axisNameAvailableWidth != null) {
          axisNameAvailableWidth = Math.abs(axisNameAvailableWidth / Math.sin(labelLayout.rotation))
          !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null)
        }
      }

      const textFont = textStyleModel.getFont()
      const truncateOpt = axisModel.get('nameTruncate', true) || {}
      const ellipsis = truncateOpt.ellipsis
      const maxWidth = retrieve(opt.nameTruncateMaxWidth, truncateOpt.maxWidth, axisNameAvailableWidth)
      const textEl = new ZRText({
        x: pos[0],
        y: pos[1],
        rotation: labelLayout.rotation,
        silent: AxisBuilder.isLabelSilent(axisModel),
        style: createTextStyle(textStyleModel, {
          text: name,
          font: textFont,
          overflow: 'truncate',
          width: maxWidth,
          ellipsis: ellipsis,
          fill: textStyleModel.getTextColor() || axisModel.get(['axisLine', 'lineStyle', 'color']),
          align: textStyleModel.get('align') || labelLayout.textAlign,
          verticalAlign: textStyleModel.get('verticalAlign') || labelLayout.textVerticalAlign
        }),
        z2: 1
      })
      setTooltipConfig({
        el: textEl,
        componentModel: axisModel,
        itemName: name
      })
      textEl.__fullText = name // Id for animation

      textEl.anid = 'name'

      if (axisModel.get('triggerEvent')) {
        const eventData = AxisBuilder.makeAxisEventDataBase(axisModel)
        eventData.targetType = 'axisName'
        eventData.name = name
        getECData(textEl).eventData = eventData
      } // FIXME

      transformGroup.add(textEl)
      textEl.updateTransform()
      group.add(textEl)
      textEl.decomposeTransform()
    }
  }

  function endTextLayout (rotation, textPosition, textRotate, extent) {
    const rotationDiff = remRadian(textRotate - rotation)
    let textAlign
    let textVerticalAlign
    const inverse = extent[0] > extent[1]
    const onLeft = textPosition === 'start' && !inverse || textPosition !== 'start' && inverse

    if (isRadianAroundZero(rotationDiff - PI$5 / 2)) {
      textVerticalAlign = onLeft ? 'bottom' : 'top'
      textAlign = 'center'
    } else if (isRadianAroundZero(rotationDiff - PI$5 * 1.5)) {
      textVerticalAlign = onLeft ? 'top' : 'bottom'
      textAlign = 'center'
    } else {
      textVerticalAlign = 'middle'

      if (rotationDiff < PI$5 * 1.5 && rotationDiff > PI$5 / 2) {
        textAlign = onLeft ? 'left' : 'right'
      } else {
        textAlign = onLeft ? 'right' : 'left'
      }
    }

    return {
      rotation: rotationDiff,
      textAlign: textAlign,
      textVerticalAlign: textVerticalAlign
    }
  }

  function fixMinMaxLabelShow (axisModel, labelEls, tickEls) {
    if (shouldShowAllLabels(axisModel.axis)) {
      return
    } // If min or max are user set, we need to check
    // If the tick on min(max) are overlap on their neighbour tick
    // If they are overlapped, we need to hide the min(max) tick label

    const showMinLabel = axisModel.get(['axisLabel', 'showMinLabel'])
    const showMaxLabel = axisModel.get(['axisLabel', 'showMaxLabel']) // FIXME
    // Have not consider onBand yet, where tick els is more than label els.

    labelEls = labelEls || []
    tickEls = tickEls || []
    const firstLabel = labelEls[0]
    const nextLabel = labelEls[1]
    const lastLabel = labelEls[labelEls.length - 1]
    const prevLabel = labelEls[labelEls.length - 2]
    const firstTick = tickEls[0]
    const nextTick = tickEls[1]
    const lastTick = tickEls[tickEls.length - 1]
    const prevTick = tickEls[tickEls.length - 2]

    if (showMinLabel === false) {
      ignoreEl(firstLabel)
      ignoreEl(firstTick)
    } else if (isTwoLabelOverlapped(firstLabel, nextLabel)) {
      if (showMinLabel) {
        ignoreEl(nextLabel)
        ignoreEl(nextTick)
      } else {
        ignoreEl(firstLabel)
        ignoreEl(firstTick)
      }
    }

    if (showMaxLabel === false) {
      ignoreEl(lastLabel)
      ignoreEl(lastTick)
    } else if (isTwoLabelOverlapped(prevLabel, lastLabel)) {
      if (showMaxLabel) {
        ignoreEl(prevLabel)
        ignoreEl(prevTick)
      } else {
        ignoreEl(lastLabel)
        ignoreEl(lastTick)
      }
    }
  }

  function ignoreEl (el) {
    el && (el.ignore = true)
  }

  function isTwoLabelOverlapped (current, next) {
    // current and next has the same rotation.
    const firstRect = current && current.getBoundingRect().clone()
    const nextRect = next && next.getBoundingRect().clone()

    if (!firstRect || !nextRect) {
      return
    } // When checking intersect of two rotated labels, we use mRotationBack
    // to avoid that boundingRect is enlarge when using `boundingRect.applyTransform`.

    const mRotationBack = identity([])
    rotate(mRotationBack, mRotationBack, -current.rotation)
    firstRect.applyTransform(mul$1([], mRotationBack, current.getLocalTransform()))
    nextRect.applyTransform(mul$1([], mRotationBack, next.getLocalTransform()))
    return firstRect.intersect(nextRect)
  }

  function isNameLocationCenter (nameLocation) {
    return nameLocation === 'middle' || nameLocation === 'center'
  }

  function createTicks (ticksCoords, tickTransform, tickEndCoord, tickLineStyle, anidPrefix) {
    const tickEls = []
    const pt1 = []
    const pt2 = []

    for (let i = 0; i < ticksCoords.length; i++) {
      const tickCoord = ticksCoords[i].coord
      pt1[0] = tickCoord
      pt1[1] = 0
      pt2[0] = tickCoord
      pt2[1] = tickEndCoord

      if (tickTransform) {
        applyTransform(pt1, pt1, tickTransform)
        applyTransform(pt2, pt2, tickTransform)
      } // Tick line, Not use group transform to have better line draw

      const tickEl = new Line({
        subPixelOptimize: true,
        shape: {
          x1: pt1[0],
          y1: pt1[1],
          x2: pt2[0],
          y2: pt2[1]
        },
        style: tickLineStyle,
        z2: 2,
        autoBatch: true,
        silent: true
      })
      tickEl.anid = anidPrefix + '_' + ticksCoords[i].tickValue
      tickEls.push(tickEl)
    }

    return tickEls
  }

  function buildAxisMajorTicks (group, transformGroup, axisModel, opt) {
    const axis = axisModel.axis
    const tickModel = axisModel.getModel('axisTick')
    let shown = tickModel.get('show')

    if (shown === 'auto' && opt.handleAutoShown) {
      shown = opt.handleAutoShown('axisTick')
    }

    if (!shown || axis.scale.isBlank()) {
      return
    }

    const lineStyleModel = tickModel.getModel('lineStyle')
    const tickEndCoord = opt.tickDirection * tickModel.get('length')
    const ticksCoords = axis.getTicksCoords()
    const ticksEls = createTicks(ticksCoords, transformGroup.transform, tickEndCoord, defaults(lineStyleModel.getLineStyle(), {
      stroke: axisModel.get(['axisLine', 'lineStyle', 'color'])
    }), 'ticks')

    for (let i = 0; i < ticksEls.length; i++) {
      group.add(ticksEls[i])
    }

    return ticksEls
  }

  function buildAxisMinorTicks (group, transformGroup, axisModel, tickDirection) {
    const axis = axisModel.axis
    const minorTickModel = axisModel.getModel('minorTick')

    if (!minorTickModel.get('show') || axis.scale.isBlank()) {
      return
    }

    const minorTicksCoords = axis.getMinorTicksCoords()

    if (!minorTicksCoords.length) {
      return
    }

    const lineStyleModel = minorTickModel.getModel('lineStyle')
    const tickEndCoord = tickDirection * minorTickModel.get('length')
    const minorTickLineStyle = defaults(lineStyleModel.getLineStyle(), defaults(axisModel.getModel('axisTick').getLineStyle(), {
      stroke: axisModel.get(['axisLine', 'lineStyle', 'color'])
    }))

    for (let i = 0; i < minorTicksCoords.length; i++) {
      const minorTicksEls = createTicks(minorTicksCoords[i], transformGroup.transform, tickEndCoord, minorTickLineStyle, 'minorticks_' + i)

      for (let k = 0; k < minorTicksEls.length; k++) {
        group.add(minorTicksEls[k])
      }
    }
  }

  function buildAxisLabel (group, transformGroup, axisModel, opt) {
    const axis = axisModel.axis
    const show = retrieve(opt.axisLabelShow, axisModel.get(['axisLabel', 'show']))

    if (!show || axis.scale.isBlank()) {
      return
    }

    const labelModel = axisModel.getModel('axisLabel')
    const labelMargin = labelModel.get('margin')
    const labels = axis.getViewLabels() // Special label rotate.

    const labelRotation = (retrieve(opt.labelRotate, labelModel.get('rotate')) || 0) * PI$5 / 180
    const labelLayout = AxisBuilder.innerTextLayout(opt.rotation, labelRotation, opt.labelDirection)
    const rawCategoryData = axisModel.getCategories && axisModel.getCategories(true)
    const labelEls = []
    const silent = AxisBuilder.isLabelSilent(axisModel)
    const triggerEvent = axisModel.get('triggerEvent')
    each(labels, function (labelItem, index) {
      const tickValue = axis.scale.type === 'ordinal' ? axis.scale.getRawOrdinalNumber(labelItem.tickValue) : labelItem.tickValue
      const formattedLabel = labelItem.formattedLabel
      const rawLabel = labelItem.rawLabel
      let itemLabelModel = labelModel

      if (rawCategoryData && rawCategoryData[tickValue]) {
        const rawCategoryItem = rawCategoryData[tickValue]

        if (isObject(rawCategoryItem) && rawCategoryItem.textStyle) {
          itemLabelModel = new Model(rawCategoryItem.textStyle, labelModel, axisModel.ecModel)
        }
      }

      const textColor = itemLabelModel.getTextColor() || axisModel.get(['axisLine', 'lineStyle', 'color'])
      const tickCoord = axis.dataToCoord(tickValue)
      const textEl = new ZRText({
        x: tickCoord,
        y: opt.labelOffset + opt.labelDirection * labelMargin,
        rotation: labelLayout.rotation,
        silent: silent,
        z2: 10 + (labelItem.level || 0),
        style: createTextStyle(itemLabelModel, {
          text: formattedLabel,
          align: itemLabelModel.getShallow('align', true) || labelLayout.textAlign,
          verticalAlign: itemLabelModel.getShallow('verticalAlign', true) || itemLabelModel.getShallow('baseline', true) || labelLayout.textVerticalAlign,
          fill: isFunction(textColor) ? textColor( // (1) In category axis with data zoom, tick is not the original
            // index of axis.data. So tick should not be exposed to user
            // in category axis.
            // (2) Compatible with previous version, which always use formatted label as
            // input. But in interval scale the formatted label is like '223,445', which
            // maked user repalce ','. So we modify it to return original val but remain
            // it as 'string' to avoid error in replacing.
            axis.type === 'category' ? rawLabel : axis.type === 'value' ? tickValue + '' : tickValue, index) : textColor
        })
      })
      textEl.anid = 'label_' + tickValue // Pack data for mouse event

      if (triggerEvent) {
        const eventData = AxisBuilder.makeAxisEventDataBase(axisModel)
        eventData.targetType = 'axisLabel'
        eventData.value = rawLabel
        eventData.tickIndex = index

        if (axis.type === 'category') {
          eventData.dataIndex = tickValue
        }

        getECData(textEl).eventData = eventData
      } // FIXME

      transformGroup.add(textEl)
      textEl.updateTransform()
      labelEls.push(textEl)
      group.add(textEl)
      textEl.decomposeTransform()
    })
    return labelEls
  }

  // allAxesInfo should be updated when setOption performed.

  function collect (ecModel, api) {
    const result = {
      /**
         * key: makeKey(axis.model)
         * value: {
         *      axis,
         *      coordSys,
         *      axisPointerModel,
         *      triggerTooltip,
         *      involveSeries,
         *      snap,
         *      seriesModels,
         *      seriesDataCount
         * }
         */
      axesInfo: {},
      seriesInvolved: false,

      /**
         * key: makeKey(coordSys.model)
         * value: Object: key makeKey(axis.model), value: axisInfo
         */
      coordSysAxesInfo: {},
      coordSysMap: {}
    }
    collectAxesInfo(result, ecModel, api) // Check seriesInvolved for performance, in case too many series in some chart.

    result.seriesInvolved && collectSeriesInfo(result, ecModel)
    return result
  }

  function collectAxesInfo (result, ecModel, api) {
    const globalTooltipModel = ecModel.getComponent('tooltip')
    const globalAxisPointerModel = ecModel.getComponent('axisPointer') // links can only be set on global.

    const linksOption = globalAxisPointerModel.get('link', true) || []
    const linkGroups = [] // Collect axes info.

    each(api.getCoordinateSystems(), function (coordSys) {
      // Some coordinate system do not support axes, like geo.
      if (!coordSys.axisPointerEnabled) {
        return
      }

      const coordSysKey = makeKey(coordSys.model)
      const axesInfoInCoordSys = result.coordSysAxesInfo[coordSysKey] = {}
      result.coordSysMap[coordSysKey] = coordSys // Set tooltip (like 'cross') is a convienent way to show axisPointer
      // for user. So we enable seting tooltip on coordSys model.

      const coordSysModel = coordSys.model
      const baseTooltipModel = coordSysModel.getModel('tooltip', globalTooltipModel)
      each(coordSys.getAxes(), curry(saveTooltipAxisInfo, false, null)) // If axis tooltip used, choose tooltip axis for each coordSys.
      // Notice this case: coordSys is `grid` but not `cartesian2D` here.

      if (coordSys.getTooltipAxes && globalTooltipModel && // If tooltip.showContent is set as false, tooltip will not
        // show but axisPointer will show as normal.
        baseTooltipModel.get('show')) {
        // Compatible with previous logic. But series.tooltip.trigger: 'axis'
        // or series.data[n].tooltip.trigger: 'axis' are not support any more.
        const triggerAxis = baseTooltipModel.get('trigger') === 'axis'
        const cross = baseTooltipModel.get(['axisPointer', 'type']) === 'cross'
        const tooltipAxes = coordSys.getTooltipAxes(baseTooltipModel.get(['axisPointer', 'axis']))

        if (triggerAxis || cross) {
          each(tooltipAxes.baseAxes, curry(saveTooltipAxisInfo, cross ? 'cross' : true, triggerAxis))
        }

        if (cross) {
          each(tooltipAxes.otherAxes, curry(saveTooltipAxisInfo, 'cross', false))
        }
      } // fromTooltip: true | false | 'cross'
      // triggerTooltip: true | false | null

      function saveTooltipAxisInfo (fromTooltip, triggerTooltip, axis) {
        let axisPointerModel = axis.model.getModel('axisPointer', globalAxisPointerModel)
        const axisPointerShow = axisPointerModel.get('show')

        if (!axisPointerShow || axisPointerShow === 'auto' && !fromTooltip && !isHandleTrigger(axisPointerModel)) {
          return
        }

        if (triggerTooltip == null) {
          triggerTooltip = axisPointerModel.get('triggerTooltip')
        }

        axisPointerModel = fromTooltip ? makeAxisPointerModel(axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) : axisPointerModel
        const snap = axisPointerModel.get('snap')
        const axisKey = makeKey(axis.model)
        const involveSeries = triggerTooltip || snap || axis.type === 'category' // If result.axesInfo[key] exist, override it (tooltip has higher priority).

        const axisInfo = result.axesInfo[axisKey] = {
          key: axisKey,
          axis: axis,
          coordSys: coordSys,
          axisPointerModel: axisPointerModel,
          triggerTooltip: triggerTooltip,
          involveSeries: involveSeries,
          snap: snap,
          useHandle: isHandleTrigger(axisPointerModel),
          seriesModels: [],
          linkGroup: null
        }
        axesInfoInCoordSys[axisKey] = axisInfo
        result.seriesInvolved = result.seriesInvolved || involveSeries
        const groupIndex = getLinkGroupIndex(linksOption, axis)

        if (groupIndex != null) {
          const linkGroup = linkGroups[groupIndex] || (linkGroups[groupIndex] = {
            axesInfo: {}
          })
          linkGroup.axesInfo[axisKey] = axisInfo
          linkGroup.mapper = linksOption[groupIndex].mapper
          axisInfo.linkGroup = linkGroup
        }
      }
    })
  }

  function makeAxisPointerModel (axis, baseTooltipModel, globalAxisPointerModel, ecModel, fromTooltip, triggerTooltip) {
    const tooltipAxisPointerModel = baseTooltipModel.getModel('axisPointer')
    const fields = ['type', 'snap', 'lineStyle', 'shadowStyle', 'label', 'animation', 'animationDurationUpdate', 'animationEasingUpdate', 'z']
    const volatileOption = {}
    each(fields, function (field) {
      volatileOption[field] = clone(tooltipAxisPointerModel.get(field))
    }) // category axis do not auto snap, otherwise some tick that do not
    // has value can not be hovered. value/time/log axis default snap if
    // triggered from tooltip and trigger tooltip.

    volatileOption.snap = axis.type !== 'category' && !!triggerTooltip // Compatibel with previous behavior, tooltip axis do not show label by default.
    // Only these properties can be overrided from tooltip to axisPointer.

    if (tooltipAxisPointerModel.get('type') === 'cross') {
      volatileOption.type = 'line'
    }

    const labelOption = volatileOption.label || (volatileOption.label = {}) // Follow the convention, do not show label when triggered by tooltip by default.

    labelOption.show == null && (labelOption.show = false)

    if (fromTooltip === 'cross') {
      // When 'cross', both axes show labels.
      const tooltipAxisPointerLabelShow = tooltipAxisPointerModel.get(['label', 'show'])
      labelOption.show = tooltipAxisPointerLabelShow != null ? tooltipAxisPointerLabelShow : true // If triggerTooltip, this is a base axis, which should better not use cross style
      // (cross style is dashed by default)

      if (!triggerTooltip) {
        const crossStyle = volatileOption.lineStyle = tooltipAxisPointerModel.get('crossStyle')
        crossStyle && defaults(labelOption, crossStyle.textStyle)
      }
    }

    return axis.model.getModel('axisPointer', new Model(volatileOption, globalAxisPointerModel, ecModel))
  }

  function collectSeriesInfo (result, ecModel) {
    // Prepare data for axis trigger
    ecModel.eachSeries(function (seriesModel) {
      // Notice this case: this coordSys is `cartesian2D` but not `grid`.
      const coordSys = seriesModel.coordinateSystem
      const seriesTooltipTrigger = seriesModel.get(['tooltip', 'trigger'], true)
      const seriesTooltipShow = seriesModel.get(['tooltip', 'show'], true)

      if (!coordSys || seriesTooltipTrigger === 'none' || seriesTooltipTrigger === false || seriesTooltipTrigger === 'item' || seriesTooltipShow === false || seriesModel.get(['axisPointer', 'show'], true) === false) {
        return
      }

      each(result.coordSysAxesInfo[makeKey(coordSys.model)], function (axisInfo) {
        const axis = axisInfo.axis

        if (coordSys.getAxis(axis.dim) === axis) {
          axisInfo.seriesModels.push(seriesModel)
          axisInfo.seriesDataCount == null && (axisInfo.seriesDataCount = 0)
          axisInfo.seriesDataCount += seriesModel.getData().count()
        }
      })
    })
  }
  /**
     * For example:
     * {
     *     axisPointer: {
     *         links: [{
     *             xAxisIndex: [2, 4],
     *             yAxisIndex: 'all'
     *         }, {
     *             xAxisId: ['a5', 'a7'],
     *             xAxisName: 'xxx'
     *         }]
     *     }
     * }
     */

  function getLinkGroupIndex (linksOption, axis) {
    const axisModel = axis.model
    const dim = axis.dim

    for (let i = 0; i < linksOption.length; i++) {
      const linkOption = linksOption[i] || {}

      if (checkPropInLink(linkOption[dim + 'AxisId'], axisModel.id) || checkPropInLink(linkOption[dim + 'AxisIndex'], axisModel.componentIndex) || checkPropInLink(linkOption[dim + 'AxisName'], axisModel.name)) {
        return i
      }
    }
  }

  function checkPropInLink (linkPropValue, axisPropValue) {
    return linkPropValue === 'all' || isArray(linkPropValue) && indexOf(linkPropValue, axisPropValue) >= 0 || linkPropValue === axisPropValue
  }

  function fixValue (axisModel) {
    const axisInfo = getAxisInfo(axisModel)

    if (!axisInfo) {
      return
    }

    const axisPointerModel = axisInfo.axisPointerModel
    const scale = axisInfo.axis.scale
    const option = axisPointerModel.option
    const status = axisPointerModel.get('status')
    let value = axisPointerModel.get('value') // Parse init value for category and time axis.

    if (value != null) {
      value = scale.parse(value)
    }

    const useHandle = isHandleTrigger(axisPointerModel) // If `handle` used, `axisPointer` will always be displayed, so value
    // and status should be initialized.

    if (status == null) {
      option.status = useHandle ? 'show' : 'hide'
    }

    const extent = scale.getExtent().slice()
    extent[0] > extent[1] && extent.reverse()

    if ( // Pick a value on axis when initializing.
      value == null || // If both `handle` and `dataZoom` are used, value may be out of axis extent,
      // where we should re-pick a value to keep `handle` displaying normally.
      value > extent[1]) {
      // Make handle displayed on the end of the axis when init, which looks better.
      value = extent[1]
    }

    if (value < extent[0]) {
      value = extent[0]
    }

    option.value = value

    if (useHandle) {
      option.status = axisInfo.axis.scale.isBlank() ? 'hide' : 'show'
    }
  }
  function getAxisInfo (axisModel) {
    const coordSysAxesInfo = (axisModel.ecModel.getComponent('axisPointer') || {}).coordSysAxesInfo
    return coordSysAxesInfo && coordSysAxesInfo.axesInfo[makeKey(axisModel)]
  }
  function getAxisPointerModel (axisModel) {
    const axisInfo = getAxisInfo(axisModel)
    return axisInfo && axisInfo.axisPointerModel
  }

  function isHandleTrigger (axisPointerModel) {
    return !!axisPointerModel.get(['handle', 'show'])
  }
  /**
     * @param {module:echarts/model/Model} model
     * @return {string} unique key
     */

  function makeKey (model) {
    return model.type + '||' + model.id
  }

  const axisPointerClazz = {}
  /**
     * Base class of AxisView.
     */

  const AxisView =
    /** @class */
    (function (_super) {
      __extends(AxisView, _super)

      function AxisView () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = AxisView.type
        return _this
      }
      /**
       * @override
       */

      AxisView.prototype.render = function (axisModel, ecModel, api, payload) {
        // FIXME
        // This process should proformed after coordinate systems updated
        // (axis scale updated), and should be performed each time update.
        // So put it here temporarily, although it is not appropriate to
        // put a model-writing procedure in `view`.
        this.axisPointerClass && fixValue(axisModel)

        _super.prototype.render.apply(this, arguments)

        this._doUpdateAxisPointerClass(axisModel, api, true)
      }
      /**
       * Action handler.
       */

      AxisView.prototype.updateAxisPointer = function (axisModel, ecModel, api, payload) {
        this._doUpdateAxisPointerClass(axisModel, api, false)
      }
      /**
       * @override
       */

      AxisView.prototype.remove = function (ecModel, api) {
        const axisPointer = this._axisPointer
        axisPointer && axisPointer.remove(api)
      }
      /**
       * @override
       */

      AxisView.prototype.dispose = function (ecModel, api) {
        this._disposeAxisPointer(api)

        _super.prototype.dispose.apply(this, arguments)
      }

      AxisView.prototype._doUpdateAxisPointerClass = function (axisModel, api, forceRender) {
        const Clazz = AxisView.getAxisPointerClass(this.axisPointerClass)

        if (!Clazz) {
          return
        }

        const axisPointerModel = getAxisPointerModel(axisModel)
        axisPointerModel ? (this._axisPointer || (this._axisPointer = new Clazz())).render(axisModel, axisPointerModel, api, forceRender) : this._disposeAxisPointer(api)
      }

      AxisView.prototype._disposeAxisPointer = function (api) {
        this._axisPointer && this._axisPointer.dispose(api)
        this._axisPointer = null
      }

      AxisView.registerAxisPointerClass = function (type, clazz) {
        if ('development' !== 'production') {
          if (axisPointerClazz[type]) {
            throw new Error('axisPointer ' + type + ' exists')
          }
        }

        axisPointerClazz[type] = clazz
      }

      AxisView.getAxisPointerClass = function (type) {
        return type && axisPointerClazz[type]
      }
      AxisView.type = 'axis'
      return AxisView
    }(ComponentView))

  const inner$6 = makeInner()
  function rectCoordAxisBuildSplitArea (axisView, axisGroup, axisModel, gridModel) {
    const axis = axisModel.axis

    if (axis.scale.isBlank()) {
      return
    } // TODO: TYPE

    const splitAreaModel = axisModel.getModel('splitArea')
    const areaStyleModel = splitAreaModel.getModel('areaStyle')
    let areaColors = areaStyleModel.get('color')
    const gridRect = gridModel.coordinateSystem.getRect()
    const ticksCoords = axis.getTicksCoords({
      tickModel: splitAreaModel,
      clamp: true
    })

    if (!ticksCoords.length) {
      return
    } // For Making appropriate splitArea animation, the color and anid
    // should be corresponding to previous one if possible.

    const areaColorsLen = areaColors.length
    const lastSplitAreaColors = inner$6(axisView).splitAreaColors
    const newSplitAreaColors = createHashMap()
    let colorIndex = 0

    if (lastSplitAreaColors) {
      for (var i = 0; i < ticksCoords.length; i++) {
        const cIndex = lastSplitAreaColors.get(ticksCoords[i].tickValue)

        if (cIndex != null) {
          colorIndex = (cIndex + (areaColorsLen - 1) * i) % areaColorsLen
          break
        }
      }
    }

    let prev = axis.toGlobalCoord(ticksCoords[0].coord)
    const areaStyle = areaStyleModel.getAreaStyle()
    areaColors = isArray(areaColors) ? areaColors : [areaColors]

    for (var i = 1; i < ticksCoords.length; i++) {
      const tickCoord = axis.toGlobalCoord(ticksCoords[i].coord)
      let x = void 0
      let y = void 0
      let width = void 0
      let height = void 0

      if (axis.isHorizontal()) {
        x = prev
        y = gridRect.y
        width = tickCoord - x
        height = gridRect.height
        prev = x + width
      } else {
        x = gridRect.x
        y = prev
        width = gridRect.width
        height = tickCoord - y
        prev = y + height
      }

      const tickValue = ticksCoords[i - 1].tickValue
      tickValue != null && newSplitAreaColors.set(tickValue, colorIndex)
      axisGroup.add(new Rect({
        anid: tickValue != null ? 'area_' + tickValue : null,
        shape: {
          x: x,
          y: y,
          width: width,
          height: height
        },
        style: defaults({
          fill: areaColors[colorIndex]
        }, areaStyle),
        autoBatch: true,
        silent: true
      }))
      colorIndex = (colorIndex + 1) % areaColorsLen
    }

    inner$6(axisView).splitAreaColors = newSplitAreaColors
  }
  function rectCoordAxisHandleRemove (axisView) {
    inner$6(axisView).splitAreaColors = null
  }

  const axisBuilderAttrs = ['axisLine', 'axisTickLabel', 'axisName']
  const selfBuilderAttrs = ['splitArea', 'splitLine', 'minorSplitLine']

  const CartesianAxisView =
    /** @class */
    (function (_super) {
      __extends(CartesianAxisView, _super)

      function CartesianAxisView () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = CartesianAxisView.type
        _this.axisPointerClass = 'CartesianAxisPointer'
        return _this
      }
      /**
       * @override
       */

      CartesianAxisView.prototype.render = function (axisModel, ecModel, api, payload) {
        this.group.removeAll()
        const oldAxisGroup = this._axisGroup
        this._axisGroup = new Group()
        this.group.add(this._axisGroup)

        if (!axisModel.get('show')) {
          return
        }

        const gridModel = axisModel.getCoordSysModel()
        const layout = layout$1(gridModel, axisModel)
        const axisBuilder = new AxisBuilder(axisModel, extend({
          handleAutoShown: function (elementType) {
            const cartesians = gridModel.coordinateSystem.getCartesians()

            for (let i = 0; i < cartesians.length; i++) {
              if (isIntervalOrLogScale(cartesians[i].getOtherAxis(axisModel.axis).scale)) {
                // Still show axis tick or axisLine if other axis is value / log
                return true
              }
            } // Not show axisTick or axisLine if other axis is category / time

            return false
          }
        }, layout))
        each(axisBuilderAttrs, axisBuilder.add, axisBuilder)

        this._axisGroup.add(axisBuilder.getGroup())

        each(selfBuilderAttrs, function (name) {
          if (axisModel.get([name, 'show'])) {
            axisElementBuilders[name](this, this._axisGroup, axisModel, gridModel)
          }
        }, this) // THIS is a special case for bar racing chart.
        // Update the axis label from the natural initial layout to
        // sorted layout should has no animation.

        const isInitialSortFromBarRacing = payload && payload.type === 'changeAxisOrder' && payload.isInitSort

        if (!isInitialSortFromBarRacing) {
          groupTransition(oldAxisGroup, this._axisGroup, axisModel)
        }

        _super.prototype.render.call(this, axisModel, ecModel, api, payload)
      }

      CartesianAxisView.prototype.remove = function () {
        rectCoordAxisHandleRemove(this)
      }

      CartesianAxisView.type = 'cartesianAxis'
      return CartesianAxisView
    }(AxisView))

  var axisElementBuilders = {
    splitLine: function (axisView, axisGroup, axisModel, gridModel) {
      const axis = axisModel.axis

      if (axis.scale.isBlank()) {
        return
      }

      const splitLineModel = axisModel.getModel('splitLine')
      const lineStyleModel = splitLineModel.getModel('lineStyle')
      let lineColors = lineStyleModel.get('color')
      lineColors = isArray(lineColors) ? lineColors : [lineColors]
      const gridRect = gridModel.coordinateSystem.getRect()
      const isHorizontal = axis.isHorizontal()
      let lineCount = 0
      const ticksCoords = axis.getTicksCoords({
        tickModel: splitLineModel
      })
      const p1 = []
      const p2 = []
      const lineStyle = lineStyleModel.getLineStyle()

      for (let i = 0; i < ticksCoords.length; i++) {
        const tickCoord = axis.toGlobalCoord(ticksCoords[i].coord)

        if (isHorizontal) {
          p1[0] = tickCoord
          p1[1] = gridRect.y
          p2[0] = tickCoord
          p2[1] = gridRect.y + gridRect.height
        } else {
          p1[0] = gridRect.x
          p1[1] = tickCoord
          p2[0] = gridRect.x + gridRect.width
          p2[1] = tickCoord
        }

        const colorIndex = lineCount++ % lineColors.length
        const tickValue = ticksCoords[i].tickValue
        axisGroup.add(new Line({
          anid: tickValue != null ? 'line_' + ticksCoords[i].tickValue : null,
          subPixelOptimize: true,
          autoBatch: true,
          shape: {
            x1: p1[0],
            y1: p1[1],
            x2: p2[0],
            y2: p2[1]
          },
          style: defaults({
            stroke: lineColors[colorIndex]
          }, lineStyle),
          silent: true
        }))
      }
    },
    minorSplitLine: function (axisView, axisGroup, axisModel, gridModel) {
      const axis = axisModel.axis
      const minorSplitLineModel = axisModel.getModel('minorSplitLine')
      const lineStyleModel = minorSplitLineModel.getModel('lineStyle')
      const gridRect = gridModel.coordinateSystem.getRect()
      const isHorizontal = axis.isHorizontal()
      const minorTicksCoords = axis.getMinorTicksCoords()

      if (!minorTicksCoords.length) {
        return
      }

      const p1 = []
      const p2 = []
      const lineStyle = lineStyleModel.getLineStyle()

      for (let i = 0; i < minorTicksCoords.length; i++) {
        for (let k = 0; k < minorTicksCoords[i].length; k++) {
          const tickCoord = axis.toGlobalCoord(minorTicksCoords[i][k].coord)

          if (isHorizontal) {
            p1[0] = tickCoord
            p1[1] = gridRect.y
            p2[0] = tickCoord
            p2[1] = gridRect.y + gridRect.height
          } else {
            p1[0] = gridRect.x
            p1[1] = tickCoord
            p2[0] = gridRect.x + gridRect.width
            p2[1] = tickCoord
          }

          axisGroup.add(new Line({
            anid: 'minor_line_' + minorTicksCoords[i][k].tickValue,
            subPixelOptimize: true,
            autoBatch: true,
            shape: {
              x1: p1[0],
              y1: p1[1],
              x2: p2[0],
              y2: p2[1]
            },
            style: lineStyle,
            silent: true
          }))
        }
      }
    },
    splitArea: function (axisView, axisGroup, axisModel, gridModel) {
      rectCoordAxisBuildSplitArea(axisView, axisGroup, axisModel, gridModel)
    }
  }

  const CartesianXAxisView =
    /** @class */
    (function (_super) {
      __extends(CartesianXAxisView, _super)

      function CartesianXAxisView () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = CartesianXAxisView.type
        return _this
      }

      CartesianXAxisView.type = 'xAxis'
      return CartesianXAxisView
    }(CartesianAxisView))

  const CartesianYAxisView =
    /** @class */
    (function (_super) {
      __extends(CartesianYAxisView, _super)

      function CartesianYAxisView () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = CartesianXAxisView.type
        return _this
      }

      CartesianYAxisView.type = 'yAxis'
      return CartesianYAxisView
    }(CartesianAxisView))

  const GridView =
    /** @class */
    (function (_super) {
      __extends(GridView, _super)

      function GridView () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = 'grid'
        return _this
      }

      GridView.prototype.render = function (gridModel, ecModel) {
        this.group.removeAll()

        if (gridModel.get('show')) {
          this.group.add(new Rect({
            shape: gridModel.coordinateSystem.getRect(),
            style: defaults({
              fill: gridModel.get('backgroundColor')
            }, gridModel.getItemStyle()),
            silent: true,
            z2: -1
          }))
        }
      }

      GridView.type = 'grid'
      return GridView
    }(ComponentView))

  const extraOption = {
    // gridIndex: 0,
    // gridId: '',
    offset: 0
  }
  function install$5 (registers) {
    registers.registerComponentView(GridView)
    registers.registerComponentModel(GridModel)
    registers.registerCoordinateSystem('cartesian2d', Grid)
    axisModelCreator(registers, 'x', CartesianAxisModel, extraOption)
    axisModelCreator(registers, 'y', CartesianAxisModel, extraOption)
    registers.registerComponentView(CartesianXAxisView)
    registers.registerComponentView(CartesianYAxisView)
    registers.registerPreprocessor(function (option) {
      // Only create grid when need
      if (option.xAxis && option.yAxis && !option.grid) {
        option.grid = {}
      }
    })
  }

  function install$6 (registers) {
    // In case developer forget to include grid component
    use(install$5)
    registers.registerSeriesModel(ScatterSeriesModel)
    registers.registerChartView(ScatterView)
    registers.registerLayout(pointsLayout('scatter'))
  }

  function radarLayout (ecModel) {
    ecModel.eachSeriesByType('radar', function (seriesModel) {
      const data = seriesModel.getData()
      const points = []
      const coordSys = seriesModel.coordinateSystem

      if (!coordSys) {
        return
      }

      const axes = coordSys.getIndicatorAxes()
      each(axes, function (axis, axisIndex) {
        data.each(data.mapDimension(axes[axisIndex].dim), function (val, dataIndex) {
          points[dataIndex] = points[dataIndex] || []
          const point = coordSys.dataToPoint(val, axisIndex)
          points[dataIndex][axisIndex] = isValidPoint(point) ? point : getValueMissingPoint(coordSys)
        })
      }) // Close polygon

      data.each(function (idx) {
        // TODO
        // Is it appropriate to connect to the next data when some data is missing?
        // Or, should trade it like `connectNull` in line chart?
        const firstPoint = find(points[idx], function (point) {
          return isValidPoint(point)
        }) || getValueMissingPoint(coordSys) // Copy the first actual point to the end of the array

        points[idx].push(firstPoint.slice())
        data.setItemLayout(idx, points[idx])
      })
    })
  }

  function isValidPoint (point) {
    return !isNaN(point[0]) && !isNaN(point[1])
  }

  function getValueMissingPoint (coordSys) {
    // It is error-prone to input [NaN, NaN] into polygon, polygon.
    // (probably cause problem when refreshing or animating)
    return [coordSys.cx, coordSys.cy]
  }

  function radarBackwardCompat (option) {
    let polarOptArr = option.polar

    if (polarOptArr) {
      if (!isArray(polarOptArr)) {
        polarOptArr = [polarOptArr]
      }

      const polarNotRadar_1 = []
      each(polarOptArr, function (polarOpt, idx) {
        if (polarOpt.indicator) {
          if (polarOpt.type && !polarOpt.shape) {
            polarOpt.shape = polarOpt.type
          }

          option.radar = option.radar || []

          if (!isArray(option.radar)) {
            option.radar = [option.radar]
          }

          option.radar.push(polarOpt)
        } else {
          polarNotRadar_1.push(polarOpt)
        }
      })
      option.polar = polarNotRadar_1
    }

    each(option.series, function (seriesOpt) {
      if (seriesOpt && seriesOpt.type === 'radar' && seriesOpt.polarIndex) {
        seriesOpt.radarIndex = seriesOpt.polarIndex
      }
    })
  }

  const RadarView =
    /** @class */
    (function (_super) {
      __extends(RadarView, _super)

      function RadarView () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = RadarView.type
        return _this
      }

      RadarView.prototype.render = function (seriesModel, ecModel, api) {
        const polar = seriesModel.coordinateSystem
        const group = this.group
        const data = seriesModel.getData()
        const oldData = this._data

        function createSymbol$1 (data, idx) {
          const symbolType = data.getItemVisual(idx, 'symbol') || 'circle'

          if (symbolType === 'none') {
            return
          }

          const symbolSize = normalizeSymbolSize(data.getItemVisual(idx, 'symbolSize'))
          const symbolPath = createSymbol(symbolType, -1, -1, 2, 2)
          const symbolRotate = data.getItemVisual(idx, 'symbolRotate') || 0
          symbolPath.attr({
            style: {
              strokeNoScale: true
            },
            z2: 100,
            scaleX: symbolSize[0] / 2,
            scaleY: symbolSize[1] / 2,
            rotation: symbolRotate * Math.PI / 180 || 0
          })
          return symbolPath
        }

        function updateSymbols (oldPoints, newPoints, symbolGroup, data, idx, isInit) {
          // Simply rerender all
          symbolGroup.removeAll()

          for (let i = 0; i < newPoints.length - 1; i++) {
            const symbolPath = createSymbol$1(data, idx)

            if (symbolPath) {
              symbolPath.__dimIdx = i

              if (oldPoints[i]) {
                symbolPath.setPosition(oldPoints[i])
                graphic[isInit ? 'initProps' : 'updateProps'](symbolPath, {
                  x: newPoints[i][0],
                  y: newPoints[i][1]
                }, seriesModel, idx)
              } else {
                symbolPath.setPosition(newPoints[i])
              }

              symbolGroup.add(symbolPath)
            }
          }
        }

        function getInitialPoints (points) {
          return map(points, function (pt) {
            return [polar.cx, polar.cy]
          })
        }

        data.diff(oldData).add(function (idx) {
          const points = data.getItemLayout(idx)

          if (!points) {
            return
          }

          const polygon = new Polygon()
          const polyline = new Polyline()
          const target = {
            shape: {
              points: points
            }
          }
          polygon.shape.points = getInitialPoints(points)
          polyline.shape.points = getInitialPoints(points)
          initProps(polygon, target, seriesModel, idx)
          initProps(polyline, target, seriesModel, idx)
          const itemGroup = new Group()
          const symbolGroup = new Group()
          itemGroup.add(polyline)
          itemGroup.add(polygon)
          itemGroup.add(symbolGroup)
          updateSymbols(polyline.shape.points, points, symbolGroup, data, idx, true)
          data.setItemGraphicEl(idx, itemGroup)
        }).update(function (newIdx, oldIdx) {
          const itemGroup = oldData.getItemGraphicEl(oldIdx)
          const polyline = itemGroup.childAt(0)
          const polygon = itemGroup.childAt(1)
          const symbolGroup = itemGroup.childAt(2)
          const target = {
            shape: {
              points: data.getItemLayout(newIdx)
            }
          }

          if (!target.shape.points) {
            return
          }

          updateSymbols(polyline.shape.points, target.shape.points, symbolGroup, data, newIdx, false)
          saveOldStyle(polygon)
          saveOldStyle(polyline)
          updateProps(polyline, target, seriesModel)
          updateProps(polygon, target, seriesModel)
          data.setItemGraphicEl(newIdx, itemGroup)
        }).remove(function (idx) {
          group.remove(oldData.getItemGraphicEl(idx))
        }).execute()
        data.eachItemGraphicEl(function (itemGroup, idx) {
          const itemModel = data.getItemModel(idx)
          const polyline = itemGroup.childAt(0)
          const polygon = itemGroup.childAt(1)
          const symbolGroup = itemGroup.childAt(2) // Radar uses the visual encoded from itemStyle.

          const itemStyle = data.getItemVisual(idx, 'style')
          const color = itemStyle.fill
          group.add(itemGroup)
          polyline.useStyle(defaults(itemModel.getModel('lineStyle').getLineStyle(), {
            fill: 'none',
            stroke: color
          }))
          setStatesStylesFromModel(polyline, itemModel, 'lineStyle')
          setStatesStylesFromModel(polygon, itemModel, 'areaStyle')
          const areaStyleModel = itemModel.getModel('areaStyle')
          const polygonIgnore = areaStyleModel.isEmpty() && areaStyleModel.parentModel.isEmpty()
          polygon.ignore = polygonIgnore
          each(['emphasis', 'select', 'blur'], function (stateName) {
            const stateModel = itemModel.getModel([stateName, 'areaStyle'])
            const stateIgnore = stateModel.isEmpty() && stateModel.parentModel.isEmpty() // Won't be ignore if normal state is not ignore.

            polygon.ensureState(stateName).ignore = stateIgnore && polygonIgnore
          })
          polygon.useStyle(defaults(areaStyleModel.getAreaStyle(), {
            fill: color,
            opacity: 0.7,
            decal: itemStyle.decal
          }))
          const emphasisModel = itemModel.getModel('emphasis')
          const itemHoverStyle = emphasisModel.getModel('itemStyle').getItemStyle()
          symbolGroup.eachChild(function (symbolPath) {
            if (symbolPath instanceof ZRImage) {
              const pathStyle = symbolPath.style
              symbolPath.useStyle(extend({
                // TODO other properties like x, y ?
                image: pathStyle.image,
                x: pathStyle.x,
                y: pathStyle.y,
                width: pathStyle.width,
                height: pathStyle.height
              }, itemStyle))
            } else {
              symbolPath.useStyle(itemStyle)
              symbolPath.setColor(color)
              symbolPath.style.strokeNoScale = true
            }

            const pathEmphasisState = symbolPath.ensureState('emphasis')
            pathEmphasisState.style = clone(itemHoverStyle)
            let defaultText = data.getStore().get(data.getDimensionIndex(symbolPath.__dimIdx), idx);
            (defaultText == null || isNaN(defaultText)) && (defaultText = '')
            setLabelStyle(symbolPath, getLabelStatesModels(itemModel), {
              labelFetcher: data.hostModel,
              labelDataIndex: idx,
              labelDimIndex: symbolPath.__dimIdx,
              defaultText: defaultText,
              inheritColor: color,
              defaultOpacity: itemStyle.opacity
            })
          })
          toggleHoverEmphasis(itemGroup, emphasisModel.get('focus'), emphasisModel.get('blurScope'), emphasisModel.get('disabled'))
        })
        this._data = data
      }

      RadarView.prototype.remove = function () {
        this.group.removeAll()
        this._data = null
      }

      RadarView.type = 'radar'
      return RadarView
    }(ChartView))

  const RadarSeriesModel =
    /** @class */
    (function (_super) {
      __extends(RadarSeriesModel, _super)

      function RadarSeriesModel () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = RadarSeriesModel.type
        _this.hasSymbolVisual = true
        return _this
      } // Overwrite

      RadarSeriesModel.prototype.init = function (option) {
        _super.prototype.init.apply(this, arguments) // Enable legend selection for each data item
        // Use a function instead of direct access because data reference may changed

        this.legendVisualProvider = new LegendVisualProvider(bind(this.getData, this), bind(this.getRawData, this))
      }

      RadarSeriesModel.prototype.getInitialData = function (option, ecModel) {
        return createSeriesDataSimply(this, {
          generateCoord: 'indicator_',
          generateCoordCount: Infinity
        })
      }

      RadarSeriesModel.prototype.formatTooltip = function (dataIndex, multipleSeries, dataType) {
        const data = this.getData()
        const coordSys = this.coordinateSystem
        const indicatorAxes = coordSys.getIndicatorAxes()
        const name = this.getData().getName(dataIndex)
        const nameToDisplay = name === '' ? this.name : name
        const markerColor = retrieveVisualColorForTooltipMarker(this, dataIndex)
        return createTooltipMarkup('section', {
          header: nameToDisplay,
          sortBlocks: true,
          blocks: map(indicatorAxes, function (axis) {
            const val = data.get(data.mapDimension(axis.dim), dataIndex)
            return createTooltipMarkup('nameValue', {
              markerType: 'subItem',
              markerColor: markerColor,
              name: axis.name,
              value: val,
              sortParam: val
            })
          })
        })
      }

      RadarSeriesModel.prototype.getTooltipPosition = function (dataIndex) {
        if (dataIndex != null) {
          const data_1 = this.getData()
          const coordSys = this.coordinateSystem
          const values = data_1.getValues(map(coordSys.dimensions, function (dim) {
            return data_1.mapDimension(dim)
          }), dataIndex)

          for (let i = 0, len = values.length; i < len; i++) {
            if (!isNaN(values[i])) {
              const indicatorAxes = coordSys.getIndicatorAxes()
              return coordSys.coordToPoint(indicatorAxes[i].dataToCoord(values[i]), i)
            }
          }
        }
      }

      RadarSeriesModel.type = 'series.radar'
      RadarSeriesModel.dependencies = ['radar']
      RadarSeriesModel.defaultOption = {
        // zlevel: 0,
        z: 2,
        colorBy: 'data',
        coordinateSystem: 'radar',
        legendHoverLink: true,
        radarIndex: 0,
        lineStyle: {
          width: 2,
          type: 'solid',
          join: 'round'
        },
        label: {
          position: 'top'
        },
        // areaStyle: {
        // },
        // itemStyle: {}
        symbolSize: 8 // symbolRotate: null

      }
      return RadarSeriesModel
    }(SeriesModel))

  const valueAxisDefault = axisDefault.value

  function defaultsShow (opt, show) {
    return defaults({
      show: show
    }, opt)
  }

  const RadarModel =
    /** @class */
    (function (_super) {
      __extends(RadarModel, _super)

      function RadarModel () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = RadarModel.type
        return _this
      }

      RadarModel.prototype.optionUpdated = function () {
        const boundaryGap = this.get('boundaryGap')
        const splitNumber = this.get('splitNumber')
        const scale = this.get('scale')
        const axisLine = this.get('axisLine')
        const axisTick = this.get('axisTick') // let axisType = this.get('axisType');

        const axisLabel = this.get('axisLabel')
        const nameTextStyle = this.get('axisName')
        const showName = this.get(['axisName', 'show'])
        const nameFormatter = this.get(['axisName', 'formatter'])
        const nameGap = this.get('axisNameGap')
        const triggerEvent = this.get('triggerEvent')
        const indicatorModels = map(this.get('indicator') || [], function (indicatorOpt) {
          // PENDING
          if (indicatorOpt.max != null && indicatorOpt.max > 0 && !indicatorOpt.min) {
            indicatorOpt.min = 0
          } else if (indicatorOpt.min != null && indicatorOpt.min < 0 && !indicatorOpt.max) {
            indicatorOpt.max = 0
          }

          let iNameTextStyle = nameTextStyle

          if (indicatorOpt.color != null) {
            iNameTextStyle = defaults({
              color: indicatorOpt.color
            }, nameTextStyle)
          } // Use same configuration

          const innerIndicatorOpt = merge(clone(indicatorOpt), {
            boundaryGap: boundaryGap,
            splitNumber: splitNumber,
            scale: scale,
            axisLine: axisLine,
            axisTick: axisTick,
            // axisType: axisType,
            axisLabel: axisLabel,
            // Compatible with 2 and use text
            name: indicatorOpt.text,
            showName: showName,
            nameLocation: 'end',
            nameGap: nameGap,
            // min: 0,
            nameTextStyle: iNameTextStyle,
            triggerEvent: triggerEvent
          }, false)

          if (isString(nameFormatter)) {
            const indName = innerIndicatorOpt.name
            innerIndicatorOpt.name = nameFormatter.replace('{value}', indName != null ? indName : '')
          } else if (isFunction(nameFormatter)) {
            innerIndicatorOpt.name = nameFormatter(innerIndicatorOpt.name, innerIndicatorOpt)
          }

          const model = new Model(innerIndicatorOpt, null, this.ecModel)
          mixin(model, AxisModelCommonMixin.prototype) // For triggerEvent.

          model.mainType = 'radar'
          model.componentIndex = this.componentIndex
          return model
        }, this)
        this._indicatorModels = indicatorModels
      }

      RadarModel.prototype.getIndicatorModels = function () {
        return this._indicatorModels
      }

      RadarModel.type = 'radar'
      RadarModel.defaultOption = {
        // zlevel: 0,
        z: 0,
        center: ['50%', '50%'],
        radius: '75%',
        startAngle: 90,
        axisName: {
          show: true // formatter: null
          // textStyle: {}

        },
        boundaryGap: [0, 0],
        splitNumber: 5,
        axisNameGap: 15,
        scale: false,
        // Polygon or circle
        shape: 'polygon',
        axisLine: merge({
          lineStyle: {
            color: '#bbb'
          }
        }, valueAxisDefault.axisLine),
        axisLabel: defaultsShow(valueAxisDefault.axisLabel, false),
        axisTick: defaultsShow(valueAxisDefault.axisTick, false),
        // axisType: 'value',
        splitLine: defaultsShow(valueAxisDefault.splitLine, true),
        splitArea: defaultsShow(valueAxisDefault.splitArea, true),
        // {text, min, max}
        indicator: []
      }
      return RadarModel
    }(ComponentModel))

  const axisBuilderAttrs$1 = ['axisLine', 'axisTickLabel', 'axisName']

  const RadarView$1 =
    /** @class */
    (function (_super) {
      __extends(RadarView, _super)

      function RadarView () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = RadarView.type
        return _this
      }

      RadarView.prototype.render = function (radarModel, ecModel, api) {
        const group = this.group
        group.removeAll()

        this._buildAxes(radarModel)

        this._buildSplitLineAndArea(radarModel)
      }

      RadarView.prototype._buildAxes = function (radarModel) {
        const radar = radarModel.coordinateSystem
        const indicatorAxes = radar.getIndicatorAxes()
        const axisBuilders = map(indicatorAxes, function (indicatorAxis) {
          const axisName = indicatorAxis.model.get('showName') ? indicatorAxis.name : '' // hide name

          const axisBuilder = new AxisBuilder(indicatorAxis.model, {
            axisName: axisName,
            position: [radar.cx, radar.cy],
            rotation: indicatorAxis.angle,
            labelDirection: -1,
            tickDirection: -1,
            nameDirection: 1
          })
          return axisBuilder
        })
        each(axisBuilders, function (axisBuilder) {
          each(axisBuilderAttrs$1, axisBuilder.add, axisBuilder)
          this.group.add(axisBuilder.getGroup())
        }, this)
      }

      RadarView.prototype._buildSplitLineAndArea = function (radarModel) {
        const radar = radarModel.coordinateSystem
        const indicatorAxes = radar.getIndicatorAxes()

        if (!indicatorAxes.length) {
          return
        }

        const shape = radarModel.get('shape')
        const splitLineModel = radarModel.getModel('splitLine')
        const splitAreaModel = radarModel.getModel('splitArea')
        const lineStyleModel = splitLineModel.getModel('lineStyle')
        const areaStyleModel = splitAreaModel.getModel('areaStyle')
        const showSplitLine = splitLineModel.get('show')
        const showSplitArea = splitAreaModel.get('show')
        const splitLineColors = lineStyleModel.get('color')
        const splitAreaColors = areaStyleModel.get('color')
        const splitLineColorsArr = isArray(splitLineColors) ? splitLineColors : [splitLineColors]
        const splitAreaColorsArr = isArray(splitAreaColors) ? splitAreaColors : [splitAreaColors]
        const splitLines = []
        const splitAreas = []

        function getColorIndex (areaOrLine, areaOrLineColorList, idx) {
          const colorIndex = idx % areaOrLineColorList.length
          areaOrLine[colorIndex] = areaOrLine[colorIndex] || []
          return colorIndex
        }

        if (shape === 'circle') {
          const ticksRadius = indicatorAxes[0].getTicksCoords()
          const cx = radar.cx
          const cy = radar.cy

          for (var i = 0; i < ticksRadius.length; i++) {
            if (showSplitLine) {
              var colorIndex = getColorIndex(splitLines, splitLineColorsArr, i)
              splitLines[colorIndex].push(new Circle({
                shape: {
                  cx: cx,
                  cy: cy,
                  r: ticksRadius[i].coord
                }
              }))
            }

            if (showSplitArea && i < ticksRadius.length - 1) {
              var colorIndex = getColorIndex(splitAreas, splitAreaColorsArr, i)
              splitAreas[colorIndex].push(new Ring({
                shape: {
                  cx: cx,
                  cy: cy,
                  r0: ticksRadius[i].coord,
                  r: ticksRadius[i + 1].coord
                }
              }))
            }
          }
        } // Polyyon
        else {
          let realSplitNumber_1
          const axesTicksPoints = map(indicatorAxes, function (indicatorAxis, idx) {
            const ticksCoords = indicatorAxis.getTicksCoords()
            realSplitNumber_1 = realSplitNumber_1 == null ? ticksCoords.length - 1 : Math.min(ticksCoords.length - 1, realSplitNumber_1)
            return map(ticksCoords, function (tickCoord) {
              return radar.coordToPoint(tickCoord.coord, idx)
            })
          })
          let prevPoints = []

          for (var i = 0; i <= realSplitNumber_1; i++) {
            const points = []

            for (let j = 0; j < indicatorAxes.length; j++) {
              points.push(axesTicksPoints[j][i])
            } // Close

            if (points[0]) {
              points.push(points[0].slice())
            } else {
              if ('development' !== 'production') {
                console.error('Can\'t draw value axis ' + i)
              }
            }

            if (showSplitLine) {
              var colorIndex = getColorIndex(splitLines, splitLineColorsArr, i)
              splitLines[colorIndex].push(new Polyline({
                shape: {
                  points: points
                }
              }))
            }

            if (showSplitArea && prevPoints) {
              var colorIndex = getColorIndex(splitAreas, splitAreaColorsArr, i - 1)
              splitAreas[colorIndex].push(new Polygon({
                shape: {
                  points: points.concat(prevPoints)
                }
              }))
            }

            prevPoints = points.slice().reverse()
          }
        }

        const lineStyle = lineStyleModel.getLineStyle()
        const areaStyle = areaStyleModel.getAreaStyle() // Add splitArea before splitLine

        each(splitAreas, function (splitAreas, idx) {
          this.group.add(mergePath$1(splitAreas, {
            style: defaults({
              stroke: 'none',
              fill: splitAreaColorsArr[idx % splitAreaColorsArr.length]
            }, areaStyle),
            silent: true
          }))
        }, this)
        each(splitLines, function (splitLines, idx) {
          this.group.add(mergePath$1(splitLines, {
            style: defaults({
              fill: 'none',
              stroke: splitLineColorsArr[idx % splitLineColorsArr.length]
            }, lineStyle),
            silent: true
          }))
        }, this)
      }

      RadarView.type = 'radar'
      return RadarView
    }(ComponentView))

  const IndicatorAxis =
    /** @class */
    (function (_super) {
      __extends(IndicatorAxis, _super)

      function IndicatorAxis (dim, scale, radiusExtent) {
        const _this = _super.call(this, dim, scale, radiusExtent) || this

        _this.type = 'value'
        _this.angle = 0
        _this.name = ''
        return _this
      }

      return IndicatorAxis
    }(Axis))

  const Radar =
    /** @class */
    (function () {
      function Radar (radarModel, ecModel, api) {
        /**
         *
         * Radar dimensions
         */
        this.dimensions = []
        this._model = radarModel
        this._indicatorAxes = map(radarModel.getIndicatorModels(), function (indicatorModel, idx) {
          const dim = 'indicator_' + idx
          const indicatorAxis = new IndicatorAxis(dim, new IntervalScale() // (indicatorModel.get('axisType') === 'log') ? new LogScale() : new IntervalScale()
          )
          indicatorAxis.name = indicatorModel.get('name') // Inject model and axis

          indicatorAxis.model = indicatorModel
          indicatorModel.axis = indicatorAxis
          this.dimensions.push(dim)
          return indicatorAxis
        }, this)
        this.resize(radarModel, api)
      }

      Radar.prototype.getIndicatorAxes = function () {
        return this._indicatorAxes
      }

      Radar.prototype.dataToPoint = function (value, indicatorIndex) {
        const indicatorAxis = this._indicatorAxes[indicatorIndex]
        return this.coordToPoint(indicatorAxis.dataToCoord(value), indicatorIndex)
      } // TODO: API should be coordToPoint([coord, indicatorIndex])

      Radar.prototype.coordToPoint = function (coord, indicatorIndex) {
        const indicatorAxis = this._indicatorAxes[indicatorIndex]
        const angle = indicatorAxis.angle
        const x = this.cx + coord * Math.cos(angle)
        const y = this.cy - coord * Math.sin(angle)
        return [x, y]
      }

      Radar.prototype.pointToData = function (pt) {
        let dx = pt[0] - this.cx
        let dy = pt[1] - this.cy
        const radius = Math.sqrt(dx * dx + dy * dy)
        dx /= radius
        dy /= radius
        const radian = Math.atan2(-dy, dx) // Find the closest angle
        // FIXME index can calculated directly

        let minRadianDiff = Infinity
        let closestAxis
        let closestAxisIdx = -1

        for (let i = 0; i < this._indicatorAxes.length; i++) {
          const indicatorAxis = this._indicatorAxes[i]
          const diff = Math.abs(radian - indicatorAxis.angle)

          if (diff < minRadianDiff) {
            closestAxis = indicatorAxis
            closestAxisIdx = i
            minRadianDiff = diff
          }
        }

        return [closestAxisIdx, +(closestAxis && closestAxis.coordToData(radius))]
      }

      Radar.prototype.resize = function (radarModel, api) {
        const center = radarModel.get('center')
        const viewWidth = api.getWidth()
        const viewHeight = api.getHeight()
        const viewSize = Math.min(viewWidth, viewHeight) / 2
        this.cx = parsePercent$1(center[0], viewWidth)
        this.cy = parsePercent$1(center[1], viewHeight)
        this.startAngle = radarModel.get('startAngle') * Math.PI / 180 // radius may be single value like `20`, `'80%'`, or array like `[10, '80%']`

        let radius = radarModel.get('radius')

        if (isString(radius) || isNumber(radius)) {
          radius = [0, radius]
        }

        this.r0 = parsePercent$1(radius[0], viewSize)
        this.r = parsePercent$1(radius[1], viewSize)
        each(this._indicatorAxes, function (indicatorAxis, idx) {
          indicatorAxis.setExtent(this.r0, this.r)
          let angle = this.startAngle + idx * Math.PI * 2 / this._indicatorAxes.length // Normalize to [-PI, PI]

          angle = Math.atan2(Math.sin(angle), Math.cos(angle))
          indicatorAxis.angle = angle
        }, this)
      }

      Radar.prototype.update = function (ecModel, api) {
        const indicatorAxes = this._indicatorAxes
        const radarModel = this._model
        each(indicatorAxes, function (indicatorAxis) {
          indicatorAxis.scale.setExtent(Infinity, -Infinity)
        })
        ecModel.eachSeriesByType('radar', function (radarSeries, idx) {
          if (radarSeries.get('coordinateSystem') !== 'radar' || // @ts-ignore
          ecModel.getComponent('radar', radarSeries.get('radarIndex')) !== radarModel) {
            return
          }

          const data = radarSeries.getData()
          each(indicatorAxes, function (indicatorAxis) {
            indicatorAxis.scale.unionExtentFromData(data, data.mapDimension(indicatorAxis.dim))
          })
        }, this)
        const splitNumber = radarModel.get('splitNumber')
        const dummyScale = new IntervalScale()
        dummyScale.setExtent(0, splitNumber)
        dummyScale.setInterval(1) // Force all the axis fixing the maxSplitNumber.

        each(indicatorAxes, function (indicatorAxis, idx) {
          alignScaleTicks(indicatorAxis.scale, indicatorAxis.model, dummyScale)
        })
      }

      Radar.prototype.convertToPixel = function (ecModel, finder, value) {
        console.warn('Not implemented.')
        return null
      }

      Radar.prototype.convertFromPixel = function (ecModel, finder, pixel) {
        console.warn('Not implemented.')
        return null
      }

      Radar.prototype.containPoint = function (point) {
        console.warn('Not implemented.')
        return false
      }

      Radar.create = function (ecModel, api) {
        const radarList = []
        ecModel.eachComponent('radar', function (radarModel) {
          const radar = new Radar(radarModel, ecModel, api)
          radarList.push(radar)
          radarModel.coordinateSystem = radar
        })
        ecModel.eachSeriesByType('radar', function (radarSeries) {
          if (radarSeries.get('coordinateSystem') === 'radar') {
            // Inject coordinate system
            // @ts-ignore
            radarSeries.coordinateSystem = radarList[radarSeries.get('radarIndex') || 0]
          }
        })
        return radarList
      }
      /**
       * Radar dimensions is based on the data
       */

      Radar.dimensions = []
      return Radar
    }())

  function install$7 (registers) {
    registers.registerCoordinateSystem('radar', Radar)
    registers.registerComponentModel(RadarModel)
    registers.registerComponentView(RadarView$1)
    registers.registerVisual({
      seriesType: 'radar',
      reset: function (seriesModel) {
        const data = seriesModel.getData() // itemVisual symbol is for selected data

        data.each(function (idx) {
          data.setItemVisual(idx, 'legendIcon', 'roundRect')
        }) // visual is for unselected data

        data.setVisual('legendIcon', 'roundRect')
      }
    })
  }

  function install$8 (registers) {
    use(install$7)
    registers.registerChartView(RadarView)
    registers.registerSeriesModel(RadarSeriesModel)
    registers.registerLayout(radarLayout)
    registers.registerProcessor(dataFilter('radar'))
    registers.registerPreprocessor(radarBackwardCompat)
  }

  const ATTR = '\0_ec_interaction_mutex'
  function take (zr, resourceKey, userKey) {
    const store = getStore(zr)
    store[resourceKey] = userKey
  }
  function release (zr, resourceKey, userKey) {
    const store = getStore(zr)
    const uKey = store[resourceKey]

    if (uKey === userKey) {
      store[resourceKey] = null
    }
  }
  function isTaken (zr, resourceKey) {
    return !!getStore(zr)[resourceKey]
  }

  function getStore (zr) {
    return zr[ATTR] || (zr[ATTR] = {})
  }
  /**
     * payload: {
     *     type: 'takeGlobalCursor',
     *     key: 'dataZoomSelect', or 'brush', or ...,
     *         If no userKey, release global cursor.
     * }
     */
  // TODO: SELF REGISTERED.

  registerAction({
    type: 'takeGlobalCursor',
    event: 'globalCursorTaken',
    update: 'update'
  }, noop)

  const RoamController =
    /** @class */
    (function (_super) {
      __extends(RoamController, _super)

      function RoamController (zr) {
        const _this = _super.call(this) || this

        _this._zr = zr // Avoid two roamController bind the same handler

        const mousedownHandler = bind(_this._mousedownHandler, _this)
        const mousemoveHandler = bind(_this._mousemoveHandler, _this)
        const mouseupHandler = bind(_this._mouseupHandler, _this)
        const mousewheelHandler = bind(_this._mousewheelHandler, _this)
        const pinchHandler = bind(_this._pinchHandler, _this)
        /**
         * Notice: only enable needed types. For example, if 'zoom'
         * is not needed, 'zoom' should not be enabled, otherwise
         * default mousewheel behaviour (scroll page) will be disabled.
         */

        _this.enable = function (controlType, opt) {
          // Disable previous first
          this.disable()
          this._opt = defaults(clone(opt) || {}, {
            zoomOnMouseWheel: true,
            moveOnMouseMove: true,
            // By default, wheel do not trigger move.
            moveOnMouseWheel: false,
            preventDefaultMouseMove: true
          })

          if (controlType == null) {
            controlType = true
          }

          if (controlType === true || controlType === 'move' || controlType === 'pan') {
            zr.on('mousedown', mousedownHandler)
            zr.on('mousemove', mousemoveHandler)
            zr.on('mouseup', mouseupHandler)
          }

          if (controlType === true || controlType === 'scale' || controlType === 'zoom') {
            zr.on('mousewheel', mousewheelHandler)
            zr.on('pinch', pinchHandler)
          }
        }

        _this.disable = function () {
          zr.off('mousedown', mousedownHandler)
          zr.off('mousemove', mousemoveHandler)
          zr.off('mouseup', mouseupHandler)
          zr.off('mousewheel', mousewheelHandler)
          zr.off('pinch', pinchHandler)
        }

        return _this
      }

      RoamController.prototype.isDragging = function () {
        return this._dragging
      }

      RoamController.prototype.isPinching = function () {
        return this._pinching
      }

      RoamController.prototype.setPointerChecker = function (pointerChecker) {
        this.pointerChecker = pointerChecker
      }

      RoamController.prototype.dispose = function () {
        this.disable()
      }

      RoamController.prototype._mousedownHandler = function (e) {
        if (isMiddleOrRightButtonOnMouseUpDown(e) || e.target && e.target.draggable) {
          return
        }

        const x = e.offsetX
        const y = e.offsetY // Only check on mosedown, but not mousemove.
        // Mouse can be out of target when mouse moving.

        if (this.pointerChecker && this.pointerChecker(e, x, y)) {
          this._x = x
          this._y = y
          this._dragging = true
        }
      }

      RoamController.prototype._mousemoveHandler = function (e) {
        if (!this._dragging || !isAvailableBehavior('moveOnMouseMove', e, this._opt) || e.gestureEvent === 'pinch' || isTaken(this._zr, 'globalPan')) {
          return
        }

        const x = e.offsetX
        const y = e.offsetY
        const oldX = this._x
        const oldY = this._y
        const dx = x - oldX
        const dy = y - oldY
        this._x = x
        this._y = y
        this._opt.preventDefaultMouseMove && stop(e.event)
        trigger(this, 'pan', 'moveOnMouseMove', e, {
          dx: dx,
          dy: dy,
          oldX: oldX,
          oldY: oldY,
          newX: x,
          newY: y,
          isAvailableBehavior: null
        })
      }

      RoamController.prototype._mouseupHandler = function (e) {
        if (!isMiddleOrRightButtonOnMouseUpDown(e)) {
          this._dragging = false
        }
      }

      RoamController.prototype._mousewheelHandler = function (e) {
        const shouldZoom = isAvailableBehavior('zoomOnMouseWheel', e, this._opt)
        const shouldMove = isAvailableBehavior('moveOnMouseWheel', e, this._opt)
        const wheelDelta = e.wheelDelta
        const absWheelDeltaDelta = Math.abs(wheelDelta)
        const originX = e.offsetX
        const originY = e.offsetY // wheelDelta maybe -0 in chrome mac.

        if (wheelDelta === 0 || !shouldZoom && !shouldMove) {
          return
        } // If both `shouldZoom` and `shouldMove` is true, trigger
        // their event both, and the final behavior is determined
        // by event listener themselves.

        if (shouldZoom) {
          // Convenience:
          // Mac and VM Windows on Mac: scroll up: zoom out.
          // Windows: scroll up: zoom in.
          // FIXME: Should do more test in different environment.
          // wheelDelta is too complicated in difference nvironment
          // (https://developer.mozilla.org/en-US/docs/Web/Events/mousewheel),
          // although it has been normallized by zrender.
          // wheelDelta of mouse wheel is bigger than touch pad.
          const factor = absWheelDeltaDelta > 3 ? 1.4 : absWheelDeltaDelta > 1 ? 1.2 : 1.1
          const scale = wheelDelta > 0 ? factor : 1 / factor
          checkPointerAndTrigger(this, 'zoom', 'zoomOnMouseWheel', e, {
            scale: scale,
            originX: originX,
            originY: originY,
            isAvailableBehavior: null
          })
        }

        if (shouldMove) {
          // FIXME: Should do more test in different environment.
          const absDelta = Math.abs(wheelDelta) // wheelDelta of mouse wheel is bigger than touch pad.

          const scrollDelta = (wheelDelta > 0 ? 1 : -1) * (absDelta > 3 ? 0.4 : absDelta > 1 ? 0.15 : 0.05)
          checkPointerAndTrigger(this, 'scrollMove', 'moveOnMouseWheel', e, {
            scrollDelta: scrollDelta,
            originX: originX,
            originY: originY,
            isAvailableBehavior: null
          })
        }
      }

      RoamController.prototype._pinchHandler = function (e) {
        if (isTaken(this._zr, 'globalPan')) {
          return
        }

        const scale = e.pinchScale > 1 ? 1.1 : 1 / 1.1
        checkPointerAndTrigger(this, 'zoom', null, e, {
          scale: scale,
          originX: e.pinchX,
          originY: e.pinchY,
          isAvailableBehavior: null
        })
      }

      return RoamController
    }(Eventful))

  function checkPointerAndTrigger (controller, eventName, behaviorToCheck, e, contollerEvent) {
    if (controller.pointerChecker && controller.pointerChecker(e, contollerEvent.originX, contollerEvent.originY)) {
      // When mouse is out of roamController rect,
      // default befavoius should not be be disabled, otherwise
      // page sliding is disabled, contrary to expectation.
      stop(e.event)
      trigger(controller, eventName, behaviorToCheck, e, contollerEvent)
    }
  }

  function trigger (controller, eventName, behaviorToCheck, e, contollerEvent) {
    // Also provide behavior checker for event listener, for some case that
    // multiple components share one listener.
    contollerEvent.isAvailableBehavior = bind(isAvailableBehavior, null, behaviorToCheck, e) // TODO should not have type issue.

    controller.trigger(eventName, contollerEvent)
  } // settings: {
  //     zoomOnMouseWheel
  //     moveOnMouseMove
  //     moveOnMouseWheel
  // }
  // The value can be: true / false / 'shift' / 'ctrl' / 'alt'.

  function isAvailableBehavior (behaviorToCheck, e, settings) {
    const setting = settings[behaviorToCheck]
    return !behaviorToCheck || setting && (!isString(setting) || e.event[setting + 'Key'])
  }

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

  /**
     * AUTO-GENERATED FILE. DO NOT MODIFY.
     */

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

  /**
     * For geo and graph.
     */
  function updateViewOnPan (controllerHost, dx, dy) {
    const target = controllerHost.target
    target.x += dx
    target.y += dy
    target.dirty()
  }
  /**
     * For geo and graph.
     */

  function updateViewOnZoom (controllerHost, zoomDelta, zoomX, zoomY) {
    const target = controllerHost.target
    const zoomLimit = controllerHost.zoomLimit
    let newZoom = controllerHost.zoom = controllerHost.zoom || 1
    newZoom *= zoomDelta

    if (zoomLimit) {
      const zoomMin = zoomLimit.min || 0
      const zoomMax = zoomLimit.max || Infinity
      newZoom = Math.max(Math.min(zoomMax, newZoom), zoomMin)
    }

    const zoomScale = newZoom / controllerHost.zoom
    controllerHost.zoom = newZoom // Keep the mouse center when scaling

    target.x -= (zoomX - target.x) * (zoomScale - 1)
    target.y -= (zoomY - target.y) * (zoomScale - 1)
    target.scaleX *= zoomScale
    target.scaleY *= zoomScale
    target.dirty()
  }

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

  /**
     * AUTO-GENERATED FILE. DO NOT MODIFY.
     */

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
  const IRRELEVANT_EXCLUDES = {
    axisPointer: 1,
    tooltip: 1,
    brush: 1
  }
  /**
     * Avoid that: mouse click on a elements that is over geo or graph,
     * but roam is triggered.
     */

  function onIrrelevantElement (e, api, targetCoordSysModel) {
    const model = api.getComponentByElement(e.topTarget) // If model is axisModel, it works only if it is injected with coordinateSystem.

    const coordSys = model && model.coordinateSystem
    return model && model !== targetCoordSysModel && !IRRELEVANT_EXCLUDES.hasOwnProperty(model.mainType) && coordSys && coordSys.model !== targetCoordSysModel
  }

  function parseXML (svg) {
    if (isString(svg)) {
      const parser = new DOMParser()
      svg = parser.parseFromString(svg, 'text/xml')
    }
    let svgNode = svg
    if (svgNode.nodeType === 9) {
      svgNode = svgNode.firstChild
    }
    while (svgNode.nodeName.toLowerCase() !== 'svg' || svgNode.nodeType !== 1) {
      svgNode = svgNode.nextSibling
    }
    return svgNode
  }

  let nodeParsers
  const INHERITABLE_STYLE_ATTRIBUTES_MAP = {
    fill: 'fill',
    stroke: 'stroke',
    'stroke-width': 'lineWidth',
    opacity: 'opacity',
    'fill-opacity': 'fillOpacity',
    'stroke-opacity': 'strokeOpacity',
    'stroke-dasharray': 'lineDash',
    'stroke-dashoffset': 'lineDashOffset',
    'stroke-linecap': 'lineCap',
    'stroke-linejoin': 'lineJoin',
    'stroke-miterlimit': 'miterLimit',
    'font-family': 'fontFamily',
    'font-size': 'fontSize',
    'font-style': 'fontStyle',
    'font-weight': 'fontWeight',
    'text-anchor': 'textAlign',
    visibility: 'visibility',
    display: 'display'
  }
  const INHERITABLE_STYLE_ATTRIBUTES_MAP_KEYS = keys(INHERITABLE_STYLE_ATTRIBUTES_MAP)
  const SELF_STYLE_ATTRIBUTES_MAP = {
    'alignment-baseline': 'textBaseline',
    'stop-color': 'stopColor'
  }
  const SELF_STYLE_ATTRIBUTES_MAP_KEYS = keys(SELF_STYLE_ATTRIBUTES_MAP)
  const SVGParser = (function () {
    function SVGParser () {
      this._defs = {}
      this._root = null
    }
    SVGParser.prototype.parse = function (xml, opt) {
      opt = opt || {}
      const svg = parseXML(xml)
      if ('development' !== 'production') {
        if (!svg) {
          throw new Error('Illegal svg')
        }
      }
      this._defsUsePending = []
      let root = new Group()
      this._root = root
      const named = []
      const viewBox = svg.getAttribute('viewBox') || ''
      let width = parseFloat((svg.getAttribute('width') || opt.width))
      let height = parseFloat((svg.getAttribute('height') || opt.height))
      isNaN(width) && (width = null)
      isNaN(height) && (height = null)
      parseAttributes(svg, root, null, true, false)
      let child = svg.firstChild
      while (child) {
        this._parseNode(child, root, named, null, false, false)
        child = child.nextSibling
      }
      applyDefs(this._defs, this._defsUsePending)
      this._defsUsePending = []
      let viewBoxRect
      let viewBoxTransform
      if (viewBox) {
        const viewBoxArr = splitNumberSequence(viewBox)
        if (viewBoxArr.length >= 4) {
          viewBoxRect = {
            x: parseFloat((viewBoxArr[0] || 0)),
            y: parseFloat((viewBoxArr[1] || 0)),
            width: parseFloat(viewBoxArr[2]),
            height: parseFloat(viewBoxArr[3])
          }
        }
      }
      if (viewBoxRect && width != null && height != null) {
        viewBoxTransform = makeViewBoxTransform(viewBoxRect, { x: 0, y: 0, width: width, height: height })
        if (!opt.ignoreViewBox) {
          const elRoot = root
          root = new Group()
          root.add(elRoot)
          elRoot.scaleX = elRoot.scaleY = viewBoxTransform.scale
          elRoot.x = viewBoxTransform.x
          elRoot.y = viewBoxTransform.y
        }
      }
      if (!opt.ignoreRootClip && width != null && height != null) {
        root.setClipPath(new Rect({
          shape: { x: 0, y: 0, width: width, height: height }
        }))
      }
      return {
        root: root,
        width: width,
        height: height,
        viewBoxRect: viewBoxRect,
        viewBoxTransform: viewBoxTransform,
        named: named
      }
    }
    SVGParser.prototype._parseNode = function (xmlNode, parentGroup, named, namedFrom, isInDefs, isInText) {
      const nodeName = xmlNode.nodeName.toLowerCase()
      let el
      let namedFromForSub = namedFrom
      if (nodeName === 'defs') {
        isInDefs = true
      }
      if (nodeName === 'text') {
        isInText = true
      }
      if (nodeName === 'defs' || nodeName === 'switch') {
        el = parentGroup
      } else {
        if (!isInDefs) {
          const parser_1 = nodeParsers[nodeName]
          if (parser_1 && hasOwn(nodeParsers, nodeName)) {
            el = parser_1.call(this, xmlNode, parentGroup)
            const nameAttr = xmlNode.getAttribute('name')
            if (nameAttr) {
              const newNamed = {
                name: nameAttr,
                namedFrom: null,
                svgNodeTagLower: nodeName,
                el: el
              }
              named.push(newNamed)
              if (nodeName === 'g') {
                namedFromForSub = newNamed
              }
            } else if (namedFrom) {
              named.push({
                name: namedFrom.name,
                namedFrom: namedFrom,
                svgNodeTagLower: nodeName,
                el: el
              })
            }
            parentGroup.add(el)
          }
        }
        const parser = paintServerParsers[nodeName]
        if (parser && hasOwn(paintServerParsers, nodeName)) {
          const def = parser.call(this, xmlNode)
          const id = xmlNode.getAttribute('id')
          if (id) {
            this._defs[id] = def
          }
        }
      }
      if (el && el.isGroup) {
        let child = xmlNode.firstChild
        while (child) {
          if (child.nodeType === 1) {
            this._parseNode(child, el, named, namedFromForSub, isInDefs, isInText)
          } else if (child.nodeType === 3 && isInText) {
            this._parseText(child, el)
          }
          child = child.nextSibling
        }
      }
    }
    SVGParser.prototype._parseText = function (xmlNode, parentGroup) {
      const text = new TSpan({
        style: {
          text: xmlNode.textContent
        },
        silent: true,
        x: this._textX || 0,
        y: this._textY || 0
      })
      inheritStyle(parentGroup, text)
      parseAttributes(xmlNode, text, this._defsUsePending, false, false)
      applyTextAlignment(text, parentGroup)
      const textStyle = text.style
      const fontSize = textStyle.fontSize
      if (fontSize && fontSize < 9) {
        textStyle.fontSize = 9
        text.scaleX *= fontSize / 9
        text.scaleY *= fontSize / 9
      }
      const font = (textStyle.fontSize || textStyle.fontFamily) && [
        textStyle.fontStyle,
        textStyle.fontWeight,
        (textStyle.fontSize || 12) + 'px',
        textStyle.fontFamily || 'sans-serif'
      ].join(' ')
      textStyle.font = font
      const rect = text.getBoundingRect()
      this._textX += rect.width
      parentGroup.add(text)
      return text
    }
    SVGParser.internalField = (function () {
      nodeParsers = {
        g: function (xmlNode, parentGroup) {
          const g = new Group()
          inheritStyle(parentGroup, g)
          parseAttributes(xmlNode, g, this._defsUsePending, false, false)
          return g
        },
        rect: function (xmlNode, parentGroup) {
          const rect = new Rect()
          inheritStyle(parentGroup, rect)
          parseAttributes(xmlNode, rect, this._defsUsePending, false, false)
          rect.setShape({
            x: parseFloat(xmlNode.getAttribute('x') || '0'),
            y: parseFloat(xmlNode.getAttribute('y') || '0'),
            width: parseFloat(xmlNode.getAttribute('width') || '0'),
            height: parseFloat(xmlNode.getAttribute('height') || '0')
          })
          rect.silent = true
          return rect
        },
        circle: function (xmlNode, parentGroup) {
          const circle = new Circle()
          inheritStyle(parentGroup, circle)
          parseAttributes(xmlNode, circle, this._defsUsePending, false, false)
          circle.setShape({
            cx: parseFloat(xmlNode.getAttribute('cx') || '0'),
            cy: parseFloat(xmlNode.getAttribute('cy') || '0'),
            r: parseFloat(xmlNode.getAttribute('r') || '0')
          })
          circle.silent = true
          return circle
        },
        line: function (xmlNode, parentGroup) {
          const line = new Line()
          inheritStyle(parentGroup, line)
          parseAttributes(xmlNode, line, this._defsUsePending, false, false)
          line.setShape({
            x1: parseFloat(xmlNode.getAttribute('x1') || '0'),
            y1: parseFloat(xmlNode.getAttribute('y1') || '0'),
            x2: parseFloat(xmlNode.getAttribute('x2') || '0'),
            y2: parseFloat(xmlNode.getAttribute('y2') || '0')
          })
          line.silent = true
          return line
        },
        ellipse: function (xmlNode, parentGroup) {
          const ellipse = new Ellipse()
          inheritStyle(parentGroup, ellipse)
          parseAttributes(xmlNode, ellipse, this._defsUsePending, false, false)
          ellipse.setShape({
            cx: parseFloat(xmlNode.getAttribute('cx') || '0'),
            cy: parseFloat(xmlNode.getAttribute('cy') || '0'),
            rx: parseFloat(xmlNode.getAttribute('rx') || '0'),
            ry: parseFloat(xmlNode.getAttribute('ry') || '0')
          })
          ellipse.silent = true
          return ellipse
        },
        polygon: function (xmlNode, parentGroup) {
          const pointsStr = xmlNode.getAttribute('points')
          let pointsArr
          if (pointsStr) {
            pointsArr = parsePoints(pointsStr)
          }
          const polygon = new Polygon({
            shape: {
              points: pointsArr || []
            },
            silent: true
          })
          inheritStyle(parentGroup, polygon)
          parseAttributes(xmlNode, polygon, this._defsUsePending, false, false)
          return polygon
        },
        polyline: function (xmlNode, parentGroup) {
          const pointsStr = xmlNode.getAttribute('points')
          let pointsArr
          if (pointsStr) {
            pointsArr = parsePoints(pointsStr)
          }
          const polyline = new Polyline({
            shape: {
              points: pointsArr || []
            },
            silent: true
          })
          inheritStyle(parentGroup, polyline)
          parseAttributes(xmlNode, polyline, this._defsUsePending, false, false)
          return polyline
        },
        image: function (xmlNode, parentGroup) {
          const img = new ZRImage()
          inheritStyle(parentGroup, img)
          parseAttributes(xmlNode, img, this._defsUsePending, false, false)
          img.setStyle({
            image: xmlNode.getAttribute('xlink:href') || xmlNode.getAttribute('href'),
            x: +xmlNode.getAttribute('x'),
            y: +xmlNode.getAttribute('y'),
            width: +xmlNode.getAttribute('width'),
            height: +xmlNode.getAttribute('height')
          })
          img.silent = true
          return img
        },
        text: function (xmlNode, parentGroup) {
          const x = xmlNode.getAttribute('x') || '0'
          const y = xmlNode.getAttribute('y') || '0'
          const dx = xmlNode.getAttribute('dx') || '0'
          const dy = xmlNode.getAttribute('dy') || '0'
          this._textX = parseFloat(x) + parseFloat(dx)
          this._textY = parseFloat(y) + parseFloat(dy)
          const g = new Group()
          inheritStyle(parentGroup, g)
          parseAttributes(xmlNode, g, this._defsUsePending, false, true)
          return g
        },
        tspan: function (xmlNode, parentGroup) {
          const x = xmlNode.getAttribute('x')
          const y = xmlNode.getAttribute('y')
          if (x != null) {
            this._textX = parseFloat(x)
          }
          if (y != null) {
            this._textY = parseFloat(y)
          }
          const dx = xmlNode.getAttribute('dx') || '0'
          const dy = xmlNode.getAttribute('dy') || '0'
          const g = new Group()
          inheritStyle(parentGroup, g)
          parseAttributes(xmlNode, g, this._defsUsePending, false, true)
          this._textX += parseFloat(dx)
          this._textY += parseFloat(dy)
          return g
        },
        path: function (xmlNode, parentGroup) {
          const d = xmlNode.getAttribute('d') || ''
          const path = createFromString(d)
          inheritStyle(parentGroup, path)
          parseAttributes(xmlNode, path, this._defsUsePending, false, false)
          path.silent = true
          return path
        }
      }
    })()
    return SVGParser
  }())
  var paintServerParsers = {
    lineargradient: function (xmlNode) {
      const x1 = parseInt(xmlNode.getAttribute('x1') || '0', 10)
      const y1 = parseInt(xmlNode.getAttribute('y1') || '0', 10)
      const x2 = parseInt(xmlNode.getAttribute('x2') || '10', 10)
      const y2 = parseInt(xmlNode.getAttribute('y2') || '0', 10)
      const gradient = new LinearGradient(x1, y1, x2, y2)
      parsePaintServerUnit(xmlNode, gradient)
      parseGradientColorStops(xmlNode, gradient)
      return gradient
    },
    radialgradient: function (xmlNode) {
      const cx = parseInt(xmlNode.getAttribute('cx') || '0', 10)
      const cy = parseInt(xmlNode.getAttribute('cy') || '0', 10)
      const r = parseInt(xmlNode.getAttribute('r') || '0', 10)
      const gradient = new RadialGradient(cx, cy, r)
      parsePaintServerUnit(xmlNode, gradient)
      parseGradientColorStops(xmlNode, gradient)
      return gradient
    }
  }
  function parsePaintServerUnit (xmlNode, gradient) {
    const gradientUnits = xmlNode.getAttribute('gradientUnits')
    if (gradientUnits === 'userSpaceOnUse') {
      gradient.global = true
    }
  }
  function parseGradientColorStops (xmlNode, gradient) {
    let stop = xmlNode.firstChild
    while (stop) {
      if (stop.nodeType === 1 &&
                stop.nodeName.toLocaleLowerCase() === 'stop') {
        const offsetStr = stop.getAttribute('offset')
        let offset = void 0
        if (offsetStr && offsetStr.indexOf('%') > 0) {
          offset = parseInt(offsetStr, 10) / 100
        } else if (offsetStr) {
          offset = parseFloat(offsetStr)
        } else {
          offset = 0
        }
        const styleVals = {}
        parseInlineStyle(stop, styleVals, styleVals)
        const stopColor = styleVals.stopColor ||
                    stop.getAttribute('stop-color') ||
                    '#000000'
        gradient.colorStops.push({
          offset: offset,
          color: stopColor
        })
      }
      stop = stop.nextSibling
    }
  }
  function inheritStyle (parent, child) {
    if (parent && parent.__inheritedStyle) {
      if (!child.__inheritedStyle) {
        child.__inheritedStyle = {}
      }
      defaults(child.__inheritedStyle, parent.__inheritedStyle)
    }
  }
  function parsePoints (pointsString) {
    const list = splitNumberSequence(pointsString)
    const points = []
    for (let i = 0; i < list.length; i += 2) {
      const x = parseFloat(list[i])
      const y = parseFloat(list[i + 1])
      points.push([x, y])
    }
    return points
  }
  function parseAttributes (xmlNode, el, defsUsePending, onlyInlineStyle, isTextGroup) {
    const disp = el
    const inheritedStyle = disp.__inheritedStyle = disp.__inheritedStyle || {}
    const selfStyle = {}
    if (xmlNode.nodeType === 1) {
      parseTransformAttribute(xmlNode, el)
      parseInlineStyle(xmlNode, inheritedStyle, selfStyle)
      if (!onlyInlineStyle) {
        parseAttributeStyle(xmlNode, inheritedStyle, selfStyle)
      }
    }
    disp.style = disp.style || {}
    if (inheritedStyle.fill != null) {
      disp.style.fill = getFillStrokeStyle(disp, 'fill', inheritedStyle.fill, defsUsePending)
    }
    if (inheritedStyle.stroke != null) {
      disp.style.stroke = getFillStrokeStyle(disp, 'stroke', inheritedStyle.stroke, defsUsePending)
    }
    each([
      'lineWidth', 'opacity', 'fillOpacity', 'strokeOpacity', 'miterLimit', 'fontSize'
    ], function (propName) {
      if (inheritedStyle[propName] != null) {
        disp.style[propName] = parseFloat(inheritedStyle[propName])
      }
    })
    each([
      'lineDashOffset', 'lineCap', 'lineJoin', 'fontWeight', 'fontFamily', 'fontStyle', 'textAlign'
    ], function (propName) {
      if (inheritedStyle[propName] != null) {
        disp.style[propName] = inheritedStyle[propName]
      }
    })
    if (isTextGroup) {
      disp.__selfStyle = selfStyle
    }
    if (inheritedStyle.lineDash) {
      disp.style.lineDash = map(splitNumberSequence(inheritedStyle.lineDash), function (str) {
        return parseFloat(str)
      })
    }
    if (inheritedStyle.visibility === 'hidden' || inheritedStyle.visibility === 'collapse') {
      disp.invisible = true
    }
    if (inheritedStyle.display === 'none') {
      disp.ignore = true
    }
  }
  function applyTextAlignment (text, parentGroup) {
    const parentSelfStyle = parentGroup.__selfStyle
    if (parentSelfStyle) {
      const textBaseline = parentSelfStyle.textBaseline
      let zrTextBaseline = textBaseline
      if (!textBaseline || textBaseline === 'auto') {
        zrTextBaseline = 'alphabetic'
      } else if (textBaseline === 'baseline') {
        zrTextBaseline = 'alphabetic'
      } else if (textBaseline === 'before-edge' || textBaseline === 'text-before-edge') {
        zrTextBaseline = 'top'
      } else if (textBaseline === 'after-edge' || textBaseline === 'text-after-edge') {
        zrTextBaseline = 'bottom'
      } else if (textBaseline === 'central' || textBaseline === 'mathematical') {
        zrTextBaseline = 'middle'
      }
      text.style.textBaseline = zrTextBaseline
    }
    const parentInheritedStyle = parentGroup.__inheritedStyle
    if (parentInheritedStyle) {
      const textAlign = parentInheritedStyle.textAlign
      let zrTextAlign = textAlign
      if (textAlign) {
        if (textAlign === 'middle') {
          zrTextAlign = 'center'
        }
        text.style.textAlign = zrTextAlign
      }
    }
  }
  const urlRegex = /^url\(\s*#(.*?)\)/
  function getFillStrokeStyle (el, method, str, defsUsePending) {
    const urlMatch = str && str.match(urlRegex)
    if (urlMatch) {
      const url = trim(urlMatch[1])
      defsUsePending.push([el, method, url])
      return
    }
    if (str === 'none') {
      str = null
    }
    return str
  }
  function applyDefs (defs, defsUsePending) {
    for (let i = 0; i < defsUsePending.length; i++) {
      const item = defsUsePending[i]
      item[0].style[item[1]] = defs[item[2]]
    }
  }
  const numberReg$1 = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g
  function splitNumberSequence (rawStr) {
    return rawStr.match(numberReg$1) || []
  }
  const transformRegex = /(translate|scale|rotate|skewX|skewY|matrix)\(([\-\s0-9\.eE,]*)\)/g
  const DEGREE_TO_ANGLE = Math.PI / 180
  function parseTransformAttribute (xmlNode, node) {
    let transform = xmlNode.getAttribute('transform')
    if (transform) {
      transform = transform.replace(/,/g, ' ')
      const transformOps_1 = []
      let mt = null
      transform.replace(transformRegex, function (str, type, value) {
        transformOps_1.push(type, value)
        return ''
      })
      for (let i = transformOps_1.length - 1; i > 0; i -= 2) {
        const value = transformOps_1[i]
        const type = transformOps_1[i - 1]
        const valueArr = splitNumberSequence(value)
        mt = mt || create$1()
        switch (type) {
          case 'translate':
            translate(mt, mt, [parseFloat(valueArr[0]), parseFloat(valueArr[1] || '0')])
            break
          case 'scale':
            scale$1(mt, mt, [parseFloat(valueArr[0]), parseFloat(valueArr[1] || valueArr[0])])
            break
          case 'rotate':
            rotate(mt, mt, -parseFloat(valueArr[0]) * DEGREE_TO_ANGLE)
            break
          case 'skewX':
            var sx = Math.tan(parseFloat(valueArr[0]) * DEGREE_TO_ANGLE)
            mul$1(mt, [1, 0, sx, 1, 0, 0], mt)
            break
          case 'skewY':
            var sy = Math.tan(parseFloat(valueArr[0]) * DEGREE_TO_ANGLE)
            mul$1(mt, [1, sy, 0, 1, 0, 0], mt)
            break
          case 'matrix':
            mt[0] = parseFloat(valueArr[0])
            mt[1] = parseFloat(valueArr[1])
            mt[2] = parseFloat(valueArr[2])
            mt[3] = parseFloat(valueArr[3])
            mt[4] = parseFloat(valueArr[4])
            mt[5] = parseFloat(valueArr[5])
            break
        }
      }
      node.setLocalTransform(mt)
    }
  }
  const styleRegex = /([^\s:;]+)\s*:\s*([^:;]+)/g
  function parseInlineStyle (xmlNode, inheritableStyleResult, selfStyleResult) {
    const style = xmlNode.getAttribute('style')
    if (!style) {
      return
    }
    styleRegex.lastIndex = 0
    let styleRegResult
    while ((styleRegResult = styleRegex.exec(style)) != null) {
      const svgStlAttr = styleRegResult[1]
      const zrInheritableStlAttr = hasOwn(INHERITABLE_STYLE_ATTRIBUTES_MAP, svgStlAttr)
        ? INHERITABLE_STYLE_ATTRIBUTES_MAP[svgStlAttr]
        : null
      if (zrInheritableStlAttr) {
        inheritableStyleResult[zrInheritableStlAttr] = styleRegResult[2]
      }
      const zrSelfStlAttr = hasOwn(SELF_STYLE_ATTRIBUTES_MAP, svgStlAttr)
        ? SELF_STYLE_ATTRIBUTES_MAP[svgStlAttr]
        : null
      if (zrSelfStlAttr) {
        selfStyleResult[zrSelfStlAttr] = styleRegResult[2]
      }
    }
  }
  function parseAttributeStyle (xmlNode, inheritableStyleResult, selfStyleResult) {
    for (var i = 0; i < INHERITABLE_STYLE_ATTRIBUTES_MAP_KEYS.length; i++) {
      var svgAttrName = INHERITABLE_STYLE_ATTRIBUTES_MAP_KEYS[i]
      var attrValue = xmlNode.getAttribute(svgAttrName)
      if (attrValue != null) {
        inheritableStyleResult[INHERITABLE_STYLE_ATTRIBUTES_MAP[svgAttrName]] = attrValue
      }
    }
    for (var i = 0; i < SELF_STYLE_ATTRIBUTES_MAP_KEYS.length; i++) {
      var svgAttrName = SELF_STYLE_ATTRIBUTES_MAP_KEYS[i]
      var attrValue = xmlNode.getAttribute(svgAttrName)
      if (attrValue != null) {
        selfStyleResult[SELF_STYLE_ATTRIBUTES_MAP[svgAttrName]] = attrValue
      }
    }
  }
  function makeViewBoxTransform (viewBoxRect, boundingRect) {
    const scaleX = boundingRect.width / viewBoxRect.width
    const scaleY = boundingRect.height / viewBoxRect.height
    const scale = Math.min(scaleX, scaleY)
    return {
      scale: scale,
      x: -(viewBoxRect.x + viewBoxRect.width / 2) * scale + (boundingRect.x + boundingRect.width / 2),
      y: -(viewBoxRect.y + viewBoxRect.height / 2) * scale + (boundingRect.y + boundingRect.height / 2)
    }
  }
  function parseSVG (xml, opt) {
    const parser = new SVGParser()
    return parser.parse(xml, opt)
  }

  /**
     * "region available" means that: enable users to set attribute `name="xxx"` on those tags
     * to make it be a region.
     * 1. region styles and its label styles can be defined in echarts opton:
     * ```js
     * geo: {
     *     regions: [{
     *         name: 'xxx',
     *         itemStyle: { ... },
     *         label: { ... }
     *     }, {
     *         ...
     *     },
     *     ...]
     * };
     * ```
     * 2. name can be duplicated in different SVG tag. All of the tags with the same name share
     * a region option. For exampel if there are two <path> representing two lung lobes. They have
     * no common parents but both of them need to display label "lung" inside.
     */

  const REGION_AVAILABLE_SVG_TAG_MAP = createHashMap(['rect', 'circle', 'line', 'ellipse', 'polygon', 'polyline', 'path', // <text> <tspan> are also enabled becuase some SVG might paint text itself,
    // but still need to trigger events or tooltip.
    'text', 'tspan', // <g> is also enabled because this case: if multiple tags share one name
    // and need label displayed, every tags will display the name, which is not
    // expected. So we can put them into a <g name="xxx">. Thereby only one label
    // displayed and located based on the bounding rect of the <g>.
    'g'])

  const GeoSVGResource =
    /** @class */
    (function () {
      function GeoSVGResource (mapName, svg) {
        this.type = 'geoSVG' // All used graphics. key: hostKey, value: root

        this._usedGraphicMap = createHashMap() // All unused graphics.

        this._freedGraphics = []
        this._mapName = mapName // Only perform parse to XML object here, which might be time
        // consiming for large SVG.
        // Although convert XML to zrender element is also time consiming,
        // if we do it here, the clone of zrender elements has to be
        // required. So we do it once for each geo instance, util real
        // performance issues call for optimizing it.

        this._parsedXML = parseXML(svg)
      }

      GeoSVGResource.prototype.load = function ()
      /* nameMap: NameMap */
      {
        // In the "load" stage, graphic need to be built to
        // get boundingRect for geo coordinate system.
        let firstGraphic = this._firstGraphic // Create the return data structure only when first graphic created.
        // Because they will be used in geo coordinate system update stage,
        // and `regions` will be mounted at `geo` coordinate system,
        // in which there is no "view" info, so that it should better not to
        // make references to graphic elements.

        if (!firstGraphic) {
          firstGraphic = this._firstGraphic = this._buildGraphic(this._parsedXML)

          this._freedGraphics.push(firstGraphic)

          this._boundingRect = this._firstGraphic.boundingRect.clone() // PENDING: `nameMap` will not be supported until some real requirement come.
          // if (nameMap) {
          //     named = applyNameMap(named, nameMap);
          // }

          const _a = createRegions(firstGraphic.named)
          const regions = _a.regions
          const regionsMap = _a.regionsMap

          this._regions = regions
          this._regionsMap = regionsMap
        }

        return {
          boundingRect: this._boundingRect,
          regions: this._regions,
          regionsMap: this._regionsMap
        }
      }

      GeoSVGResource.prototype._buildGraphic = function (svgXML) {
        let result
        let rootFromParse

        try {
          result = svgXML && parseSVG(svgXML, {
            ignoreViewBox: true,
            ignoreRootClip: true
          }) || {}
          rootFromParse = result.root
          assert(rootFromParse != null)
        } catch (e) {
          throw new Error('Invalid svg format\n' + e.message)
        } // Note: we keep the covenant that the root has no transform. So always add an extra root.

        const root = new Group()
        root.add(rootFromParse)
        root.isGeoSVGGraphicRoot = true // [THE_RULE_OF_VIEWPORT_AND_VIEWBOX]
        //
        // Consider: `<svg width="..." height="..." viewBox="...">`
        // - the `width/height` we call it `svgWidth/svgHeight` for short.
        // - `(0, 0, svgWidth, svgHeight)` defines the viewport of the SVG, or say,
        //   "viewport boundingRect", or `boundingRect` for short.
        // - `viewBox` defines the transform from the real content ot the viewport.
        //   `viewBox` has the same unit as the content of SVG.
        //   If `viewBox` exists, a transform is defined, so the unit of `svgWidth/svgHeight` become
        //   different from the content of SVG. Otherwise, they are the same.
        //
        // If both `svgWidth/svgHeight/viewBox` are specified in a SVG file, the transform rule will be:
        // 0. `boundingRect` is `(0, 0, svgWidth, svgHeight)`. Set it to Geo['_rect'] (View['_rect']).
        // 1. Make a transform from `viewBox` to `boundingRect`.
        //    Note: only suport `preserveAspectRatio 'xMidYMid'` here. That is, this transform will preserve
        //    the aspect ratio.
        // 2. Make a transform from boundingRect to Geo['_viewRect'] (View['_viewRect'])
        //    (`Geo`/`View` will do this job).
        //    Note: this transform might not preserve aspect radio, which depending on how users specify
        //    viewRect in echarts option (e.g., `geo.left/top/width/height` will not preserve aspect ratio,
        //    but `geo.layoutCenter/layoutSize` will preserve aspect ratio).
        //
        // If `svgWidth/svgHeight` not specified, we use `viewBox` as the `boundingRect` to make the SVG
        // layout look good.
        //
        // If neither `svgWidth/svgHeight` nor `viewBox` are not specified, we calculate the boundingRect
        // of the SVG content and use them to make SVG layout look good.

        const svgWidth = result.width
        const svgHeight = result.height
        const viewBoxRect = result.viewBoxRect
        let boundingRect = this._boundingRect

        if (!boundingRect) {
          let bRectX = void 0
          let bRectY = void 0
          let bRectWidth = void 0
          let bRectHeight = void 0

          if (svgWidth != null) {
            bRectX = 0
            bRectWidth = svgWidth
          } else if (viewBoxRect) {
            bRectX = viewBoxRect.x
            bRectWidth = viewBoxRect.width
          }

          if (svgHeight != null) {
            bRectY = 0
            bRectHeight = svgHeight
          } else if (viewBoxRect) {
            bRectY = viewBoxRect.y
            bRectHeight = viewBoxRect.height
          } // If both viewBox and svgWidth/svgHeight not specified,
          // we have to determine how to layout those element to make them look good.

          if (bRectX == null || bRectY == null) {
            const calculatedBoundingRect = rootFromParse.getBoundingRect()

            if (bRectX == null) {
              bRectX = calculatedBoundingRect.x
              bRectWidth = calculatedBoundingRect.width
            }

            if (bRectY == null) {
              bRectY = calculatedBoundingRect.y
              bRectHeight = calculatedBoundingRect.height
            }
          }

          boundingRect = this._boundingRect = new BoundingRect(bRectX, bRectY, bRectWidth, bRectHeight)
        }

        if (viewBoxRect) {
          const viewBoxTransform = makeViewBoxTransform(viewBoxRect, boundingRect) // Only support `preserveAspectRatio 'xMidYMid'`

          rootFromParse.scaleX = rootFromParse.scaleY = viewBoxTransform.scale
          rootFromParse.x = viewBoxTransform.x
          rootFromParse.y = viewBoxTransform.y
        } // SVG needs to clip based on `viewBox`. And some SVG files really rely on this feature.
        // They do not strictly confine all of the content inside a display rect, but deliberately
        // use a `viewBox` to define a displayable rect.
        // PENDING:
        // The drawback of the `setClipPath` here is: the region label (genereted by echarts) near the
        // edge might also be clipped, because region labels are put as `textContent` of the SVG path.

        root.setClipPath(new Rect({
          shape: boundingRect.plain()
        }))
        const named = []
        each(result.named, function (namedItem) {
          if (REGION_AVAILABLE_SVG_TAG_MAP.get(namedItem.svgNodeTagLower) != null) {
            named.push(namedItem)
            setSilent(namedItem.el)
          }
        })
        return {
          root: root,
          boundingRect: boundingRect,
          named: named
        }
      }
      /**
       * Consider:
       * (1) One graphic element can not be shared by different `geoView` running simultaneously.
       *     Notice, also need to consider multiple echarts instances share a `mapRecord`.
       * (2) Converting SVG to graphic elements is time consuming.
       * (3) In the current architecture, `load` should be called frequently to get boundingRect,
       *     and it is called without view info.
       * So we maintain graphic elements in this module, and enables `view` to use/return these
       * graphics from/to the pool with it's uid.
       */

      GeoSVGResource.prototype.useGraphic = function (hostKey
      /*, nameMap: NameMap */
      ) {
        const usedRootMap = this._usedGraphicMap
        let svgGraphic = usedRootMap.get(hostKey)

        if (svgGraphic) {
          return svgGraphic
        }

        svgGraphic = this._freedGraphics.pop() || // use the first boundingRect to avoid duplicated boundingRect calculation.
        this._buildGraphic(this._parsedXML)
        usedRootMap.set(hostKey, svgGraphic) // PENDING: `nameMap` will not be supported until some real requirement come.
        // `nameMap` can only be obtained from echarts option.
        // The original `named` must not be modified.
        // if (nameMap) {
        //     svgGraphic = extend({}, svgGraphic);
        //     svgGraphic.named = applyNameMap(svgGraphic.named, nameMap);
        // }

        return svgGraphic
      }

      GeoSVGResource.prototype.freeGraphic = function (hostKey) {
        const usedRootMap = this._usedGraphicMap
        const svgGraphic = usedRootMap.get(hostKey)

        if (svgGraphic) {
          usedRootMap.removeKey(hostKey)

          this._freedGraphics.push(svgGraphic)
        }
      }

      return GeoSVGResource
    }())

  function setSilent (el) {
    // Only named element has silent: false, other elements should
    // act as background and has no user interaction.
    el.silent = false // text|tspan will be converted to group.

    if (el.isGroup) {
      el.traverse(function (child) {
        child.silent = false
      })
    }
  }

  function createRegions (named) {
    const regions = []
    const regionsMap = createHashMap() // Create resions only for the first graphic.

    each(named, function (namedItem) {
      // Region has feature to calculate center for tooltip or other features.
      // If there is a <g name="xxx">, the center should be the center of the
      // bounding rect of the g.
      if (namedItem.namedFrom != null) {
        return
      }

      const region = new GeoSVGRegion(namedItem.name, namedItem.el) // PENDING: if `nameMap` supported, this region can not be mounted on
      // `this`, but can only be created each time `load()` called.

      regions.push(region) // PENDING: if multiple tag named with the same name, only one will be
      // found by `_regionsMap`. `_regionsMap` is used to find a coordinate
      // by name. We use `region.getCenter()` as the coordinate.

      regionsMap.set(namedItem.name, region)
    })
    return {
      regions: regions,
      regionsMap: regionsMap
    }
  } // PENDING: `nameMap` will not be supported until some real requirement come.
  // /**
  //  * Use the alias in geoNameMap.
  //  * The input `named` must not be modified.
  //  */
  // function applyNameMap(
  //     named: GeoSVGGraphicRecord['named'],
  //     nameMap: NameMap
  // ): GeoSVGGraphicRecord['named'] {
  //     const result = [] as GeoSVGGraphicRecord['named'];
  //     for (let i = 0; i < named.length; i++) {
  //         let regionGraphic = named[i];
  //         const name = regionGraphic.name;
  //         if (nameMap && nameMap.hasOwnProperty(name)) {
  //             regionGraphic = extend({}, regionGraphic);
  //             regionGraphic.name = name;
  //         }
  //         result.push(regionGraphic);
  //     }
  //     return result;
  // }

  const geoCoord = [126, 25]
  const nanhaiName = '南海诸岛'
  const points$1 = [[[0, 3.5], [7, 11.2], [15, 11.9], [30, 7], [42, 0.7], [52, 0.7], [56, 7.7], [59, 0.7], [64, 0.7], [64, 0], [5, 0], [0, 3.5]], [[13, 16.1], [19, 14.7], [16, 21.7], [11, 23.1], [13, 16.1]], [[12, 32.2], [14, 38.5], [15, 38.5], [13, 32.2], [12, 32.2]], [[16, 47.6], [12, 53.2], [13, 53.2], [18, 47.6], [16, 47.6]], [[6, 64.4], [8, 70], [9, 70], [8, 64.4], [6, 64.4]], [[23, 82.6], [29, 79.8], [30, 79.8], [25, 82.6], [23, 82.6]], [[37, 70.7], [43, 62.3], [44, 62.3], [39, 70.7], [37, 70.7]], [[48, 51.1], [51, 45.5], [53, 45.5], [50, 51.1], [48, 51.1]], [[51, 35], [51, 28.7], [53, 28.7], [53, 35], [51, 35]], [[52, 22.4], [55, 17.5], [56, 17.5], [53, 22.4], [52, 22.4]], [[58, 12.6], [62, 7], [63, 7], [60, 12.6], [58, 12.6]], [[0, 3.5], [0, 93.1], [64, 93.1], [64, 0], [63, 0], [63, 92.4], [1, 92.4], [1, 3.5], [0, 3.5]]]

  for (let i = 0; i < points$1.length; i++) {
    for (let k = 0; k < points$1[i].length; k++) {
      points$1[i][k][0] /= 10.5
      points$1[i][k][1] /= -10.5 / 0.75
      points$1[i][k][0] += geoCoord[0]
      points$1[i][k][1] += geoCoord[1]
    }
  }

  function fixNanhai (mapType, regions) {
    if (mapType === 'china') {
      for (let i = 0; i < regions.length; i++) {
        // Already exists.
        if (regions[i].name === nanhaiName) {
          return
        }
      }

      regions.push(new GeoJSONRegion(nanhaiName, map(points$1, function (exterior) {
        return {
          type: 'polygon',
          exterior: exterior
        }
      }), geoCoord))
    }
  }

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

  /**
     * AUTO-GENERATED FILE. DO NOT MODIFY.
     */

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
  const coordsOffsetMap = {
    南海诸岛: [32, 80],
    // 全国
    广东: [0, -10],
    香港: [10, 5],
    澳门: [-10, 10],
    // '北京': [-10, 0],
    天津: [5, 5]
  }
  function fixTextCoords (mapType, region) {
    if (mapType === 'china') {
      const coordFix = coordsOffsetMap[region.name]

      if (coordFix) {
        const cp = region.getCenter()
        cp[0] += coordFix[0] / 10.5
        cp[1] += -coordFix[1] / (10.5 / 0.75)
        region.setCenter(cp)
      }
    }
  }

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

  /**
     * AUTO-GENERATED FILE. DO NOT MODIFY.
     */

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
  // Fix for 钓鱼岛
  // let Region = require('../Region');
  // let zrUtil = require('zrender/lib/core/util');
  // let geoCoord = [126, 25];
  const points$2 = [[[123.45165252685547, 25.73527164402261], [123.49731445312499, 25.73527164402261], [123.49731445312499, 25.750734064600884], [123.45165252685547, 25.750734064600884], [123.45165252685547, 25.73527164402261]]]
  function fixDiaoyuIsland (mapType, region) {
    if (mapType === 'china' && region.name === '台湾') {
      region.geometries.push({
        type: 'polygon',
        exterior: points$2[0]
      })
    }
  }

  const DEFAULT_NAME_PROPERTY = 'name'

  const GeoJSONResource =
    /** @class */
    (function () {
      function GeoJSONResource (mapName, geoJSON, specialAreas) {
        this.type = 'geoJSON'
        this._parsedMap = createHashMap()
        this._mapName = mapName
        this._specialAreas = specialAreas // PENDING: delay the parse to the first usage to rapid up the FMP?

        this._geoJSON = parseInput(geoJSON)
      }
      /**
       * @param nameMap can be null/undefined
       * @param nameProperty can be null/undefined
       */

      GeoJSONResource.prototype.load = function (nameMap, nameProperty) {
        nameProperty = nameProperty || DEFAULT_NAME_PROPERTY

        let parsed = this._parsedMap.get(nameProperty)

        if (!parsed) {
          const rawRegions = this._parseToRegions(nameProperty)

          parsed = this._parsedMap.set(nameProperty, {
            regions: rawRegions,
            boundingRect: calculateBoundingRect(rawRegions)
          })
        }

        const regionsMap = createHashMap()
        const finalRegions = []
        each(parsed.regions, function (region) {
          let regionName = region.name // Try use the alias in geoNameMap

          if (nameMap && hasOwn(nameMap, regionName)) {
            region = region.cloneShallow(regionName = nameMap[regionName])
          }

          finalRegions.push(region)
          regionsMap.set(regionName, region)
        })
        return {
          regions: finalRegions,
          boundingRect: parsed.boundingRect || new BoundingRect(0, 0, 0, 0),
          regionsMap: regionsMap
        }
      }

      GeoJSONResource.prototype._parseToRegions = function (nameProperty) {
        const mapName = this._mapName
        const geoJSON = this._geoJSON
        let rawRegions // https://jsperf.com/try-catch-performance-overhead

        try {
          rawRegions = geoJSON ? parseGeoJSON(geoJSON, nameProperty) : []
        } catch (e) {
          throw new Error('Invalid geoJson format\n' + e.message)
        }

        fixNanhai(mapName, rawRegions)
        each(rawRegions, function (region) {
          const regionName = region.name
          fixTextCoords(mapName, region)
          fixDiaoyuIsland(mapName, region) // Some area like Alaska in USA map needs to be tansformed
          // to look better

          const specialArea = this._specialAreas && this._specialAreas[regionName]

          if (specialArea) {
            region.transformTo(specialArea.left, specialArea.top, specialArea.width, specialArea.height)
          }
        }, this)
        return rawRegions
      }
      /**
       * Only for exporting to users.
       * **MUST NOT** used internally.
       */

      GeoJSONResource.prototype.getMapForUser = function () {
        return {
          // For backward compatibility, use geoJson
          // PENDING: it has been returning them without clone.
          // do we need to avoid outsite modification?
          geoJson: this._geoJSON,
          geoJSON: this._geoJSON,
          specialAreas: this._specialAreas
        }
      }

      return GeoJSONResource
    }())

  function calculateBoundingRect (regions) {
    let rect

    for (let i = 0; i < regions.length; i++) {
      const regionRect = regions[i].getBoundingRect()
      rect = rect || regionRect.clone()
      rect.union(regionRect)
    }

    return rect
  }

  function parseInput (source) {
    return !isString(source) ? source : typeof JSON !== 'undefined' && JSON.parse ? JSON.parse(source) : new Function('return (' + source + ');')()
  }

  const storage = createHashMap()
  const geoSourceManager = {
    /**
       * Compatible with previous `echarts.registerMap`.
       *
       * @usage
       * ```js
       *
       * echarts.registerMap('USA', geoJson, specialAreas);
       *
       * echarts.registerMap('USA', {
       *     geoJson: geoJson,
       *     specialAreas: {...}
       * });
       * echarts.registerMap('USA', {
       *     geoJSON: geoJson,
       *     specialAreas: {...}
       * });
       *
       * echarts.registerMap('airport', {
       *     svg: svg
       * }
       * ```
       *
       * Note:
       * Do not support that register multiple geoJSON or SVG
       * one map name. Because different geoJSON and SVG have
       * different unit. It's not easy to make sure how those
       * units are mapping/normalize.
       * If intending to use multiple geoJSON or SVG, we can
       * use multiple geo coordinate system.
       */
    registerMap: function (mapName, rawDef, rawSpecialAreas) {
      if (rawDef.svg) {
        var resource = new GeoSVGResource(mapName, rawDef.svg)
        storage.set(mapName, resource)
      } else {
        // Recommend:
        //     echarts.registerMap('eu', { geoJSON: xxx, specialAreas: xxx });
        // Backward compatibility:
        //     echarts.registerMap('eu', geoJSON, specialAreas);
        //     echarts.registerMap('eu', { geoJson: xxx, specialAreas: xxx });
        let geoJSON = rawDef.geoJson || rawDef.geoJSON

        if (geoJSON && !rawDef.features) {
          rawSpecialAreas = rawDef.specialAreas
        } else {
          geoJSON = rawDef
        }

        var resource = new GeoJSONResource(mapName, geoJSON, rawSpecialAreas)
        storage.set(mapName, resource)
      }
    },
    getGeoResource: function (mapName) {
      return storage.get(mapName)
    },

    /**
       * Only for exporting to users.
       * **MUST NOT** used internally.
       */
    getMapForUser: function (mapName) {
      const resource = storage.get(mapName) // Do not support return SVG until some real requirement come.

      return resource && resource.type === 'geoJSON' && resource.getMapForUser()
    },
    load: function (mapName, nameMap, nameProperty) {
      const resource = storage.get(mapName)

      if (!resource) {
        if ('development' !== 'production') {
          console.error('Map ' + mapName + ' not exists. The GeoJSON of the map must be provided.')
        }

        return
      }

      return resource.load(nameMap, nameProperty)
    }
  }

  /**
     * Only these tags enable use `itemStyle` if they are named in SVG.
     * Other tags like <text> <tspan> <image> might not suitable for `itemStyle`.
     * They will not be considered to be styled until some requirements come.
     */

  const OPTION_STYLE_ENABLED_TAGS = ['rect', 'circle', 'line', 'ellipse', 'polygon', 'polyline', 'path']
  const OPTION_STYLE_ENABLED_TAG_MAP = createHashMap(OPTION_STYLE_ENABLED_TAGS)
  const STATE_TRIGGER_TAG_MAP = createHashMap(OPTION_STYLE_ENABLED_TAGS.concat(['g']))
  const LABEL_HOST_MAP = createHashMap(OPTION_STYLE_ENABLED_TAGS.concat(['g']))
  const mapLabelRaw = makeInner()

  function getFixedItemStyle (model) {
    const itemStyle = model.getItemStyle()
    const areaColor = model.get('areaColor') // If user want the color not to be changed when hover,
    // they should both set areaColor and color to be null.

    if (areaColor != null) {
      itemStyle.fill = areaColor
    }

    return itemStyle
  } // Only stroke can be used for line.
  // Using fill in style if stroke not exits.
  // TODO Not sure yet. Perhaps a separate `lineStyle`?

  function fixLineStyle (styleHost) {
    const style = styleHost.style

    if (style) {
      style.stroke = style.stroke || style.fill
      style.fill = null
    }
  }

  const MapDraw =
    /** @class */
    (function () {
      function MapDraw (api) {
        const group = new Group()
        this.uid = getUID('ec_map_draw')
        this._controller = new RoamController(api.getZr())
        this._controllerHost = {
          target: group
        }
        this.group = group
        group.add(this._regionsGroup = new Group())
        group.add(this._svgGroup = new Group())
      }

      MapDraw.prototype.draw = function (mapOrGeoModel, ecModel, api, fromView, payload) {
        const isGeo = mapOrGeoModel.mainType === 'geo' // Map series has data. GEO model that controlled by map series
        // will be assigned with map data. Other GEO model has no data.

        let data = mapOrGeoModel.getData && mapOrGeoModel.getData()
        isGeo && ecModel.eachComponent({
          mainType: 'series',
          subType: 'map'
        }, function (mapSeries) {
          if (!data && mapSeries.getHostGeoModel() === mapOrGeoModel) {
            data = mapSeries.getData()
          }
        })
        const geo = mapOrGeoModel.coordinateSystem
        const regionsGroup = this._regionsGroup
        const group = this.group
        const transformInfo = geo.getTransformInfo()
        const transformInfoRaw = transformInfo.raw
        const transformInfoRoam = transformInfo.roam // No animation when first draw or in action

        const isFirstDraw = !regionsGroup.childAt(0) || payload

        if (isFirstDraw) {
          group.x = transformInfoRoam.x
          group.y = transformInfoRoam.y
          group.scaleX = transformInfoRoam.scaleX
          group.scaleY = transformInfoRoam.scaleY
          group.dirty()
        } else {
          updateProps(group, transformInfoRoam, mapOrGeoModel)
        }

        const isVisualEncodedByVisualMap = data && data.getVisual('visualMeta') && data.getVisual('visualMeta').length > 0
        const viewBuildCtx = {
          api: api,
          geo: geo,
          mapOrGeoModel: mapOrGeoModel,
          data: data,
          isVisualEncodedByVisualMap: isVisualEncodedByVisualMap,
          isGeo: isGeo,
          transformInfoRaw: transformInfoRaw
        }

        if (geo.resourceType === 'geoJSON') {
          this._buildGeoJSON(viewBuildCtx)
        } else if (geo.resourceType === 'geoSVG') {
          this._buildSVG(viewBuildCtx)
        }

        this._updateController(mapOrGeoModel, ecModel, api)

        this._updateMapSelectHandler(mapOrGeoModel, regionsGroup, api, fromView)
      }

      MapDraw.prototype._buildGeoJSON = function (viewBuildCtx) {
        const regionsGroupByName = this._regionsGroupByName = createHashMap()
        const regionsInfoByName = createHashMap()
        const regionsGroup = this._regionsGroup
        const transformInfoRaw = viewBuildCtx.transformInfoRaw
        const mapOrGeoModel = viewBuildCtx.mapOrGeoModel
        const data = viewBuildCtx.data
        const projection = viewBuildCtx.geo.projection
        const projectionStream = projection && projection.stream

        function transformPoint (point, project) {
          if (project) {
            // projection may return null point.
            point = project(point)
          }

          return point && [point[0] * transformInfoRaw.scaleX + transformInfoRaw.x, point[1] * transformInfoRaw.scaleY + transformInfoRaw.y]
        }

        function transformPolygonPoints (inPoints) {
          const outPoints = [] // If projectionStream is provided. Use it instead of single point project.

          const project = !projectionStream && projection && projection.project

          for (let i = 0; i < inPoints.length; ++i) {
            const newPt = transformPoint(inPoints[i], project)
            newPt && outPoints.push(newPt)
          }

          return outPoints
        }

        function getPolyShape (points) {
          return {
            shape: {
              points: transformPolygonPoints(points)
            }
          }
        }

        regionsGroup.removeAll() // Only when the resource is GeoJSON, there is `geo.regions`.

        each(viewBuildCtx.geo.regions, function (region) {
          const regionName = region.name // Consider in GeoJson properties.name may be duplicated, for example,
          // there is multiple region named "United Kindom" or "France" (so many
          // colonies). And it is not appropriate to merge them in geo, which
          // will make them share the same label and bring trouble in label
          // location calculation.

          let regionGroup = regionsGroupByName.get(regionName)

          const _a = regionsInfoByName.get(regionName) || {}
          let dataIdx = _a.dataIdx
          let regionModel = _a.regionModel

          if (!regionGroup) {
            regionGroup = regionsGroupByName.set(regionName, new Group())
            regionsGroup.add(regionGroup)
            dataIdx = data ? data.indexOfName(regionName) : null
            regionModel = viewBuildCtx.isGeo ? mapOrGeoModel.getRegionModel(regionName) : data ? data.getItemModel(dataIdx) : null
            regionsInfoByName.set(regionName, {
              dataIdx: dataIdx,
              regionModel: regionModel
            })
          }

          const polygonSubpaths = []
          const polylineSubpaths = []
          each(region.geometries, function (geometry) {
            // Polygon and MultiPolygon
            if (geometry.type === 'polygon') {
              let polys = [geometry.exterior].concat(geometry.interiors || [])

              if (projectionStream) {
                polys = projectPolys(polys, projectionStream)
              }

              each(polys, function (poly) {
                polygonSubpaths.push(new Polygon(getPolyShape(poly)))
              })
            } // LineString and MultiLineString
            else {
              let points = geometry.points

              if (projectionStream) {
                points = projectPolys(points, projectionStream, true)
              }

              each(points, function (points) {
                polylineSubpaths.push(new Polyline(getPolyShape(points)))
              })
            }
          })
          const centerPt = transformPoint(region.getCenter(), projection && projection.project)

          function createCompoundPath (subpaths, isLine) {
            if (!subpaths.length) {
              return
            }

            const compoundPath = new CompoundPath({
              culling: true,
              segmentIgnoreThreshold: 1,
              shape: {
                paths: subpaths
              }
            })
            regionGroup.add(compoundPath)
            applyOptionStyleForRegion(viewBuildCtx, compoundPath, dataIdx, regionModel)
            resetLabelForRegion(viewBuildCtx, compoundPath, regionName, regionModel, mapOrGeoModel, dataIdx, centerPt)

            if (isLine) {
              fixLineStyle(compoundPath)
              each(compoundPath.states, fixLineStyle)
            }
          }

          createCompoundPath(polygonSubpaths)
          createCompoundPath(polylineSubpaths, true)
        }) // Ensure children have been added to `regionGroup` before calling them.

        regionsGroupByName.each(function (regionGroup, regionName) {
          const _a = regionsInfoByName.get(regionName)
          const dataIdx = _a.dataIdx
          const regionModel = _a.regionModel

          resetEventTriggerForRegion(viewBuildCtx, regionGroup, regionName, regionModel, mapOrGeoModel, dataIdx)
          resetTooltipForRegion(viewBuildCtx, regionGroup, regionName, regionModel, mapOrGeoModel)
          resetStateTriggerForRegion(viewBuildCtx, regionGroup, regionName, regionModel, mapOrGeoModel)
        }, this)
      }

      MapDraw.prototype._buildSVG = function (viewBuildCtx) {
        const mapName = viewBuildCtx.geo.map
        const transformInfoRaw = viewBuildCtx.transformInfoRaw
        this._svgGroup.x = transformInfoRaw.x
        this._svgGroup.y = transformInfoRaw.y
        this._svgGroup.scaleX = transformInfoRaw.scaleX
        this._svgGroup.scaleY = transformInfoRaw.scaleY

        if (this._svgResourceChanged(mapName)) {
          this._freeSVG()

          this._useSVG(mapName)
        }

        const svgDispatcherMap = this._svgDispatcherMap = createHashMap()
        let focusSelf = false
        each(this._svgGraphicRecord.named, function (namedItem) {
          // Note that we also allow different elements have the same name.
          // For example, a glyph of a city and the label of the city have
          // the same name and their tooltip info can be defined in a single
          // region option.
          const regionName = namedItem.name
          const mapOrGeoModel = viewBuildCtx.mapOrGeoModel
          const data = viewBuildCtx.data
          const svgNodeTagLower = namedItem.svgNodeTagLower
          const el = namedItem.el
          const dataIdx = data ? data.indexOfName(regionName) : null
          const regionModel = mapOrGeoModel.getRegionModel(regionName)

          if (OPTION_STYLE_ENABLED_TAG_MAP.get(svgNodeTagLower) != null && el instanceof Displayable) {
            applyOptionStyleForRegion(viewBuildCtx, el, dataIdx, regionModel)
          }

          if (el instanceof Displayable) {
            el.culling = true
          } // We do not know how the SVG like so we'd better not to change z2.
          // Otherwise it might bring some unexpected result. For example,
          // an area hovered that make some inner city can not be clicked.

          el.z2EmphasisLift = 0 // If self named:

          if (!namedItem.namedFrom) {
            // label should batter to be displayed based on the center of <g>
            // if it is named rather than displayed on each child.
            if (LABEL_HOST_MAP.get(svgNodeTagLower) != null) {
              resetLabelForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel, dataIdx, null)
            }

            resetEventTriggerForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel, dataIdx)
            resetTooltipForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel)

            if (STATE_TRIGGER_TAG_MAP.get(svgNodeTagLower) != null) {
              const focus_1 = resetStateTriggerForRegion(viewBuildCtx, el, regionName, regionModel, mapOrGeoModel)

              if (focus_1 === 'self') {
                focusSelf = true
              }

              const els = svgDispatcherMap.get(regionName) || svgDispatcherMap.set(regionName, [])
              els.push(el)
            }
          }
        }, this)

        this._enableBlurEntireSVG(focusSelf, viewBuildCtx)
      }

      MapDraw.prototype._enableBlurEntireSVG = function (focusSelf, viewBuildCtx) {
        // It's a little complicated to support blurring the entire geoSVG in series-map.
        // So do not suport it until some requirements come.
        // At present, in series-map, only regions can be blurred.
        if (focusSelf && viewBuildCtx.isGeo) {
          const blurStyle = viewBuildCtx.mapOrGeoModel.getModel(['blur', 'itemStyle']).getItemStyle() // Only suport `opacity` here. Because not sure that other props are suitable for
          // all of the elements generated by SVG (especially for Text/TSpan/Image/... ).

          const opacity_1 = blurStyle.opacity

          this._svgGraphicRecord.root.traverse(function (el) {
            if (!el.isGroup) {
              // PENDING: clear those settings to SVG elements when `_freeSVG`.
              // (Currently it happen not to be needed.)
              setDefaultStateProxy(el)
              const style = el.ensureState('blur').style || {} // Do not overwrite the region style that already set from region option.

              if (style.opacity == null && opacity_1 != null) {
                style.opacity = opacity_1
              } // If `ensureState('blur').style = {}`, there will be default opacity.
              // Enable `stateTransition` (animation).

              el.ensureState('emphasis')
            }
          })
        }
      }

      MapDraw.prototype.remove = function () {
        this._regionsGroup.removeAll()

        this._regionsGroupByName = null

        this._svgGroup.removeAll()

        this._freeSVG()

        this._controller.dispose()

        this._controllerHost = null
      }

      MapDraw.prototype.findHighDownDispatchers = function (name, geoModel) {
        if (name == null) {
          return []
        }

        const geo = geoModel.coordinateSystem

        if (geo.resourceType === 'geoJSON') {
          const regionsGroupByName = this._regionsGroupByName

          if (regionsGroupByName) {
            const regionGroup = regionsGroupByName.get(name)
            return regionGroup ? [regionGroup] : []
          }
        } else if (geo.resourceType === 'geoSVG') {
          return this._svgDispatcherMap && this._svgDispatcherMap.get(name) || []
        }
      }

      MapDraw.prototype._svgResourceChanged = function (mapName) {
        return this._svgMapName !== mapName
      }

      MapDraw.prototype._useSVG = function (mapName) {
        const resource = geoSourceManager.getGeoResource(mapName)

        if (resource && resource.type === 'geoSVG') {
          const svgGraphic = resource.useGraphic(this.uid)

          this._svgGroup.add(svgGraphic.root)

          this._svgGraphicRecord = svgGraphic
          this._svgMapName = mapName
        }
      }

      MapDraw.prototype._freeSVG = function () {
        const mapName = this._svgMapName

        if (mapName == null) {
          return
        }

        const resource = geoSourceManager.getGeoResource(mapName)

        if (resource && resource.type === 'geoSVG') {
          resource.freeGraphic(this.uid)
        }

        this._svgGraphicRecord = null
        this._svgDispatcherMap = null

        this._svgGroup.removeAll()

        this._svgMapName = null
      }

      MapDraw.prototype._updateController = function (mapOrGeoModel, ecModel, api) {
        const geo = mapOrGeoModel.coordinateSystem
        const controller = this._controller
        const controllerHost = this._controllerHost // @ts-ignore FIXME:TS

        controllerHost.zoomLimit = mapOrGeoModel.get('scaleLimit')
        controllerHost.zoom = geo.getZoom() // roamType is will be set default true if it is null
        // @ts-ignore FIXME:TS

        controller.enable(mapOrGeoModel.get('roam') || false)
        const mainType = mapOrGeoModel.mainType

        function makeActionBase () {
          const action = {
            type: 'geoRoam',
            componentType: mainType
          }
          action[mainType + 'Id'] = mapOrGeoModel.id
          return action
        }

        controller.off('pan').on('pan', function (e) {
          this._mouseDownFlag = false
          updateViewOnPan(controllerHost, e.dx, e.dy)
          api.dispatchAction(extend(makeActionBase(), {
            dx: e.dx,
            dy: e.dy,
            animation: {
              duration: 0
            }
          }))
        }, this)
        controller.off('zoom').on('zoom', function (e) {
          this._mouseDownFlag = false
          updateViewOnZoom(controllerHost, e.scale, e.originX, e.originY)
          api.dispatchAction(extend(makeActionBase(), {
            zoom: e.scale,
            originX: e.originX,
            originY: e.originY,
            animation: {
              duration: 0
            }
          }))
        }, this)
        controller.setPointerChecker(function (e, x, y) {
          return geo.containPoint([x, y]) && !onIrrelevantElement(e, api, mapOrGeoModel)
        })
      }
      /**
       * FIXME: this is a temporarily workaround.
       * When `geoRoam` the elements need to be reset in `MapView['render']`, because the props like
       * `ignore` might have been modified by `LabelManager`, and `LabelManager#addLabelsOfSeries`
       * will subsequently cache `defaultAttr` like `ignore`. If do not do this reset, the modified
       * props will have no chance to be restored.
       * Note: this reset should be after `clearStates` in `renderSeries` becuase `useStates` in
       * `renderSeries` will cache the modified `ignore` to `el._normalState`.
       * TODO:
       * Use clone/immutable in `LabelManager`?
       */

      MapDraw.prototype.resetForLabelLayout = function () {
        this.group.traverse(function (el) {
          const label = el.getTextContent()

          if (label) {
            label.ignore = mapLabelRaw(label).ignore
          }
        })
      }

      MapDraw.prototype._updateMapSelectHandler = function (mapOrGeoModel, regionsGroup, api, fromView) {
        const mapDraw = this
        regionsGroup.off('mousedown')
        regionsGroup.off('click') // @ts-ignore FIXME:TS resolve type conflict

        if (mapOrGeoModel.get('selectedMode')) {
          regionsGroup.on('mousedown', function () {
            mapDraw._mouseDownFlag = true
          })
          regionsGroup.on('click', function (e) {
            if (!mapDraw._mouseDownFlag) {
              return
            }

            mapDraw._mouseDownFlag = false
          })
        }
      }

      return MapDraw
    }())

  function applyOptionStyleForRegion (viewBuildCtx, el, dataIndex, regionModel) {
    // All of the path are using `itemStyle`, becuase
    // (1) Some SVG also use fill on polyline (The different between
    // polyline and polygon is "open" or "close" but not fill or not).
    // (2) For the common props like opacity, if some use itemStyle
    // and some use `lineStyle`, it might confuse users.
    // (3) Most SVG use <path>, where can not detect wether draw a "line"
    // or a filled shape, so use `itemStyle` for <path>.
    const normalStyleModel = regionModel.getModel('itemStyle')
    const emphasisStyleModel = regionModel.getModel(['emphasis', 'itemStyle'])
    const blurStyleModel = regionModel.getModel(['blur', 'itemStyle'])
    const selectStyleModel = regionModel.getModel(['select', 'itemStyle']) // NOTE: DONT use 'style' in visual when drawing map.
    // This component is used for drawing underlying map for both geo component and map series.

    const normalStyle = getFixedItemStyle(normalStyleModel)
    const emphasisStyle = getFixedItemStyle(emphasisStyleModel)
    const selectStyle = getFixedItemStyle(selectStyleModel)
    const blurStyle = getFixedItemStyle(blurStyleModel) // Update the itemStyle if has data visual

    const data = viewBuildCtx.data

    if (data) {
      // Only visual color of each item will be used. It can be encoded by visualMap
      // But visual color of series is used in symbol drawing
      // Visual color for each series is for the symbol draw
      const style = data.getItemVisual(dataIndex, 'style')
      const decal = data.getItemVisual(dataIndex, 'decal')

      if (viewBuildCtx.isVisualEncodedByVisualMap && style.fill) {
        normalStyle.fill = style.fill
      }

      if (decal) {
        normalStyle.decal = createOrUpdatePatternFromDecal(decal, viewBuildCtx.api)
      }
    } // SVG text, tspan and image can be named but not supporeted
    // to be styled by region option yet.

    el.setStyle(normalStyle)
    el.style.strokeNoScale = true
    el.ensureState('emphasis').style = emphasisStyle
    el.ensureState('select').style = selectStyle
    el.ensureState('blur').style = blurStyle // Enable blur

    setDefaultStateProxy(el)
  }

  function resetLabelForRegion (viewBuildCtx, el, regionName, regionModel, mapOrGeoModel, // Exist only if `viewBuildCtx.data` exists.
    dataIdx, // If labelXY not provided, use `textConfig.position: 'inside'`
    labelXY) {
    const data = viewBuildCtx.data
    const isGeo = viewBuildCtx.isGeo
    const isDataNaN = data && isNaN(data.get(data.mapDimension('value'), dataIdx))
    const itemLayout = data && data.getItemLayout(dataIdx) // In the following cases label will be drawn
    // 1. In map series and data value is NaN
    // 2. In geo component
    // 3. Region has no series legendIcon, which will be add a showLabel flag in mapSymbolLayout

    if (isGeo || isDataNaN || itemLayout && itemLayout.showLabel) {
      const query = !isGeo ? dataIdx : regionName
      let labelFetcher = void 0 // Consider dataIdx not found.

      if (!data || dataIdx >= 0) {
        labelFetcher = mapOrGeoModel
      }

      const specifiedTextOpt = labelXY
        ? {
            normal: {
              align: 'center',
              verticalAlign: 'middle'
            }
          }
        : null // Caveat: must be called after `setDefaultStateProxy(el);` called.
        // because textContent will be assign with `el.stateProxy` inside.

      setLabelStyle(el, getLabelStatesModels(regionModel), {
        labelFetcher: labelFetcher,
        labelDataIndex: query,
        defaultText: regionName
      }, specifiedTextOpt)
      const textEl = el.getTextContent()

      if (textEl) {
        mapLabelRaw(textEl).ignore = textEl.ignore

        if (el.textConfig && labelXY) {
          // Compute a relative offset based on the el bounding rect.
          const rect = el.getBoundingRect().clone() // Need to make sure the percent position base on the same rect in normal and
          // emphasis state. Otherwise if using boundingRect of el, but the emphasis state
          // has borderWidth (even 0.5px), the text position will be changed obviously
          // if the position is very big like ['1234%', '1345%'].

          el.textConfig.layoutRect = rect
          el.textConfig.position = [(labelXY[0] - rect.x) / rect.width * 100 + '%', (labelXY[1] - rect.y) / rect.height * 100 + '%']
        }
      } // PENDING:
      // If labelLayout is enabled (test/label-layout.html), el.dataIndex should be specified.
      // But el.dataIndex is also used to determine whether user event should be triggered,
      // where el.seriesIndex or el.dataModel must be specified. At present for a single el
      // there is not case that "only label layout enabled but user event disabled", so here
      // we depends `resetEventTriggerForRegion` to do the job of setting `el.dataIndex`.

      el.disableLabelAnimation = true
    } else {
      el.removeTextContent()
      el.removeTextConfig()
      el.disableLabelAnimation = null
    }
  }

  function resetEventTriggerForRegion (viewBuildCtx, eventTrigger, regionName, regionModel, mapOrGeoModel, // Exist only if `viewBuildCtx.data` exists.
    dataIdx) {
    // setItemGraphicEl, setHoverStyle after all polygons and labels
    // are added to the rigionGroup
    if (viewBuildCtx.data) {
      // FIXME: when series-map use a SVG map, and there are duplicated name specified
      // on different SVG elements, after `data.setItemGraphicEl(...)`:
      // (1) all of them will be mounted with `dataIndex`, `seriesIndex`, so that tooltip
      // can be triggered only mouse hover. That's correct.
      // (2) only the last element will be kept in `data`, so that if trigger tooltip
      // by `dispatchAction`, only the last one can be found and triggered. That might be
      // not correct. We will fix it in future if anyone demanding that.
      viewBuildCtx.data.setItemGraphicEl(dataIdx, eventTrigger)
    } // series-map will not trigger "geoselectchange" no matter it is
    // based on a declared geo component. Becuause series-map will
    // trigger "selectchange". If it trigger both the two events,
    // If users call `chart.dispatchAction({type: 'toggleSelect'})`,
    // it not easy to also fire event "geoselectchanged".
    else {
      // Package custom mouse event for geo component
      getECData(eventTrigger).eventData = {
        componentType: 'geo',
        componentIndex: mapOrGeoModel.componentIndex,
        geoIndex: mapOrGeoModel.componentIndex,
        name: regionName,
        region: regionModel && regionModel.option || {}
      }
    }
  }

  function resetTooltipForRegion (viewBuildCtx, el, regionName, regionModel, mapOrGeoModel) {
    if (!viewBuildCtx.data) {
      setTooltipConfig({
        el: el,
        componentModel: mapOrGeoModel,
        itemName: regionName,
        // @ts-ignore FIXME:TS fix the "compatible with each other"?
        itemTooltipOption: regionModel.get('tooltip')
      })
    }
  }

  function resetStateTriggerForRegion (viewBuildCtx, el, regionName, regionModel, mapOrGeoModel) {
    // @ts-ignore FIXME:TS fix the "compatible with each other"?
    el.highDownSilentOnTouch = !!mapOrGeoModel.get('selectedMode') // @ts-ignore FIXME:TS fix the "compatible with each other"?

    const emphasisModel = regionModel.getModel('emphasis')
    const focus = emphasisModel.get('focus')
    toggleHoverEmphasis(el, focus, emphasisModel.get('blurScope'), emphasisModel.get('disabled'))

    if (viewBuildCtx.isGeo) {
      enableComponentHighDownFeatures(el, mapOrGeoModel, regionName)
    }

    return focus
  }

  function projectPolys (rings, // Polygons include exterior and interiors. Or polylines.
    createStream, isLine) {
    const polygons = []
    let curPoly

    function startPolygon () {
      curPoly = []
    }

    function endPolygon () {
      if (curPoly.length) {
        polygons.push(curPoly)
        curPoly = []
      }
    }

    const stream = createStream({
      polygonStart: startPolygon,
      polygonEnd: endPolygon,
      lineStart: startPolygon,
      lineEnd: endPolygon,
      point: function (x, y) {
        // May have NaN values from stream.
        if (isFinite(x) && isFinite(y)) {
          curPoly.push([x, y])
        }
      },
      sphere: function () {}
    })
    !isLine && stream.polygonStart()
    each(rings, function (ring) {
      stream.lineStart()

      for (let i = 0; i < ring.length; i++) {
        stream.point(ring[i][0], ring[i][1])
      }

      stream.lineEnd()
    })
    !isLine && stream.polygonEnd()
    return polygons
  }
  // @ts-ignore FIXME:TS fix the "compatible with each other"?

  const MapView =
    /** @class */
    (function (_super) {
      __extends(MapView, _super)

      function MapView () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = MapView.type
        return _this
      }

      MapView.prototype.render = function (mapModel, ecModel, api, payload) {
        // Not render if it is an toggleSelect action from self
        if (payload && payload.type === 'mapToggleSelect' && payload.from === this.uid) {
          return
        }

        const group = this.group
        group.removeAll()

        if (mapModel.getHostGeoModel()) {
          return
        }

        if (this._mapDraw && payload && payload.type === 'geoRoam') {
          this._mapDraw.resetForLabelLayout()
        } // Not update map if it is an roam action from self

        if (!(payload && payload.type === 'geoRoam' && payload.componentType === 'series' && payload.seriesId === mapModel.id)) {
          if (mapModel.needsDrawMap) {
            var mapDraw = this._mapDraw || new MapDraw(api)
            group.add(mapDraw.group)
            mapDraw.draw(mapModel, ecModel, api, this, payload)
            this._mapDraw = mapDraw
          } else {
            // Remove drawed map
            this._mapDraw && this._mapDraw.remove()
            this._mapDraw = null
          }
        } else {
          var mapDraw = this._mapDraw
          mapDraw && group.add(mapDraw.group)
        }

        mapModel.get('showLegendSymbol') && ecModel.getComponent('legend') && this._renderSymbols(mapModel, ecModel, api)
      }

      MapView.prototype.remove = function () {
        this._mapDraw && this._mapDraw.remove()
        this._mapDraw = null
        this.group.removeAll()
      }

      MapView.prototype.dispose = function () {
        this._mapDraw && this._mapDraw.remove()
        this._mapDraw = null
      }

      MapView.prototype._renderSymbols = function (mapModel, ecModel, api) {
        const originalData = mapModel.originalData
        const group = this.group
        originalData.each(originalData.mapDimension('value'), function (value, originalDataIndex) {
          if (isNaN(value)) {
            return
          }

          const layout = originalData.getItemLayout(originalDataIndex)

          if (!layout || !layout.point) {
            // Not exists in map
            return
          }

          const point = layout.point
          const offset = layout.offset
          const circle = new Circle({
            style: {
              // Because the special of map draw.
              // Which needs statistic of multiple series and draw on one map.
              // And each series also need a symbol with legend color
              //
              // Layout and visual are put one the different data
              // TODO
              fill: mapModel.getData().getVisual('style').fill
            },
            shape: {
              cx: point[0] + offset * 9,
              cy: point[1],
              r: 3
            },
            silent: true,
            // Do not overlap the first series, on which labels are displayed.
            z2: 8 + (!offset ? Z2_EMPHASIS_LIFT + 1 : 0)
          }) // Only the series that has the first value on the same region is in charge of rendering the label.
          // But consider the case:
          // series: [
          //     {id: 'X', type: 'map', map: 'm', {data: [{name: 'A', value: 11}, {name: 'B', {value: 22}]},
          //     {id: 'Y', type: 'map', map: 'm', {data: [{name: 'A', value: 21}, {name: 'C', {value: 33}]}
          // ]
          // The offset `0` of item `A` is at series `X`, but of item `C` is at series `Y`.
          // For backward compatibility, we follow the rule that render label `A` by the
          // settings on series `X` but render label `C` by the settings on series `Y`.

          if (!offset) {
            const fullData = mapModel.mainSeries.getData()
            const name_1 = originalData.getName(originalDataIndex)
            const fullIndex_1 = fullData.indexOfName(name_1)
            const itemModel = originalData.getItemModel(originalDataIndex)
            const labelModel = itemModel.getModel('label')
            const regionGroup = fullData.getItemGraphicEl(fullIndex_1) // `getFormattedLabel` needs to use `getData` inside. Here
            // `mapModel.getData()` is shallow cloned from `mainSeries.getData()`.
            // FIXME
            // If this is not the `mainSeries`, the item model (like label formatter)
            // set on original data item will never get. But it has been working
            // like that from the begining, and this scenario is rarely encountered.
            // So it won't be fixed until have to.

            setLabelStyle(circle, getLabelStatesModels(itemModel), {
              labelFetcher: {
                getFormattedLabel: function (idx, state) {
                  return mapModel.getFormattedLabel(fullIndex_1, state)
                }
              },
              defaultText: name_1
            })
            circle.disableLabelAnimation = true

            if (!labelModel.get('position')) {
              circle.setTextConfig({
                position: 'bottom'
              })
            }

            regionGroup.onHoverStateChange = function (toState) {
              setStatesFlag(circle, toState)
            }
          }

          group.add(circle)
        })
      }

      MapView.type = 'map'
      return MapView
    }(ChartView))

  const MapSeries =
    /** @class */
    (function (_super) {
      __extends(MapSeries, _super)

      function MapSeries () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = MapSeries.type // Only first map series of same mapType will drawMap.

        _this.needsDrawMap = false // Group of all map series with same mapType

        _this.seriesGroup = []

        _this.getTooltipPosition = function (dataIndex) {
          if (dataIndex != null) {
            const name_1 = this.getData().getName(dataIndex)
            const geo = this.coordinateSystem
            const region = geo.getRegion(name_1)
            return region && geo.dataToPoint(region.getCenter())
          }
        }

        return _this
      }

      MapSeries.prototype.getInitialData = function (option) {
        const data = createSeriesDataSimply(this, {
          coordDimensions: ['value'],
          encodeDefaulter: curry(makeSeriesEncodeForNameBased, this)
        })
        const dataNameMap = createHashMap()
        const toAppendNames = []

        for (let i = 0, len = data.count(); i < len; i++) {
          const name_2 = data.getName(i)
          dataNameMap.set(name_2, true)
        }

        const geoSource = geoSourceManager.load(this.getMapType(), this.option.nameMap, this.option.nameProperty)
        each(geoSource.regions, function (region) {
          const name = region.name

          if (!dataNameMap.get(name)) {
            toAppendNames.push(name)
          }
        }) // Complete data with missing regions. The consequent processes (like visual
        // map and render) can not be performed without a "full data". For example,
        // find `dataIndex` by name.

        data.appendValues([], toAppendNames)
        return data
      }
      /**
       * If no host geo model, return null, which means using a
       * inner exclusive geo model.
       */

      MapSeries.prototype.getHostGeoModel = function () {
        const geoIndex = this.option.geoIndex
        return geoIndex != null ? this.ecModel.getComponent('geo', geoIndex) : null
      }

      MapSeries.prototype.getMapType = function () {
        return (this.getHostGeoModel() || this).option.map
      } // _fillOption(option, mapName) {
      // Shallow clone
      // option = zrUtil.extend({}, option);
      // option.data = geoCreator.getFilledRegions(option.data, mapName, option.nameMap);
      // return option;
      // }

      MapSeries.prototype.getRawValue = function (dataIndex) {
        // Use value stored in data instead because it is calculated from multiple series
        // FIXME Provide all value of multiple series ?
        const data = this.getData()
        return data.get(data.mapDimension('value'), dataIndex)
      }
      /**
       * Get model of region
       */

      MapSeries.prototype.getRegionModel = function (regionName) {
        const data = this.getData()
        return data.getItemModel(data.indexOfName(regionName))
      }
      /**
       * Map tooltip formatter
       */

      MapSeries.prototype.formatTooltip = function (dataIndex, multipleSeries, dataType) {
        // FIXME orignalData and data is a bit confusing
        const data = this.getData()
        const value = this.getRawValue(dataIndex)
        const name = data.getName(dataIndex)
        const seriesGroup = this.seriesGroup
        const seriesNames = []

        for (let i = 0; i < seriesGroup.length; i++) {
          const otherIndex = seriesGroup[i].originalData.indexOfName(name)
          const valueDim = data.mapDimension('value')

          if (!isNaN(seriesGroup[i].originalData.get(valueDim, otherIndex))) {
            seriesNames.push(seriesGroup[i].name)
          }
        }

        return createTooltipMarkup('section', {
          header: seriesNames.join(', '),
          noHeader: !seriesNames.length,
          blocks: [createTooltipMarkup('nameValue', {
            name: name,
            value: value
          })]
        })
      }

      MapSeries.prototype.setZoom = function (zoom) {
        this.option.zoom = zoom
      }

      MapSeries.prototype.setCenter = function (center) {
        this.option.center = center
      }

      MapSeries.prototype.getLegendIcon = function (opt) {
        const iconType = opt.icon || 'roundRect'
        const icon = createSymbol(iconType, 0, 0, opt.itemWidth, opt.itemHeight, opt.itemStyle.fill)
        icon.setStyle(opt.itemStyle) // Map do not use itemStyle.borderWidth as border width

        icon.style.stroke = 'none' // No rotation because no series visual symbol for map

        if (iconType.indexOf('empty') > -1) {
          icon.style.stroke = icon.style.fill
          icon.style.fill = '#fff'
          icon.style.lineWidth = 2
        }

        return icon
      }

      MapSeries.type = 'series.map'
      MapSeries.dependencies = ['geo']
      MapSeries.layoutMode = 'box'
      MapSeries.defaultOption = {
        // 一级层叠
        // zlevel: 0,
        // 二级层叠
        z: 2,
        coordinateSystem: 'geo',
        // map should be explicitly specified since ec3.
        map: '',
        // If `geoIndex` is not specified, a exclusive geo will be
        // created. Otherwise use the specified geo component, and
        // `map` and `mapType` are ignored.
        // geoIndex: 0,
        // 'center' | 'left' | 'right' | 'x%' | {number}
        left: 'center',
        // 'center' | 'top' | 'bottom' | 'x%' | {number}
        top: 'center',
        // right
        // bottom
        // width:
        // height
        // Aspect is width / height. Inited to be geoJson bbox aspect
        // This parameter is used for scale this aspect
        // Default value:
        // for geoSVG source: 1,
        // for geoJSON source: 0.75.
        aspectScale: null,
        /// // Layout with center and size
        // If you wan't to put map in a fixed size box with right aspect ratio
        // This two properties may more conveninet
        // layoutCenter: [50%, 50%]
        // layoutSize: 100
        showLegendSymbol: true,
        // Define left-top, right-bottom coords to control view
        // For example, [ [180, 90], [-180, -90] ],
        // higher priority than center and zoom
        boundingCoords: null,
        // Default on center of map
        center: null,
        zoom: 1,
        scaleLimit: null,
        selectedMode: true,
        label: {
          show: false,
          color: '#000'
        },
        // scaleLimit: null,
        itemStyle: {
          borderWidth: 0.5,
          borderColor: '#444',
          areaColor: '#eee'
        },
        emphasis: {
          label: {
            show: true,
            color: 'rgb(100,0,0)'
          },
          itemStyle: {
            areaColor: 'rgba(255,215,0,0.8)'
          }
        },
        select: {
          label: {
            show: true,
            color: 'rgb(100,0,0)'
          },
          itemStyle: {
            color: 'rgba(255,215,0,0.8)'
          }
        },
        nameProperty: 'name'
      }
      return MapSeries
    }(SeriesModel))

  function dataStatistics (datas, statisticType) {
    const dataNameMap = {}
    each(datas, function (data) {
      data.each(data.mapDimension('value'), function (value, idx) {
        // Add prefix to avoid conflict with Object.prototype.
        const mapKey = 'ec-' + data.getName(idx)
        dataNameMap[mapKey] = dataNameMap[mapKey] || []

        if (!isNaN(value)) {
          dataNameMap[mapKey].push(value)
        }
      })
    })
    return datas[0].map(datas[0].mapDimension('value'), function (value, idx) {
      const mapKey = 'ec-' + datas[0].getName(idx)
      let sum = 0
      let min = Infinity
      let max = -Infinity
      const len = dataNameMap[mapKey].length

      for (let i = 0; i < len; i++) {
        min = Math.min(min, dataNameMap[mapKey][i])
        max = Math.max(max, dataNameMap[mapKey][i])
        sum += dataNameMap[mapKey][i]
      }

      let result

      if (statisticType === 'min') {
        result = min
      } else if (statisticType === 'max') {
        result = max
      } else if (statisticType === 'average') {
        result = sum / len
      } else {
        result = sum
      }

      return len === 0 ? NaN : result
    })
  }

  function mapDataStatistic (ecModel) {
    const seriesGroups = {}
    ecModel.eachSeriesByType('map', function (seriesModel) {
      const hostGeoModel = seriesModel.getHostGeoModel()
      const key = hostGeoModel ? 'o' + hostGeoModel.id : 'i' + seriesModel.getMapType();
      (seriesGroups[key] = seriesGroups[key] || []).push(seriesModel)
    })
    each(seriesGroups, function (seriesList, key) {
      const data = dataStatistics(map(seriesList, function (seriesModel) {
        return seriesModel.getData()
      }), seriesList[0].get('mapValueCalculation'))

      for (var i = 0; i < seriesList.length; i++) {
        seriesList[i].originalData = seriesList[i].getData()
      } // FIXME Put where?

      for (var i = 0; i < seriesList.length; i++) {
        seriesList[i].seriesGroup = seriesList
        seriesList[i].needsDrawMap = i === 0 && !seriesList[i].getHostGeoModel()
        seriesList[i].setData(data.cloneShallow())
        seriesList[i].mainSeries = seriesList[0]
      }
    })
  }

  function mapSymbolLayout (ecModel) {
    const processedMapType = {}
    ecModel.eachSeriesByType('map', function (mapSeries) {
      const mapType = mapSeries.getMapType()

      if (mapSeries.getHostGeoModel() || processedMapType[mapType]) {
        return
      }

      const mapSymbolOffsets = {}
      each(mapSeries.seriesGroup, function (subMapSeries) {
        const geo = subMapSeries.coordinateSystem
        const data = subMapSeries.originalData

        if (subMapSeries.get('showLegendSymbol') && ecModel.getComponent('legend')) {
          data.each(data.mapDimension('value'), function (value, idx) {
            const name = data.getName(idx)
            const region = geo.getRegion(name) // If input series.data is [11, 22, '-'/null/undefined, 44],
            // it will be filled with NaN: [11, 22, NaN, 44] and NaN will
            // not be drawn. So here must validate if value is NaN.

            if (!region || isNaN(value)) {
              return
            }

            const offset = mapSymbolOffsets[name] || 0
            const point = geo.dataToPoint(region.getCenter())
            mapSymbolOffsets[name] = offset + 1
            data.setItemLayout(idx, {
              point: point,
              offset: offset
            })
          })
        }
      }) // Show label of those region not has legendIcon (which is offset 0)

      const data = mapSeries.getData()
      data.each(function (idx) {
        const name = data.getName(idx)
        const layout = data.getItemLayout(idx) || {}
        layout.showLabel = !mapSymbolOffsets[name]
        data.setItemLayout(idx, layout)
      })
      processedMapType[mapType] = true
    })
  }

  const v2ApplyTransform = applyTransform

  const View =
    /** @class */
    (function (_super) {
      __extends(View, _super)

      function View (name) {
        const _this = _super.call(this) || this

        _this.type = 'view'
        _this.dimensions = ['x', 'y']
        /**
         * Represents the transform brought by roam/zoom.
         * If `View['_viewRect']` applies roam transform,
         * we can get the final displayed rect.
         */

        _this._roamTransformable = new Transformable()
        /**
         * Represents the transform from `View['_rect']` to `View['_viewRect']`.
         */

        _this._rawTransformable = new Transformable()
        _this.name = name
        return _this
      }

      View.prototype.setBoundingRect = function (x, y, width, height) {
        this._rect = new BoundingRect(x, y, width, height)
        return this._rect
      }
      /**
       * @return {module:zrender/core/BoundingRect}
       */

      View.prototype.getBoundingRect = function () {
        return this._rect
      }

      View.prototype.setViewRect = function (x, y, width, height) {
        this._transformTo(x, y, width, height)

        this._viewRect = new BoundingRect(x, y, width, height)
      }
      /**
       * Transformed to particular position and size
       */

      View.prototype._transformTo = function (x, y, width, height) {
        const rect = this.getBoundingRect()
        const rawTransform = this._rawTransformable
        rawTransform.transform = rect.calculateTransform(new BoundingRect(x, y, width, height))
        const rawParent = rawTransform.parent
        rawTransform.parent = null
        rawTransform.decomposeTransform()
        rawTransform.parent = rawParent

        this._updateTransform()
      }
      /**
       * Set center of view
       */

      View.prototype.setCenter = function (centerCoord, api) {
        if (!centerCoord) {
          return
        }

        this._center = [parsePercent$1(centerCoord[0], api.getWidth()), parsePercent$1(centerCoord[1], api.getHeight())]

        this._updateCenterAndZoom()
      }

      View.prototype.setZoom = function (zoom) {
        zoom = zoom || 1
        const zoomLimit = this.zoomLimit

        if (zoomLimit) {
          if (zoomLimit.max != null) {
            zoom = Math.min(zoomLimit.max, zoom)
          }

          if (zoomLimit.min != null) {
            zoom = Math.max(zoomLimit.min, zoom)
          }
        }

        this._zoom = zoom

        this._updateCenterAndZoom()
      }
      /**
       * Get default center without roam
       */

      View.prototype.getDefaultCenter = function () {
        // Rect before any transform
        const rawRect = this.getBoundingRect()
        const cx = rawRect.x + rawRect.width / 2
        const cy = rawRect.y + rawRect.height / 2
        return [cx, cy]
      }

      View.prototype.getCenter = function () {
        return this._center || this.getDefaultCenter()
      }

      View.prototype.getZoom = function () {
        return this._zoom || 1
      }

      View.prototype.getRoamTransform = function () {
        return this._roamTransformable.getLocalTransform()
      }
      /**
       * Remove roam
       */

      View.prototype._updateCenterAndZoom = function () {
        // Must update after view transform updated
        const rawTransformMatrix = this._rawTransformable.getLocalTransform()

        const roamTransform = this._roamTransformable
        let defaultCenter = this.getDefaultCenter()
        let center = this.getCenter()
        const zoom = this.getZoom()
        center = applyTransform([], center, rawTransformMatrix)
        defaultCenter = applyTransform([], defaultCenter, rawTransformMatrix)
        roamTransform.originX = center[0]
        roamTransform.originY = center[1]
        roamTransform.x = defaultCenter[0] - center[0]
        roamTransform.y = defaultCenter[1] - center[1]
        roamTransform.scaleX = roamTransform.scaleY = zoom

        this._updateTransform()
      }
      /**
       * Update transform props on `this` based on the current
       * `this._roamTransformable` and `this._rawTransformable`.
       */

      View.prototype._updateTransform = function () {
        const roamTransformable = this._roamTransformable
        const rawTransformable = this._rawTransformable
        rawTransformable.parent = roamTransformable
        roamTransformable.updateTransform()
        rawTransformable.updateTransform()
        copy$1(this.transform || (this.transform = []), rawTransformable.transform || create$1())
        this._rawTransform = rawTransformable.getLocalTransform()
        this.invTransform = this.invTransform || []
        invert(this.invTransform, this.transform)
        this.decomposeTransform()
      }

      View.prototype.getTransformInfo = function () {
        const rawTransformable = this._rawTransformable
        const roamTransformable = this._roamTransformable // Becuase roamTransformabel has `originX/originY` modified,
        // but the caller of `getTransformInfo` can not handle `originX/originY`,
        // so need to recalcualte them.

        const dummyTransformable = new Transformable()
        dummyTransformable.transform = roamTransformable.transform
        dummyTransformable.decomposeTransform()
        return {
          roam: {
            x: dummyTransformable.x,
            y: dummyTransformable.y,
            scaleX: dummyTransformable.scaleX,
            scaleY: dummyTransformable.scaleY
          },
          raw: {
            x: rawTransformable.x,
            y: rawTransformable.y,
            scaleX: rawTransformable.scaleX,
            scaleY: rawTransformable.scaleY
          }
        }
      }

      View.prototype.getViewRect = function () {
        return this._viewRect
      }
      /**
       * Get view rect after roam transform
       */

      View.prototype.getViewRectAfterRoam = function () {
        const rect = this.getBoundingRect().clone()
        rect.applyTransform(this.transform)
        return rect
      }
      /**
       * Convert a single (lon, lat) data item to (x, y) point.
       */

      View.prototype.dataToPoint = function (data, noRoam, out) {
        const transform = noRoam ? this._rawTransform : this.transform
        out = out || []
        return transform ? v2ApplyTransform(out, data, transform) : copy(out, data)
      }
      /**
       * Convert a (x, y) point to (lon, lat) data
       */

      View.prototype.pointToData = function (point) {
        const invTransform = this.invTransform
        return invTransform ? v2ApplyTransform([], point, invTransform) : [point[0], point[1]]
      }

      View.prototype.convertToPixel = function (ecModel, finder, value) {
        const coordSys = getCoordSys(finder)
        return coordSys === this ? coordSys.dataToPoint(value) : null
      }

      View.prototype.convertFromPixel = function (ecModel, finder, pixel) {
        const coordSys = getCoordSys(finder)
        return coordSys === this ? coordSys.pointToData(pixel) : null
      }
      /**
       * @implements
       */

      View.prototype.containPoint = function (point) {
        return this.getViewRectAfterRoam().contain(point[0], point[1])
      }

      View.dimensions = ['x', 'y']
      return View
    }(Transformable))

  function getCoordSys (finder) {
    const seriesModel = finder.seriesModel
    return seriesModel ? seriesModel.coordinateSystem : null // e.g., graph.
  }

  const GEO_DEFAULT_PARAMS = {
    geoJSON: {
      aspectScale: 0.75,
      invertLongitute: true
    },
    geoSVG: {
      aspectScale: 1,
      invertLongitute: false
    }
  }
  const geo2DDimensions = ['lng', 'lat']

  const Geo =
    /** @class */
    (function (_super) {
      __extends(Geo, _super)

      function Geo (name, map, opt) {
        const _this = _super.call(this, name) || this

        _this.dimensions = geo2DDimensions
        _this.type = 'geo' // Only store specified name coord via `addGeoCoord`.

        _this._nameCoordMap = createHashMap()
        _this.map = map
        let projection = opt.projection
        const source = geoSourceManager.load(map, opt.nameMap, opt.nameProperty)
        const resource = geoSourceManager.getGeoResource(map)
        const resourceType = _this.resourceType = resource ? resource.type : null
        const regions = _this.regions = source.regions
        const defaultParams = GEO_DEFAULT_PARAMS[resource.type]
        _this._regionsMap = source.regionsMap
        _this.regions = source.regions

        if ('development' !== 'production' && projection) {
          // Do some check
          if (resourceType === 'geoSVG') {
            if ('development' !== 'production') {
              warn('Map ' + map + " with SVG source can't use projection. Only GeoJSON source supports projection.")
            }

            projection = null
          }

          if (!(projection.project && projection.unproject)) {
            if ('development' !== 'production') {
              warn('project and unproject must be both provided in the projeciton.')
            }

            projection = null
          }
        }

        _this.projection = projection
        let boundingRect

        if (projection) {
          // Can't reuse the raw bounding rect
          for (let i = 0; i < regions.length; i++) {
            const regionRect = regions[i].getBoundingRect(projection)
            boundingRect = boundingRect || regionRect.clone()
            boundingRect.union(regionRect)
          }
        } else {
          boundingRect = source.boundingRect
        }

        _this.setBoundingRect(boundingRect.x, boundingRect.y, boundingRect.width, boundingRect.height) // aspectScale and invertLongitute actually is the parameters default raw projection.
        // So we ignore them if projection is given.
        // Ignore default aspect scale if projection exits.

        _this.aspectScale = projection ? 1 : retrieve2(opt.aspectScale, defaultParams.aspectScale) // Not invert longitute if projection exits.

        _this._invertLongitute = projection ? false : defaultParams.invertLongitute
        return _this
      }

      Geo.prototype._transformTo = function (x, y, width, height) {
        let rect = this.getBoundingRect()
        const invertLongitute = this._invertLongitute
        rect = rect.clone()

        if (invertLongitute) {
          // Longitute is inverted
          rect.y = -rect.y - rect.height
        }

        const rawTransformable = this._rawTransformable
        rawTransformable.transform = rect.calculateTransform(new BoundingRect(x, y, width, height))
        const rawParent = rawTransformable.parent
        rawTransformable.parent = null
        rawTransformable.decomposeTransform()
        rawTransformable.parent = rawParent

        if (invertLongitute) {
          rawTransformable.scaleY = -rawTransformable.scaleY
        }

        this._updateTransform()
      }

      Geo.prototype.getRegion = function (name) {
        return this._regionsMap.get(name)
      }

      Geo.prototype.getRegionByCoord = function (coord) {
        const regions = this.regions

        for (let i = 0; i < regions.length; i++) {
          const region = regions[i]

          if (region.type === 'geoJSON' && region.contain(coord)) {
            return regions[i]
          }
        }
      }
      /**
       * Add geoCoord for indexing by name
       */

      Geo.prototype.addGeoCoord = function (name, geoCoord) {
        this._nameCoordMap.set(name, geoCoord)
      }
      /**
       * Get geoCoord by name
       */

      Geo.prototype.getGeoCoord = function (name) {
        const region = this._regionsMap.get(name) // calcualte center only on demand.

        return this._nameCoordMap.get(name) || region && region.getCenter()
      }

      Geo.prototype.dataToPoint = function (data, noRoam, out) {
        if (isString(data)) {
          // Map area name to geoCoord
          data = this.getGeoCoord(data)
        }

        if (data) {
          const projection = this.projection

          if (projection) {
            // projection may return null point.
            data = projection.project(data)
          }

          return data && this.projectedToPoint(data, noRoam, out)
        }
      }

      Geo.prototype.pointToData = function (point) {
        const projection = this.projection

        if (projection) {
          // projection may return null point.
          point = projection.unproject(point)
        }

        return point && this.pointToProjected(point)
      }
      /**
       * Point to projected data. Same with pointToData when projection is used.
       */

      Geo.prototype.pointToProjected = function (point) {
        return _super.prototype.pointToData.call(this, point)
      }

      Geo.prototype.projectedToPoint = function (projected, noRoam, out) {
        return _super.prototype.dataToPoint.call(this, projected, noRoam, out)
      }

      Geo.prototype.convertToPixel = function (ecModel, finder, value) {
        const coordSys = getCoordSys$1(finder)
        return coordSys === this ? coordSys.dataToPoint(value) : null
      }

      Geo.prototype.convertFromPixel = function (ecModel, finder, pixel) {
        const coordSys = getCoordSys$1(finder)
        return coordSys === this ? coordSys.pointToData(pixel) : null
      }

      return Geo
    }(View))
  mixin(Geo, View)

  function getCoordSys$1 (finder) {
    const geoModel = finder.geoModel
    const seriesModel = finder.seriesModel
    return geoModel ? geoModel.coordinateSystem : seriesModel ? seriesModel.coordinateSystem || // For map series.
      (seriesModel.getReferringComponents('geo', SINGLE_REFERRING).models[0] || {}).coordinateSystem : null
  }

  /**
     * Resize method bound to the geo
     */

  function resizeGeo (geoModel, api) {
    const boundingCoords = geoModel.get('boundingCoords')

    if (boundingCoords != null) {
      let leftTop_1 = boundingCoords[0]
      let rightBottom_1 = boundingCoords[1]

      if (!(isFinite(leftTop_1[0]) && isFinite(leftTop_1[1]) && isFinite(rightBottom_1[0]) && isFinite(rightBottom_1[1]))) {
        if ('development' !== 'production') {
          console.error('Invalid boundingCoords')
        }
      } else {
        // Sample around the lng/lat rect and use projection to calculate actual bounding rect.
        const projection_1 = this.projection

        if (projection_1) {
          const xMin = leftTop_1[0]
          const yMin = leftTop_1[1]
          const xMax = rightBottom_1[0]
          const yMax = rightBottom_1[1]
          leftTop_1 = [Infinity, Infinity]
          rightBottom_1 = [-Infinity, -Infinity] // TODO better way?

          const sampleLine = function (x0, y0, x1, y1) {
            const dx = x1 - x0
            const dy = y1 - y0

            for (let i = 0; i <= 100; i++) {
              const p = i / 100
              const pt = projection_1.project([x0 + dx * p, y0 + dy * p])
              min(leftTop_1, leftTop_1, pt)
              max(rightBottom_1, rightBottom_1, pt)
            }
          } // Top

          sampleLine(xMin, yMin, xMax, yMin) // Right

          sampleLine(xMax, yMin, xMax, yMax) // Bottom

          sampleLine(xMax, yMax, xMin, yMax) // Left

          sampleLine(xMin, yMax, xMax, yMin)
        }

        this.setBoundingRect(leftTop_1[0], leftTop_1[1], rightBottom_1[0] - leftTop_1[0], rightBottom_1[1] - leftTop_1[1])
      }
    }

    const rect = this.getBoundingRect()
    const centerOption = geoModel.get('layoutCenter')
    const sizeOption = geoModel.get('layoutSize')
    const viewWidth = api.getWidth()
    const viewHeight = api.getHeight()
    const aspect = rect.width / rect.height * this.aspectScale
    let useCenterAndSize = false
    let center
    let size

    if (centerOption && sizeOption) {
      center = [parsePercent$1(centerOption[0], viewWidth), parsePercent$1(centerOption[1], viewHeight)]
      size = parsePercent$1(sizeOption, Math.min(viewWidth, viewHeight))

      if (!isNaN(center[0]) && !isNaN(center[1]) && !isNaN(size)) {
        useCenterAndSize = true
      } else {
        if ('development' !== 'production') {
          console.warn('Given layoutCenter or layoutSize data are invalid. Use left/top/width/height instead.')
        }
      }
    }

    let viewRect

    if (useCenterAndSize) {
      viewRect = {}

      if (aspect > 1) {
        // Width is same with size
        viewRect.width = size
        viewRect.height = size / aspect
      } else {
        viewRect.height = size
        viewRect.width = size * aspect
      }

      viewRect.y = center[1] - viewRect.height / 2
      viewRect.x = center[0] - viewRect.width / 2
    } else {
      // Use left/top/width/height
      const boxLayoutOption = geoModel.getBoxLayoutParams()
      boxLayoutOption.aspect = aspect
      viewRect = getLayoutRect(boxLayoutOption, {
        width: viewWidth,
        height: viewHeight
      })
    }

    this.setViewRect(viewRect.x, viewRect.y, viewRect.width, viewRect.height)
    this.setCenter(geoModel.get('center'), api)
    this.setZoom(geoModel.get('zoom'))
  } // Back compat for ECharts2, where the coord map is set on map series:
  // {type: 'map', geoCoord: {'cityA': [116.46,39.92], 'cityA': [119.12,24.61]}},

  function setGeoCoords (geo, model) {
    each(model.get('geoCoord'), function (geoCoord, name) {
      geo.addGeoCoord(name, geoCoord)
    })
  }

  const GeoCreator =
    /** @class */
    (function () {
      function GeoCreator () {
        // For deciding which dimensions to use when creating list data
        this.dimensions = geo2DDimensions
      }

      GeoCreator.prototype.create = function (ecModel, api) {
        const geoList = []

        function getCommonGeoProperties (model) {
          return {
            nameProperty: model.get('nameProperty'),
            aspectScale: model.get('aspectScale'),
            projection: model.get('projection')
          }
        } // FIXME Create each time may be slow

        ecModel.eachComponent('geo', function (geoModel, idx) {
          const mapName = geoModel.get('map')
          const geo = new Geo(mapName + idx, mapName, extend({
            nameMap: geoModel.get('nameMap')
          }, getCommonGeoProperties(geoModel)))
          geo.zoomLimit = geoModel.get('scaleLimit')
          geoList.push(geo) // setGeoCoords(geo, geoModel);

          geoModel.coordinateSystem = geo
          geo.model = geoModel // Inject resize method

          geo.resize = resizeGeo
          geo.resize(geoModel, api)
        })
        ecModel.eachSeries(function (seriesModel) {
          const coordSys = seriesModel.get('coordinateSystem')

          if (coordSys === 'geo') {
            const geoIndex = seriesModel.get('geoIndex') || 0
            seriesModel.coordinateSystem = geoList[geoIndex]
          }
        }) // If has map series

        const mapModelGroupBySeries = {}
        ecModel.eachSeriesByType('map', function (seriesModel) {
          if (!seriesModel.getHostGeoModel()) {
            const mapType = seriesModel.getMapType()
            mapModelGroupBySeries[mapType] = mapModelGroupBySeries[mapType] || []
            mapModelGroupBySeries[mapType].push(seriesModel)
          }
        })
        each(mapModelGroupBySeries, function (mapSeries, mapType) {
          const nameMapList = map(mapSeries, function (singleMapSeries) {
            return singleMapSeries.get('nameMap')
          })
          const geo = new Geo(mapType, mapType, extend({
            nameMap: mergeAll(nameMapList)
          }, getCommonGeoProperties(mapSeries[0])))
          geo.zoomLimit = retrieve.apply(null, map(mapSeries, function (singleMapSeries) {
            return singleMapSeries.get('scaleLimit')
          }))
          geoList.push(geo) // Inject resize method

          geo.resize = resizeGeo
          geo.resize(mapSeries[0], api)
          each(mapSeries, function (singleMapSeries) {
            singleMapSeries.coordinateSystem = geo
            setGeoCoords(geo, singleMapSeries)
          })
        })
        return geoList
      }
      /**
       * Fill given regions array
       */

      GeoCreator.prototype.getFilledRegions = function (originRegionArr, mapName, nameMap, nameProperty) {
        // Not use the original
        const regionsArr = (originRegionArr || []).slice()
        const dataNameMap = createHashMap()

        for (let i = 0; i < regionsArr.length; i++) {
          dataNameMap.set(regionsArr[i].name, regionsArr[i])
        }

        const source = geoSourceManager.load(mapName, nameMap, nameProperty)
        each(source.regions, function (region) {
          const name = region.name
          !dataNameMap.get(name) && regionsArr.push({
            name: name
          })
        })
        return regionsArr
      }

      return GeoCreator
    }())

  const geoCreator = new GeoCreator()

  const GeoModel =
    /** @class */
    (function (_super) {
      __extends(GeoModel, _super)

      function GeoModel () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = GeoModel.type
        return _this
      }

      GeoModel.prototype.init = function (option, parentModel, ecModel) {
        const source = geoSourceManager.getGeoResource(option.map)

        if (source && source.type === 'geoJSON') {
          const itemStyle = option.itemStyle = option.itemStyle || {}

          if (!('color' in itemStyle)) {
            itemStyle.color = '#eee'
          }
        }

        this.mergeDefaultAndTheme(option, ecModel) // Default label emphasis `show`

        defaultEmphasis(option, 'label', ['show'])
      }

      GeoModel.prototype.optionUpdated = function () {
        const _this = this

        const option = this.option
        option.regions = geoCreator.getFilledRegions(option.regions, option.map, option.nameMap, option.nameProperty)
        const selectedMap = {}
        this._optionModelMap = reduce(option.regions || [], function (optionModelMap, regionOpt) {
          const regionName = regionOpt.name

          if (regionName) {
            optionModelMap.set(regionName, new Model(regionOpt, _this, _this.ecModel))

            if (regionOpt.selected) {
              selectedMap[regionName] = true
            }
          }

          return optionModelMap
        }, createHashMap())

        if (!option.selectedMap) {
          option.selectedMap = selectedMap
        }
      }
      /**
       * Get model of region.
       */

      GeoModel.prototype.getRegionModel = function (name) {
        return this._optionModelMap.get(name) || new Model(null, this, this.ecModel)
      }
      /**
       * Format label
       * @param name Region name
       */

      GeoModel.prototype.getFormattedLabel = function (name, status) {
        const regionModel = this.getRegionModel(name)
        const formatter = status === 'normal' ? regionModel.get(['label', 'formatter']) : regionModel.get(['emphasis', 'label', 'formatter'])
        const params = {
          name: name
        }

        if (isFunction(formatter)) {
          params.status = status
          return formatter(params)
        } else if (isString(formatter)) {
          return formatter.replace('{a}', name != null ? name : '')
        }
      }

      GeoModel.prototype.setZoom = function (zoom) {
        this.option.zoom = zoom
      }

      GeoModel.prototype.setCenter = function (center) {
        this.option.center = center
      } // PENGING If selectedMode is null ?

      GeoModel.prototype.select = function (name) {
        const option = this.option
        const selectedMode = option.selectedMode

        if (!selectedMode) {
          return
        }

        if (selectedMode !== 'multiple') {
          option.selectedMap = null
        }

        const selectedMap = option.selectedMap || (option.selectedMap = {})
        selectedMap[name] = true
      }

      GeoModel.prototype.unSelect = function (name) {
        const selectedMap = this.option.selectedMap

        if (selectedMap) {
          selectedMap[name] = false
        }
      }

      GeoModel.prototype.toggleSelected = function (name) {
        this[this.isSelected(name) ? 'unSelect' : 'select'](name)
      }

      GeoModel.prototype.isSelected = function (name) {
        const selectedMap = this.option.selectedMap
        return !!(selectedMap && selectedMap[name])
      }

      GeoModel.type = 'geo'
      GeoModel.layoutMode = 'box'
      GeoModel.defaultOption = {
        // zlevel: 0,
        z: 0,
        show: true,
        left: 'center',
        top: 'center',
        // Default value:
        // for geoSVG source: 1,
        // for geoJSON source: 0.75.
        aspectScale: null,
        /// // Layout with center and size
        // If you wan't to put map in a fixed size box with right aspect ratio
        // This two properties may more conveninet
        // layoutCenter: [50%, 50%]
        // layoutSize: 100
        silent: false,
        // Map type
        map: '',
        // Define left-top, right-bottom coords to control view
        // For example, [ [180, 90], [-180, -90] ]
        boundingCoords: null,
        // Default on center of map
        center: null,
        zoom: 1,
        scaleLimit: null,
        // selectedMode: false
        label: {
          show: false,
          color: '#000'
        },
        itemStyle: {
          borderWidth: 0.5,
          borderColor: '#444' // Default color:
          // + geoJSON: #eee
          // + geoSVG: null (use SVG original `fill`)
          // color: '#eee'

        },
        emphasis: {
          label: {
            show: true,
            color: 'rgb(100,0,0)'
          },
          itemStyle: {
            color: 'rgba(255,215,0,0.8)'
          }
        },
        select: {
          label: {
            show: true,
            color: 'rgb(100,0,0)'
          },
          itemStyle: {
            color: 'rgba(255,215,0,0.8)'
          }
        },
        regions: [] // tooltip: {
        //     show: false
        // }

      }
      return GeoModel
    }(ComponentModel))

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

  /**
     * AUTO-GENERATED FILE. DO NOT MODIFY.
     */

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
  function getCenterCoord (view, point) {
    // Use projected coord as center because it's linear.
    return view.pointToProjected ? view.pointToProjected(point) : view.pointToData(point)
  }

  function updateCenterAndZoom (view, payload, zoomLimit, api) {
    const previousZoom = view.getZoom()
    const center = view.getCenter()
    let zoom = payload.zoom
    const point = view.projectedToPoint ? view.projectedToPoint(center) : view.dataToPoint(center)

    if (payload.dx != null && payload.dy != null) {
      point[0] -= payload.dx
      point[1] -= payload.dy
      view.setCenter(getCenterCoord(view, point), api)
    }

    if (zoom != null) {
      if (zoomLimit) {
        const zoomMin = zoomLimit.min || 0
        const zoomMax = zoomLimit.max || Infinity
        zoom = Math.max(Math.min(previousZoom * zoom, zoomMax), zoomMin) / previousZoom
      } // Zoom on given point(originX, originY)

      view.scaleX *= zoom
      view.scaleY *= zoom
      const fixX = (payload.originX - view.x) * (zoom - 1)
      const fixY = (payload.originY - view.y) * (zoom - 1)
      view.x -= fixX
      view.y -= fixY
      view.updateTransform() // Get the new center

      view.setCenter(getCenterCoord(view, point), api)
      view.setZoom(zoom * previousZoom)
    }

    return {
      center: view.getCenter(),
      zoom: view.getZoom()
    }
  }

  const GeoView =
    /** @class */
    (function (_super) {
      __extends(GeoView, _super)

      function GeoView () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = GeoView.type
        _this.focusBlurEnabled = true
        return _this
      }

      GeoView.prototype.init = function (ecModel, api) {
        this._api = api
      }

      GeoView.prototype.render = function (geoModel, ecModel, api, payload) {
        this._model = geoModel

        if (!geoModel.get('show')) {
          this._mapDraw && this._mapDraw.remove()
          this._mapDraw = null
          return
        }

        if (!this._mapDraw) {
          this._mapDraw = new MapDraw(api)
        }

        const mapDraw = this._mapDraw
        mapDraw.draw(geoModel, ecModel, api, this, payload)
        mapDraw.group.on('click', this._handleRegionClick, this)
        mapDraw.group.silent = geoModel.get('silent')
        this.group.add(mapDraw.group)
        this.updateSelectStatus(geoModel, ecModel, api)
      }

      GeoView.prototype._handleRegionClick = function (e) {
        let eventData
        findEventDispatcher(e.target, function (current) {
          return (eventData = getECData(current).eventData) != null
        }, true)

        if (eventData) {
          this._api.dispatchAction({
            type: 'geoToggleSelect',
            geoId: this._model.id,
            name: eventData.name
          })
        }
      }

      GeoView.prototype.updateSelectStatus = function (model, ecModel, api) {
        const _this = this

        this._mapDraw.group.traverse(function (node) {
          const eventData = getECData(node).eventData

          if (eventData) {
            _this._model.isSelected(eventData.name) ? api.enterSelect(node) : api.leaveSelect(node) // No need to traverse children.

            return true
          }
        })
      }

      GeoView.prototype.findHighDownDispatchers = function (name) {
        return this._mapDraw && this._mapDraw.findHighDownDispatchers(name, this._model)
      }

      GeoView.prototype.dispose = function () {
        this._mapDraw && this._mapDraw.remove()
      }

      GeoView.type = 'geo'
      return GeoView
    }(ComponentView))

  function registerMap$1 (mapName, geoJson, specialAreas) {
    geoSourceManager.registerMap(mapName, geoJson, specialAreas)
  }

  function install$9 (registers) {
    registers.registerCoordinateSystem('geo', geoCreator)
    registers.registerComponentModel(GeoModel)
    registers.registerComponentView(GeoView)
    registers.registerImpl('registerMap', registerMap$1)
    registers.registerImpl('getMap', function (mapName) {
      return geoSourceManager.getMapForUser(mapName)
    })

    function makeAction (method, actionInfo) {
      actionInfo.update = 'geo:updateSelectStatus'
      registers.registerAction(actionInfo, function (payload, ecModel) {
        const selected = {}
        const allSelected = []
        ecModel.eachComponent({
          mainType: 'geo',
          query: payload
        }, function (geoModel) {
          geoModel[method](payload.name)
          const geo = geoModel.coordinateSystem
          each(geo.regions, function (region) {
            selected[region.name] = geoModel.isSelected(region.name) || false
          }) // Notice: there might be duplicated name in different regions.

          const names = []
          each(selected, function (v, name) {
            selected[name] && names.push(name)
          })
          allSelected.push({
            geoIndex: geoModel.componentIndex,
            // Use singular, the same naming convention as the event `selectchanged`.
            name: names
          })
        })
        return {
          selected: selected,
          allSelected: allSelected,
          name: payload.name
        }
      })
    }

    makeAction('toggleSelected', {
      type: 'geoToggleSelect',
      event: 'geoselectchanged'
    })
    makeAction('select', {
      type: 'geoSelect',
      event: 'geoselected'
    })
    makeAction('unSelect', {
      type: 'geoUnSelect',
      event: 'geounselected'
    })
    /**
       * @payload
       * @property {string} [componentType=series]
       * @property {number} [dx]
       * @property {number} [dy]
       * @property {number} [zoom]
       * @property {number} [originX]
       * @property {number} [originY]
       */

    registers.registerAction({
      type: 'geoRoam',
      event: 'geoRoam',
      update: 'updateTransform'
    }, function (payload, ecModel, api) {
      const componentType = payload.componentType || 'series'
      ecModel.eachComponent({
        mainType: componentType,
        query: payload
      }, function (componentModel) {
        const geo = componentModel.coordinateSystem

        if (geo.type !== 'geo') {
          return
        }

        const res = updateCenterAndZoom(geo, payload, componentModel.get('scaleLimit'), api)
        componentModel.setCenter && componentModel.setCenter(res.center)
        componentModel.setZoom && componentModel.setZoom(res.zoom) // All map series with same `map` use the same geo coordinate system
        // So the center and zoom must be in sync. Include the series not selected by legend

        if (componentType === 'series') {
          each(componentModel.seriesGroup, function (seriesModel) {
            seriesModel.setCenter(res.center)
            seriesModel.setZoom(res.zoom)
          })
        }
      })
    })
  }

  function install$a (registers) {
    use(install$9)
    registers.registerChartView(MapView)
    registers.registerSeriesModel(MapSeries)
    registers.registerLayout(mapSymbolLayout)
    registers.registerProcessor(registers.PRIORITY.PROCESSOR.STATISTIC, mapDataStatistic)
    createLegacyDataSelectAction('map', registers.registerAction)
  }

  /**
     * Initialize all computational message for following algorithm.
     */

  function init$2 (inRoot) {
    const root = inRoot
    root.hierNode = {
      defaultAncestor: null,
      ancestor: root,
      prelim: 0,
      modifier: 0,
      change: 0,
      shift: 0,
      i: 0,
      thread: null
    }
    const nodes = [root]
    let node
    let children

    while (node = nodes.pop()) {
      // jshint ignore:line
      children = node.children

      if (node.isExpand && children.length) {
        const n = children.length

        for (let i = n - 1; i >= 0; i--) {
          const child = children[i]
          child.hierNode = {
            defaultAncestor: null,
            ancestor: child,
            prelim: 0,
            modifier: 0,
            change: 0,
            shift: 0,
            i: i,
            thread: null
          }
          nodes.push(child)
        }
      }
    }
  }
  /**
     * The implementation of this function was originally copied from "d3.js"
     * <https://github.com/d3/d3-hierarchy/blob/4c1f038f2725d6eae2e49b61d01456400694bac4/src/tree.js>
     * with some modifications made for this program.
     * See the license statement at the head of this file.
     *
     * Computes a preliminary x coordinate for node. Before that, this function is
     * applied recursively to the children of node, as well as the function
     * apportion(). After spacing out the children by calling executeShifts(), the
     * node is placed to the midpoint of its outermost children.
     */

  function firstWalk (node, separation) {
    const children = node.isExpand ? node.children : []
    const siblings = node.parentNode.children
    const subtreeW = node.hierNode.i ? siblings[node.hierNode.i - 1] : null

    if (children.length) {
      executeShifts(node)
      const midPoint = (children[0].hierNode.prelim + children[children.length - 1].hierNode.prelim) / 2

      if (subtreeW) {
        node.hierNode.prelim = subtreeW.hierNode.prelim + separation(node, subtreeW)
        node.hierNode.modifier = node.hierNode.prelim - midPoint
      } else {
        node.hierNode.prelim = midPoint
      }
    } else if (subtreeW) {
      node.hierNode.prelim = subtreeW.hierNode.prelim + separation(node, subtreeW)
    }

    node.parentNode.hierNode.defaultAncestor = apportion(node, subtreeW, node.parentNode.hierNode.defaultAncestor || siblings[0], separation)
  }
  /**
     * The implementation of this function was originally copied from "d3.js"
     * <https://github.com/d3/d3-hierarchy/blob/4c1f038f2725d6eae2e49b61d01456400694bac4/src/tree.js>
     * with some modifications made for this program.
     * See the license statement at the head of this file.
     *
     * Computes all real x-coordinates by summing up the modifiers recursively.
     */

  function secondWalk (node) {
    const nodeX = node.hierNode.prelim + node.parentNode.hierNode.modifier
    node.setLayout({
      x: nodeX
    }, true)
    node.hierNode.modifier += node.parentNode.hierNode.modifier
  }
  function separation (cb) {
    return arguments.length ? cb : defaultSeparation
  }
  /**
     * Transform the common coordinate to radial coordinate.
     */

  function radialCoordinate (rad, r) {
    rad -= Math.PI / 2
    return {
      x: r * Math.cos(rad),
      y: r * Math.sin(rad)
    }
  }
  /**
     * Get the layout position of the whole view.
     */

  function getViewRect$1 (seriesModel, api) {
    return getLayoutRect(seriesModel.getBoxLayoutParams(), {
      width: api.getWidth(),
      height: api.getHeight()
    })
  }
  /**
     * All other shifts, applied to the smaller subtrees between w- and w+, are
     * performed by this function.
     *
     * The implementation of this function was originally copied from "d3.js"
     * <https://github.com/d3/d3-hierarchy/blob/4c1f038f2725d6eae2e49b61d01456400694bac4/src/tree.js>
     * with some modifications made for this program.
     * See the license statement at the head of this file.
     */

  function executeShifts (node) {
    const children = node.children
    let n = children.length
    let shift = 0
    let change = 0

    while (--n >= 0) {
      const child = children[n]
      child.hierNode.prelim += shift
      child.hierNode.modifier += shift
      change += child.hierNode.change
      shift += child.hierNode.shift + change
    }
  }
  /**
     * The implementation of this function was originally copied from "d3.js"
     * <https://github.com/d3/d3-hierarchy/blob/4c1f038f2725d6eae2e49b61d01456400694bac4/src/tree.js>
     * with some modifications made for this program.
     * See the license statement at the head of this file.
     *
     * The core of the algorithm. Here, a new subtree is combined with the
     * previous subtrees. Threads are used to traverse the inside and outside
     * contours of the left and right subtree up to the highest common level.
     * Whenever two nodes of the inside contours conflict, we compute the left
     * one of the greatest uncommon ancestors using the function nextAncestor()
     * and call moveSubtree() to shift the subtree and prepare the shifts of
     * smaller subtrees. Finally, we add a new thread (if necessary).
     */

  function apportion (subtreeV, subtreeW, ancestor, separation) {
    if (subtreeW) {
      let nodeOutRight = subtreeV
      let nodeInRight = subtreeV
      let nodeOutLeft = nodeInRight.parentNode.children[0]
      let nodeInLeft = subtreeW
      let sumOutRight = nodeOutRight.hierNode.modifier
      let sumInRight = nodeInRight.hierNode.modifier
      let sumOutLeft = nodeOutLeft.hierNode.modifier
      let sumInLeft = nodeInLeft.hierNode.modifier

      while (nodeInLeft = nextRight(nodeInLeft), nodeInRight = nextLeft(nodeInRight), nodeInLeft && nodeInRight) {
        nodeOutRight = nextRight(nodeOutRight)
        nodeOutLeft = nextLeft(nodeOutLeft)
        nodeOutRight.hierNode.ancestor = subtreeV
        const shift = nodeInLeft.hierNode.prelim + sumInLeft - nodeInRight.hierNode.prelim - sumInRight + separation(nodeInLeft, nodeInRight)

        if (shift > 0) {
          moveSubtree(nextAncestor(nodeInLeft, subtreeV, ancestor), subtreeV, shift)
          sumInRight += shift
          sumOutRight += shift
        }

        sumInLeft += nodeInLeft.hierNode.modifier
        sumInRight += nodeInRight.hierNode.modifier
        sumOutRight += nodeOutRight.hierNode.modifier
        sumOutLeft += nodeOutLeft.hierNode.modifier
      }

      if (nodeInLeft && !nextRight(nodeOutRight)) {
        nodeOutRight.hierNode.thread = nodeInLeft
        nodeOutRight.hierNode.modifier += sumInLeft - sumOutRight
      }

      if (nodeInRight && !nextLeft(nodeOutLeft)) {
        nodeOutLeft.hierNode.thread = nodeInRight
        nodeOutLeft.hierNode.modifier += sumInRight - sumOutLeft
        ancestor = subtreeV
      }
    }

    return ancestor
  }
  /**
     * This function is used to traverse the right contour of a subtree.
     * It returns the rightmost child of node or the thread of node. The function
     * returns null if and only if node is on the highest depth of its subtree.
     */

  function nextRight (node) {
    const children = node.children
    return children.length && node.isExpand ? children[children.length - 1] : node.hierNode.thread
  }
  /**
     * This function is used to traverse the left contour of a subtree (or a subforest).
     * It returns the leftmost child of node or the thread of node. The function
     * returns null if and only if node is on the highest depth of its subtree.
     */

  function nextLeft (node) {
    const children = node.children
    return children.length && node.isExpand ? children[0] : node.hierNode.thread
  }
  /**
     * If nodeInLeft’s ancestor is a sibling of node, returns nodeInLeft’s ancestor.
     * Otherwise, returns the specified ancestor.
     */

  function nextAncestor (nodeInLeft, node, ancestor) {
    return nodeInLeft.hierNode.ancestor.parentNode === node.parentNode ? nodeInLeft.hierNode.ancestor : ancestor
  }
  /**
     * The implementation of this function was originally copied from "d3.js"
     * <https://github.com/d3/d3-hierarchy/blob/4c1f038f2725d6eae2e49b61d01456400694bac4/src/tree.js>
     * with some modifications made for this program.
     * See the license statement at the head of this file.
     *
     * Shifts the current subtree rooted at wr.
     * This is done by increasing prelim(w+) and modifier(w+) by shift.
     */

  function moveSubtree (wl, wr, shift) {
    const change = shift / (wr.hierNode.i - wl.hierNode.i)
    wr.hierNode.change -= change
    wr.hierNode.shift += shift
    wr.hierNode.modifier += shift
    wr.hierNode.prelim += shift
    wl.hierNode.change += change
  }
  /**
     * The implementation of this function was originally copied from "d3.js"
     * <https://github.com/d3/d3-hierarchy/blob/4c1f038f2725d6eae2e49b61d01456400694bac4/src/tree.js>
     * with some modifications made for this program.
     * See the license statement at the head of this file.
     */

  function defaultSeparation (node1, node2) {
    return node1.parentNode === node2.parentNode ? 1 : 2
  }

  const TreeEdgeShape =
    /** @class */
    (function () {
      function TreeEdgeShape () {
        this.parentPoint = []
        this.childPoints = []
      }

      return TreeEdgeShape
    }())

  const TreePath =
    /** @class */
    (function (_super) {
      __extends(TreePath, _super)

      function TreePath (opts) {
        return _super.call(this, opts) || this
      }

      TreePath.prototype.getDefaultStyle = function () {
        return {
          stroke: '#000',
          fill: null
        }
      }

      TreePath.prototype.getDefaultShape = function () {
        return new TreeEdgeShape()
      }

      TreePath.prototype.buildPath = function (ctx, shape) {
        const childPoints = shape.childPoints
        const childLen = childPoints.length
        const parentPoint = shape.parentPoint
        const firstChildPos = childPoints[0]
        const lastChildPos = childPoints[childLen - 1]

        if (childLen === 1) {
          ctx.moveTo(parentPoint[0], parentPoint[1])
          ctx.lineTo(firstChildPos[0], firstChildPos[1])
          return
        }

        const orient = shape.orient
        const forkDim = orient === 'TB' || orient === 'BT' ? 0 : 1
        const otherDim = 1 - forkDim
        const forkPosition = parsePercent$1(shape.forkPosition, 1)
        const tmpPoint = []
        tmpPoint[forkDim] = parentPoint[forkDim]
        tmpPoint[otherDim] = parentPoint[otherDim] + (lastChildPos[otherDim] - parentPoint[otherDim]) * forkPosition
        ctx.moveTo(parentPoint[0], parentPoint[1])
        ctx.lineTo(tmpPoint[0], tmpPoint[1])
        ctx.moveTo(firstChildPos[0], firstChildPos[1])
        tmpPoint[forkDim] = firstChildPos[forkDim]
        ctx.lineTo(tmpPoint[0], tmpPoint[1])
        tmpPoint[forkDim] = lastChildPos[forkDim]
        ctx.lineTo(tmpPoint[0], tmpPoint[1])
        ctx.lineTo(lastChildPos[0], lastChildPos[1])

        for (let i = 1; i < childLen - 1; i++) {
          const point = childPoints[i]
          ctx.moveTo(point[0], point[1])
          tmpPoint[forkDim] = point[forkDim]
          ctx.lineTo(tmpPoint[0], tmpPoint[1])
        }
      }

      return TreePath
    }(Path))

  const TreeView =
    /** @class */
    (function (_super) {
      __extends(TreeView, _super)

      function TreeView () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = TreeView.type
        _this._mainGroup = new Group()
        return _this
      }

      TreeView.prototype.init = function (ecModel, api) {
        this._controller = new RoamController(api.getZr())
        this._controllerHost = {
          target: this.group
        }
        this.group.add(this._mainGroup)
      }

      TreeView.prototype.render = function (seriesModel, ecModel, api) {
        const data = seriesModel.getData()
        const layoutInfo = seriesModel.layoutInfo
        const group = this._mainGroup
        const layout = seriesModel.get('layout')

        if (layout === 'radial') {
          group.x = layoutInfo.x + layoutInfo.width / 2
          group.y = layoutInfo.y + layoutInfo.height / 2
        } else {
          group.x = layoutInfo.x
          group.y = layoutInfo.y
        }

        this._updateViewCoordSys(seriesModel, api)

        this._updateController(seriesModel, ecModel, api)

        const oldData = this._data
        data.diff(oldData).add(function (newIdx) {
          if (symbolNeedsDraw$1(data, newIdx)) {
            // Create node and edge
            updateNode(data, newIdx, null, group, seriesModel)
          }
        }).update(function (newIdx, oldIdx) {
          const symbolEl = oldData.getItemGraphicEl(oldIdx)

          if (!symbolNeedsDraw$1(data, newIdx)) {
            symbolEl && removeNode(oldData, oldIdx, symbolEl, group, seriesModel)
            return
          } // Update node and edge

          updateNode(data, newIdx, symbolEl, group, seriesModel)
        }).remove(function (oldIdx) {
          const symbolEl = oldData.getItemGraphicEl(oldIdx) // When remove a collapsed node of subtree, since the collapsed
          // node haven't been initialized with a symbol element,
          // you can't found it's symbol element through index.
          // so if we want to remove the symbol element we should insure
          // that the symbol element is not null.

          if (symbolEl) {
            removeNode(oldData, oldIdx, symbolEl, group, seriesModel)
          }
        }).execute()
        this._nodeScaleRatio = seriesModel.get('nodeScaleRatio')

        this._updateNodeAndLinkScale(seriesModel)

        if (seriesModel.get('expandAndCollapse') === true) {
          data.eachItemGraphicEl(function (el, dataIndex) {
            el.off('click').on('click', function () {
              api.dispatchAction({
                type: 'treeExpandAndCollapse',
                seriesId: seriesModel.id,
                dataIndex: dataIndex
              })
            })
          })
        }

        this._data = data
      }

      TreeView.prototype._updateViewCoordSys = function (seriesModel, api) {
        const data = seriesModel.getData()
        const points = []
        data.each(function (idx) {
          const layout = data.getItemLayout(idx)

          if (layout && !isNaN(layout.x) && !isNaN(layout.y)) {
            points.push([+layout.x, +layout.y])
          }
        })
        const min = []
        const max = []
        fromPoints(points, min, max) // If don't Store min max when collapse the root node after roam,
        // the root node will disappear.

        const oldMin = this._min
        const oldMax = this._max // If width or height is 0

        if (max[0] - min[0] === 0) {
          min[0] = oldMin ? oldMin[0] : min[0] - 1
          max[0] = oldMax ? oldMax[0] : max[0] + 1
        }

        if (max[1] - min[1] === 0) {
          min[1] = oldMin ? oldMin[1] : min[1] - 1
          max[1] = oldMax ? oldMax[1] : max[1] + 1
        }

        const viewCoordSys = seriesModel.coordinateSystem = new View()
        viewCoordSys.zoomLimit = seriesModel.get('scaleLimit')
        viewCoordSys.setBoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1])
        viewCoordSys.setCenter(seriesModel.get('center'), api)
        viewCoordSys.setZoom(seriesModel.get('zoom')) // Here we use viewCoordSys just for computing the 'position' and 'scale' of the group

        this.group.attr({
          x: viewCoordSys.x,
          y: viewCoordSys.y,
          scaleX: viewCoordSys.scaleX,
          scaleY: viewCoordSys.scaleY
        })
        this._min = min
        this._max = max
      }

      TreeView.prototype._updateController = function (seriesModel, ecModel, api) {
        const _this = this

        const controller = this._controller
        const controllerHost = this._controllerHost
        const group = this.group
        controller.setPointerChecker(function (e, x, y) {
          const rect = group.getBoundingRect()
          rect.applyTransform(group.transform)
          return rect.contain(x, y) && !onIrrelevantElement(e, api, seriesModel)
        })
        controller.enable(seriesModel.get('roam'))
        controllerHost.zoomLimit = seriesModel.get('scaleLimit')
        controllerHost.zoom = seriesModel.coordinateSystem.getZoom()
        controller.off('pan').off('zoom').on('pan', function (e) {
          updateViewOnPan(controllerHost, e.dx, e.dy)
          api.dispatchAction({
            seriesId: seriesModel.id,
            type: 'treeRoam',
            dx: e.dx,
            dy: e.dy
          })
        }).on('zoom', function (e) {
          updateViewOnZoom(controllerHost, e.scale, e.originX, e.originY)
          api.dispatchAction({
            seriesId: seriesModel.id,
            type: 'treeRoam',
            zoom: e.scale,
            originX: e.originX,
            originY: e.originY
          })

          _this._updateNodeAndLinkScale(seriesModel) // Only update label layout on zoom

          api.updateLabelLayout()
        })
      }

      TreeView.prototype._updateNodeAndLinkScale = function (seriesModel) {
        const data = seriesModel.getData()

        const nodeScale = this._getNodeGlobalScale(seriesModel)

        data.eachItemGraphicEl(function (el, idx) {
          el.setSymbolScale(nodeScale)
        })
      }

      TreeView.prototype._getNodeGlobalScale = function (seriesModel) {
        const coordSys = seriesModel.coordinateSystem

        if (coordSys.type !== 'view') {
          return 1
        }

        const nodeScaleRatio = this._nodeScaleRatio
        const groupZoom = coordSys.scaleX || 1 // Scale node when zoom changes

        const roamZoom = coordSys.getZoom()
        const nodeScale = (roamZoom - 1) * nodeScaleRatio + 1
        return nodeScale / groupZoom
      }

      TreeView.prototype.dispose = function () {
        this._controller && this._controller.dispose()
        this._controllerHost = null
      }

      TreeView.prototype.remove = function () {
        this._mainGroup.removeAll()

        this._data = null
      }

      TreeView.type = 'tree'
      return TreeView
    }(ChartView))

  function symbolNeedsDraw$1 (data, dataIndex) {
    const layout = data.getItemLayout(dataIndex)
    return layout && !isNaN(layout.x) && !isNaN(layout.y)
  }

  function updateNode (data, dataIndex, symbolEl, group, seriesModel) {
    const isInit = !symbolEl
    const node = data.tree.getNodeByDataIndex(dataIndex)
    const itemModel = node.getModel()
    const visualColor = node.getVisual('style').fill
    const symbolInnerColor = node.isExpand === false && node.children.length !== 0 ? visualColor : '#fff'
    const virtualRoot = data.tree.root
    const source = node.parentNode === virtualRoot ? node : node.parentNode || node
    const sourceSymbolEl = data.getItemGraphicEl(source.dataIndex)
    const sourceLayout = source.getLayout()
    const sourceOldLayout = sourceSymbolEl
      ? {
          x: sourceSymbolEl.__oldX,
          y: sourceSymbolEl.__oldY,
          rawX: sourceSymbolEl.__radialOldRawX,
          rawY: sourceSymbolEl.__radialOldRawY
        }
      : sourceLayout
    const targetLayout = node.getLayout()

    if (isInit) {
      symbolEl = new Symbol(data, dataIndex, null, {
        symbolInnerColor: symbolInnerColor,
        useNameLabel: true
      })
      symbolEl.x = sourceOldLayout.x
      symbolEl.y = sourceOldLayout.y
    } else {
      symbolEl.updateData(data, dataIndex, null, {
        symbolInnerColor: symbolInnerColor,
        useNameLabel: true
      })
    }

    symbolEl.__radialOldRawX = symbolEl.__radialRawX
    symbolEl.__radialOldRawY = symbolEl.__radialRawY
    symbolEl.__radialRawX = targetLayout.rawX
    symbolEl.__radialRawY = targetLayout.rawY
    group.add(symbolEl)
    data.setItemGraphicEl(dataIndex, symbolEl)
    symbolEl.__oldX = symbolEl.x
    symbolEl.__oldY = symbolEl.y
    updateProps(symbolEl, {
      x: targetLayout.x,
      y: targetLayout.y
    }, seriesModel)
    const symbolPath = symbolEl.getSymbolPath()

    if (seriesModel.get('layout') === 'radial') {
      const realRoot = virtualRoot.children[0]
      const rootLayout = realRoot.getLayout()
      const length_1 = realRoot.children.length
      let rad = void 0
      let isLeft = void 0

      if (targetLayout.x === rootLayout.x && node.isExpand === true && realRoot.children.length) {
        const center = {
          x: (realRoot.children[0].getLayout().x + realRoot.children[length_1 - 1].getLayout().x) / 2,
          y: (realRoot.children[0].getLayout().y + realRoot.children[length_1 - 1].getLayout().y) / 2
        }
        rad = Math.atan2(center.y - rootLayout.y, center.x - rootLayout.x)

        if (rad < 0) {
          rad = Math.PI * 2 + rad
        }

        isLeft = center.x < rootLayout.x

        if (isLeft) {
          rad = rad - Math.PI
        }
      } else {
        rad = Math.atan2(targetLayout.y - rootLayout.y, targetLayout.x - rootLayout.x)

        if (rad < 0) {
          rad = Math.PI * 2 + rad
        }

        if (node.children.length === 0 || node.children.length !== 0 && node.isExpand === false) {
          isLeft = targetLayout.x < rootLayout.x

          if (isLeft) {
            rad = rad - Math.PI
          }
        } else {
          isLeft = targetLayout.x > rootLayout.x

          if (!isLeft) {
            rad = rad - Math.PI
          }
        }
      }

      const textPosition = isLeft ? 'left' : 'right'
      const normalLabelModel = itemModel.getModel('label')
      const rotate = normalLabelModel.get('rotate')
      const labelRotateRadian = rotate * (Math.PI / 180)
      const textContent = symbolPath.getTextContent()

      if (textContent) {
        symbolPath.setTextConfig({
          position: normalLabelModel.get('position') || textPosition,
          rotation: rotate == null ? -rad : labelRotateRadian,
          origin: 'center'
        })
        textContent.setStyle('verticalAlign', 'middle')
      }
    } // Handle status

    const focus = itemModel.get(['emphasis', 'focus'])
    const focusDataIndices = focus === 'relative' ? concatArray(node.getAncestorsIndices(), node.getDescendantIndices()) : focus === 'ancestor' ? node.getAncestorsIndices() : focus === 'descendant' ? node.getDescendantIndices() : null

    if (focusDataIndices) {
      // Modify the focus to data indices.
      getECData(symbolEl).focus = focusDataIndices
    }

    drawEdge(seriesModel, node, virtualRoot, symbolEl, sourceOldLayout, sourceLayout, targetLayout, group)

    if (symbolEl.__edge) {
      symbolEl.onHoverStateChange = function (toState) {
        if (toState !== 'blur') {
          // NOTE: Ensure the parent elements will been blurred firstly.
          // According to the return of getAncestorsIndices and getDescendantIndices
          // TODO: A bit tricky.
          const parentEl = node.parentNode && data.getItemGraphicEl(node.parentNode.dataIndex)

          if (!(parentEl && parentEl.hoverState === HOVER_STATE_BLUR)) {
            setStatesFlag(symbolEl.__edge, toState)
          }
        }
      }
    }
  }

  function drawEdge (seriesModel, node, virtualRoot, symbolEl, sourceOldLayout, sourceLayout, targetLayout, group) {
    const itemModel = node.getModel()
    const edgeShape = seriesModel.get('edgeShape')
    const layout = seriesModel.get('layout')
    const orient = seriesModel.getOrient()
    const curvature = seriesModel.get(['lineStyle', 'curveness'])
    const edgeForkPosition = seriesModel.get('edgeForkPosition')
    const lineStyle = itemModel.getModel('lineStyle').getLineStyle()
    let edge = symbolEl.__edge // curve edge from node -> parent
    // polyline edge from node -> children

    if (edgeShape === 'curve') {
      if (node.parentNode && node.parentNode !== virtualRoot) {
        if (!edge) {
          edge = symbolEl.__edge = new BezierCurve({
            shape: getEdgeShape(layout, orient, curvature, sourceOldLayout, sourceOldLayout)
          })
        }

        updateProps(edge, {
          shape: getEdgeShape(layout, orient, curvature, sourceLayout, targetLayout)
        }, seriesModel)
      }
    } else if (edgeShape === 'polyline') {
      if (layout === 'orthogonal') {
        if (node !== virtualRoot && node.children && node.children.length !== 0 && node.isExpand === true) {
          const children = node.children
          const childPoints = []

          for (let i = 0; i < children.length; i++) {
            const childLayout = children[i].getLayout()
            childPoints.push([childLayout.x, childLayout.y])
          }

          if (!edge) {
            edge = symbolEl.__edge = new TreePath({
              shape: {
                parentPoint: [targetLayout.x, targetLayout.y],
                childPoints: [[targetLayout.x, targetLayout.y]],
                orient: orient,
                forkPosition: edgeForkPosition
              }
            })
          }

          updateProps(edge, {
            shape: {
              parentPoint: [targetLayout.x, targetLayout.y],
              childPoints: childPoints
            }
          }, seriesModel)
        }
      } else {
        if ('development' !== 'production') {
          throw new Error('The polyline edgeShape can only be used in orthogonal layout')
        }
      }
    } // show all edge when edgeShape is 'curve', filter node `isExpand` is false when edgeShape is 'polyline'

    if (edge && !(edgeShape === 'polyline' && !node.isExpand)) {
      edge.useStyle(defaults({
        strokeNoScale: true,
        fill: null
      }, lineStyle))
      setStatesStylesFromModel(edge, itemModel, 'lineStyle')
      setDefaultStateProxy(edge)
      group.add(edge)
    }
  }

  function removeNodeEdge (node, data, group, seriesModel, removeAnimationOpt) {
    const virtualRoot = data.tree.root

    const _a = getSourceNode(virtualRoot, node)
    const source = _a.source
    const sourceLayout = _a.sourceLayout

    const symbolEl = data.getItemGraphicEl(node.dataIndex)

    if (!symbolEl) {
      return
    }

    const sourceSymbolEl = data.getItemGraphicEl(source.dataIndex)
    const sourceEdge = sourceSymbolEl.__edge // 1. when expand the sub tree, delete the children node should delete the edge of
    // the source at the same time. because the polyline edge shape is only owned by the source.
    // 2.when the node is the only children of the source, delete the node should delete the edge of
    // the source at the same time. the same reason as above.

    const edge = symbolEl.__edge || (source.isExpand === false || source.children.length === 1 ? sourceEdge : undefined)
    const edgeShape = seriesModel.get('edgeShape')
    const layoutOpt = seriesModel.get('layout')
    const orient = seriesModel.get('orient')
    const curvature = seriesModel.get(['lineStyle', 'curveness'])

    if (edge) {
      if (edgeShape === 'curve') {
        removeElement(edge, {
          shape: getEdgeShape(layoutOpt, orient, curvature, sourceLayout, sourceLayout),
          style: {
            opacity: 0
          }
        }, seriesModel, {
          cb: function () {
            group.remove(edge)
          },
          removeOpt: removeAnimationOpt
        })
      } else if (edgeShape === 'polyline' && seriesModel.get('layout') === 'orthogonal') {
        removeElement(edge, {
          shape: {
            parentPoint: [sourceLayout.x, sourceLayout.y],
            childPoints: [[sourceLayout.x, sourceLayout.y]]
          },
          style: {
            opacity: 0
          }
        }, seriesModel, {
          cb: function () {
            group.remove(edge)
          },
          removeOpt: removeAnimationOpt
        })
      }
    }
  }

  function getSourceNode (virtualRoot, node) {
    let source = node.parentNode === virtualRoot ? node : node.parentNode || node
    let sourceLayout

    while (sourceLayout = source.getLayout(), sourceLayout == null) {
      source = source.parentNode === virtualRoot ? source : source.parentNode || source
    }

    return {
      source: source,
      sourceLayout: sourceLayout
    }
  }

  function removeNode (data, dataIndex, symbolEl, group, seriesModel) {
    const node = data.tree.getNodeByDataIndex(dataIndex)
    const virtualRoot = data.tree.root
    const sourceLayout = getSourceNode(virtualRoot, node).sourceLayout // Use same duration and easing with update to have more consistent animation.

    const removeAnimationOpt = {
      duration: seriesModel.get('animationDurationUpdate'),
      easing: seriesModel.get('animationEasingUpdate')
    }
    removeElement(symbolEl, {
      x: sourceLayout.x + 1,
      y: sourceLayout.y + 1
    }, seriesModel, {
      cb: function () {
        group.remove(symbolEl)
        data.setItemGraphicEl(dataIndex, null)
      },
      removeOpt: removeAnimationOpt
    })
    symbolEl.fadeOut(null, data.hostModel, {
      fadeLabel: true,
      animation: removeAnimationOpt
    }) // remove edge as parent node

    node.children.forEach(function (childNode) {
      removeNodeEdge(childNode, data, group, seriesModel, removeAnimationOpt)
    }) // remove edge as child node

    removeNodeEdge(node, data, group, seriesModel, removeAnimationOpt)
  }

  function getEdgeShape (layoutOpt, orient, curvature, sourceLayout, targetLayout) {
    let cpx1
    let cpy1
    let cpx2
    let cpy2
    let x1
    let x2
    let y1
    let y2

    if (layoutOpt === 'radial') {
      x1 = sourceLayout.rawX
      y1 = sourceLayout.rawY
      x2 = targetLayout.rawX
      y2 = targetLayout.rawY
      const radialCoor1 = radialCoordinate(x1, y1)
      const radialCoor2 = radialCoordinate(x1, y1 + (y2 - y1) * curvature)
      const radialCoor3 = radialCoordinate(x2, y2 + (y1 - y2) * curvature)
      const radialCoor4 = radialCoordinate(x2, y2)
      return {
        x1: radialCoor1.x || 0,
        y1: radialCoor1.y || 0,
        x2: radialCoor4.x || 0,
        y2: radialCoor4.y || 0,
        cpx1: radialCoor2.x || 0,
        cpy1: radialCoor2.y || 0,
        cpx2: radialCoor3.x || 0,
        cpy2: radialCoor3.y || 0
      }
    } else {
      x1 = sourceLayout.x
      y1 = sourceLayout.y
      x2 = targetLayout.x
      y2 = targetLayout.y

      if (orient === 'LR' || orient === 'RL') {
        cpx1 = x1 + (x2 - x1) * curvature
        cpy1 = y1
        cpx2 = x2 + (x1 - x2) * curvature
        cpy2 = y2
      }

      if (orient === 'TB' || orient === 'BT') {
        cpx1 = x1
        cpy1 = y1 + (y2 - y1) * curvature
        cpx2 = x2
        cpy2 = y2 + (y1 - y2) * curvature
      }
    }

    return {
      x1: x1,
      y1: y1,
      x2: x2,
      y2: y2,
      cpx1: cpx1,
      cpy1: cpy1,
      cpx2: cpx2,
      cpy2: cpy2
    }
  }

  const inner$7 = makeInner()

  function linkSeriesData (opt) {
    const mainData = opt.mainData
    let datas = opt.datas

    if (!datas) {
      datas = {
        main: mainData
      }
      opt.datasAttr = {
        main: 'data'
      }
    }

    opt.datas = opt.mainData = null
    linkAll(mainData, datas, opt) // Porxy data original methods.

    each(datas, function (data) {
      each(mainData.TRANSFERABLE_METHODS, function (methodName) {
        data.wrapMethod(methodName, curry(transferInjection, opt))
      })
    }) // Beyond transfer, additional features should be added to `cloneShallow`.

    mainData.wrapMethod('cloneShallow', curry(cloneShallowInjection, opt)) // Only mainData trigger change, because struct.update may trigger
    // another changable methods, which may bring about dead lock.

    each(mainData.CHANGABLE_METHODS, function (methodName) {
      mainData.wrapMethod(methodName, curry(changeInjection, opt))
    }) // Make sure datas contains mainData.

    assert(datas[mainData.dataType] === mainData)
  }

  function transferInjection (opt, res) {
    if (isMainData(this)) {
      // Transfer datas to new main data.
      const datas = extend({}, inner$7(this).datas)
      datas[this.dataType] = res
      linkAll(res, datas, opt)
    } else {
      // Modify the reference in main data to point newData.
      linkSingle(res, this.dataType, inner$7(this).mainData, opt)
    }

    return res
  }

  function changeInjection (opt, res) {
    opt.struct && opt.struct.update()
    return res
  }

  function cloneShallowInjection (opt, res) {
    // cloneShallow, which brings about some fragilities, may be inappropriate
    // to be exposed as an API. So for implementation simplicity we can make
    // the restriction that cloneShallow of not-mainData should not be invoked
    // outside, but only be invoked here.
    each(inner$7(res).datas, function (data, dataType) {
      data !== res && linkSingle(data.cloneShallow(), dataType, res, opt)
    })
    return res
  }
  /**
     * Supplement method to List.
     *
     * @public
     * @param [dataType] If not specified, return mainData.
     */

  function getLinkedData (dataType) {
    const mainData = inner$7(this).mainData
    return dataType == null || mainData == null ? mainData : inner$7(mainData).datas[dataType]
  }
  /**
     * Get list of all linked data
     */

  function getLinkedDataAll () {
    const mainData = inner$7(this).mainData
    return mainData == null
      ? [{
          data: mainData
        }]
      : map(keys(inner$7(mainData).datas), function (type) {
        return {
          type: type,
          data: inner$7(mainData).datas[type]
        }
      })
  }

  function isMainData (data) {
    return inner$7(data).mainData === data
  }

  function linkAll (mainData, datas, opt) {
    inner$7(mainData).datas = {}
    each(datas, function (data, dataType) {
      linkSingle(data, dataType, mainData, opt)
    })
  }

  function linkSingle (data, dataType, mainData, opt) {
    inner$7(mainData).datas[dataType] = data
    inner$7(data).mainData = mainData
    data.dataType = dataType

    if (opt.struct) {
      data[opt.structAttr] = opt.struct
      opt.struct[opt.datasAttr[dataType]] = data
    } // Supplement method.

    data.getLinkedData = getLinkedData
    data.getLinkedDataAll = getLinkedDataAll
  }

  const TreeNode =
    /** @class */
    (function () {
      function TreeNode (name, hostTree) {
        this.depth = 0
        this.height = 0
        /**
         * Reference to list item.
         * Do not persistent dataIndex outside,
         * besause it may be changed by list.
         * If dataIndex -1,
         * this node is logical deleted (filtered) in list.
         */

        this.dataIndex = -1
        this.children = []
        this.viewChildren = []
        this.isExpand = false
        this.name = name || ''
        this.hostTree = hostTree
      }
      /**
       * The node is removed.
       */

      TreeNode.prototype.isRemoved = function () {
        return this.dataIndex < 0
      }

      TreeNode.prototype.eachNode = function (options, cb, context) {
        if (isFunction(options)) {
          context = cb
          cb = options
          options = null
        }

        options = options || {}

        if (isString(options)) {
          options = {
            order: options
          }
        }

        const order = options.order || 'preorder'
        const children = this[options.attr || 'children']
        let suppressVisitSub
        order === 'preorder' && (suppressVisitSub = cb.call(context, this))

        for (let i = 0; !suppressVisitSub && i < children.length; i++) {
          children[i].eachNode(options, cb, context)
        }

        order === 'postorder' && cb.call(context, this)
      }
      /**
       * Update depth and height of this subtree.
       */

      TreeNode.prototype.updateDepthAndHeight = function (depth) {
        let height = 0
        this.depth = depth

        for (let i = 0; i < this.children.length; i++) {
          const child = this.children[i]
          child.updateDepthAndHeight(depth + 1)

          if (child.height > height) {
            height = child.height
          }
        }

        this.height = height + 1
      }

      TreeNode.prototype.getNodeById = function (id) {
        if (this.getId() === id) {
          return this
        }

        for (let i = 0, children = this.children, len = children.length; i < len; i++) {
          const res = children[i].getNodeById(id)

          if (res) {
            return res
          }
        }
      }

      TreeNode.prototype.contains = function (node) {
        if (node === this) {
          return true
        }

        for (let i = 0, children = this.children, len = children.length; i < len; i++) {
          const res = children[i].contains(node)

          if (res) {
            return res
          }
        }
      }
      /**
       * @param includeSelf Default false.
       * @return order: [root, child, grandchild, ...]
       */

      TreeNode.prototype.getAncestors = function (includeSelf) {
        const ancestors = []
        let node = includeSelf ? this : this.parentNode

        while (node) {
          ancestors.push(node)
          node = node.parentNode
        }

        ancestors.reverse()
        return ancestors
      }

      TreeNode.prototype.getAncestorsIndices = function () {
        const indices = []
        let currNode = this

        while (currNode) {
          indices.push(currNode.dataIndex)
          currNode = currNode.parentNode
        }

        indices.reverse()
        return indices
      }

      TreeNode.prototype.getDescendantIndices = function () {
        const indices = []
        this.eachNode(function (childNode) {
          indices.push(childNode.dataIndex)
        })
        return indices
      }

      TreeNode.prototype.getValue = function (dimension) {
        const data = this.hostTree.data
        return data.getStore().get(data.getDimensionIndex(dimension || 'value'), this.dataIndex)
      }

      TreeNode.prototype.setLayout = function (layout, merge) {
        this.dataIndex >= 0 && this.hostTree.data.setItemLayout(this.dataIndex, layout, merge)
      }
      /**
       * @return {Object} layout
       */

      TreeNode.prototype.getLayout = function () {
        return this.hostTree.data.getItemLayout(this.dataIndex)
      } // @depcrecated
      // getModel<T = unknown, S extends keyof T = keyof T>(path: S): Model<T[S]>
      // eslint-disable-next-line @typescript-eslint/no-unused-vars

      TreeNode.prototype.getModel = function (path) {
        if (this.dataIndex < 0) {
          return
        }

        const hostTree = this.hostTree
        const itemModel = hostTree.data.getItemModel(this.dataIndex)
        return itemModel.getModel(path)
      } // TODO: TYPE More specific model

      TreeNode.prototype.getLevelModel = function () {
        return (this.hostTree.levelModels || [])[this.depth]
      }

      TreeNode.prototype.setVisual = function (key, value) {
        this.dataIndex >= 0 && this.hostTree.data.setItemVisual(this.dataIndex, key, value)
      }
      /**
       * Get item visual
       * FIXME: make return type better
       */

      TreeNode.prototype.getVisual = function (key) {
        return this.hostTree.data.getItemVisual(this.dataIndex, key)
      }

      TreeNode.prototype.getRawIndex = function () {
        return this.hostTree.data.getRawIndex(this.dataIndex)
      }

      TreeNode.prototype.getId = function () {
        return this.hostTree.data.getId(this.dataIndex)
      }
      /**
       * index in parent's children
       */

      TreeNode.prototype.getChildIndex = function () {
        if (this.parentNode) {
          const children = this.parentNode.children

          for (let i = 0; i < children.length; ++i) {
            if (children[i] === this) {
              return i
            }
          }

          return -1
        }

        return -1
      }
      /**
       * if this is an ancestor of another node
       *
       * @param node another node
       * @return if is ancestor
       */

      TreeNode.prototype.isAncestorOf = function (node) {
        let parent = node.parentNode

        while (parent) {
          if (parent === this) {
            return true
          }

          parent = parent.parentNode
        }

        return false
      }
      /**
       * if this is an descendant of another node
       *
       * @param node another node
       * @return if is descendant
       */

      TreeNode.prototype.isDescendantOf = function (node) {
        return node !== this && node.isAncestorOf(this)
      }

      return TreeNode
    }())

  const Tree =
    /** @class */
    (function () {
      function Tree (hostModel) {
        this.type = 'tree'
        this._nodes = []
        this.hostModel = hostModel
      }

      Tree.prototype.eachNode = function (options, cb, context) {
        this.root.eachNode(options, cb, context)
      }

      Tree.prototype.getNodeByDataIndex = function (dataIndex) {
        const rawIndex = this.data.getRawIndex(dataIndex)
        return this._nodes[rawIndex]
      }

      Tree.prototype.getNodeById = function (name) {
        return this.root.getNodeById(name)
      }
      /**
       * Update item available by list,
       * when list has been performed options like 'filterSelf' or 'map'.
       */

      Tree.prototype.update = function () {
        const data = this.data
        const nodes = this._nodes

        for (var i = 0, len = nodes.length; i < len; i++) {
          nodes[i].dataIndex = -1
        }

        for (var i = 0, len = data.count(); i < len; i++) {
          nodes[data.getRawIndex(i)].dataIndex = i
        }
      }
      /**
       * Clear all layouts
       */

      Tree.prototype.clearLayouts = function () {
        this.data.clearItemLayouts()
      }
      /**
       * data node format:
       * {
       *     name: ...
       *     value: ...
       *     children: [
       *         {
       *             name: ...
       *             value: ...
       *             children: ...
       *         },
       *         ...
       *     ]
       * }
       */

      Tree.createTree = function (dataRoot, hostModel, beforeLink) {
        const tree = new Tree(hostModel)
        const listData = []
        let dimMax = 1
        buildHierarchy(dataRoot)

        function buildHierarchy (dataNode, parentNode) {
          const value = dataNode.value
          dimMax = Math.max(dimMax, isArray(value) ? value.length : 1)
          listData.push(dataNode)
          const node = new TreeNode(convertOptionIdName(dataNode.name, ''), tree)
          parentNode ? addChild(node, parentNode) : tree.root = node

          tree._nodes.push(node)

          const children = dataNode.children

          if (children) {
            for (let i = 0; i < children.length; i++) {
              buildHierarchy(children[i], node)
            }
          }
        }

        tree.root.updateDepthAndHeight(0)
        const dimensions = prepareSeriesDataSchema(listData, {
          coordDimensions: ['value'],
          dimensionsCount: dimMax
        }).dimensions
        const list = new SeriesData(dimensions, hostModel)
        list.initData(listData)
        beforeLink && beforeLink(list)
        linkSeriesData({
          mainData: list,
          struct: tree,
          structAttr: 'tree'
        })
        tree.update()
        return tree
      }

      return Tree
    }())
    /**
     * It is needed to consider the mess of 'list', 'hostModel' when creating a TreeNote,
     * so this function is not ready and not necessary to be public.
     */

  function addChild (child, node) {
    const children = node.children

    if (child.parentNode === node) {
      return
    }

    children.push(child)
    child.parentNode = node
  }

  function retrieveTargetInfo (payload, validPayloadTypes, seriesModel) {
    if (payload && indexOf(validPayloadTypes, payload.type) >= 0) {
      const root = seriesModel.getData().tree.root
      let targetNode = payload.targetNode

      if (isString(targetNode)) {
        targetNode = root.getNodeById(targetNode)
      }

      if (targetNode && root.contains(targetNode)) {
        return {
          node: targetNode
        }
      }

      const targetNodeId = payload.targetNodeId

      if (targetNodeId != null && (targetNode = root.getNodeById(targetNodeId))) {
        return {
          node: targetNode
        }
      }
    }
  } // Not includes the given node at the last item.

  function getPathToRoot (node) {
    const path = []

    while (node) {
      node = node.parentNode
      node && path.push(node)
    }

    return path.reverse()
  }
  function aboveViewRoot (viewRoot, node) {
    const viewPath = getPathToRoot(viewRoot)
    return indexOf(viewPath, node) >= 0
  } // From root to the input node (the input node will be included).

  function wrapTreePathInfo (node, seriesModel) {
    const treePathInfo = []

    while (node) {
      const nodeDataIndex = node.dataIndex
      treePathInfo.push({
        name: node.name,
        dataIndex: nodeDataIndex,
        value: seriesModel.getRawValue(nodeDataIndex)
      })
      node = node.parentNode
    }

    treePathInfo.reverse()
    return treePathInfo
  }

  const TreeSeriesModel =
    /** @class */
    (function (_super) {
      __extends(TreeSeriesModel, _super)

      function TreeSeriesModel () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.hasSymbolVisual = true // Do it self.

        _this.ignoreStyleOnData = true
        return _this
      }
      /**
       * Init a tree data structure from data in option series
       */

      TreeSeriesModel.prototype.getInitialData = function (option) {
        // create an virtual root
        const root = {
          name: option.name,
          children: option.data
        }
        const leaves = option.leaves || {}
        const leavesModel = new Model(leaves, this, this.ecModel)
        const tree = Tree.createTree(root, this, beforeLink)

        function beforeLink (nodeData) {
          nodeData.wrapMethod('getItemModel', function (model, idx) {
            const node = tree.getNodeByDataIndex(idx)

            if (!(node && node.children.length && node.isExpand)) {
              model.parentModel = leavesModel
            }

            return model
          })
        }

        let treeDepth = 0
        tree.eachNode('preorder', function (node) {
          if (node.depth > treeDepth) {
            treeDepth = node.depth
          }
        })
        const expandAndCollapse = option.expandAndCollapse
        const expandTreeDepth = expandAndCollapse && option.initialTreeDepth >= 0 ? option.initialTreeDepth : treeDepth
        tree.root.eachNode('preorder', function (node) {
          const item = node.hostTree.data.getRawDataItem(node.dataIndex) // Add item.collapsed != null, because users can collapse node original in the series.data.

          node.isExpand = item && item.collapsed != null ? !item.collapsed : node.depth <= expandTreeDepth
        })
        return tree.data
      }
      /**
       * Make the configuration 'orient' backward compatibly, with 'horizontal = LR', 'vertical = TB'.
       * @returns {string} orient
       */

      TreeSeriesModel.prototype.getOrient = function () {
        let orient = this.get('orient')

        if (orient === 'horizontal') {
          orient = 'LR'
        } else if (orient === 'vertical') {
          orient = 'TB'
        }

        return orient
      }

      TreeSeriesModel.prototype.setZoom = function (zoom) {
        this.option.zoom = zoom
      }

      TreeSeriesModel.prototype.setCenter = function (center) {
        this.option.center = center
      }

      TreeSeriesModel.prototype.formatTooltip = function (dataIndex, multipleSeries, dataType) {
        const tree = this.getData().tree
        const realRoot = tree.root.children[0]
        let node = tree.getNodeByDataIndex(dataIndex)
        const value = node.getValue()
        let name = node.name

        while (node && node !== realRoot) {
          name = node.parentNode.name + '.' + name
          node = node.parentNode
        }

        return createTooltipMarkup('nameValue', {
          name: name,
          value: value,
          noValue: isNaN(value) || value == null
        })
      } // Add tree path to tooltip param

      TreeSeriesModel.prototype.getDataParams = function (dataIndex) {
        const params = _super.prototype.getDataParams.apply(this, arguments)

        const node = this.getData().tree.getNodeByDataIndex(dataIndex)
        params.treeAncestors = wrapTreePathInfo(node, this)
        params.collapsed = !node.isExpand
        return params
      }

      TreeSeriesModel.type = 'series.tree' // can support the position parameters 'left', 'top','right','bottom', 'width',
      // 'height' in the setOption() with 'merge' mode normal.

      TreeSeriesModel.layoutMode = 'box'
      TreeSeriesModel.defaultOption = {
        // zlevel: 0,
        z: 2,
        coordinateSystem: 'view',
        // the position of the whole view
        left: '12%',
        top: '12%',
        right: '12%',
        bottom: '12%',
        // the layout of the tree, two value can be selected, 'orthogonal' or 'radial'
        layout: 'orthogonal',
        // value can be 'polyline'
        edgeShape: 'curve',
        edgeForkPosition: '50%',
        // true | false | 'move' | 'scale', see module:component/helper/RoamController.
        roam: false,
        // Symbol size scale ratio in roam
        nodeScaleRatio: 0.4,
        // Default on center of graph
        center: null,
        zoom: 1,
        orient: 'LR',
        symbol: 'emptyCircle',
        symbolSize: 7,
        expandAndCollapse: true,
        initialTreeDepth: 2,
        lineStyle: {
          color: '#ccc',
          width: 1.5,
          curveness: 0.5
        },
        itemStyle: {
          color: 'lightsteelblue',
          // borderColor: '#c23531',
          borderWidth: 1.5
        },
        label: {
          show: true
        },
        animationEasing: 'linear',
        animationDuration: 700,
        animationDurationUpdate: 500
      }
      return TreeSeriesModel
    }(SeriesModel))

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

  /**
     * AUTO-GENERATED FILE. DO NOT MODIFY.
     */

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

  /**
     * Traverse the tree from bottom to top and do something
     */
  function eachAfter (root, callback, separation) {
    const nodes = [root]
    const next = []
    let node

    while (node = nodes.pop()) {
      // jshint ignore:line
      next.push(node)

      if (node.isExpand) {
        const children = node.children

        if (children.length) {
          for (let i = 0; i < children.length; i++) {
            nodes.push(children[i])
          }
        }
      }
    }

    while (node = next.pop()) {
      // jshint ignore:line
      callback(node, separation)
    }
  }
  /**
     * Traverse the tree from top to bottom and do something
     */

  function eachBefore (root, callback) {
    const nodes = [root]
    let node

    while (node = nodes.pop()) {
      // jshint ignore:line
      callback(node)

      if (node.isExpand) {
        const children = node.children

        if (children.length) {
          for (let i = children.length - 1; i >= 0; i--) {
            nodes.push(children[i])
          }
        }
      }
    }
  }

  function treeLayout (ecModel, api) {
    ecModel.eachSeriesByType('tree', function (seriesModel) {
      commonLayout(seriesModel, api)
    })
  }

  function commonLayout (seriesModel, api) {
    const layoutInfo = getViewRect$1(seriesModel, api)
    seriesModel.layoutInfo = layoutInfo
    const layout = seriesModel.get('layout')
    let width = 0
    let height = 0
    let separation$1 = null

    if (layout === 'radial') {
      width = 2 * Math.PI
      height = Math.min(layoutInfo.height, layoutInfo.width) / 2
      separation$1 = separation(function (node1, node2) {
        return (node1.parentNode === node2.parentNode ? 1 : 2) / node1.depth
      })
    } else {
      width = layoutInfo.width
      height = layoutInfo.height
      separation$1 = separation()
    }

    const virtualRoot = seriesModel.getData().tree.root
    const realRoot = virtualRoot.children[0]

    if (realRoot) {
      init$2(virtualRoot)
      eachAfter(realRoot, firstWalk, separation$1)
      virtualRoot.hierNode.modifier = -realRoot.hierNode.prelim
      eachBefore(realRoot, secondWalk)
      let left_1 = realRoot
      let right_1 = realRoot
      let bottom_1 = realRoot
      eachBefore(realRoot, function (node) {
        const x = node.getLayout().x

        if (x < left_1.getLayout().x) {
          left_1 = node
        }

        if (x > right_1.getLayout().x) {
          right_1 = node
        }

        if (node.depth > bottom_1.depth) {
          bottom_1 = node
        }
      })
      const delta = left_1 === right_1 ? 1 : separation$1(left_1, right_1) / 2
      const tx_1 = delta - left_1.getLayout().x
      let kx_1 = 0
      let ky_1 = 0
      let coorX_1 = 0
      let coorY_1 = 0

      if (layout === 'radial') {
        kx_1 = width / (right_1.getLayout().x + delta + tx_1) // here we use (node.depth - 1), bucause the real root's depth is 1

        ky_1 = height / (bottom_1.depth - 1 || 1)
        eachBefore(realRoot, function (node) {
          coorX_1 = (node.getLayout().x + tx_1) * kx_1
          coorY_1 = (node.depth - 1) * ky_1
          const finalCoor = radialCoordinate(coorX_1, coorY_1)
          node.setLayout({
            x: finalCoor.x,
            y: finalCoor.y,
            rawX: coorX_1,
            rawY: coorY_1
          }, true)
        })
      } else {
        const orient_1 = seriesModel.getOrient()

        if (orient_1 === 'RL' || orient_1 === 'LR') {
          ky_1 = height / (right_1.getLayout().x + delta + tx_1)
          kx_1 = width / (bottom_1.depth - 1 || 1)
          eachBefore(realRoot, function (node) {
            coorY_1 = (node.getLayout().x + tx_1) * ky_1
            coorX_1 = orient_1 === 'LR' ? (node.depth - 1) * kx_1 : width - (node.depth - 1) * kx_1
            node.setLayout({
              x: coorX_1,
              y: coorY_1
            }, true)
          })
        } else if (orient_1 === 'TB' || orient_1 === 'BT') {
          kx_1 = width / (right_1.getLayout().x + delta + tx_1)
          ky_1 = height / (bottom_1.depth - 1 || 1)
          eachBefore(realRoot, function (node) {
            coorX_1 = (node.getLayout().x + tx_1) * kx_1
            coorY_1 = orient_1 === 'TB' ? (node.depth - 1) * ky_1 : height - (node.depth - 1) * ky_1
            node.setLayout({
              x: coorX_1,
              y: coorY_1
            }, true)
          })
        }
      }
    }
  }

  function treeVisual (ecModel) {
    ecModel.eachSeriesByType('tree', function (seriesModel) {
      const data = seriesModel.getData()
      const tree = data.tree
      tree.eachNode(function (node) {
        const model = node.getModel() // TODO Optimize

        const style = model.getModel('itemStyle').getItemStyle()
        const existsStyle = data.ensureUniqueItemVisual(node.dataIndex, 'style')
        extend(existsStyle, style)
      })
    })
  }

  function installTreeAction (registers) {
    registers.registerAction({
      type: 'treeExpandAndCollapse',
      event: 'treeExpandAndCollapse',
      update: 'update'
    }, function (payload, ecModel) {
      ecModel.eachComponent({
        mainType: 'series',
        subType: 'tree',
        query: payload
      }, function (seriesModel) {
        const dataIndex = payload.dataIndex
        const tree = seriesModel.getData().tree
        const node = tree.getNodeByDataIndex(dataIndex)
        node.isExpand = !node.isExpand
      })
    })
    registers.registerAction({
      type: 'treeRoam',
      event: 'treeRoam',
      // Here we set 'none' instead of 'update', because roam action
      // just need to update the transform matrix without having to recalculate
      // the layout. So don't need to go through the whole update process, such
      // as 'dataPrcocess', 'coordSystemUpdate', 'layout' and so on.
      update: 'none'
    }, function (payload, ecModel, api) {
      ecModel.eachComponent({
        mainType: 'series',
        subType: 'tree',
        query: payload
      }, function (seriesModel) {
        const coordSys = seriesModel.coordinateSystem
        const res = updateCenterAndZoom(coordSys, payload, undefined, api)
        seriesModel.setCenter && seriesModel.setCenter(res.center)
        seriesModel.setZoom && seriesModel.setZoom(res.zoom)
      })
    })
  }

  function install$b (registers) {
    registers.registerChartView(TreeView)
    registers.registerSeriesModel(TreeSeriesModel)
    registers.registerLayout(treeLayout)
    registers.registerVisual(treeVisual)
    installTreeAction(registers)
  }

  const actionTypes = ['treemapZoomToNode', 'treemapRender', 'treemapMove']
  function installTreemapAction (registers) {
    for (let i = 0; i < actionTypes.length; i++) {
      registers.registerAction({
        type: actionTypes[i],
        update: 'updateView'
      }, noop)
    }

    registers.registerAction({
      type: 'treemapRootToNode',
      update: 'updateView'
    }, function (payload, ecModel) {
      ecModel.eachComponent({
        mainType: 'series',
        subType: 'treemap',
        query: payload
      }, handleRootToNode)

      function handleRootToNode (model, index) {
        const types = ['treemapZoomToNode', 'treemapRootToNode']
        const targetInfo = retrieveTargetInfo(payload, types, model)

        if (targetInfo) {
          const originViewRoot = model.getViewRoot()

          if (originViewRoot) {
            payload.direction = aboveViewRoot(originViewRoot, targetInfo.node) ? 'rollUp' : 'drillDown'
          }

          model.resetViewRoot(targetInfo.node)
        }
      }
    })
  }

  function enableAriaDecalForTree (seriesModel) {
    const data = seriesModel.getData()
    const tree = data.tree
    const decalPaletteScope = {}
    tree.eachNode(function (node) {
      // Use decal of level 1 node
      let current = node

      while (current && current.depth > 1) {
        current = current.parentNode
      }

      const decal = getDecalFromPalette(seriesModel.ecModel, current.name || current.dataIndex + '', decalPaletteScope)
      node.setVisual('decal', decal)
    })
  }

  const TreemapSeriesModel =
    /** @class */
    (function (_super) {
      __extends(TreemapSeriesModel, _super)

      function TreemapSeriesModel () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = TreemapSeriesModel.type
        _this.preventUsingHoverLayer = true
        return _this
      }
      /**
       * @override
       */

      TreemapSeriesModel.prototype.getInitialData = function (option, ecModel) {
        // Create a virtual root.
        const root = {
          name: option.name,
          children: option.data
        }
        completeTreeValue(root)
        let levels = option.levels || [] // Used in "visual priority" in `treemapVisual.js`.
        // This way is a little tricky, must satisfy the precondition:
        //   1. There is no `treeNode.getModel('itemStyle.xxx')` used.
        //   2. The `Model.prototype.getModel()` will not use any clone-like way.

        const designatedVisualItemStyle = this.designatedVisualItemStyle = {}
        const designatedVisualModel = new Model({
          itemStyle: designatedVisualItemStyle
        }, this, ecModel)
        levels = option.levels = setDefault(levels, ecModel)
        const levelModels = map(levels || [], function (levelDefine) {
          return new Model(levelDefine, designatedVisualModel, ecModel)
        }, this) // Make sure always a new tree is created when setOption,
        // in TreemapView, we check whether oldTree === newTree
        // to choose mappings approach among old shapes and new shapes.

        const tree = Tree.createTree(root, this, beforeLink)

        function beforeLink (nodeData) {
          nodeData.wrapMethod('getItemModel', function (model, idx) {
            const node = tree.getNodeByDataIndex(idx)
            const levelModel = node ? levelModels[node.depth] : null // If no levelModel, we also need `designatedVisualModel`.

            model.parentModel = levelModel || designatedVisualModel
            return model
          })
        }

        return tree.data
      }

      TreemapSeriesModel.prototype.optionUpdated = function () {
        this.resetViewRoot()
      }
      /**
       * @override
       * @param {number} dataIndex
       * @param {boolean} [mutipleSeries=false]
       */

      TreemapSeriesModel.prototype.formatTooltip = function (dataIndex, multipleSeries, dataType) {
        const data = this.getData()
        const value = this.getRawValue(dataIndex)
        const name = data.getName(dataIndex)
        return createTooltipMarkup('nameValue', {
          name: name,
          value: value
        })
      }
      /**
       * Add tree path to tooltip param
       *
       * @override
       * @param {number} dataIndex
       * @return {Object}
       */

      TreemapSeriesModel.prototype.getDataParams = function (dataIndex) {
        const params = _super.prototype.getDataParams.apply(this, arguments)

        const node = this.getData().tree.getNodeByDataIndex(dataIndex)
        params.treeAncestors = wrapTreePathInfo(node, this) // compatitable the previous code.

        params.treePathInfo = params.treeAncestors
        return params
      }
      /**
       * @public
       * @param {Object} layoutInfo {
       *                                x: containerGroup x
       *                                y: containerGroup y
       *                                width: containerGroup width
       *                                height: containerGroup height
       *                            }
       */

      TreemapSeriesModel.prototype.setLayoutInfo = function (layoutInfo) {
        /**
         * @readOnly
         * @type {Object}
         */
        this.layoutInfo = this.layoutInfo || {}
        extend(this.layoutInfo, layoutInfo)
      }
      /**
       * @param  {string} id
       * @return {number} index
       */

      TreemapSeriesModel.prototype.mapIdToIndex = function (id) {
        // A feature is implemented:
        // index is monotone increasing with the sequence of
        // input id at the first time.
        // This feature can make sure that each data item and its
        // mapped color have the same index between data list and
        // color list at the beginning, which is useful for user
        // to adjust data-color mapping.

        /**
         * @private
         * @type {Object}
         */
        let idIndexMap = this._idIndexMap

        if (!idIndexMap) {
          idIndexMap = this._idIndexMap = createHashMap()
          /**
           * @private
           * @type {number}
           */

          this._idIndexMapCount = 0
        }

        let index = idIndexMap.get(id)

        if (index == null) {
          idIndexMap.set(id, index = this._idIndexMapCount++)
        }

        return index
      }

      TreemapSeriesModel.prototype.getViewRoot = function () {
        return this._viewRoot
      }

      TreemapSeriesModel.prototype.resetViewRoot = function (viewRoot) {
        viewRoot ? this._viewRoot = viewRoot : viewRoot = this._viewRoot
        const root = this.getRawData().tree.root

        if (!viewRoot || viewRoot !== root && !root.contains(viewRoot)) {
          this._viewRoot = root
        }
      }

      TreemapSeriesModel.prototype.enableAriaDecal = function () {
        enableAriaDecalForTree(this)
      }

      TreemapSeriesModel.type = 'series.treemap'
      TreemapSeriesModel.layoutMode = 'box'
      TreemapSeriesModel.defaultOption = {
        // Disable progressive rendering
        progressive: 0,
        // size: ['80%', '80%'],            // deprecated, compatible with ec2.
        left: 'center',
        top: 'middle',
        width: '80%',
        height: '80%',
        sort: true,
        clipWindow: 'origin',
        squareRatio: 0.5 * (1 + Math.sqrt(5)),
        leafDepth: null,
        drillDownIcon: '▶',
        // to align specialized icon. ▷▶❒❐▼✚
        zoomToNodeRatio: 0.32 * 0.32,
        roam: true,
        nodeClick: 'zoomToNode',
        animation: true,
        animationDurationUpdate: 900,
        animationEasing: 'quinticInOut',
        breadcrumb: {
          show: true,
          height: 22,
          left: 'center',
          top: 'bottom',
          // right
          // bottom
          emptyItemWidth: 25,
          itemStyle: {
            color: 'rgba(0,0,0,0.7)',
            textStyle: {
              color: '#fff'
            }
          }
        },
        label: {
          show: true,
          // Do not use textDistance, for ellipsis rect just the same as treemap node rect.
          distance: 0,
          padding: 5,
          position: 'inside',
          // formatter: null,
          color: '#fff',
          overflow: 'truncate' // align
          // verticalAlign

        },
        upperLabel: {
          show: false,
          position: [0, '50%'],
          height: 20,
          // formatter: null,
          // color: '#fff',
          overflow: 'truncate',
          // align: null,
          verticalAlign: 'middle'
        },
        itemStyle: {
          color: null,
          colorAlpha: null,
          colorSaturation: null,
          borderWidth: 0,
          gapWidth: 0,
          borderColor: '#fff',
          borderColorSaturation: null // If specified, borderColor will be ineffective, and the
          // border color is evaluated by color of current node and
          // borderColorSaturation.

        },
        emphasis: {
          upperLabel: {
            show: true,
            position: [0, '50%'],
            overflow: 'truncate',
            verticalAlign: 'middle'
          }
        },
        visualDimension: 0,
        visualMin: null,
        visualMax: null,
        color: [],
        // level[n].color (if necessary).
        // + Specify color list of each level. level[0].color would be global
        // color list if not specified. (see method `setDefault`).
        // + But set as a empty array to forbid fetch color from global palette
        // when using nodeModel.get('color'), otherwise nodes on deep level
        // will always has color palette set and are not able to inherit color
        // from parent node.
        // + TreemapSeries.color can not be set as 'none', otherwise effect
        // legend color fetching (see seriesColor.js).
        colorAlpha: null,
        colorSaturation: null,
        colorMappingBy: 'index',
        visibleMin: 10,
        // be rendered. Only works when sort is 'asc' or 'desc'.
        childrenVisibleMin: null,
        // grandchildren will not show.
        // Why grandchildren? If not grandchildren but children,
        // some siblings show children and some not,
        // the appearance may be mess and not consistent,
        levels: [] // Each item: {
        //     visibleMin, itemStyle, visualDimension, label
        // }

      }
      return TreemapSeriesModel
    }(SeriesModel))
    /**
     * @param {Object} dataNode
     */

  function completeTreeValue (dataNode) {
    // Postorder travel tree.
    // If value of none-leaf node is not set,
    // calculate it by suming up the value of all children.
    let sum = 0
    each(dataNode.children, function (child) {
      completeTreeValue(child)
      let childValue = child.value
      isArray(childValue) && (childValue = childValue[0])
      sum += childValue
    })
    let thisValue = dataNode.value

    if (isArray(thisValue)) {
      thisValue = thisValue[0]
    }

    if (thisValue == null || isNaN(thisValue)) {
      thisValue = sum
    } // Value should not less than 0.

    if (thisValue < 0) {
      thisValue = 0
    }

    isArray(dataNode.value) ? dataNode.value[0] = thisValue : dataNode.value = thisValue
  }
  /**
     * set default to level configuration
     */

  function setDefault (levels, ecModel) {
    const globalColorList = normalizeToArray(ecModel.get('color'))
    const globalDecalList = normalizeToArray(ecModel.get(['aria', 'decal', 'decals']))

    if (!globalColorList) {
      return
    }

    levels = levels || []
    let hasColorDefine
    let hasDecalDefine
    each(levels, function (levelDefine) {
      const model = new Model(levelDefine)
      const modelColor = model.get('color')
      const modelDecal = model.get('decal')

      if (model.get(['itemStyle', 'color']) || modelColor && modelColor !== 'none') {
        hasColorDefine = true
      }

      if (model.get(['itemStyle', 'decal']) || modelDecal && modelDecal !== 'none') {
        hasDecalDefine = true
      }
    })
    const level0 = levels[0] || (levels[0] = {})

    if (!hasColorDefine) {
      level0.color = globalColorList.slice()
    }

    if (!hasDecalDefine && globalDecalList) {
      level0.decal = globalDecalList.slice()
    }

    return levels
  }

  const TEXT_PADDING = 8
  const ITEM_GAP = 8
  const ARRAY_LENGTH = 5

  const Breadcrumb =
    /** @class */
    (function () {
      function Breadcrumb (containerGroup) {
        this.group = new Group()
        containerGroup.add(this.group)
      }

      Breadcrumb.prototype.render = function (seriesModel, api, targetNode, onSelect) {
        const model = seriesModel.getModel('breadcrumb')
        const thisGroup = this.group
        thisGroup.removeAll()

        if (!model.get('show') || !targetNode) {
          return
        }

        const normalStyleModel = model.getModel('itemStyle') // let emphasisStyleModel = model.getModel('emphasis.itemStyle');

        const textStyleModel = normalStyleModel.getModel('textStyle')
        const layoutParam = {
          pos: {
            left: model.get('left'),
            right: model.get('right'),
            top: model.get('top'),
            bottom: model.get('bottom')
          },
          box: {
            width: api.getWidth(),
            height: api.getHeight()
          },
          emptyItemWidth: model.get('emptyItemWidth'),
          totalWidth: 0,
          renderList: []
        }

        this._prepare(targetNode, layoutParam, textStyleModel)

        this._renderContent(seriesModel, layoutParam, normalStyleModel, textStyleModel, onSelect)

        positionElement(thisGroup, layoutParam.pos, layoutParam.box)
      }
      /**
       * Prepare render list and total width
       * @private
       */

      Breadcrumb.prototype._prepare = function (targetNode, layoutParam, textStyleModel) {
        for (let node = targetNode; node; node = node.parentNode) {
          const text = convertOptionIdName(node.getModel().get('name'), '')
          const textRect = textStyleModel.getTextRect(text)
          const itemWidth = Math.max(textRect.width + TEXT_PADDING * 2, layoutParam.emptyItemWidth)
          layoutParam.totalWidth += itemWidth + ITEM_GAP
          layoutParam.renderList.push({
            node: node,
            text: text,
            width: itemWidth
          })
        }
      }
      /**
       * @private
       */

      Breadcrumb.prototype._renderContent = function (seriesModel, layoutParam, normalStyleModel, textStyleModel, onSelect) {
        // Start rendering.
        let lastX = 0
        const emptyItemWidth = layoutParam.emptyItemWidth
        const height = seriesModel.get(['breadcrumb', 'height'])
        const availableSize = getAvailableSize(layoutParam.pos, layoutParam.box)
        let totalWidth = layoutParam.totalWidth
        const renderList = layoutParam.renderList

        for (let i = renderList.length - 1; i >= 0; i--) {
          const item = renderList[i]
          const itemNode = item.node
          let itemWidth = item.width
          let text = item.text // Hdie text and shorten width if necessary.

          if (totalWidth > availableSize.width) {
            totalWidth -= itemWidth - emptyItemWidth
            itemWidth = emptyItemWidth
            text = null
          }

          const el = new Polygon({
            shape: {
              points: makeItemPoints(lastX, 0, itemWidth, height, i === renderList.length - 1, i === 0)
            },
            style: defaults(normalStyleModel.getItemStyle(), {
              lineJoin: 'bevel'
            }),
            textContent: new ZRText({
              style: {
                text: text,
                fill: textStyleModel.getTextColor(),
                font: textStyleModel.getFont()
              }
            }),
            textConfig: {
              position: 'inside'
            },
            z2: Z2_EMPHASIS_LIFT * 1e4,
            onclick: curry(onSelect, itemNode)
          })
          el.disableLabelAnimation = true
          this.group.add(el)
          packEventData(el, seriesModel, itemNode)
          lastX += itemWidth + ITEM_GAP
        }
      }

      Breadcrumb.prototype.remove = function () {
        this.group.removeAll()
      }

      return Breadcrumb
    }())

  function makeItemPoints (x, y, itemWidth, itemHeight, head, tail) {
    const points = [[head ? x : x - ARRAY_LENGTH, y], [x + itemWidth, y], [x + itemWidth, y + itemHeight], [head ? x : x - ARRAY_LENGTH, y + itemHeight]]
    !tail && points.splice(2, 0, [x + itemWidth + ARRAY_LENGTH, y + itemHeight / 2])
    !head && points.push([x, y + itemHeight / 2])
    return points
  } // Package custom mouse event.

  function packEventData (el, seriesModel, itemNode) {
    getECData(el).eventData = {
      componentType: 'series',
      componentSubType: 'treemap',
      componentIndex: seriesModel.componentIndex,
      seriesIndex: seriesModel.seriesIndex,
      seriesName: seriesModel.name,
      seriesType: 'treemap',
      selfType: 'breadcrumb',
      nodeData: {
        dataIndex: itemNode && itemNode.dataIndex,
        name: itemNode && itemNode.name
      },
      treePathInfo: itemNode && wrapTreePathInfo(itemNode, seriesModel)
    }
  }

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

  /**
     * AUTO-GENERATED FILE. DO NOT MODIFY.
     */

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

  /**
     * Animate multiple elements with a single done-callback.
     *
     * @example
     *  animation
     *      .createWrap()
     *      .add(el1, {x: 10, y: 10})
     *      .add(el2, {shape: {width: 500}, style: {fill: 'red'}}, 400)
     *      .done(function () { // done })
     *      .start('cubicOut');
     */
  const AnimationWrap =
    /** @class */
    (function () {
      function AnimationWrap () {
        this._storage = []
        this._elExistsMap = {}
      }
      /**
       * Caution: a el can only be added once, otherwise 'done'
       * might not be called. This method checks this (by el.id),
       * suppresses adding and returns false when existing el found.
       *
       * @return Whether adding succeeded.
       */

      AnimationWrap.prototype.add = function (el, target, duration, delay, easing) {
        if (this._elExistsMap[el.id]) {
          return false
        }

        this._elExistsMap[el.id] = true

        this._storage.push({
          el: el,
          target: target,
          duration: duration,
          delay: delay,
          easing: easing
        })

        return true
      }
      /**
       * Only execute when animation done/aborted.
       */

      AnimationWrap.prototype.finished = function (callback) {
        this._finishedCallback = callback
        return this
      }
      /**
       * Will stop exist animation firstly.
       */

      AnimationWrap.prototype.start = function () {
        const _this = this

        let count = this._storage.length

        const checkTerminate = function () {
          count--

          if (count <= 0) {
            // Guard.
            _this._storage.length = 0
            _this._elExistsMap = {}
            _this._finishedCallback && _this._finishedCallback()
          }
        }

        for (let i = 0, len = this._storage.length; i < len; i++) {
          const item = this._storage[i]
          item.el.animateTo(item.target, {
            duration: item.duration,
            delay: item.delay,
            easing: item.easing,
            setToFinal: true,
            done: checkTerminate,
            aborted: checkTerminate
          })
        }

        return this
      }

      return AnimationWrap
    }())

  function createWrap () {
    return new AnimationWrap()
  }

  const Group$1 = Group
  const Rect$1 = Rect
  const DRAG_THRESHOLD = 3
  const PATH_LABEL_NOAMAL = 'label'
  const PATH_UPPERLABEL_NORMAL = 'upperLabel' // Should larger than emphasis states lift z

  const Z2_BASE = Z2_EMPHASIS_LIFT * 10 // Should bigger than every z2.

  const Z2_BG = Z2_EMPHASIS_LIFT * 2
  const Z2_CONTENT = Z2_EMPHASIS_LIFT * 3
  const getStateItemStyle = makeStyleMapper([['fill', 'color'], // `borderColor` and `borderWidth` has been occupied,
    // so use `stroke` to indicate the stroke of the rect.
    ['stroke', 'strokeColor'], ['lineWidth', 'strokeWidth'], ['shadowBlur'], ['shadowOffsetX'], ['shadowOffsetY'], ['shadowColor'] // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
    // So do not transfer decal directly.
  ])

  const getItemStyleNormal = function (model) {
    // Normal style props should include emphasis style props.
    const itemStyle = getStateItemStyle(model) // Clear styles set by emphasis.

    itemStyle.stroke = itemStyle.fill = itemStyle.lineWidth = null
    return itemStyle
  }

  const inner$8 = makeInner()

  const TreemapView =
    /** @class */
    (function (_super) {
      __extends(TreemapView, _super)

      function TreemapView () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = TreemapView.type
        _this._state = 'ready'
        _this._storage = createStorage()
        return _this
      }
      /**
       * @override
       */

      TreemapView.prototype.render = function (seriesModel, ecModel, api, payload) {
        const models = ecModel.findComponents({
          mainType: 'series',
          subType: 'treemap',
          query: payload
        })

        if (indexOf(models, seriesModel) < 0) {
          return
        }

        this.seriesModel = seriesModel
        this.api = api
        this.ecModel = ecModel
        const types = ['treemapZoomToNode', 'treemapRootToNode']
        const targetInfo = retrieveTargetInfo(payload, types, seriesModel)
        const payloadType = payload && payload.type
        const layoutInfo = seriesModel.layoutInfo
        const isInit = !this._oldTree
        const thisStorage = this._storage // Mark new root when action is treemapRootToNode.

        const reRoot = payloadType === 'treemapRootToNode' && targetInfo && thisStorage
          ? {
              rootNodeGroup: thisStorage.nodeGroup[targetInfo.node.getRawIndex()],
              direction: payload.direction
            }
          : null

        const containerGroup = this._giveContainerGroup(layoutInfo)

        const hasAnimation = seriesModel.get('animation')

        const renderResult = this._doRender(containerGroup, seriesModel, reRoot)

        hasAnimation && !isInit && (!payloadType || payloadType === 'treemapZoomToNode' || payloadType === 'treemapRootToNode') ? this._doAnimation(containerGroup, renderResult, seriesModel, reRoot) : renderResult.renderFinally()

        this._resetController(api)

        this._renderBreadcrumb(seriesModel, api, targetInfo)
      }

      TreemapView.prototype._giveContainerGroup = function (layoutInfo) {
        let containerGroup = this._containerGroup

        if (!containerGroup) {
          // FIXME
          // 加一层containerGroup是为了clip，但是现在clip功能并没有实现。
          containerGroup = this._containerGroup = new Group$1()

          this._initEvents(containerGroup)

          this.group.add(containerGroup)
        }

        containerGroup.x = layoutInfo.x
        containerGroup.y = layoutInfo.y
        return containerGroup
      }

      TreemapView.prototype._doRender = function (containerGroup, seriesModel, reRoot) {
        const thisTree = seriesModel.getData().tree
        const oldTree = this._oldTree // Clear last shape records.

        const lastsForAnimation = createStorage()
        const thisStorage = createStorage()
        const oldStorage = this._storage
        const willInvisibleEls = []

        function doRenderNode (thisNode, oldNode, parentGroup, depth) {
          return renderNode(seriesModel, thisStorage, oldStorage, reRoot, lastsForAnimation, willInvisibleEls, thisNode, oldNode, parentGroup, depth)
        } // Notice: when thisTree and oldTree are the same tree (see list.cloneShallow),
        // the oldTree is actually losted, so we can not find all of the old graphic
        // elements from tree. So we use this stragegy: make element storage, move
        // from old storage to new storage, clear old storage.

        dualTravel(thisTree.root ? [thisTree.root] : [], oldTree && oldTree.root ? [oldTree.root] : [], containerGroup, thisTree === oldTree || !oldTree, 0) // Process all removing.

        const willDeleteEls = clearStorage(oldStorage)
        this._oldTree = thisTree
        this._storage = thisStorage
        return {
          lastsForAnimation: lastsForAnimation,
          willDeleteEls: willDeleteEls,
          renderFinally: renderFinally
        }

        function dualTravel (thisViewChildren, oldViewChildren, parentGroup, sameTree, depth) {
          // When 'render' is triggered by action,
          // 'this' and 'old' may be the same tree,
          // we use rawIndex in that case.
          if (sameTree) {
            oldViewChildren = thisViewChildren
            each(thisViewChildren, function (child, index) {
              !child.isRemoved() && processNode(index, index)
            })
          } // Diff hierarchically (diff only in each subtree, but not whole).
          // because, consistency of view is important.
          else {
            new DataDiffer(oldViewChildren, thisViewChildren, getKey, getKey).add(processNode).update(processNode).remove(curry(processNode, null)).execute()
          }

          function getKey (node) {
            // Identify by name or raw index.
            return node.getId()
          }

          function processNode (newIndex, oldIndex) {
            const thisNode = newIndex != null ? thisViewChildren[newIndex] : null
            const oldNode = oldIndex != null ? oldViewChildren[oldIndex] : null
            const group = doRenderNode(thisNode, oldNode, parentGroup, depth)
            group && dualTravel(thisNode && thisNode.viewChildren || [], oldNode && oldNode.viewChildren || [], group, sameTree, depth + 1)
          }
        }

        function clearStorage (storage) {
          const willDeleteEls = createStorage()
          storage && each(storage, function (store, storageName) {
            const delEls = willDeleteEls[storageName]
            each(store, function (el) {
              el && (delEls.push(el), inner$8(el).willDelete = true)
            })
          })
          return willDeleteEls
        }

        function renderFinally () {
          each(willDeleteEls, function (els) {
            each(els, function (el) {
              el.parent && el.parent.remove(el)
            })
          })
          each(willInvisibleEls, function (el) {
            el.invisible = true // Setting invisible is for optimizing, so no need to set dirty,
            // just mark as invisible.

            el.dirty()
          })
        }
      }

      TreemapView.prototype._doAnimation = function (containerGroup, renderResult, seriesModel, reRoot) {
        const durationOption = seriesModel.get('animationDurationUpdate')
        const easingOption = seriesModel.get('animationEasing') // TODO: do not support function until necessary.

        const duration = (isFunction(durationOption) ? 0 : durationOption) || 0
        const easing = (isFunction(easingOption) ? null : easingOption) || 'cubicOut'
        const animationWrap = createWrap() // Make delete animations.

        each(renderResult.willDeleteEls, function (store, storageName) {
          each(store, function (el, rawIndex) {
            if (el.invisible) {
              return
            }

            const parent = el.parent // Always has parent, and parent is nodeGroup.

            let target
            const innerStore = inner$8(parent)

            if (reRoot && reRoot.direction === 'drillDown') {
              target = parent === reRoot.rootNodeGroup // This is the content element of view root.
              // Only `content` will enter this branch, because
              // `background` and `nodeGroup` will not be deleted.
                ? {
                    shape: {
                      x: 0,
                      y: 0,
                      width: innerStore.nodeWidth,
                      height: innerStore.nodeHeight
                    },
                    style: {
                      opacity: 0
                    }
                  } // Others.
                : {
                    style: {
                      opacity: 0
                    }
                  }
            } else {
              let targetX = 0
              let targetY = 0

              if (!innerStore.willDelete) {
                // Let node animate to right-bottom corner, cooperating with fadeout,
                // which is appropriate for user understanding.
                // Divided by 2 for reRoot rolling up effect.
                targetX = innerStore.nodeWidth / 2
                targetY = innerStore.nodeHeight / 2
              }

              target = storageName === 'nodeGroup'
                ? {
                    x: targetX,
                    y: targetY,
                    style: {
                      opacity: 0
                    }
                  }
                : {
                    shape: {
                      x: targetX,
                      y: targetY,
                      width: 0,
                      height: 0
                    },
                    style: {
                      opacity: 0
                    }
                  }
            } // TODO: do not support delay until necessary.

            target && animationWrap.add(el, target, duration, 0, easing)
          })
        }) // Make other animations

        each(this._storage, function (store, storageName) {
          each(store, function (el, rawIndex) {
            const last = renderResult.lastsForAnimation[storageName][rawIndex]
            const target = {}

            if (!last) {
              return
            }

            if (el instanceof Group) {
              if (last.oldX != null) {
                target.x = el.x
                target.y = el.y
                el.x = last.oldX
                el.y = last.oldY
              }
            } else {
              if (last.oldShape) {
                target.shape = extend({}, el.shape)
                el.setShape(last.oldShape)
              }

              if (last.fadein) {
                el.setStyle('opacity', 0)
                target.style = {
                  opacity: 1
                }
              } // When animation is stopped for succedent animation starting,
              // el.style.opacity might not be 1
              else if (el.style.opacity !== 1) {
                target.style = {
                  opacity: 1
                }
              }
            }

            animationWrap.add(el, target, duration, 0, easing)
          })
        }, this)
        this._state = 'animating'
        animationWrap.finished(bind(function () {
          this._state = 'ready'
          renderResult.renderFinally()
        }, this)).start()
      }

      TreemapView.prototype._resetController = function (api) {
        let controller = this._controller // Init controller.

        if (!controller) {
          controller = this._controller = new RoamController(api.getZr())
          controller.enable(this.seriesModel.get('roam'))
          controller.on('pan', bind(this._onPan, this))
          controller.on('zoom', bind(this._onZoom, this))
        }

        const rect = new BoundingRect(0, 0, api.getWidth(), api.getHeight())
        controller.setPointerChecker(function (e, x, y) {
          return rect.contain(x, y)
        })
      }

      TreemapView.prototype._clearController = function () {
        let controller = this._controller

        if (controller) {
          controller.dispose()
          controller = null
        }
      }

      TreemapView.prototype._onPan = function (e) {
        if (this._state !== 'animating' && (Math.abs(e.dx) > DRAG_THRESHOLD || Math.abs(e.dy) > DRAG_THRESHOLD)) {
          // These param must not be cached.
          const root = this.seriesModel.getData().tree.root

          if (!root) {
            return
          }

          const rootLayout = root.getLayout()

          if (!rootLayout) {
            return
          }

          this.api.dispatchAction({
            type: 'treemapMove',
            from: this.uid,
            seriesId: this.seriesModel.id,
            rootRect: {
              x: rootLayout.x + e.dx,
              y: rootLayout.y + e.dy,
              width: rootLayout.width,
              height: rootLayout.height
            }
          })
        }
      }

      TreemapView.prototype._onZoom = function (e) {
        let mouseX = e.originX
        let mouseY = e.originY

        if (this._state !== 'animating') {
          // These param must not be cached.
          const root = this.seriesModel.getData().tree.root

          if (!root) {
            return
          }

          const rootLayout = root.getLayout()

          if (!rootLayout) {
            return
          }

          const rect = new BoundingRect(rootLayout.x, rootLayout.y, rootLayout.width, rootLayout.height)
          const layoutInfo = this.seriesModel.layoutInfo // Transform mouse coord from global to containerGroup.

          mouseX -= layoutInfo.x
          mouseY -= layoutInfo.y // Scale root bounding rect.

          const m = create$1()
          translate(m, m, [-mouseX, -mouseY])
          scale$1(m, m, [e.scale, e.scale])
          translate(m, m, [mouseX, mouseY])
          rect.applyTransform(m)
          this.api.dispatchAction({
            type: 'treemapRender',
            from: this.uid,
            seriesId: this.seriesModel.id,
            rootRect: {
              x: rect.x,
              y: rect.y,
              width: rect.width,
              height: rect.height
            }
          })
        }
      }

      TreemapView.prototype._initEvents = function (containerGroup) {
        const _this = this

        containerGroup.on('click', function (e) {
          if (_this._state !== 'ready') {
            return
          }

          const nodeClick = _this.seriesModel.get('nodeClick', true)

          if (!nodeClick) {
            return
          }

          const targetInfo = _this.findTarget(e.offsetX, e.offsetY)

          if (!targetInfo) {
            return
          }

          const node = targetInfo.node

          if (node.getLayout().isLeafRoot) {
            _this._rootToNode(targetInfo)
          } else {
            if (nodeClick === 'zoomToNode') {
              _this._zoomToNode(targetInfo)
            } else if (nodeClick === 'link') {
              const itemModel = node.hostTree.data.getItemModel(node.dataIndex)
              const link = itemModel.get('link', true)
              const linkTarget = itemModel.get('target', true) || 'blank'
              link && windowOpen(link, linkTarget)
            }
          }
        }, this)
      }

      TreemapView.prototype._renderBreadcrumb = function (seriesModel, api, targetInfo) {
        const _this = this

        if (!targetInfo) {
          targetInfo = seriesModel.get('leafDepth', true) != null ? {
            node: seriesModel.getViewRoot()
          } // FIXME
          // better way?
          // Find breadcrumb tail on center of containerGroup.
            : this.findTarget(api.getWidth() / 2, api.getHeight() / 2)

          if (!targetInfo) {
            targetInfo = {
              node: seriesModel.getData().tree.root
            }
          }
        }

        (this._breadcrumb || (this._breadcrumb = new Breadcrumb(this.group))).render(seriesModel, api, targetInfo.node, function (node) {
          if (_this._state !== 'animating') {
            aboveViewRoot(seriesModel.getViewRoot(), node)
              ? _this._rootToNode({
                node: node
              })
              : _this._zoomToNode({
                node: node
              })
          }
        })
      }
      /**
       * @override
       */

      TreemapView.prototype.remove = function () {
        this._clearController()

        this._containerGroup && this._containerGroup.removeAll()
        this._storage = createStorage()
        this._state = 'ready'
        this._breadcrumb && this._breadcrumb.remove()
      }

      TreemapView.prototype.dispose = function () {
        this._clearController()
      }

      TreemapView.prototype._zoomToNode = function (targetInfo) {
        this.api.dispatchAction({
          type: 'treemapZoomToNode',
          from: this.uid,
          seriesId: this.seriesModel.id,
          targetNode: targetInfo.node
        })
      }

      TreemapView.prototype._rootToNode = function (targetInfo) {
        this.api.dispatchAction({
          type: 'treemapRootToNode',
          from: this.uid,
          seriesId: this.seriesModel.id,
          targetNode: targetInfo.node
        })
      }
      /**
       * @public
       * @param {number} x Global coord x.
       * @param {number} y Global coord y.
       * @return {Object} info If not found, return undefined;
       * @return {number} info.node Target node.
       * @return {number} info.offsetX x refer to target node.
       * @return {number} info.offsetY y refer to target node.
       */

      TreemapView.prototype.findTarget = function (x, y) {
        let targetInfo
        const viewRoot = this.seriesModel.getViewRoot()
        viewRoot.eachNode({
          attr: 'viewChildren',
          order: 'preorder'
        }, function (node) {
          const bgEl = this._storage.background[node.getRawIndex()] // If invisible, there might be no element.

          if (bgEl) {
            const point = bgEl.transformCoordToLocal(x, y)
            const shape = bgEl.shape // For performance consideration, dont use 'getBoundingRect'.

            if (shape.x <= point[0] && point[0] <= shape.x + shape.width && shape.y <= point[1] && point[1] <= shape.y + shape.height) {
              targetInfo = {
                node: node,
                offsetX: point[0],
                offsetY: point[1]
              }
            } else {
              return false // Suppress visit subtree.
            }
          }
        }, this)
        return targetInfo
      }

      TreemapView.type = 'treemap'
      return TreemapView
    }(ChartView))
    /**
     * @inner
     */

  function createStorage () {
    return {
      nodeGroup: [],
      background: [],
      content: []
    }
  }
  /**
     * @inner
     * @return Return undefined means do not travel further.
     */

  function renderNode (seriesModel, thisStorage, oldStorage, reRoot, lastsForAnimation, willInvisibleEls, thisNode, oldNode, parentGroup, depth) {
    // Whether under viewRoot.
    if (!thisNode) {
      // Deleting nodes will be performed finally. This method just find
      // element from old storage, or create new element, set them to new
      // storage, and set styles.
      return
    } // -------------------------------------------------------------------
    // Start of closure variables available in "Procedures in renderNode".

    const thisLayout = thisNode.getLayout()
    const data = seriesModel.getData()
    const nodeModel = thisNode.getModel() // Only for enabling highlight/downplay. Clear firstly.
    // Because some node will not be rendered.

    data.setItemGraphicEl(thisNode.dataIndex, null)

    if (!thisLayout || !thisLayout.isInView) {
      return
    }

    const thisWidth = thisLayout.width
    const thisHeight = thisLayout.height
    const borderWidth = thisLayout.borderWidth
    const thisInvisible = thisLayout.invisible
    const thisRawIndex = thisNode.getRawIndex()
    const oldRawIndex = oldNode && oldNode.getRawIndex()
    const thisViewChildren = thisNode.viewChildren
    const upperHeight = thisLayout.upperHeight
    const isParent = thisViewChildren && thisViewChildren.length
    const itemStyleNormalModel = nodeModel.getModel('itemStyle')
    const itemStyleEmphasisModel = nodeModel.getModel(['emphasis', 'itemStyle'])
    const itemStyleBlurModel = nodeModel.getModel(['blur', 'itemStyle'])
    const itemStyleSelectModel = nodeModel.getModel(['select', 'itemStyle'])
    const borderRadius = itemStyleNormalModel.get('borderRadius') || 0 // End of closure ariables available in "Procedures in renderNode".
    // -----------------------------------------------------------------
    // Node group

    const group = giveGraphic('nodeGroup', Group$1)

    if (!group) {
      return
    }

    parentGroup.add(group) // x,y are not set when el is above view root.

    group.x = thisLayout.x || 0
    group.y = thisLayout.y || 0
    group.markRedraw()
    inner$8(group).nodeWidth = thisWidth
    inner$8(group).nodeHeight = thisHeight

    if (thisLayout.isAboveViewRoot) {
      return group
    } // Background

    const bg = giveGraphic('background', Rect$1, depth, Z2_BG)
    bg && renderBackground(group, bg, isParent && thisLayout.upperLabelHeight)
    const emphasisModel = nodeModel.getModel('emphasis')
    const focus = emphasisModel.get('focus')
    const blurScope = emphasisModel.get('blurScope')
    const isDisabled = emphasisModel.get('disabled')
    const focusOrIndices = focus === 'ancestor' ? thisNode.getAncestorsIndices() : focus === 'descendant' ? thisNode.getDescendantIndices() : focus // No children, render content.

    if (isParent) {
      // Because of the implementation about "traverse" in graphic hover style, we
      // can not set hover listener on the "group" of non-leaf node. Otherwise the
      // hover event from the descendents will be listenered.
      if (isHighDownDispatcher(group)) {
        setAsHighDownDispatcher(group, false)
      }

      if (bg) {
        setAsHighDownDispatcher(bg, !isDisabled) // Only for enabling highlight/downplay.

        data.setItemGraphicEl(thisNode.dataIndex, bg)
        enableHoverFocus(bg, focusOrIndices, blurScope)
      }
    } else {
      const content = giveGraphic('content', Rect$1, depth, Z2_CONTENT)
      content && renderContent(group, content)
      bg.disableMorphing = true

      if (bg && isHighDownDispatcher(bg)) {
        setAsHighDownDispatcher(bg, false)
      }

      setAsHighDownDispatcher(group, !isDisabled) // Only for enabling highlight/downplay.

      data.setItemGraphicEl(thisNode.dataIndex, group)
      enableHoverFocus(group, focusOrIndices, blurScope)
    }

    return group // ----------------------------
    // | Procedures in renderNode |
    // ----------------------------

    function renderBackground (group, bg, useUpperLabel) {
      const ecData = getECData(bg) // For tooltip.

      ecData.dataIndex = thisNode.dataIndex
      ecData.seriesIndex = seriesModel.seriesIndex
      bg.setShape({
        x: 0,
        y: 0,
        width: thisWidth,
        height: thisHeight,
        r: borderRadius
      })

      if (thisInvisible) {
        // If invisible, do not set visual, otherwise the element will
        // change immediately before animation. We think it is OK to
        // remain its origin color when moving out of the view window.
        processInvisible(bg)
      } else {
        bg.invisible = false
        const style = thisNode.getVisual('style')
        const visualBorderColor = style.stroke
        const normalStyle = getItemStyleNormal(itemStyleNormalModel)
        normalStyle.fill = visualBorderColor
        const emphasisStyle = getStateItemStyle(itemStyleEmphasisModel)
        emphasisStyle.fill = itemStyleEmphasisModel.get('borderColor')
        const blurStyle = getStateItemStyle(itemStyleBlurModel)
        blurStyle.fill = itemStyleBlurModel.get('borderColor')
        const selectStyle = getStateItemStyle(itemStyleSelectModel)
        selectStyle.fill = itemStyleSelectModel.get('borderColor')

        if (useUpperLabel) {
          const upperLabelWidth = thisWidth - 2 * borderWidth
          prepareText( // PENDING: convert ZRColor to ColorString for text.
            bg, visualBorderColor, style.opacity, {
              x: borderWidth,
              y: 0,
              width: upperLabelWidth,
              height: upperHeight
            })
        } // For old bg.
        else {
          bg.removeTextContent()
        }

        bg.setStyle(normalStyle)
        bg.ensureState('emphasis').style = emphasisStyle
        bg.ensureState('blur').style = blurStyle
        bg.ensureState('select').style = selectStyle
        setDefaultStateProxy(bg)
      }

      group.add(bg)
    }

    function renderContent (group, content) {
      const ecData = getECData(content) // For tooltip.

      ecData.dataIndex = thisNode.dataIndex
      ecData.seriesIndex = seriesModel.seriesIndex
      const contentWidth = Math.max(thisWidth - 2 * borderWidth, 0)
      const contentHeight = Math.max(thisHeight - 2 * borderWidth, 0)
      content.culling = true
      content.setShape({
        x: borderWidth,
        y: borderWidth,
        width: contentWidth,
        height: contentHeight,
        r: borderRadius
      })

      if (thisInvisible) {
        // If invisible, do not set visual, otherwise the element will
        // change immediately before animation. We think it is OK to
        // remain its origin color when moving out of the view window.
        processInvisible(content)
      } else {
        content.invisible = false
        const nodeStyle = thisNode.getVisual('style')
        const visualColor = nodeStyle.fill
        const normalStyle = getItemStyleNormal(itemStyleNormalModel)
        normalStyle.fill = visualColor
        normalStyle.decal = nodeStyle.decal
        const emphasisStyle = getStateItemStyle(itemStyleEmphasisModel)
        const blurStyle = getStateItemStyle(itemStyleBlurModel)
        const selectStyle = getStateItemStyle(itemStyleSelectModel) // PENDING: convert ZRColor to ColorString for text.

        prepareText(content, visualColor, nodeStyle.opacity, null)
        content.setStyle(normalStyle)
        content.ensureState('emphasis').style = emphasisStyle
        content.ensureState('blur').style = blurStyle
        content.ensureState('select').style = selectStyle
        setDefaultStateProxy(content)
      }

      group.add(content)
    }

    function processInvisible (element) {
      // Delay invisible setting utill animation finished,
      // avoid element vanish suddenly before animation.
      !element.invisible && willInvisibleEls.push(element)
    }

    function prepareText (rectEl, visualColor, visualOpacity, // Can be null/undefined
      upperLabelRect) {
      const normalLabelModel = nodeModel.getModel(upperLabelRect ? PATH_UPPERLABEL_NORMAL : PATH_LABEL_NOAMAL)
      const defaultText = convertOptionIdName(nodeModel.get('name'), null)
      const isShow = normalLabelModel.getShallow('show')
      setLabelStyle(rectEl, getLabelStatesModels(nodeModel, upperLabelRect ? PATH_UPPERLABEL_NORMAL : PATH_LABEL_NOAMAL), {
        defaultText: isShow ? defaultText : null,
        inheritColor: visualColor,
        defaultOpacity: visualOpacity,
        labelFetcher: seriesModel,
        labelDataIndex: thisNode.dataIndex
      })
      const textEl = rectEl.getTextContent()

      if (!textEl) {
        return
      }

      const textStyle = textEl.style
      const textPadding = normalizeCssArray(textStyle.padding || 0)

      if (upperLabelRect) {
        rectEl.setTextConfig({
          layoutRect: upperLabelRect
        })
        textEl.disableLabelLayout = true
      }

      textEl.beforeUpdate = function () {
        const width = Math.max((upperLabelRect ? upperLabelRect.width : rectEl.shape.width) - textPadding[1] - textPadding[3], 0)
        const height = Math.max((upperLabelRect ? upperLabelRect.height : rectEl.shape.height) - textPadding[0] - textPadding[2], 0)

        if (textStyle.width !== width || textStyle.height !== height) {
          textEl.setStyle({
            width: width,
            height: height
          })
        }
      }

      textStyle.truncateMinChar = 2
      textStyle.lineOverflow = 'truncate'
      addDrillDownIcon(textStyle, upperLabelRect, thisLayout)
      const textEmphasisState = textEl.getState('emphasis')
      addDrillDownIcon(textEmphasisState ? textEmphasisState.style : null, upperLabelRect, thisLayout)
    }

    function addDrillDownIcon (style, upperLabelRect, thisLayout) {
      const text = style ? style.text : null

      if (!upperLabelRect && thisLayout.isLeafRoot && text != null) {
        const iconChar = seriesModel.get('drillDownIcon', true)
        style.text = iconChar ? iconChar + ' ' + text : text
      }
    }

    function giveGraphic (storageName, Ctor, depth, z) {
      let element = oldRawIndex != null && oldStorage[storageName][oldRawIndex]
      const lasts = lastsForAnimation[storageName]

      if (element) {
        // Remove from oldStorage
        oldStorage[storageName][oldRawIndex] = null
        prepareAnimationWhenHasOld(lasts, element)
      } // If invisible and no old element, do not create new element (for optimizing).
      else if (!thisInvisible) {
        element = new Ctor()

        if (element instanceof Displayable) {
          element.z2 = calculateZ2(depth, z)
        }

        prepareAnimationWhenNoOld(lasts, element)
      } // Set to thisStorage

      return thisStorage[storageName][thisRawIndex] = element
    }

    function prepareAnimationWhenHasOld (lasts, element) {
      const lastCfg = lasts[thisRawIndex] = {}

      if (element instanceof Group$1) {
        lastCfg.oldX = element.x
        lastCfg.oldY = element.y
      } else {
        lastCfg.oldShape = extend({}, element.shape)
      }
    } // If a element is new, we need to find the animation start point carefully,
    // otherwise it will looks strange when 'zoomToNode'.

    function prepareAnimationWhenNoOld (lasts, element) {
      const lastCfg = lasts[thisRawIndex] = {}
      const parentNode = thisNode.parentNode
      const isGroup = element instanceof Group

      if (parentNode && (!reRoot || reRoot.direction === 'drillDown')) {
        let parentOldX = 0
        let parentOldY = 0 // New nodes appear from right-bottom corner in 'zoomToNode' animation.
        // For convenience, get old bounding rect from background.

        const parentOldBg = lastsForAnimation.background[parentNode.getRawIndex()]

        if (!reRoot && parentOldBg && parentOldBg.oldShape) {
          parentOldX = parentOldBg.oldShape.width
          parentOldY = parentOldBg.oldShape.height
        } // When no parent old shape found, its parent is new too,
        // so we can just use {x:0, y:0}.

        if (isGroup) {
          lastCfg.oldX = 0
          lastCfg.oldY = parentOldY
        } else {
          lastCfg.oldShape = {
            x: parentOldX,
            y: parentOldY,
            width: 0,
            height: 0
          }
        }
      } // Fade in, user can be aware that these nodes are new.

      lastCfg.fadein = !isGroup
    }
  } // We can not set all backgroud with the same z, Because the behaviour of
  // drill down and roll up differ background creation sequence from tree
  // hierarchy sequence, which cause that lowser background element overlap
  // upper ones. So we calculate z based on depth.
  // Moreover, we try to shrink down z interval to [0, 1] to avoid that
  // treemap with large z overlaps other components.

  function calculateZ2 (depth, z2InLevel) {
    return depth * Z2_BASE + z2InLevel
  }

  const each$3 = each
  const isObject$3 = isObject
  const CATEGORY_DEFAULT_VISUAL_INDEX = -1

  const VisualMapping =
    /** @class */
    (function () {
      function VisualMapping (option) {
        const mappingMethod = option.mappingMethod
        const visualType = option.type
        const thisOption = this.option = clone(option)
        this.type = visualType
        this.mappingMethod = mappingMethod
        this._normalizeData = normalizers[mappingMethod]
        const visualHandler = VisualMapping.visualHandlers[visualType]
        this.applyVisual = visualHandler.applyVisual
        this.getColorMapper = visualHandler.getColorMapper
        this._normalizedToVisual = visualHandler._normalizedToVisual[mappingMethod]

        if (mappingMethod === 'piecewise') {
          normalizeVisualRange(thisOption)
          preprocessForPiecewise(thisOption)
        } else if (mappingMethod === 'category') {
          thisOption.categories ? preprocessForSpecifiedCategory(thisOption) // categories is ordinal when thisOption.categories not specified,
          // which need no more preprocess except normalize visual.
            : normalizeVisualRange(thisOption, true)
        } else {
          // mappingMethod === 'linear' or 'fixed'
          assert(mappingMethod !== 'linear' || thisOption.dataExtent)
          normalizeVisualRange(thisOption)
        }
      }

      VisualMapping.prototype.mapValueToVisual = function (value) {
        const normalized = this._normalizeData(value)

        return this._normalizedToVisual(normalized, value)
      }

      VisualMapping.prototype.getNormalizer = function () {
        return bind(this._normalizeData, this)
      }
      /**
       * List available visual types.
       *
       * @public
       * @return {Array.<string>}
       */

      VisualMapping.listVisualTypes = function () {
        return keys(VisualMapping.visualHandlers)
      } // /**
      //  * @public
      //  */
      // static addVisualHandler(name, handler) {
      //     visualHandlers[name] = handler;
      // }

      /**
       * @public
       */

      VisualMapping.isValidType = function (visualType) {
        return VisualMapping.visualHandlers.hasOwnProperty(visualType)
      }
      /**
       * Convinent method.
       * Visual can be Object or Array or primary type.
       */

      VisualMapping.eachVisual = function (visual, callback, context) {
        if (isObject(visual)) {
          each(visual, callback, context)
        } else {
          callback.call(context, visual)
        }
      }

      VisualMapping.mapVisual = function (visual, callback, context) {
        let isPrimary
        let newVisual = isArray(visual) ? [] : isObject(visual) ? {} : (isPrimary = true, null)
        VisualMapping.eachVisual(visual, function (v, key) {
          const newVal = callback.call(context, v, key)
          isPrimary ? newVisual = newVal : newVisual[key] = newVal
        })
        return newVisual
      }
      /**
       * Retrieve visual properties from given object.
       */

      VisualMapping.retrieveVisuals = function (obj) {
        const ret = {}
        let hasVisual
        obj && each$3(VisualMapping.visualHandlers, function (h, visualType) {
          if (obj.hasOwnProperty(visualType)) {
            ret[visualType] = obj[visualType]
            hasVisual = true
          }
        })
        return hasVisual ? ret : null
      }
      /**
       * Give order to visual types, considering colorSaturation, colorAlpha depends on color.
       *
       * @public
       * @param {(Object|Array)} visualTypes If Object, like: {color: ..., colorSaturation: ...}
       *                                     IF Array, like: ['color', 'symbol', 'colorSaturation']
       * @return {Array.<string>} Sorted visual types.
       */

      VisualMapping.prepareVisualTypes = function (visualTypes) {
        if (isArray(visualTypes)) {
          visualTypes = visualTypes.slice()
        } else if (isObject$3(visualTypes)) {
          const types_1 = []
          each$3(visualTypes, function (item, type) {
            types_1.push(type)
          })
          visualTypes = types_1
        } else {
          return []
        }

        visualTypes.sort(function (type1, type2) {
          // color should be front of colorSaturation, colorAlpha, ...
          // symbol and symbolSize do not matter.
          return type2 === 'color' && type1 !== 'color' && type1.indexOf('color') === 0 ? 1 : -1
        })
        return visualTypes
      }
      /**
       * 'color', 'colorSaturation', 'colorAlpha', ... are depends on 'color'.
       * Other visuals are only depends on themself.
       */

      VisualMapping.dependsOn = function (visualType1, visualType2) {
        return visualType2 === 'color' ? !!(visualType1 && visualType1.indexOf(visualType2) === 0) : visualType1 === visualType2
      }
      /**
       * @param value
       * @param pieceList [{value: ..., interval: [min, max]}, ...]
       *                         Always from small to big.
       * @param findClosestWhenOutside Default to be false
       * @return index
       */

      VisualMapping.findPieceIndex = function (value, pieceList, findClosestWhenOutside) {
        let possibleI
        let abs = Infinity // value has the higher priority.

        for (var i = 0, len = pieceList.length; i < len; i++) {
          const pieceValue = pieceList[i].value

          if (pieceValue != null) {
            if (pieceValue === value || // FIXME
            // It is supposed to compare value according to value type of dimension,
            // but currently value type can exactly be string or number.
            // Compromise for numeric-like string (like '12'), especially
            // in the case that visualMap.categories is ['22', '33'].
            isString(pieceValue) && pieceValue === value + '') {
              return i
            }

            findClosestWhenOutside && updatePossible(pieceValue, i)
          }
        }

        for (var i = 0, len = pieceList.length; i < len; i++) {
          const piece = pieceList[i]
          const interval = piece.interval
          const close_1 = piece.close

          if (interval) {
            if (interval[0] === -Infinity) {
              if (littleThan(close_1[1], value, interval[1])) {
                return i
              }
            } else if (interval[1] === Infinity) {
              if (littleThan(close_1[0], interval[0], value)) {
                return i
              }
            } else if (littleThan(close_1[0], interval[0], value) && littleThan(close_1[1], value, interval[1])) {
              return i
            }

            findClosestWhenOutside && updatePossible(interval[0], i)
            findClosestWhenOutside && updatePossible(interval[1], i)
          }
        }

        if (findClosestWhenOutside) {
          return value === Infinity ? pieceList.length - 1 : value === -Infinity ? 0 : possibleI
        }

        function updatePossible (val, index) {
          const newAbs = Math.abs(val - value)

          if (newAbs < abs) {
            abs = newAbs
            possibleI = index
          }
        }
      }

      VisualMapping.visualHandlers = {
        color: {
          applyVisual: makeApplyVisual('color'),
          getColorMapper: function () {
            const thisOption = this.option
            return bind(thisOption.mappingMethod === 'category' ? function (value, isNormalized) {
              !isNormalized && (value = this._normalizeData(value))
              return doMapCategory.call(this, value)
            } : function (value, isNormalized, out) {
              // If output rgb array
              // which will be much faster and useful in pixel manipulation
              const returnRGBArray = !!out
              !isNormalized && (value = this._normalizeData(value))
              out = fastLerp(value, thisOption.parsedVisual, out)
              return returnRGBArray ? out : stringify(out, 'rgba')
            }, this)
          },
          _normalizedToVisual: {
            linear: function (normalized) {
              return stringify(fastLerp(normalized, this.option.parsedVisual), 'rgba')
            },
            category: doMapCategory,
            piecewise: function (normalized, value) {
              let result = getSpecifiedVisual.call(this, value)

              if (result == null) {
                result = stringify(fastLerp(normalized, this.option.parsedVisual), 'rgba')
              }

              return result
            },
            fixed: doMapFixed
          }
        },
        colorHue: makePartialColorVisualHandler(function (color$1, value) {
          return modifyHSL(color$1, value)
        }),
        colorSaturation: makePartialColorVisualHandler(function (color$1, value) {
          return modifyHSL(color$1, null, value)
        }),
        colorLightness: makePartialColorVisualHandler(function (color$1, value) {
          return modifyHSL(color$1, null, null, value)
        }),
        colorAlpha: makePartialColorVisualHandler(function (color$1, value) {
          return modifyAlpha(color$1, value)
        }),
        decal: {
          applyVisual: makeApplyVisual('decal'),
          _normalizedToVisual: {
            linear: null,
            category: doMapCategory,
            piecewise: null,
            fixed: null
          }
        },
        opacity: {
          applyVisual: makeApplyVisual('opacity'),
          _normalizedToVisual: createNormalizedToNumericVisual([0, 1])
        },
        liftZ: {
          applyVisual: makeApplyVisual('liftZ'),
          _normalizedToVisual: {
            linear: doMapFixed,
            category: doMapFixed,
            piecewise: doMapFixed,
            fixed: doMapFixed
          }
        },
        symbol: {
          applyVisual: function (value, getter, setter) {
            const symbolCfg = this.mapValueToVisual(value)
            setter('symbol', symbolCfg)
          },
          _normalizedToVisual: {
            linear: doMapToArray,
            category: doMapCategory,
            piecewise: function (normalized, value) {
              let result = getSpecifiedVisual.call(this, value)

              if (result == null) {
                result = doMapToArray.call(this, normalized)
              }

              return result
            },
            fixed: doMapFixed
          }
        },
        symbolSize: {
          applyVisual: makeApplyVisual('symbolSize'),
          _normalizedToVisual: createNormalizedToNumericVisual([0, 1])
        }
      }
      return VisualMapping
    }())

  function preprocessForPiecewise (thisOption) {
    const pieceList = thisOption.pieceList
    thisOption.hasSpecialVisual = false
    each(pieceList, function (piece, index) {
      piece.originIndex = index // piece.visual is "result visual value" but not
      // a visual range, so it does not need to be normalized.

      if (piece.visual != null) {
        thisOption.hasSpecialVisual = true
      }
    })
  }

  function preprocessForSpecifiedCategory (thisOption) {
    // Hash categories.
    const categories = thisOption.categories
    const categoryMap = thisOption.categoryMap = {}
    let visual = thisOption.visual
    each$3(categories, function (cate, index) {
      categoryMap[cate] = index
    }) // Process visual map input.

    if (!isArray(visual)) {
      const visualArr_1 = []

      if (isObject(visual)) {
        each$3(visual, function (v, cate) {
          const index = categoryMap[cate]
          visualArr_1[index != null ? index : CATEGORY_DEFAULT_VISUAL_INDEX] = v
        })
      } else {
        // Is primary type, represents default visual.
        visualArr_1[CATEGORY_DEFAULT_VISUAL_INDEX] = visual
      }

      visual = setVisualToOption(thisOption, visualArr_1)
    } // Remove categories that has no visual,
    // then we can mapping them to CATEGORY_DEFAULT_VISUAL_INDEX.

    for (let i = categories.length - 1; i >= 0; i--) {
      if (visual[i] == null) {
        delete categoryMap[categories[i]]
        categories.pop()
      }
    }
  }

  function normalizeVisualRange (thisOption, isCategory) {
    const visual = thisOption.visual
    const visualArr = []

    if (isObject(visual)) {
      each$3(visual, function (v) {
        visualArr.push(v)
      })
    } else if (visual != null) {
      visualArr.push(visual)
    }

    const doNotNeedPair = {
      color: 1,
      symbol: 1
    }

    if (!isCategory && visualArr.length === 1 && !doNotNeedPair.hasOwnProperty(thisOption.type)) {
      // Do not care visualArr.length === 0, which is illegal.
      visualArr[1] = visualArr[0]
    }

    setVisualToOption(thisOption, visualArr)
  }

  function makePartialColorVisualHandler (applyValue) {
    return {
      applyVisual: function (value, getter, setter) {
        // Only used in HSL
        const colorChannel = this.mapValueToVisual(value) // Must not be array value

        setter('color', applyValue(getter('color'), colorChannel))
      },
      _normalizedToVisual: createNormalizedToNumericVisual([0, 1])
    }
  }

  function doMapToArray (normalized) {
    const visual = this.option.visual
    return visual[Math.round(linearMap(normalized, [0, 1], [0, visual.length - 1], true))] || {} // TODO {}?
  }

  function makeApplyVisual (visualType) {
    return function (value, getter, setter) {
      setter(visualType, this.mapValueToVisual(value))
    }
  }

  function doMapCategory (normalized) {
    const visual = this.option.visual
    return visual[this.option.loop && normalized !== CATEGORY_DEFAULT_VISUAL_INDEX ? normalized % visual.length : normalized]
  }

  function doMapFixed () {
    // visual will be convert to array.
    return this.option.visual[0]
  }
  /**
     * Create mapped to numeric visual
     */

  function createNormalizedToNumericVisual (sourceExtent) {
    return {
      linear: function (normalized) {
        return linearMap(normalized, sourceExtent, this.option.visual, true)
      },
      category: doMapCategory,
      piecewise: function (normalized, value) {
        let result = getSpecifiedVisual.call(this, value)

        if (result == null) {
          result = linearMap(normalized, sourceExtent, this.option.visual, true)
        }

        return result
      },
      fixed: doMapFixed
    }
  }

  function getSpecifiedVisual (value) {
    const thisOption = this.option
    const pieceList = thisOption.pieceList

    if (thisOption.hasSpecialVisual) {
      const pieceIndex = VisualMapping.findPieceIndex(value, pieceList)
      const piece = pieceList[pieceIndex]

      if (piece && piece.visual) {
        return piece.visual[this.type]
      }
    }
  }

  function setVisualToOption (thisOption, visualArr) {
    thisOption.visual = visualArr

    if (thisOption.type === 'color') {
      thisOption.parsedVisual = map(visualArr, function (item) {
        const color$1 = parse(item)

        if (!color$1 && 'development' !== 'production') {
          warn("'" + item + "' is an illegal color, fallback to '#000000'", true)
        }

        return color$1 || [0, 0, 0, 1]
      })
    }

    return visualArr
  }
  /**
     * Normalizers by mapping methods.
     */

  var normalizers = {
    linear: function (value) {
      return linearMap(value, this.option.dataExtent, [0, 1], true)
    },
    piecewise: function (value) {
      const pieceList = this.option.pieceList
      const pieceIndex = VisualMapping.findPieceIndex(value, pieceList, true)

      if (pieceIndex != null) {
        return linearMap(pieceIndex, [0, pieceList.length - 1], [0, 1], true)
      }
    },
    category: function (value) {
      const index = this.option.categories ? this.option.categoryMap[value] : value // ordinal value

      return index == null ? CATEGORY_DEFAULT_VISUAL_INDEX : index
    },
    fixed: noop
  }

  function littleThan (close, a, b) {
    return close ? a <= b : a < b
  }

  const ITEM_STYLE_NORMAL = 'itemStyle'
  const inner$9 = makeInner()
  const treemapVisual = {
    seriesType: 'treemap',
    reset: function (seriesModel) {
      const tree = seriesModel.getData().tree
      const root = tree.root

      if (root.isRemoved()) {
        return
      }

      travelTree(root, // Visual should calculate from tree root but not view root.
        {}, seriesModel.getViewRoot().getAncestors(), seriesModel)
    }
  }

  function travelTree (node, designatedVisual, viewRootAncestors, seriesModel) {
    const nodeModel = node.getModel()
    const nodeLayout = node.getLayout()
    const data = node.hostTree.data // Optimize

    if (!nodeLayout || nodeLayout.invisible || !nodeLayout.isInView) {
      return
    }

    const nodeItemStyleModel = nodeModel.getModel(ITEM_STYLE_NORMAL)
    const visuals = buildVisuals(nodeItemStyleModel, designatedVisual, seriesModel)
    const existsStyle = data.ensureUniqueItemVisual(node.dataIndex, 'style') // calculate border color

    let borderColor = nodeItemStyleModel.get('borderColor')
    const borderColorSaturation = nodeItemStyleModel.get('borderColorSaturation')
    let thisNodeColor

    if (borderColorSaturation != null) {
      // For performance, do not always execute 'calculateColor'.
      thisNodeColor = calculateColor(visuals)
      borderColor = calculateBorderColor(borderColorSaturation, thisNodeColor)
    }

    existsStyle.stroke = borderColor
    const viewChildren = node.viewChildren

    if (!viewChildren || !viewChildren.length) {
      thisNodeColor = calculateColor(visuals) // Apply visual to this node.

      existsStyle.fill = thisNodeColor
    } else {
      const mapping_1 = buildVisualMapping(node, nodeModel, nodeLayout, nodeItemStyleModel, visuals, viewChildren) // Designate visual to children.

      each(viewChildren, function (child, index) {
        // If higher than viewRoot, only ancestors of viewRoot is needed to visit.
        if (child.depth >= viewRootAncestors.length || child === viewRootAncestors[child.depth]) {
          const childVisual = mapVisual(nodeModel, visuals, child, index, mapping_1, seriesModel)
          travelTree(child, childVisual, viewRootAncestors, seriesModel)
        }
      })
    }
  }

  function buildVisuals (nodeItemStyleModel, designatedVisual, seriesModel) {
    const visuals = extend({}, designatedVisual)
    const designatedVisualItemStyle = seriesModel.designatedVisualItemStyle
    each(['color', 'colorAlpha', 'colorSaturation'], function (visualName) {
      // Priority: thisNode > thisLevel > parentNodeDesignated > seriesModel
      designatedVisualItemStyle[visualName] = designatedVisual[visualName]
      const val = nodeItemStyleModel.get(visualName)
      designatedVisualItemStyle[visualName] = null
      val != null && (visuals[visualName] = val)
    })
    return visuals
  }

  function calculateColor (visuals) {
    let color = getValueVisualDefine(visuals, 'color')

    if (color) {
      const colorAlpha = getValueVisualDefine(visuals, 'colorAlpha')
      const colorSaturation = getValueVisualDefine(visuals, 'colorSaturation')

      if (colorSaturation) {
        color = modifyHSL(color, null, null, colorSaturation)
      }

      if (colorAlpha) {
        color = modifyAlpha(color, colorAlpha)
      }

      return color
    }
  }

  function calculateBorderColor (borderColorSaturation, thisNodeColor) {
    return thisNodeColor != null // Can only be string
      ? modifyHSL(thisNodeColor, null, null, borderColorSaturation) : null
  }

  function getValueVisualDefine (visuals, name) {
    const value = visuals[name]

    if (value != null && value !== 'none') {
      return value
    }
  }

  function buildVisualMapping (node, nodeModel, nodeLayout, nodeItemStyleModel, visuals, viewChildren) {
    if (!viewChildren || !viewChildren.length) {
      return
    }

    const rangeVisual = getRangeVisual(nodeModel, 'color') || visuals.color != null && visuals.color !== 'none' && (getRangeVisual(nodeModel, 'colorAlpha') || getRangeVisual(nodeModel, 'colorSaturation'))

    if (!rangeVisual) {
      return
    }

    const visualMin = nodeModel.get('visualMin')
    const visualMax = nodeModel.get('visualMax')
    const dataExtent = nodeLayout.dataExtent.slice()
    visualMin != null && visualMin < dataExtent[0] && (dataExtent[0] = visualMin)
    visualMax != null && visualMax > dataExtent[1] && (dataExtent[1] = visualMax)
    const colorMappingBy = nodeModel.get('colorMappingBy')
    const opt = {
      type: rangeVisual.name,
      dataExtent: dataExtent,
      visual: rangeVisual.range
    }

    if (opt.type === 'color' && (colorMappingBy === 'index' || colorMappingBy === 'id')) {
      opt.mappingMethod = 'category'
      opt.loop = true // categories is ordinal, so do not set opt.categories.
    } else {
      opt.mappingMethod = 'linear'
    }

    const mapping = new VisualMapping(opt)
    inner$9(mapping).drColorMappingBy = colorMappingBy
    return mapping
  } // Notice: If we dont have the attribute 'colorRange', but only use
  // attribute 'color' to represent both concepts of 'colorRange' and 'color',
  // (It means 'colorRange' when 'color' is Array, means 'color' when not array),
  // this problem will be encountered:
  // If a level-1 node dont have children, and its siblings has children,
  // and colorRange is set on level-1, then the node can not be colored.
  // So we separate 'colorRange' and 'color' to different attributes.

  function getRangeVisual (nodeModel, name) {
    // 'colorRange', 'colorARange', 'colorSRange'.
    // If not exsits on this node, fetch from levels and series.
    const range = nodeModel.get(name)
    return isArray(range) && range.length
      ? {
          name: name,
          range: range
        }
      : null
  }

  function mapVisual (nodeModel, visuals, child, index, mapping, seriesModel) {
    const childVisuals = extend({}, visuals)

    if (mapping) {
      // Only support color, colorAlpha, colorSaturation.
      const mappingType = mapping.type
      const colorMappingBy = mappingType === 'color' && inner$9(mapping).drColorMappingBy
      const value = colorMappingBy === 'index' ? index : colorMappingBy === 'id' ? seriesModel.mapIdToIndex(child.getId()) : child.getValue(nodeModel.get('visualDimension'))
      childVisuals[mappingType] = mapping.mapValueToVisual(value)
    }

    return childVisuals
  }

  const mathMax$7 = Math.max
  const mathMin$7 = Math.min
  const retrieveValue = retrieve
  const each$4 = each
  const PATH_BORDER_WIDTH = ['itemStyle', 'borderWidth']
  const PATH_GAP_WIDTH = ['itemStyle', 'gapWidth']
  const PATH_UPPER_LABEL_SHOW = ['upperLabel', 'show']
  const PATH_UPPER_LABEL_HEIGHT = ['upperLabel', 'height']
  /**
     * @public
     */

  const treemapLayout = {
    seriesType: 'treemap',
    reset: function (seriesModel, ecModel, api, payload) {
      // Layout result in each node:
      // {x, y, width, height, area, borderWidth}
      const ecWidth = api.getWidth()
      const ecHeight = api.getHeight()
      const seriesOption = seriesModel.option
      const layoutInfo = getLayoutRect(seriesModel.getBoxLayoutParams(), {
        width: api.getWidth(),
        height: api.getHeight()
      })
      const size = seriesOption.size || [] // Compatible with ec2.

      const containerWidth = parsePercent$1(retrieveValue(layoutInfo.width, size[0]), ecWidth)
      const containerHeight = parsePercent$1(retrieveValue(layoutInfo.height, size[1]), ecHeight) // Fetch payload info.

      const payloadType = payload && payload.type
      const types = ['treemapZoomToNode', 'treemapRootToNode']
      const targetInfo = retrieveTargetInfo(payload, types, seriesModel)
      const rootRect = payloadType === 'treemapRender' || payloadType === 'treemapMove' ? payload.rootRect : null
      const viewRoot = seriesModel.getViewRoot()
      const viewAbovePath = getPathToRoot(viewRoot)

      if (payloadType !== 'treemapMove') {
        const rootSize = payloadType === 'treemapZoomToNode' ? estimateRootSize(seriesModel, targetInfo, viewRoot, containerWidth, containerHeight) : rootRect ? [rootRect.width, rootRect.height] : [containerWidth, containerHeight]
        let sort_1 = seriesOption.sort

        if (sort_1 && sort_1 !== 'asc' && sort_1 !== 'desc') {
          // Default to be desc order.
          sort_1 = 'desc'
        }

        const options = {
          squareRatio: seriesOption.squareRatio,
          sort: sort_1,
          leafDepth: seriesOption.leafDepth
        } // layout should be cleared because using updateView but not update.

        viewRoot.hostTree.clearLayouts() // TODO
        // optimize: if out of view clip, do not layout.
        // But take care that if do not render node out of view clip,
        // how to calculate start po

        let viewRootLayout_1 = {
          x: 0,
          y: 0,
          width: rootSize[0],
          height: rootSize[1],
          area: rootSize[0] * rootSize[1]
        }
        viewRoot.setLayout(viewRootLayout_1)
        squarify(viewRoot, options, false, 0) // Supplement layout.

        viewRootLayout_1 = viewRoot.getLayout()
        each$4(viewAbovePath, function (node, index) {
          const childValue = (viewAbovePath[index + 1] || viewRoot).getValue()
          node.setLayout(extend({
            dataExtent: [childValue, childValue],
            borderWidth: 0,
            upperHeight: 0
          }, viewRootLayout_1))
        })
      }

      const treeRoot = seriesModel.getData().tree.root
      treeRoot.setLayout(calculateRootPosition(layoutInfo, rootRect, targetInfo), true)
      seriesModel.setLayoutInfo(layoutInfo) // FIXME
      // 现在没有clip功能，暂时取ec高宽。

      prunning(treeRoot, // Transform to base element coordinate system.
        new BoundingRect(-layoutInfo.x, -layoutInfo.y, ecWidth, ecHeight), viewAbovePath, viewRoot, 0)
    }
  }
  /**
     * Layout treemap with squarify algorithm.
     * The original presentation of this algorithm
     * was made by Mark Bruls, Kees Huizing, and Jarke J. van Wijk
     * <https://graphics.ethz.ch/teaching/scivis_common/Literature/squarifiedTreeMaps.pdf>.
     * The implementation of this algorithm was originally copied from "d3.js"
     * <https://github.com/d3/d3/blob/9cc9a875e636a1dcf36cc1e07bdf77e1ad6e2c74/src/layout/treemap.js>
     * with some modifications made for this program.
     * See the license statement at the head of this file.
     *
     * @protected
     * @param {module:echarts/data/Tree~TreeNode} node
     * @param {Object} options
     * @param {string} options.sort 'asc' or 'desc'
     * @param {number} options.squareRatio
     * @param {boolean} hideChildren
     * @param {number} depth
     */

  function squarify (node, options, hideChildren, depth) {
    let width
    let height

    if (node.isRemoved()) {
      return
    }

    const thisLayout = node.getLayout()
    width = thisLayout.width
    height = thisLayout.height // Considering border and gap

    const nodeModel = node.getModel()
    const borderWidth = nodeModel.get(PATH_BORDER_WIDTH)
    const halfGapWidth = nodeModel.get(PATH_GAP_WIDTH) / 2
    const upperLabelHeight = getUpperLabelHeight(nodeModel)
    const upperHeight = Math.max(borderWidth, upperLabelHeight)
    const layoutOffset = borderWidth - halfGapWidth
    const layoutOffsetUpper = upperHeight - halfGapWidth
    node.setLayout({
      borderWidth: borderWidth,
      upperHeight: upperHeight,
      upperLabelHeight: upperLabelHeight
    }, true)
    width = mathMax$7(width - 2 * layoutOffset, 0)
    height = mathMax$7(height - layoutOffset - layoutOffsetUpper, 0)
    const totalArea = width * height
    const viewChildren = initChildren(node, nodeModel, totalArea, options, hideChildren, depth)

    if (!viewChildren.length) {
      return
    }

    const rect = {
      x: layoutOffset,
      y: layoutOffsetUpper,
      width: width,
      height: height
    }
    let rowFixedLength = mathMin$7(width, height)
    let best = Infinity // the best row score so far

    const row = []
    row.area = 0

    for (var i = 0, len = viewChildren.length; i < len;) {
      const child = viewChildren[i]
      row.push(child)
      row.area += child.getLayout().area
      const score = worst(row, rowFixedLength, options.squareRatio) // continue with this orientation

      if (score <= best) {
        i++
        best = score
      } // abort, and try a different orientation
      else {
        row.area -= row.pop().getLayout().area
        position(row, rowFixedLength, rect, halfGapWidth, false)
        rowFixedLength = mathMin$7(rect.width, rect.height)
        row.length = row.area = 0
        best = Infinity
      }
    }

    if (row.length) {
      position(row, rowFixedLength, rect, halfGapWidth, true)
    }

    if (!hideChildren) {
      const childrenVisibleMin = nodeModel.get('childrenVisibleMin')

      if (childrenVisibleMin != null && totalArea < childrenVisibleMin) {
        hideChildren = true
      }
    }

    for (var i = 0, len = viewChildren.length; i < len; i++) {
      squarify(viewChildren[i], options, hideChildren, depth + 1)
    }
  }
  /**
     * Set area to each child, and calculate data extent for visual coding.
     */

  function initChildren (node, nodeModel, totalArea, options, hideChildren, depth) {
    let viewChildren = node.children || []
    let orderBy = options.sort
    orderBy !== 'asc' && orderBy !== 'desc' && (orderBy = null)
    const overLeafDepth = options.leafDepth != null && options.leafDepth <= depth // leafDepth has higher priority.

    if (hideChildren && !overLeafDepth) {
      return node.viewChildren = []
    } // Sort children, order by desc.

    viewChildren = filter(viewChildren, function (child) {
      return !child.isRemoved()
    })
    sort$1(viewChildren, orderBy)
    const info = statistic(nodeModel, viewChildren, orderBy)

    if (info.sum === 0) {
      return node.viewChildren = []
    }

    info.sum = filterByThreshold(nodeModel, totalArea, info.sum, orderBy, viewChildren)

    if (info.sum === 0) {
      return node.viewChildren = []
    } // Set area to each child.

    for (let i = 0, len = viewChildren.length; i < len; i++) {
      const area = viewChildren[i].getValue() / info.sum * totalArea // Do not use setLayout({...}, true), because it is needed to clear last layout.

      viewChildren[i].setLayout({
        area: area
      })
    }

    if (overLeafDepth) {
      viewChildren.length && node.setLayout({
        isLeafRoot: true
      }, true)
      viewChildren.length = 0
    }

    node.viewChildren = viewChildren
    node.setLayout({
      dataExtent: info.dataExtent
    }, true)
    return viewChildren
  }
  /**
     * Consider 'visibleMin'. Modify viewChildren and get new sum.
     */

  function filterByThreshold (nodeModel, totalArea, sum, orderBy, orderedChildren) {
    // visibleMin is not supported yet when no option.sort.
    if (!orderBy) {
      return sum
    }

    const visibleMin = nodeModel.get('visibleMin')
    const len = orderedChildren.length
    let deletePoint = len // Always travel from little value to big value.

    for (let i = len - 1; i >= 0; i--) {
      const value = orderedChildren[orderBy === 'asc' ? len - i - 1 : i].getValue()

      if (value / sum * totalArea < visibleMin) {
        deletePoint = i
        sum -= value
      }
    }

    orderBy === 'asc' ? orderedChildren.splice(0, len - deletePoint) : orderedChildren.splice(deletePoint, len - deletePoint)
    return sum
  }
  /**
     * Sort
     */

  function sort$1 (viewChildren, orderBy) {
    if (orderBy) {
      viewChildren.sort(function (a, b) {
        const diff = orderBy === 'asc' ? a.getValue() - b.getValue() : b.getValue() - a.getValue()
        return diff === 0 ? orderBy === 'asc' ? a.dataIndex - b.dataIndex : b.dataIndex - a.dataIndex : diff
      })
    }

    return viewChildren
  }
  /**
     * Statistic
     */

  function statistic (nodeModel, children, orderBy) {
    // Calculate sum.
    let sum = 0

    for (let i = 0, len = children.length; i < len; i++) {
      sum += children[i].getValue()
    } // Statistic data extent for latter visual coding.
    // Notice: data extent should be calculate based on raw children
    // but not filtered view children, otherwise visual mapping will not
    // be stable when zoom (where children is filtered by visibleMin).

    const dimension = nodeModel.get('visualDimension')
    let dataExtent // The same as area dimension.

    if (!children || !children.length) {
      dataExtent = [NaN, NaN]
    } else if (dimension === 'value' && orderBy) {
      dataExtent = [children[children.length - 1].getValue(), children[0].getValue()]
      orderBy === 'asc' && dataExtent.reverse()
    } // Other dimension.
    else {
      dataExtent = [Infinity, -Infinity]
      each$4(children, function (child) {
        const value = child.getValue(dimension)
        value < dataExtent[0] && (dataExtent[0] = value)
        value > dataExtent[1] && (dataExtent[1] = value)
      })
    }

    return {
      sum: sum,
      dataExtent: dataExtent
    }
  }
  /**
     * Computes the score for the specified row,
     * as the worst aspect ratio.
     */

  function worst (row, rowFixedLength, ratio) {
    let areaMax = 0
    let areaMin = Infinity

    for (let i = 0, area = void 0, len = row.length; i < len; i++) {
      area = row[i].getLayout().area

      if (area) {
        area < areaMin && (areaMin = area)
        area > areaMax && (areaMax = area)
      }
    }

    const squareArea = row.area * row.area
    const f = rowFixedLength * rowFixedLength * ratio
    return squareArea ? mathMax$7(f * areaMax / squareArea, squareArea / (f * areaMin)) : Infinity
  }
  /**
     * Positions the specified row of nodes. Modifies `rect`.
     */

  function position (row, rowFixedLength, rect, halfGapWidth, flush) {
    // When rowFixedLength === rect.width,
    // it is horizontal subdivision,
    // rowFixedLength is the width of the subdivision,
    // rowOtherLength is the height of the subdivision,
    // and nodes will be positioned from left to right.
    // wh[idx0WhenH] means: when horizontal,
    //      wh[idx0WhenH] => wh[0] => 'width'.
    //      xy[idx1WhenH] => xy[1] => 'y'.
    const idx0WhenH = rowFixedLength === rect.width ? 0 : 1
    const idx1WhenH = 1 - idx0WhenH
    const xy = ['x', 'y']
    const wh = ['width', 'height']
    let last = rect[xy[idx0WhenH]]
    let rowOtherLength = rowFixedLength ? row.area / rowFixedLength : 0

    if (flush || rowOtherLength > rect[wh[idx1WhenH]]) {
      rowOtherLength = rect[wh[idx1WhenH]] // over+underflow
    }

    for (let i = 0, rowLen = row.length; i < rowLen; i++) {
      const node = row[i]
      const nodeLayout = {}
      const step = rowOtherLength ? node.getLayout().area / rowOtherLength : 0
      const wh1 = nodeLayout[wh[idx1WhenH]] = mathMax$7(rowOtherLength - 2 * halfGapWidth, 0) // We use Math.max/min to avoid negative width/height when considering gap width.

      const remain = rect[xy[idx0WhenH]] + rect[wh[idx0WhenH]] - last
      const modWH = i === rowLen - 1 || remain < step ? remain : step
      const wh0 = nodeLayout[wh[idx0WhenH]] = mathMax$7(modWH - 2 * halfGapWidth, 0)
      nodeLayout[xy[idx1WhenH]] = rect[xy[idx1WhenH]] + mathMin$7(halfGapWidth, wh1 / 2)
      nodeLayout[xy[idx0WhenH]] = last + mathMin$7(halfGapWidth, wh0 / 2)
      last += modWH
      node.setLayout(nodeLayout, true)
    }

    rect[xy[idx1WhenH]] += rowOtherLength
    rect[wh[idx1WhenH]] -= rowOtherLength
  } // Return [containerWidth, containerHeight] as default.

  function estimateRootSize (seriesModel, targetInfo, viewRoot, containerWidth, containerHeight) {
    // If targetInfo.node exists, we zoom to the node,
    // so estimate whold width and heigth by target node.
    let currNode = (targetInfo || {}).node
    const defaultSize = [containerWidth, containerHeight]

    if (!currNode || currNode === viewRoot) {
      return defaultSize
    }

    let parent
    const viewArea = containerWidth * containerHeight
    let area = viewArea * seriesModel.option.zoomToNodeRatio

    while (parent = currNode.parentNode) {
      // jshint ignore:line
      let sum = 0
      const siblings = parent.children

      for (let i = 0, len = siblings.length; i < len; i++) {
        sum += siblings[i].getValue()
      }

      const currNodeValue = currNode.getValue()

      if (currNodeValue === 0) {
        return defaultSize
      }

      area *= sum / currNodeValue // Considering border, suppose aspect ratio is 1.

      const parentModel = parent.getModel()
      const borderWidth = parentModel.get(PATH_BORDER_WIDTH)
      const upperHeight = Math.max(borderWidth, getUpperLabelHeight(parentModel))
      area += 4 * borderWidth * borderWidth + (3 * borderWidth + upperHeight) * Math.pow(area, 0.5)
      area > MAX_SAFE_INTEGER && (area = MAX_SAFE_INTEGER)
      currNode = parent
    }

    area < viewArea && (area = viewArea)
    const scale = Math.pow(area / viewArea, 0.5)
    return [containerWidth * scale, containerHeight * scale]
  } // Root postion base on coord of containerGroup

  function calculateRootPosition (layoutInfo, rootRect, targetInfo) {
    if (rootRect) {
      return {
        x: rootRect.x,
        y: rootRect.y
      }
    }

    const defaultPosition = {
      x: 0,
      y: 0
    }

    if (!targetInfo) {
      return defaultPosition
    } // If targetInfo is fetched by 'retrieveTargetInfo',
    // old tree and new tree are the same tree,
    // so the node still exists and we can visit it.

    const targetNode = targetInfo.node
    const layout = targetNode.getLayout()

    if (!layout) {
      return defaultPosition
    } // Transform coord from local to container.

    const targetCenter = [layout.width / 2, layout.height / 2]
    let node = targetNode

    while (node) {
      const nodeLayout = node.getLayout()
      targetCenter[0] += nodeLayout.x
      targetCenter[1] += nodeLayout.y
      node = node.parentNode
    }

    return {
      x: layoutInfo.width / 2 - targetCenter[0],
      y: layoutInfo.height / 2 - targetCenter[1]
    }
  } // Mark nodes visible for prunning when visual coding and rendering.
  // Prunning depends on layout and root position, so we have to do it after layout.

  function prunning (node, clipRect, viewAbovePath, viewRoot, depth) {
    const nodeLayout = node.getLayout()
    const nodeInViewAbovePath = viewAbovePath[depth]
    const isAboveViewRoot = nodeInViewAbovePath && nodeInViewAbovePath === node

    if (nodeInViewAbovePath && !isAboveViewRoot || depth === viewAbovePath.length && node !== viewRoot) {
      return
    }

    node.setLayout({
      // isInView means: viewRoot sub tree + viewAbovePath
      isInView: true,
      // invisible only means: outside view clip so that the node can not
      // see but still layout for animation preparation but not render.
      invisible: !isAboveViewRoot && !clipRect.intersect(nodeLayout),
      isAboveViewRoot: isAboveViewRoot
    }, true) // Transform to child coordinate.

    const childClipRect = new BoundingRect(clipRect.x - nodeLayout.x, clipRect.y - nodeLayout.y, clipRect.width, clipRect.height)
    each$4(node.viewChildren || [], function (child) {
      prunning(child, childClipRect, viewAbovePath, viewRoot, depth + 1)
    })
  }

  function getUpperLabelHeight (model) {
    return model.get(PATH_UPPER_LABEL_SHOW) ? model.get(PATH_UPPER_LABEL_HEIGHT) : 0
  }

  function install$c (registers) {
    registers.registerSeriesModel(TreemapSeriesModel)
    registers.registerChartView(TreemapView)
    registers.registerVisual(treemapVisual)
    registers.registerLayout(treemapLayout)
    installTreemapAction(registers)
  }

  function categoryFilter (ecModel) {
    const legendModels = ecModel.findComponents({
      mainType: 'legend'
    })

    if (!legendModels || !legendModels.length) {
      return
    }

    ecModel.eachSeriesByType('graph', function (graphSeries) {
      const categoriesData = graphSeries.getCategoriesData()
      const graph = graphSeries.getGraph()
      const data = graph.data
      const categoryNames = categoriesData.mapArray(categoriesData.getName)
      data.filterSelf(function (idx) {
        const model = data.getItemModel(idx)
        let category = model.getShallow('category')

        if (category != null) {
          if (isNumber(category)) {
            category = categoryNames[category]
          } // If in any legend component the status is not selected.

          for (let i = 0; i < legendModels.length; i++) {
            if (!legendModels[i].isSelected(category)) {
              return false
            }
          }
        }

        return true
      })
    })
  }

  function categoryVisual (ecModel) {
    const paletteScope = {}
    ecModel.eachSeriesByType('graph', function (seriesModel) {
      const categoriesData = seriesModel.getCategoriesData()
      const data = seriesModel.getData()
      const categoryNameIdxMap = {}
      categoriesData.each(function (idx) {
        const name = categoriesData.getName(idx) // Add prefix to avoid conflict with Object.prototype.

        categoryNameIdxMap['ec-' + name] = idx
        const itemModel = categoriesData.getItemModel(idx)
        const style = itemModel.getModel('itemStyle').getItemStyle()

        if (!style.fill) {
          // Get color from palette.
          style.fill = seriesModel.getColorFromPalette(name, paletteScope)
        }

        categoriesData.setItemVisual(idx, 'style', style)
        const symbolVisualList = ['symbol', 'symbolSize', 'symbolKeepAspect']

        for (let i = 0; i < symbolVisualList.length; i++) {
          const symbolVisual = itemModel.getShallow(symbolVisualList[i], true)

          if (symbolVisual != null) {
            categoriesData.setItemVisual(idx, symbolVisualList[i], symbolVisual)
          }
        }
      }) // Assign category color to visual

      if (categoriesData.count()) {
        data.each(function (idx) {
          const model = data.getItemModel(idx)
          let categoryIdx = model.getShallow('category')

          if (categoryIdx != null) {
            if (isString(categoryIdx)) {
              categoryIdx = categoryNameIdxMap['ec-' + categoryIdx]
            }

            const categoryStyle = categoriesData.getItemVisual(categoryIdx, 'style')
            const style = data.ensureUniqueItemVisual(idx, 'style')
            extend(style, categoryStyle)
            const visualList = ['symbol', 'symbolSize', 'symbolKeepAspect']

            for (let i = 0; i < visualList.length; i++) {
              data.setItemVisual(idx, visualList[i], categoriesData.getItemVisual(categoryIdx, visualList[i]))
            }
          }
        })
      }
    })
  }

  function normalize$2 (a) {
    if (!(a instanceof Array)) {
      a = [a, a]
    }

    return a
  }

  function graphEdgeVisual (ecModel) {
    ecModel.eachSeriesByType('graph', function (seriesModel) {
      const graph = seriesModel.getGraph()
      const edgeData = seriesModel.getEdgeData()
      const symbolType = normalize$2(seriesModel.get('edgeSymbol'))
      const symbolSize = normalize$2(seriesModel.get('edgeSymbolSize')) // const colorQuery = ['lineStyle', 'color'] as const;
      // const opacityQuery = ['lineStyle', 'opacity'] as const;

      edgeData.setVisual('fromSymbol', symbolType && symbolType[0])
      edgeData.setVisual('toSymbol', symbolType && symbolType[1])
      edgeData.setVisual('fromSymbolSize', symbolSize && symbolSize[0])
      edgeData.setVisual('toSymbolSize', symbolSize && symbolSize[1])
      edgeData.setVisual('style', seriesModel.getModel('lineStyle').getLineStyle())
      edgeData.each(function (idx) {
        const itemModel = edgeData.getItemModel(idx)
        const edge = graph.getEdgeByIndex(idx)
        const symbolType = normalize$2(itemModel.getShallow('symbol', true))
        const symbolSize = normalize$2(itemModel.getShallow('symbolSize', true)) // Edge visual must after node visual

        const style = itemModel.getModel('lineStyle').getLineStyle()
        const existsStyle = edgeData.ensureUniqueItemVisual(idx, 'style')
        extend(existsStyle, style)

        switch (existsStyle.stroke) {
          case 'source':
          {
            var nodeStyle = edge.node1.getVisual('style')
            existsStyle.stroke = nodeStyle && nodeStyle.fill
            break
          }

          case 'target':
          {
            var nodeStyle = edge.node2.getVisual('style')
            existsStyle.stroke = nodeStyle && nodeStyle.fill
            break
          }
        }

        symbolType[0] && edge.setVisual('fromSymbol', symbolType[0])
        symbolType[1] && edge.setVisual('toSymbol', symbolType[1])
        symbolSize[0] && edge.setVisual('fromSymbolSize', symbolSize[0])
        symbolSize[1] && edge.setVisual('toSymbolSize', symbolSize[1])
      })
    })
  }

  const KEY_DELIMITER = '-->'
  /**
     * params handler
     * @param {module:echarts/model/SeriesModel} seriesModel
     * @returns {*}
     */

  const getAutoCurvenessParams = function (seriesModel) {
    return seriesModel.get('autoCurveness') || null
  }
  /**
     * Generate a list of edge curvatures, 20 is the default
     * @param {module:echarts/model/SeriesModel} seriesModel
     * @param {number} appendLength
     * @return  20 => [0, -0.2, 0.2, -0.4, 0.4, -0.6, 0.6, -0.8, 0.8, -1, 1, -1.2, 1.2, -1.4, 1.4, -1.6, 1.6, -1.8, 1.8, -2]
     */

  const createCurveness = function (seriesModel, appendLength) {
    const autoCurvenessParmas = getAutoCurvenessParams(seriesModel)
    let length = 20
    let curvenessList = [] // handler the function set

    if (isNumber(autoCurvenessParmas)) {
      length = autoCurvenessParmas
    } else if (isArray(autoCurvenessParmas)) {
      seriesModel.__curvenessList = autoCurvenessParmas
      return
    } // append length

    if (appendLength > length) {
      length = appendLength
    } // make sure the length is even

    const len = length % 2 ? length + 2 : length + 3
    curvenessList = []

    for (let i = 0; i < len; i++) {
      curvenessList.push((i % 2 ? i + 1 : i) / 10 * (i % 2 ? -1 : 1))
    }

    seriesModel.__curvenessList = curvenessList
  }
  /**
     * Create different cache key data in the positive and negative directions, in order to set the curvature later
     * @param {number|string|module:echarts/data/Graph.Node} n1
     * @param {number|string|module:echarts/data/Graph.Node} n2
     * @param {module:echarts/model/SeriesModel} seriesModel
     * @returns {string} key
     */

  const getKeyOfEdges = function (n1, n2, seriesModel) {
    const source = [n1.id, n1.dataIndex].join('.')
    const target = [n2.id, n2.dataIndex].join('.')
    return [seriesModel.uid, source, target].join(KEY_DELIMITER)
  }
  /**
     * get opposite key
     * @param {string} key
     * @returns {string}
     */

  const getOppositeKey = function (key) {
    const keys = key.split(KEY_DELIMITER)
    return [keys[0], keys[2], keys[1]].join(KEY_DELIMITER)
  }
  /**
     * get edgeMap with key
     * @param edge
     * @param {module:echarts/model/SeriesModel} seriesModel
     */

  const getEdgeFromMap = function (edge, seriesModel) {
    const key = getKeyOfEdges(edge.node1, edge.node2, seriesModel)
    return seriesModel.__edgeMap[key]
  }
  /**
     * calculate all cases total length
     * @param edge
     * @param seriesModel
     * @returns {number}
     */

  const getTotalLengthBetweenNodes = function (edge, seriesModel) {
    const len = getEdgeMapLengthWithKey(getKeyOfEdges(edge.node1, edge.node2, seriesModel), seriesModel)
    const lenV = getEdgeMapLengthWithKey(getKeyOfEdges(edge.node2, edge.node1, seriesModel), seriesModel)
    return len + lenV
  }
  /**
     *
     * @param key
     */

  var getEdgeMapLengthWithKey = function (key, seriesModel) {
    const edgeMap = seriesModel.__edgeMap
    return edgeMap[key] ? edgeMap[key].length : 0
  }
  /**
     * Count the number of edges between the same two points, used to obtain the curvature table and the parity of the edge
     * @see /graph/GraphSeries.js@getInitialData
     * @param {module:echarts/model/SeriesModel} seriesModel
     */

  function initCurvenessList (seriesModel) {
    if (!getAutoCurvenessParams(seriesModel)) {
      return
    }

    seriesModel.__curvenessList = []
    seriesModel.__edgeMap = {} // calc the array of curveness List

    createCurveness(seriesModel)
  }
  /**
     * set edgeMap with key
     * @param {number|string|module:echarts/data/Graph.Node} n1
     * @param {number|string|module:echarts/data/Graph.Node} n2
     * @param {module:echarts/model/SeriesModel} seriesModel
     * @param {number} index
     */

  function createEdgeMapForCurveness (n1, n2, seriesModel, index) {
    if (!getAutoCurvenessParams(seriesModel)) {
      return
    }

    const key = getKeyOfEdges(n1, n2, seriesModel)
    const edgeMap = seriesModel.__edgeMap
    const oppositeEdges = edgeMap[getOppositeKey(key)] // set direction

    if (edgeMap[key] && !oppositeEdges) {
      edgeMap[key].isForward = true
    } else if (oppositeEdges && edgeMap[key]) {
      oppositeEdges.isForward = true
      edgeMap[key].isForward = false
    }

    edgeMap[key] = edgeMap[key] || []
    edgeMap[key].push(index)
  }
  /**
     * get curvature for edge
     * @param edge
     * @param {module:echarts/model/SeriesModel} seriesModel
     * @param index
     */

  function getCurvenessForEdge (edge, seriesModel, index, needReverse) {
    const autoCurvenessParams = getAutoCurvenessParams(seriesModel)
    const isArrayParam = isArray(autoCurvenessParams)

    if (!autoCurvenessParams) {
      return null
    }

    const edgeArray = getEdgeFromMap(edge, seriesModel)

    if (!edgeArray) {
      return null
    }

    let edgeIndex = -1

    for (let i = 0; i < edgeArray.length; i++) {
      if (edgeArray[i] === index) {
        edgeIndex = i
        break
      }
    } // if totalLen is Longer createCurveness

    const totalLen = getTotalLengthBetweenNodes(edge, seriesModel)
    createCurveness(seriesModel, totalLen)
    edge.lineStyle = edge.lineStyle || {} // if is opposite edge, must set curvenss to opposite number

    const curKey = getKeyOfEdges(edge.node1, edge.node2, seriesModel)
    const curvenessList = seriesModel.__curvenessList // if pass array no need parity

    const parityCorrection = isArrayParam ? 0 : totalLen % 2 ? 0 : 1

    if (!edgeArray.isForward) {
      // the opposite edge show outside
      const oppositeKey = getOppositeKey(curKey)
      const len = getEdgeMapLengthWithKey(oppositeKey, seriesModel)
      const resValue = curvenessList[edgeIndex + len + parityCorrection] // isNeedReverse, simple, force type need reverse the curveness in the junction of the forword and the opposite

      if (needReverse) {
        // set as array may make the parity handle with the len of opposite
        if (isArrayParam) {
          if (autoCurvenessParams && autoCurvenessParams[0] === 0) {
            return (len + parityCorrection) % 2 ? resValue : -resValue
          } else {
            return ((len % 2 ? 0 : 1) + parityCorrection) % 2 ? resValue : -resValue
          }
        } else {
          return (len + parityCorrection) % 2 ? resValue : -resValue
        }
      } else {
        return curvenessList[edgeIndex + len + parityCorrection]
      }
    } else {
      return curvenessList[parityCorrection + edgeIndex]
    }
  }

  function simpleLayout (seriesModel) {
    const coordSys = seriesModel.coordinateSystem

    if (coordSys && coordSys.type !== 'view') {
      return
    }

    const graph = seriesModel.getGraph()
    graph.eachNode(function (node) {
      const model = node.getModel()
      node.setLayout([+model.get('x'), +model.get('y')])
    })
    simpleLayoutEdge(graph, seriesModel)
  }
  function simpleLayoutEdge (graph, seriesModel) {
    graph.eachEdge(function (edge, index) {
      const curveness = retrieve3(edge.getModel().get(['lineStyle', 'curveness']), -getCurvenessForEdge(edge, seriesModel, index, true), 0)
      const p1 = clone$1(edge.node1.getLayout())
      const p2 = clone$1(edge.node2.getLayout())
      const points = [p1, p2]

      if (+curveness) {
        points.push([(p1[0] + p2[0]) / 2 - (p1[1] - p2[1]) * curveness, (p1[1] + p2[1]) / 2 - (p2[0] - p1[0]) * curveness])
      }

      edge.setLayout(points)
    })
  }

  function graphSimpleLayout (ecModel, api) {
    ecModel.eachSeriesByType('graph', function (seriesModel) {
      const layout = seriesModel.get('layout')
      const coordSys = seriesModel.coordinateSystem

      if (coordSys && coordSys.type !== 'view') {
        const data_1 = seriesModel.getData()
        let dimensions_1 = []
        each(coordSys.dimensions, function (coordDim) {
          dimensions_1 = dimensions_1.concat(data_1.mapDimensionsAll(coordDim))
        })

        for (let dataIndex = 0; dataIndex < data_1.count(); dataIndex++) {
          const value = []
          let hasValue = false

          for (let i = 0; i < dimensions_1.length; i++) {
            const val = data_1.get(dimensions_1[i], dataIndex)

            if (!isNaN(val)) {
              hasValue = true
            }

            value.push(val)
          }

          if (hasValue) {
            data_1.setItemLayout(dataIndex, coordSys.dataToPoint(value))
          } else {
            // Also {Array.<number>}, not undefined to avoid if...else... statement
            data_1.setItemLayout(dataIndex, [NaN, NaN])
          }
        }

        simpleLayoutEdge(data_1.graph, seriesModel)
      } else if (!layout || layout === 'none') {
        simpleLayout(seriesModel)
      }
    })
  }

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

  /**
     * AUTO-GENERATED FILE. DO NOT MODIFY.
     */

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
  function getNodeGlobalScale (seriesModel) {
    const coordSys = seriesModel.coordinateSystem

    if (coordSys.type !== 'view') {
      return 1
    }

    const nodeScaleRatio = seriesModel.option.nodeScaleRatio
    const groupZoom = coordSys.scaleX // Scale node when zoom changes

    const roamZoom = coordSys.getZoom()
    const nodeScale = (roamZoom - 1) * nodeScaleRatio + 1
    return nodeScale / groupZoom
  }
  function getSymbolSize (node) {
    let symbolSize = node.getVisual('symbolSize')

    if (symbolSize instanceof Array) {
      symbolSize = (symbolSize[0] + symbolSize[1]) / 2
    }

    return +symbolSize
  }

  const PI$6 = Math.PI
  const _symbolRadiansHalf = []
  /**
     * `basedOn` can be:
     * 'value':
     *     This layout is not accurate and have same bad case. For example,
     *     if the min value is very smaller than the max value, the nodes
     *     with the min value probably overlap even though there is enough
     *     space to layout them. So we only use this approach in the as the
     *     init layout of the force layout.
     *     FIXME
     *     Probably we do not need this method any more but use
     *     `basedOn: 'symbolSize'` in force layout if
     *     delay its init operations to GraphView.
     * 'symbolSize':
     *     This approach work only if all of the symbol size calculated.
     *     That is, the progressive rendering is not applied to graph.
     *     FIXME
     *     If progressive rendering is applied to graph some day,
     *     probably we have to use `basedOn: 'value'`.
     */

  function circularLayout (seriesModel, basedOn) {
    const coordSys = seriesModel.coordinateSystem

    if (coordSys && coordSys.type !== 'view') {
      return
    }

    const rect = coordSys.getBoundingRect()
    const nodeData = seriesModel.getData()
    const graph = nodeData.graph
    const cx = rect.width / 2 + rect.x
    const cy = rect.height / 2 + rect.y
    const r = Math.min(rect.width, rect.height) / 2
    const count = nodeData.count()
    nodeData.setLayout({
      cx: cx,
      cy: cy
    })

    if (!count) {
      return
    }

    _layoutNodesBasedOn[basedOn](seriesModel, graph, nodeData, r, cx, cy, count)

    graph.eachEdge(function (edge, index) {
      let curveness = retrieve3(edge.getModel().get(['lineStyle', 'curveness']), getCurvenessForEdge(edge, seriesModel, index), 0)
      const p1 = clone$1(edge.node1.getLayout())
      const p2 = clone$1(edge.node2.getLayout())
      let cp1
      const x12 = (p1[0] + p2[0]) / 2
      const y12 = (p1[1] + p2[1]) / 2

      if (+curveness) {
        curveness *= 3
        cp1 = [cx * curveness + x12 * (1 - curveness), cy * curveness + y12 * (1 - curveness)]
      }

      edge.setLayout([p1, p2, cp1])
    })
  }
  var _layoutNodesBasedOn = {
    value: function (seriesModel, graph, nodeData, r, cx, cy, count) {
      let angle = 0
      const sum = nodeData.getSum('value')
      const unitAngle = Math.PI * 2 / (sum || count)
      graph.eachNode(function (node) {
        const value = node.getValue('value')
        const radianHalf = unitAngle * (sum ? value : 1) / 2
        angle += radianHalf
        node.setLayout([r * Math.cos(angle) + cx, r * Math.sin(angle) + cy])
        angle += radianHalf
      })
    },
    symbolSize: function (seriesModel, graph, nodeData, r, cx, cy, count) {
      let sumRadian = 0
      _symbolRadiansHalf.length = count
      const nodeScale = getNodeGlobalScale(seriesModel)
      graph.eachNode(function (node) {
        let symbolSize = getSymbolSize(node) // Normally this case will not happen, but we still add
        // some the defensive code (2px is an arbitrary value).

        isNaN(symbolSize) && (symbolSize = 2)
        symbolSize < 0 && (symbolSize = 0)
        symbolSize *= nodeScale
        let symbolRadianHalf = Math.asin(symbolSize / 2 / r) // when `symbolSize / 2` is bigger than `r`.

        isNaN(symbolRadianHalf) && (symbolRadianHalf = PI$6 / 2)
        _symbolRadiansHalf[node.dataIndex] = symbolRadianHalf
        sumRadian += symbolRadianHalf * 2
      })
      const halfRemainRadian = (2 * PI$6 - sumRadian) / count / 2
      let angle = 0
      graph.eachNode(function (node) {
        const radianHalf = halfRemainRadian + _symbolRadiansHalf[node.dataIndex]
        angle += radianHalf
        node.setLayout([r * Math.cos(angle) + cx, r * Math.sin(angle) + cy])
        angle += radianHalf
      })
    }
  }

  function graphCircularLayout (ecModel) {
    ecModel.eachSeriesByType('graph', function (seriesModel) {
      if (seriesModel.get('layout') === 'circular') {
        circularLayout(seriesModel, 'symbolSize')
      }
    })
  }

  const scaleAndAdd$1 = scaleAndAdd // function adjacentNode(n, e) {
  //     return e.n1 === n ? e.n2 : e.n1;
  // }

  function forceLayout (inNodes, inEdges, opts) {
    const nodes = inNodes
    const edges = inEdges
    const rect = opts.rect
    const width = rect.width
    const height = rect.height
    const center = [rect.x + width / 2, rect.y + height / 2] // let scale = opts.scale || 1;

    const gravity = opts.gravity == null ? 0.1 : opts.gravity // for (let i = 0; i < edges.length; i++) {
    //     let e = edges[i];
    //     let n1 = e.n1;
    //     let n2 = e.n2;
    //     n1.edges = n1.edges || [];
    //     n2.edges = n2.edges || [];
    //     n1.edges.push(e);
    //     n2.edges.push(e);
    // }
    // Init position

    for (let i = 0; i < nodes.length; i++) {
      const n = nodes[i]

      if (!n.p) {
        n.p = create(width * (Math.random() - 0.5) + center[0], height * (Math.random() - 0.5) + center[1])
      }

      n.pp = clone$1(n.p)
      n.edges = null
    } // Formula in 'Graph Drawing by Force-directed Placement'
    // let k = scale * Math.sqrt(width * height / nodes.length);
    // let k2 = k * k;

    const initialFriction = opts.friction == null ? 0.6 : opts.friction
    let friction = initialFriction
    let beforeStepCallback
    let afterStepCallback
    return {
      warmUp: function () {
        friction = initialFriction * 0.8
      },
      setFixed: function (idx) {
        nodes[idx].fixed = true
      },
      setUnfixed: function (idx) {
        nodes[idx].fixed = false
      },

      /**
         * Before step hook
         */
      beforeStep: function (cb) {
        beforeStepCallback = cb
      },

      /**
         * After step hook
         */
      afterStep: function (cb) {
        afterStepCallback = cb
      },

      /**
         * Some formulas were originally copied from "d3.js"
         * https://github.com/d3/d3/blob/b516d77fb8566b576088e73410437494717ada26/src/layout/force.js
         * with some modifications made for this project.
         * See the license statement at the head of this file.
         */
      step: function (cb) {
        beforeStepCallback && beforeStepCallback(nodes, edges)
        const v12 = []
        const nLen = nodes.length

        for (var i = 0; i < edges.length; i++) {
          const e = edges[i]

          if (e.ignoreForceLayout) {
            continue
          }

          var n1 = e.n1
          var n2 = e.n2
          sub(v12, n2.p, n1.p)
          var d = len(v12) - e.d
          let w = n2.w / (n1.w + n2.w)

          if (isNaN(w)) {
            w = 0
          }

          normalize(v12, v12)
          !n1.fixed && scaleAndAdd$1(n1.p, n1.p, v12, w * d * friction)
          !n2.fixed && scaleAndAdd$1(n2.p, n2.p, v12, -(1 - w) * d * friction)
        } // Gravity

        for (var i = 0; i < nLen; i++) {
          var n = nodes[i]

          if (!n.fixed) {
            sub(v12, center, n.p) // let d = vec2.len(v12);
            // vec2.scale(v12, v12, 1 / d);
            // let gravityFactor = gravity;

            scaleAndAdd$1(n.p, n.p, v12, gravity * friction)
          }
        } // Repulsive
        // PENDING

        for (var i = 0; i < nLen; i++) {
          var n1 = nodes[i]

          for (let j = i + 1; j < nLen; j++) {
            var n2 = nodes[j]
            sub(v12, n2.p, n1.p)
            var d = len(v12)

            if (d === 0) {
              // Random repulse
              set(v12, Math.random() - 0.5, Math.random() - 0.5)
              d = 1
            }

            const repFact = (n1.rep + n2.rep) / d / d
            !n1.fixed && scaleAndAdd$1(n1.pp, n1.pp, v12, repFact)
            !n2.fixed && scaleAndAdd$1(n2.pp, n2.pp, v12, -repFact)
          }
        }

        const v = []

        for (var i = 0; i < nLen; i++) {
          var n = nodes[i]

          if (!n.fixed) {
            sub(v, n.p, n.pp)
            scaleAndAdd$1(n.p, n.p, v, friction)
            copy(n.pp, n.p)
          }
        }

        friction = friction * 0.992
        const finished = friction < 0.01
        afterStepCallback && afterStepCallback(nodes, edges, finished)
        cb && cb(finished)
      }
    }
  }

  function graphForceLayout (ecModel) {
    ecModel.eachSeriesByType('graph', function (graphSeries) {
      const coordSys = graphSeries.coordinateSystem

      if (coordSys && coordSys.type !== 'view') {
        return
      }

      if (graphSeries.get('layout') === 'force') {
        const preservedPoints_1 = graphSeries.preservedPoints || {}
        const graph_1 = graphSeries.getGraph()
        const nodeData_1 = graph_1.data
        const edgeData = graph_1.edgeData
        const forceModel = graphSeries.getModel('force')
        const initLayout = forceModel.get('initLayout')

        if (graphSeries.preservedPoints) {
          nodeData_1.each(function (idx) {
            const id = nodeData_1.getId(idx)
            nodeData_1.setItemLayout(idx, preservedPoints_1[id] || [NaN, NaN])
          })
        } else if (!initLayout || initLayout === 'none') {
          simpleLayout(graphSeries)
        } else if (initLayout === 'circular') {
          circularLayout(graphSeries, 'value')
        }

        const nodeDataExtent_1 = nodeData_1.getDataExtent('value')
        const edgeDataExtent_1 = edgeData.getDataExtent('value') // let edgeDataExtent = edgeData.getDataExtent('value');

        const repulsion = forceModel.get('repulsion')
        const edgeLength = forceModel.get('edgeLength')
        const repulsionArr_1 = isArray(repulsion) ? repulsion : [repulsion, repulsion]
        let edgeLengthArr_1 = isArray(edgeLength) ? edgeLength : [edgeLength, edgeLength] // Larger value has smaller length

        edgeLengthArr_1 = [edgeLengthArr_1[1], edgeLengthArr_1[0]]
        const nodes_1 = nodeData_1.mapArray('value', function (value, idx) {
          const point = nodeData_1.getItemLayout(idx)
          let rep = linearMap(value, nodeDataExtent_1, repulsionArr_1)

          if (isNaN(rep)) {
            rep = (repulsionArr_1[0] + repulsionArr_1[1]) / 2
          }

          return {
            w: rep,
            rep: rep,
            fixed: nodeData_1.getItemModel(idx).get('fixed'),
            p: !point || isNaN(point[0]) || isNaN(point[1]) ? null : point
          }
        })
        const edges = edgeData.mapArray('value', function (value, idx) {
          const edge = graph_1.getEdgeByIndex(idx)
          let d = linearMap(value, edgeDataExtent_1, edgeLengthArr_1)

          if (isNaN(d)) {
            d = (edgeLengthArr_1[0] + edgeLengthArr_1[1]) / 2
          }

          const edgeModel = edge.getModel()
          const curveness = retrieve3(edge.getModel().get(['lineStyle', 'curveness']), -getCurvenessForEdge(edge, graphSeries, idx, true), 0)
          return {
            n1: nodes_1[edge.node1.dataIndex],
            n2: nodes_1[edge.node2.dataIndex],
            d: d,
            curveness: curveness,
            ignoreForceLayout: edgeModel.get('ignoreForceLayout')
          }
        }) // let coordSys = graphSeries.coordinateSystem;

        const rect = coordSys.getBoundingRect()
        const forceInstance = forceLayout(nodes_1, edges, {
          rect: rect,
          gravity: forceModel.get('gravity'),
          friction: forceModel.get('friction')
        })
        forceInstance.beforeStep(function (nodes, edges) {
          for (let i = 0, l = nodes.length; i < l; i++) {
            if (nodes[i].fixed) {
              // Write back to layout instance
              copy(nodes[i].p, graph_1.getNodeByIndex(i).getLayout())
            }
          }
        })
        forceInstance.afterStep(function (nodes, edges, stopped) {
          for (var i = 0, l = nodes.length; i < l; i++) {
            if (!nodes[i].fixed) {
              graph_1.getNodeByIndex(i).setLayout(nodes[i].p)
            }

            preservedPoints_1[nodeData_1.getId(i)] = nodes[i].p
          }

          for (var i = 0, l = edges.length; i < l; i++) {
            const e = edges[i]
            const edge = graph_1.getEdgeByIndex(i)
            const p1 = e.n1.p
            const p2 = e.n2.p
            let points = edge.getLayout()
            points = points ? points.slice() : []
            points[0] = points[0] || []
            points[1] = points[1] || []
            copy(points[0], p1)
            copy(points[1], p2)

            if (+e.curveness) {
              points[2] = [(p1[0] + p2[0]) / 2 - (p1[1] - p2[1]) * e.curveness, (p1[1] + p2[1]) / 2 - (p2[0] - p1[0]) * e.curveness]
            }

            edge.setLayout(points)
          }
        })
        graphSeries.forceLayout = forceInstance
        graphSeries.preservedPoints = preservedPoints_1 // Step to get the layout

        forceInstance.step()
      } else {
        // Remove prev injected forceLayout instance
        graphSeries.forceLayout = null
      }
    })
  }

  function getViewRect$2 (seriesModel, api, aspect) {
    const option = extend(seriesModel.getBoxLayoutParams(), {
      aspect: aspect
    })
    return getLayoutRect(option, {
      width: api.getWidth(),
      height: api.getHeight()
    })
  }

  function createViewCoordSys (ecModel, api) {
    const viewList = []
    ecModel.eachSeriesByType('graph', function (seriesModel) {
      const coordSysType = seriesModel.get('coordinateSystem')

      if (!coordSysType || coordSysType === 'view') {
        const data_1 = seriesModel.getData()
        const positions = data_1.mapArray(function (idx) {
          const itemModel = data_1.getItemModel(idx)
          return [+itemModel.get('x'), +itemModel.get('y')]
        })
        let min = []
        let max = []
        fromPoints(positions, min, max) // If width or height is 0

        if (max[0] - min[0] === 0) {
          max[0] += 1
          min[0] -= 1
        }

        if (max[1] - min[1] === 0) {
          max[1] += 1
          min[1] -= 1
        }

        const aspect = (max[0] - min[0]) / (max[1] - min[1]) // FIXME If get view rect after data processed?

        const viewRect = getViewRect$2(seriesModel, api, aspect) // Position may be NaN, use view rect instead

        if (isNaN(aspect)) {
          min = [viewRect.x, viewRect.y]
          max = [viewRect.x + viewRect.width, viewRect.y + viewRect.height]
        }

        const bbWidth = max[0] - min[0]
        const bbHeight = max[1] - min[1]
        const viewWidth = viewRect.width
        const viewHeight = viewRect.height
        const viewCoordSys = seriesModel.coordinateSystem = new View()
        viewCoordSys.zoomLimit = seriesModel.get('scaleLimit')
        viewCoordSys.setBoundingRect(min[0], min[1], bbWidth, bbHeight)
        viewCoordSys.setViewRect(viewRect.x, viewRect.y, viewWidth, viewHeight) // Update roam info

        viewCoordSys.setCenter(seriesModel.get('center'), api)
        viewCoordSys.setZoom(seriesModel.get('zoom'))
        viewList.push(viewCoordSys)
      }
    })
    return viewList
  }

  const straightLineProto = Line.prototype
  const bezierCurveProto = BezierCurve.prototype

  const StraightLineShape =
    /** @class */
    (function () {
      function StraightLineShape () {
        // Start point
        this.x1 = 0
        this.y1 = 0 // End point

        this.x2 = 0
        this.y2 = 0
        this.percent = 1
      }

      return StraightLineShape
    }())

  const CurveShape =
    /** @class */
    (function (_super) {
      __extends(CurveShape, _super)

      function CurveShape () {
        return _super !== null && _super.apply(this, arguments) || this
      }

      return CurveShape
    }(StraightLineShape))

  function isStraightLine (shape) {
    return isNaN(+shape.cpx1) || isNaN(+shape.cpy1)
  }

  const ECLinePath =
    /** @class */
    (function (_super) {
      __extends(ECLinePath, _super)

      function ECLinePath (opts) {
        const _this = _super.call(this, opts) || this

        _this.type = 'ec-line'
        return _this
      }

      ECLinePath.prototype.getDefaultStyle = function () {
        return {
          stroke: '#000',
          fill: null
        }
      }

      ECLinePath.prototype.getDefaultShape = function () {
        return new StraightLineShape()
      }

      ECLinePath.prototype.buildPath = function (ctx, shape) {
        if (isStraightLine(shape)) {
          straightLineProto.buildPath.call(this, ctx, shape)
        } else {
          bezierCurveProto.buildPath.call(this, ctx, shape)
        }
      }

      ECLinePath.prototype.pointAt = function (t) {
        if (isStraightLine(this.shape)) {
          return straightLineProto.pointAt.call(this, t)
        } else {
          return bezierCurveProto.pointAt.call(this, t)
        }
      }

      ECLinePath.prototype.tangentAt = function (t) {
        const shape = this.shape
        const p = isStraightLine(shape) ? [shape.x2 - shape.x1, shape.y2 - shape.y1] : bezierCurveProto.tangentAt.call(this, t)
        return normalize(p, p)
      }

      return ECLinePath
    }(Path))

  const SYMBOL_CATEGORIES = ['fromSymbol', 'toSymbol']

  function makeSymbolTypeKey (symbolCategory) {
    return '_' + symbolCategory + 'Type'
  }
  /**
     * @inner
     */

  function createSymbol$1 (name, lineData, idx) {
    const symbolType = lineData.getItemVisual(idx, name)

    if (!symbolType || symbolType === 'none') {
      return
    }

    const symbolSize = lineData.getItemVisual(idx, name + 'Size')
    const symbolRotate = lineData.getItemVisual(idx, name + 'Rotate')
    const symbolOffset = lineData.getItemVisual(idx, name + 'Offset')
    const symbolKeepAspect = lineData.getItemVisual(idx, name + 'KeepAspect')
    const symbolSizeArr = normalizeSymbolSize(symbolSize)
    const symbolOffsetArr = normalizeSymbolOffset(symbolOffset || 0, symbolSizeArr)
    const symbolPath = createSymbol(symbolType, -symbolSizeArr[0] / 2 + symbolOffsetArr[0], -symbolSizeArr[1] / 2 + symbolOffsetArr[1], symbolSizeArr[0], symbolSizeArr[1], null, symbolKeepAspect)
    symbolPath.__specifiedRotation = symbolRotate == null || isNaN(symbolRotate) ? void 0 : +symbolRotate * Math.PI / 180 || 0
    symbolPath.name = name
    return symbolPath
  }

  function createLine (points) {
    const line = new ECLinePath({
      name: 'line',
      subPixelOptimize: true
    })
    setLinePoints(line.shape, points)
    return line
  }

  function setLinePoints (targetShape, points) {
    targetShape.x1 = points[0][0]
    targetShape.y1 = points[0][1]
    targetShape.x2 = points[1][0]
    targetShape.y2 = points[1][1]
    targetShape.percent = 1
    const cp1 = points[2]

    if (cp1) {
      targetShape.cpx1 = cp1[0]
      targetShape.cpy1 = cp1[1]
    } else {
      targetShape.cpx1 = NaN
      targetShape.cpy1 = NaN
    }
  }

  const Line$1 =
    /** @class */
    (function (_super) {
      __extends(Line, _super)

      function Line (lineData, idx, seriesScope) {
        const _this = _super.call(this) || this

        _this._createLine(lineData, idx, seriesScope)

        return _this
      }

      Line.prototype._createLine = function (lineData, idx, seriesScope) {
        const seriesModel = lineData.hostModel
        const linePoints = lineData.getItemLayout(idx)
        const line = createLine(linePoints)
        line.shape.percent = 0
        initProps(line, {
          shape: {
            percent: 1
          }
        }, seriesModel, idx)
        this.add(line)
        each(SYMBOL_CATEGORIES, function (symbolCategory) {
          const symbol = createSymbol$1(symbolCategory, lineData, idx) // symbols must added after line to make sure
          // it will be updated after line#update.
          // Or symbol position and rotation update in line#beforeUpdate will be one frame slow

          this.add(symbol)
          this[makeSymbolTypeKey(symbolCategory)] = lineData.getItemVisual(idx, symbolCategory)
        }, this)

        this._updateCommonStl(lineData, idx, seriesScope)
      } // TODO More strict on the List type in parameters?

      Line.prototype.updateData = function (lineData, idx, seriesScope) {
        const seriesModel = lineData.hostModel
        const line = this.childOfName('line')
        const linePoints = lineData.getItemLayout(idx)
        const target = {
          shape: {}
        }
        setLinePoints(target.shape, linePoints)
        updateProps(line, target, seriesModel, idx)
        each(SYMBOL_CATEGORIES, function (symbolCategory) {
          const symbolType = lineData.getItemVisual(idx, symbolCategory)
          const key = makeSymbolTypeKey(symbolCategory) // Symbol changed

          if (this[key] !== symbolType) {
            this.remove(this.childOfName(symbolCategory))
            const symbol = createSymbol$1(symbolCategory, lineData, idx)
            this.add(symbol)
          }

          this[key] = symbolType
        }, this)

        this._updateCommonStl(lineData, idx, seriesScope)
      }

      Line.prototype.getLinePath = function () {
        return this.childAt(0)
      }

      Line.prototype._updateCommonStl = function (lineData, idx, seriesScope) {
        const seriesModel = lineData.hostModel
        const line = this.childOfName('line')
        let emphasisLineStyle = seriesScope && seriesScope.emphasisLineStyle
        let blurLineStyle = seriesScope && seriesScope.blurLineStyle
        let selectLineStyle = seriesScope && seriesScope.selectLineStyle
        let labelStatesModels = seriesScope && seriesScope.labelStatesModels
        let emphasisDisabled = seriesScope && seriesScope.emphasisDisabled
        let focus = seriesScope && seriesScope.focus
        let blurScope = seriesScope && seriesScope.blurScope // Optimization for large dataset

        if (!seriesScope || lineData.hasItemOption) {
          const itemModel = lineData.getItemModel(idx)
          const emphasisModel = itemModel.getModel('emphasis')
          emphasisLineStyle = emphasisModel.getModel('lineStyle').getLineStyle()
          blurLineStyle = itemModel.getModel(['blur', 'lineStyle']).getLineStyle()
          selectLineStyle = itemModel.getModel(['select', 'lineStyle']).getLineStyle()
          emphasisDisabled = emphasisModel.get('disabled')
          focus = emphasisModel.get('focus')
          blurScope = emphasisModel.get('blurScope')
          labelStatesModels = getLabelStatesModels(itemModel)
        }

        const lineStyle = lineData.getItemVisual(idx, 'style')
        const visualColor = lineStyle.stroke
        line.useStyle(lineStyle)
        line.style.fill = null
        line.style.strokeNoScale = true
        line.ensureState('emphasis').style = emphasisLineStyle
        line.ensureState('blur').style = blurLineStyle
        line.ensureState('select').style = selectLineStyle // Update symbol

        each(SYMBOL_CATEGORIES, function (symbolCategory) {
          const symbol = this.childOfName(symbolCategory)

          if (symbol) {
            // Share opacity and color with line.
            symbol.setColor(visualColor)
            symbol.style.opacity = lineStyle.opacity

            for (let i = 0; i < SPECIAL_STATES.length; i++) {
              const stateName = SPECIAL_STATES[i]
              const lineState = line.getState(stateName)

              if (lineState) {
                const lineStateStyle = lineState.style || {}
                const state = symbol.ensureState(stateName)
                const stateStyle = state.style || (state.style = {})

                if (lineStateStyle.stroke != null) {
                  stateStyle[symbol.__isEmptyBrush ? 'stroke' : 'fill'] = lineStateStyle.stroke
                }

                if (lineStateStyle.opacity != null) {
                  stateStyle.opacity = lineStateStyle.opacity
                }
              }
            }

            symbol.markRedraw()
          }
        }, this)
        const rawVal = seriesModel.getRawValue(idx)
        setLabelStyle(this, labelStatesModels, {
          labelDataIndex: idx,
          labelFetcher: {
            getFormattedLabel: function (dataIndex, stateName) {
              return seriesModel.getFormattedLabel(dataIndex, stateName, lineData.dataType)
            }
          },
          inheritColor: visualColor || '#000',
          defaultOpacity: lineStyle.opacity,
          defaultText: (rawVal == null ? lineData.getName(idx) : isFinite(rawVal) ? round(rawVal) : rawVal) + ''
        })
        const label = this.getTextContent() // Always set `textStyle` even if `normalStyle.text` is null, because default
        // values have to be set on `normalStyle`.

        if (label) {
          const labelNormalModel = labelStatesModels.normal
          label.__align = label.style.align
          label.__verticalAlign = label.style.verticalAlign // 'start', 'middle', 'end'

          label.__position = labelNormalModel.get('position') || 'middle'
          let distance = labelNormalModel.get('distance')

          if (!isArray(distance)) {
            distance = [distance, distance]
          }

          label.__labelDistance = distance
        }

        this.setTextConfig({
          position: null,
          local: true,
          inside: false // Can't be inside for stroke element.

        })
        toggleHoverEmphasis(this, focus, blurScope, emphasisDisabled)
      }

      Line.prototype.highlight = function () {
        enterEmphasis(this)
      }

      Line.prototype.downplay = function () {
        leaveEmphasis(this)
      }

      Line.prototype.updateLayout = function (lineData, idx) {
        this.setLinePoints(lineData.getItemLayout(idx))
      }

      Line.prototype.setLinePoints = function (points) {
        const linePath = this.childOfName('line')
        setLinePoints(linePath.shape, points)
        linePath.dirty()
      }

      Line.prototype.beforeUpdate = function () {
        const lineGroup = this
        const symbolFrom = lineGroup.childOfName('fromSymbol')
        const symbolTo = lineGroup.childOfName('toSymbol')
        const label = lineGroup.getTextContent() // Quick reject

        if (!symbolFrom && !symbolTo && (!label || label.ignore)) {
          return
        }

        let invScale = 1
        let parentNode = this.parent

        while (parentNode) {
          if (parentNode.scaleX) {
            invScale /= parentNode.scaleX
          }

          parentNode = parentNode.parent
        }

        const line = lineGroup.childOfName('line') // If line not changed
        // FIXME Parent scale changed

        if (!this.__dirty && !line.__dirty) {
          return
        }

        const percent = line.shape.percent
        const fromPos = line.pointAt(0)
        const toPos = line.pointAt(percent)
        const d = sub([], toPos, fromPos)
        normalize(d, d)

        function setSymbolRotation (symbol, percent) {
          // Fix #12388
          // when symbol is set to be 'arrow' in markLine,
          // symbolRotate value will be ignored, and compulsively use tangent angle.
          // rotate by default if symbol rotation is not specified
          const specifiedRotation = symbol.__specifiedRotation

          if (specifiedRotation == null) {
            const tangent = line.tangentAt(percent)
            symbol.attr('rotation', (percent === 1 ? -1 : 1) * Math.PI / 2 - Math.atan2(tangent[1], tangent[0]))
          } else {
            symbol.attr('rotation', specifiedRotation)
          }
        }

        if (symbolFrom) {
          symbolFrom.setPosition(fromPos)
          setSymbolRotation(symbolFrom, 0)
          symbolFrom.scaleX = symbolFrom.scaleY = invScale * percent
          symbolFrom.markRedraw()
        }

        if (symbolTo) {
          symbolTo.setPosition(toPos)
          setSymbolRotation(symbolTo, 1)
          symbolTo.scaleX = symbolTo.scaleY = invScale * percent
          symbolTo.markRedraw()
        }

        if (label && !label.ignore) {
          label.x = label.y = 0
          label.originX = label.originY = 0
          let textAlign = void 0
          let textVerticalAlign = void 0
          const distance = label.__labelDistance
          const distanceX = distance[0] * invScale
          const distanceY = distance[1] * invScale
          const halfPercent = percent / 2
          const tangent = line.tangentAt(halfPercent)
          const n = [tangent[1], -tangent[0]]
          const cp = line.pointAt(halfPercent)

          if (n[1] > 0) {
            n[0] = -n[0]
            n[1] = -n[1]
          }

          const dir = tangent[0] < 0 ? -1 : 1

          if (label.__position !== 'start' && label.__position !== 'end') {
            let rotation = -Math.atan2(tangent[1], tangent[0])

            if (toPos[0] < fromPos[0]) {
              rotation = Math.PI + rotation
            }

            label.rotation = rotation
          }

          let dy = void 0

          switch (label.__position) {
            case 'insideStartTop':
            case 'insideMiddleTop':
            case 'insideEndTop':
            case 'middle':
              dy = -distanceY
              textVerticalAlign = 'bottom'
              break

            case 'insideStartBottom':
            case 'insideMiddleBottom':
            case 'insideEndBottom':
              dy = distanceY
              textVerticalAlign = 'top'
              break

            default:
              dy = 0
              textVerticalAlign = 'middle'
          }

          switch (label.__position) {
            case 'end':
              label.x = d[0] * distanceX + toPos[0]
              label.y = d[1] * distanceY + toPos[1]
              textAlign = d[0] > 0.8 ? 'left' : d[0] < -0.8 ? 'right' : 'center'
              textVerticalAlign = d[1] > 0.8 ? 'top' : d[1] < -0.8 ? 'bottom' : 'middle'
              break

            case 'start':
              label.x = -d[0] * distanceX + fromPos[0]
              label.y = -d[1] * distanceY + fromPos[1]
              textAlign = d[0] > 0.8 ? 'right' : d[0] < -0.8 ? 'left' : 'center'
              textVerticalAlign = d[1] > 0.8 ? 'bottom' : d[1] < -0.8 ? 'top' : 'middle'
              break

            case 'insideStartTop':
            case 'insideStart':
            case 'insideStartBottom':
              label.x = distanceX * dir + fromPos[0]
              label.y = fromPos[1] + dy
              textAlign = tangent[0] < 0 ? 'right' : 'left'
              label.originX = -distanceX * dir
              label.originY = -dy
              break

            case 'insideMiddleTop':
            case 'insideMiddle':
            case 'insideMiddleBottom':
            case 'middle':
              label.x = cp[0]
              label.y = cp[1] + dy
              textAlign = 'center'
              label.originY = -dy
              break

            case 'insideEndTop':
            case 'insideEnd':
            case 'insideEndBottom':
              label.x = -distanceX * dir + toPos[0]
              label.y = toPos[1] + dy
              textAlign = tangent[0] >= 0 ? 'right' : 'left'
              label.originX = distanceX * dir
              label.originY = -dy
              break
          }

          label.scaleX = label.scaleY = invScale
          label.setStyle({
            // Use the user specified text align and baseline first
            verticalAlign: label.__verticalAlign || textVerticalAlign,
            align: label.__align || textAlign
          })
        }
      }

      return Line
    }(Group))

  const LineDraw =
    /** @class */
    (function () {
      function LineDraw (LineCtor) {
        this.group = new Group()
        this._LineCtor = LineCtor || Line$1
      }

      LineDraw.prototype.updateData = function (lineData) {
        const _this = this // Remove progressive els.

        this._progressiveEls = null
        const lineDraw = this
        const group = lineDraw.group
        const oldLineData = lineDraw._lineData
        lineDraw._lineData = lineData // There is no oldLineData only when first rendering or switching from
        // stream mode to normal mode, where previous elements should be removed.

        if (!oldLineData) {
          group.removeAll()
        }

        const seriesScope = makeSeriesScope$1(lineData)
        lineData.diff(oldLineData).add(function (idx) {
          _this._doAdd(lineData, idx, seriesScope)
        }).update(function (newIdx, oldIdx) {
          _this._doUpdate(oldLineData, lineData, oldIdx, newIdx, seriesScope)
        }).remove(function (idx) {
          group.remove(oldLineData.getItemGraphicEl(idx))
        }).execute()
      }

      LineDraw.prototype.updateLayout = function () {
        const lineData = this._lineData // Do not support update layout in incremental mode.

        if (!lineData) {
          return
        }

        lineData.eachItemGraphicEl(function (el, idx) {
          el.updateLayout(lineData, idx)
        }, this)
      }

      LineDraw.prototype.incrementalPrepareUpdate = function (lineData) {
        this._seriesScope = makeSeriesScope$1(lineData)
        this._lineData = null
        this.group.removeAll()
      }

      LineDraw.prototype.incrementalUpdate = function (taskParams, lineData) {
        this._progressiveEls = []

        function updateIncrementalAndHover (el) {
          if (!el.isGroup && !isEffectObject(el)) {
            el.incremental = true
            el.ensureState('emphasis').hoverLayer = true
          }
        }

        for (let idx = taskParams.start; idx < taskParams.end; idx++) {
          const itemLayout = lineData.getItemLayout(idx)

          if (lineNeedsDraw(itemLayout)) {
            const el = new this._LineCtor(lineData, idx, this._seriesScope)
            el.traverse(updateIncrementalAndHover)
            this.group.add(el)
            lineData.setItemGraphicEl(idx, el)

            this._progressiveEls.push(el)
          }
        }
      }

      LineDraw.prototype.remove = function () {
        this.group.removeAll()
      }

      LineDraw.prototype.eachRendered = function (cb) {
        traverseElements(this._progressiveEls || this.group, cb)
      }

      LineDraw.prototype._doAdd = function (lineData, idx, seriesScope) {
        const itemLayout = lineData.getItemLayout(idx)

        if (!lineNeedsDraw(itemLayout)) {
          return
        }

        const el = new this._LineCtor(lineData, idx, seriesScope)
        lineData.setItemGraphicEl(idx, el)
        this.group.add(el)
      }

      LineDraw.prototype._doUpdate = function (oldLineData, newLineData, oldIdx, newIdx, seriesScope) {
        let itemEl = oldLineData.getItemGraphicEl(oldIdx)

        if (!lineNeedsDraw(newLineData.getItemLayout(newIdx))) {
          this.group.remove(itemEl)
          return
        }

        if (!itemEl) {
          itemEl = new this._LineCtor(newLineData, newIdx, seriesScope)
        } else {
          itemEl.updateData(newLineData, newIdx, seriesScope)
        }

        newLineData.setItemGraphicEl(newIdx, itemEl)
        this.group.add(itemEl)
      }

      return LineDraw
    }())

  function isEffectObject (el) {
    return el.animators && el.animators.length > 0
  }

  function makeSeriesScope$1 (lineData) {
    const hostModel = lineData.hostModel
    const emphasisModel = hostModel.getModel('emphasis')
    return {
      lineStyle: hostModel.getModel('lineStyle').getLineStyle(),
      emphasisLineStyle: emphasisModel.getModel(['lineStyle']).getLineStyle(),
      blurLineStyle: hostModel.getModel(['blur', 'lineStyle']).getLineStyle(),
      selectLineStyle: hostModel.getModel(['select', 'lineStyle']).getLineStyle(),
      emphasisDisabled: emphasisModel.get('disabled'),
      blurScope: emphasisModel.get('blurScope'),
      focus: emphasisModel.get('focus'),
      labelStatesModels: getLabelStatesModels(hostModel)
    }
  }

  function isPointNaN (pt) {
    return isNaN(pt[0]) || isNaN(pt[1])
  }

  function lineNeedsDraw (pts) {
    return pts && !isPointNaN(pts[0]) && !isPointNaN(pts[1])
  }

  const v1 = []
  const v2 = []
  const v3 = []
  const quadraticAt$1 = quadraticAt
  const v2DistSquare = distSquare
  const mathAbs$2 = Math.abs

  function intersectCurveCircle (curvePoints, center, radius) {
    const p0 = curvePoints[0]
    const p1 = curvePoints[1]
    const p2 = curvePoints[2]
    let d = Infinity
    let t
    const radiusSquare = radius * radius
    let interval = 0.1

    for (let _t = 0.1; _t <= 0.9; _t += 0.1) {
      v1[0] = quadraticAt$1(p0[0], p1[0], p2[0], _t)
      v1[1] = quadraticAt$1(p0[1], p1[1], p2[1], _t)
      var diff = mathAbs$2(v2DistSquare(v1, center) - radiusSquare)

      if (diff < d) {
        d = diff
        t = _t
      }
    } // Assume the segment is monotone，Find root through Bisection method
    // At most 32 iteration

    for (let i = 0; i < 32; i++) {
      // let prev = t - interval;
      const next = t + interval // v1[0] = quadraticAt(p0[0], p1[0], p2[0], prev);
      // v1[1] = quadraticAt(p0[1], p1[1], p2[1], prev);

      v2[0] = quadraticAt$1(p0[0], p1[0], p2[0], t)
      v2[1] = quadraticAt$1(p0[1], p1[1], p2[1], t)
      v3[0] = quadraticAt$1(p0[0], p1[0], p2[0], next)
      v3[1] = quadraticAt$1(p0[1], p1[1], p2[1], next)
      var diff = v2DistSquare(v2, center) - radiusSquare

      if (mathAbs$2(diff) < 1e-2) {
        break
      } // let prevDiff = v2DistSquare(v1, center) - radiusSquare;

      const nextDiff = v2DistSquare(v3, center) - radiusSquare
      interval /= 2

      if (diff < 0) {
        if (nextDiff >= 0) {
          t = t + interval
        } else {
          t = t - interval
        }
      } else {
        if (nextDiff >= 0) {
          t = t - interval
        } else {
          t = t + interval
        }
      }
    }

    return t
  } // Adjust edge to avoid

  function adjustEdge (graph, scale) {
    const tmp0 = []
    const quadraticSubdivide$1 = quadraticSubdivide
    const pts = [[], [], []]
    const pts2 = [[], []]
    const v = []
    scale /= 2
    graph.eachEdge(function (edge, idx) {
      const linePoints = edge.getLayout()
      const fromSymbol = edge.getVisual('fromSymbol')
      const toSymbol = edge.getVisual('toSymbol')

      if (!linePoints.__original) {
        linePoints.__original = [clone$1(linePoints[0]), clone$1(linePoints[1])]

        if (linePoints[2]) {
          linePoints.__original.push(clone$1(linePoints[2]))
        }
      }

      const originalPoints = linePoints.__original // Quadratic curve

      if (linePoints[2] != null) {
        copy(pts[0], originalPoints[0])
        copy(pts[1], originalPoints[2])
        copy(pts[2], originalPoints[1])

        if (fromSymbol && fromSymbol !== 'none') {
          var symbolSize = getSymbolSize(edge.node1)
          var t = intersectCurveCircle(pts, originalPoints[0], symbolSize * scale) // Subdivide and get the second

          quadraticSubdivide$1(pts[0][0], pts[1][0], pts[2][0], t, tmp0)
          pts[0][0] = tmp0[3]
          pts[1][0] = tmp0[4]
          quadraticSubdivide$1(pts[0][1], pts[1][1], pts[2][1], t, tmp0)
          pts[0][1] = tmp0[3]
          pts[1][1] = tmp0[4]
        }

        if (toSymbol && toSymbol !== 'none') {
          var symbolSize = getSymbolSize(edge.node2)
          var t = intersectCurveCircle(pts, originalPoints[1], symbolSize * scale) // Subdivide and get the first

          quadraticSubdivide$1(pts[0][0], pts[1][0], pts[2][0], t, tmp0)
          pts[1][0] = tmp0[1]
          pts[2][0] = tmp0[2]
          quadraticSubdivide$1(pts[0][1], pts[1][1], pts[2][1], t, tmp0)
          pts[1][1] = tmp0[1]
          pts[2][1] = tmp0[2]
        } // Copy back to layout

        copy(linePoints[0], pts[0])
        copy(linePoints[1], pts[2])
        copy(linePoints[2], pts[1])
      } // Line
      else {
        copy(pts2[0], originalPoints[0])
        copy(pts2[1], originalPoints[1])
        sub(v, pts2[1], pts2[0])
        normalize(v, v)

        if (fromSymbol && fromSymbol !== 'none') {
          var symbolSize = getSymbolSize(edge.node1)
          scaleAndAdd(pts2[0], pts2[0], v, symbolSize * scale)
        }

        if (toSymbol && toSymbol !== 'none') {
          var symbolSize = getSymbolSize(edge.node2)
          scaleAndAdd(pts2[1], pts2[1], v, -symbolSize * scale)
        }

        copy(linePoints[0], pts2[0])
        copy(linePoints[1], pts2[1])
      }
    })
  }

  function isViewCoordSys (coordSys) {
    return coordSys.type === 'view'
  }

  const GraphView =
    /** @class */
    (function (_super) {
      __extends(GraphView, _super)

      function GraphView () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = GraphView.type
        return _this
      }

      GraphView.prototype.init = function (ecModel, api) {
        const symbolDraw = new SymbolDraw()
        const lineDraw = new LineDraw()
        const group = this.group
        this._controller = new RoamController(api.getZr())
        this._controllerHost = {
          target: group
        }
        group.add(symbolDraw.group)
        group.add(lineDraw.group)
        this._symbolDraw = symbolDraw
        this._lineDraw = lineDraw
        this._firstRender = true
      }

      GraphView.prototype.render = function (seriesModel, ecModel, api) {
        const _this = this

        const coordSys = seriesModel.coordinateSystem
        this._model = seriesModel
        const symbolDraw = this._symbolDraw
        const lineDraw = this._lineDraw
        const group = this.group

        if (isViewCoordSys(coordSys)) {
          const groupNewProp = {
            x: coordSys.x,
            y: coordSys.y,
            scaleX: coordSys.scaleX,
            scaleY: coordSys.scaleY
          }

          if (this._firstRender) {
            group.attr(groupNewProp)
          } else {
            updateProps(group, groupNewProp, seriesModel)
          }
        } // Fix edge contact point with node

        adjustEdge(seriesModel.getGraph(), getNodeGlobalScale(seriesModel))
        const data = seriesModel.getData()
        symbolDraw.updateData(data)
        const edgeData = seriesModel.getEdgeData() // TODO: TYPE

        lineDraw.updateData(edgeData)

        this._updateNodeAndLinkScale()

        this._updateController(seriesModel, ecModel, api)

        clearTimeout(this._layoutTimeout)
        const forceLayout = seriesModel.forceLayout
        const layoutAnimation = seriesModel.get(['force', 'layoutAnimation'])

        if (forceLayout) {
          this._startForceLayoutIteration(forceLayout, layoutAnimation)
        }

        data.graph.eachNode(function (node) {
          const idx = node.dataIndex
          const el = node.getGraphicEl()
          const itemModel = node.getModel()

          if (!el) {
            return
          } // Update draggable

          el.off('drag').off('dragend')
          const draggable = itemModel.get('draggable')

          if (draggable) {
            el.on('drag', function () {
              if (forceLayout) {
                forceLayout.warmUp()
                !_this._layouting && _this._startForceLayoutIteration(forceLayout, layoutAnimation)
                forceLayout.setFixed(idx) // Write position back to layout

                data.setItemLayout(idx, [el.x, el.y])
              }
            }).on('dragend', function () {
              if (forceLayout) {
                forceLayout.setUnfixed(idx)
              }
            })
          }

          el.setDraggable(draggable && !!forceLayout, !!itemModel.get('cursor'))
          const focus = itemModel.get(['emphasis', 'focus'])

          if (focus === 'adjacency') {
            getECData(el).focus = node.getAdjacentDataIndices()
          }
        })
        data.graph.eachEdge(function (edge) {
          const el = edge.getGraphicEl()
          const focus = edge.getModel().get(['emphasis', 'focus'])

          if (!el) {
            return
          }

          if (focus === 'adjacency') {
            getECData(el).focus = {
              edge: [edge.dataIndex],
              node: [edge.node1.dataIndex, edge.node2.dataIndex]
            }
          }
        })
        const circularRotateLabel = seriesModel.get('layout') === 'circular' && seriesModel.get(['circular', 'rotateLabel'])
        const cx = data.getLayout('cx')
        const cy = data.getLayout('cy')
        data.eachItemGraphicEl(function (el, idx) {
          const itemModel = data.getItemModel(idx)
          let labelRotate = itemModel.get(['label', 'rotate']) || 0
          const symbolPath = el.getSymbolPath()

          if (circularRotateLabel) {
            const pos = data.getItemLayout(idx)
            let rad = Math.atan2(pos[1] - cy, pos[0] - cx)

            if (rad < 0) {
              rad = Math.PI * 2 + rad
            }

            const isLeft = pos[0] < cx

            if (isLeft) {
              rad = rad - Math.PI
            }

            const textPosition = isLeft ? 'left' : 'right'
            symbolPath.setTextConfig({
              rotation: -rad,
              position: textPosition,
              origin: 'center'
            })
            const emphasisState = symbolPath.ensureState('emphasis')
            extend(emphasisState.textConfig || (emphasisState.textConfig = {}), {
              position: textPosition
            })
          } else {
            symbolPath.setTextConfig({
              rotation: labelRotate *= Math.PI / 180
            })
          }
        })
        this._firstRender = false
      }

      GraphView.prototype.dispose = function () {
        this._controller && this._controller.dispose()
        this._controllerHost = null
      }

      GraphView.prototype._startForceLayoutIteration = function (forceLayout, layoutAnimation) {
        const self = this;

        (function step () {
          forceLayout.step(function (stopped) {
            self.updateLayout(self._model);
            (self._layouting = !stopped) && (layoutAnimation ? self._layoutTimeout = setTimeout(step, 16) : step())
          })
        })()
      }

      GraphView.prototype._updateController = function (seriesModel, ecModel, api) {
        const _this = this

        const controller = this._controller
        const controllerHost = this._controllerHost
        const group = this.group
        controller.setPointerChecker(function (e, x, y) {
          const rect = group.getBoundingRect()
          rect.applyTransform(group.transform)
          return rect.contain(x, y) && !onIrrelevantElement(e, api, seriesModel)
        })

        if (!isViewCoordSys(seriesModel.coordinateSystem)) {
          controller.disable()
          return
        }

        controller.enable(seriesModel.get('roam'))
        controllerHost.zoomLimit = seriesModel.get('scaleLimit')
        controllerHost.zoom = seriesModel.coordinateSystem.getZoom()
        controller.off('pan').off('zoom').on('pan', function (e) {
          updateViewOnPan(controllerHost, e.dx, e.dy)
          api.dispatchAction({
            seriesId: seriesModel.id,
            type: 'graphRoam',
            dx: e.dx,
            dy: e.dy
          })
        }).on('zoom', function (e) {
          updateViewOnZoom(controllerHost, e.scale, e.originX, e.originY)
          api.dispatchAction({
            seriesId: seriesModel.id,
            type: 'graphRoam',
            zoom: e.scale,
            originX: e.originX,
            originY: e.originY
          })

          _this._updateNodeAndLinkScale()

          adjustEdge(seriesModel.getGraph(), getNodeGlobalScale(seriesModel))

          _this._lineDraw.updateLayout() // Only update label layout on zoom

          api.updateLabelLayout()
        })
      }

      GraphView.prototype._updateNodeAndLinkScale = function () {
        const seriesModel = this._model
        const data = seriesModel.getData()
        const nodeScale = getNodeGlobalScale(seriesModel)
        data.eachItemGraphicEl(function (el, idx) {
          el && el.setSymbolScale(nodeScale)
        })
      }

      GraphView.prototype.updateLayout = function (seriesModel) {
        adjustEdge(seriesModel.getGraph(), getNodeGlobalScale(seriesModel))

        this._symbolDraw.updateLayout()

        this._lineDraw.updateLayout()
      }

      GraphView.prototype.remove = function (ecModel, api) {
        this._symbolDraw && this._symbolDraw.remove()
        this._lineDraw && this._lineDraw.remove()
      }

      GraphView.type = 'graph'
      return GraphView
    }(ChartView))

  function generateNodeKey (id) {
    return '_EC_' + id
  }

  const Graph =
    /** @class */
    (function () {
      function Graph (directed) {
        this.type = 'graph'
        this.nodes = []
        this.edges = []
        this._nodesMap = {}
        /**
         * @type {Object.<string, module:echarts/data/Graph.Edge>}
         * @private
         */

        this._edgesMap = {}
        this._directed = directed || false
      }
      /**
       * If is directed graph
       */

      Graph.prototype.isDirected = function () {
        return this._directed
      }
      /**
       * Add a new node
       */

      Graph.prototype.addNode = function (id, dataIndex) {
        id = id == null ? '' + dataIndex : '' + id
        const nodesMap = this._nodesMap

        if (nodesMap[generateNodeKey(id)]) {
          if ('development' !== 'production') {
            console.error('Graph nodes have duplicate name or id')
          }

          return
        }

        const node = new GraphNode(id, dataIndex)
        node.hostGraph = this
        this.nodes.push(node)
        nodesMap[generateNodeKey(id)] = node
        return node
      }
      /**
       * Get node by data index
       */

      Graph.prototype.getNodeByIndex = function (dataIndex) {
        const rawIdx = this.data.getRawIndex(dataIndex)
        return this.nodes[rawIdx]
      }
      /**
       * Get node by id
       */

      Graph.prototype.getNodeById = function (id) {
        return this._nodesMap[generateNodeKey(id)]
      }
      /**
       * Add a new edge
       */

      Graph.prototype.addEdge = function (n1, n2, dataIndex) {
        const nodesMap = this._nodesMap
        const edgesMap = this._edgesMap // PNEDING

        if (isNumber(n1)) {
          n1 = this.nodes[n1]
        }

        if (isNumber(n2)) {
          n2 = this.nodes[n2]
        }

        if (!(n1 instanceof GraphNode)) {
          n1 = nodesMap[generateNodeKey(n1)]
        }

        if (!(n2 instanceof GraphNode)) {
          n2 = nodesMap[generateNodeKey(n2)]
        }

        if (!n1 || !n2) {
          return
        }

        const key = n1.id + '-' + n2.id
        const edge = new GraphEdge(n1, n2, dataIndex)
        edge.hostGraph = this

        if (this._directed) {
          n1.outEdges.push(edge)
          n2.inEdges.push(edge)
        }

        n1.edges.push(edge)

        if (n1 !== n2) {
          n2.edges.push(edge)
        }

        this.edges.push(edge)
        edgesMap[key] = edge
        return edge
      }
      /**
       * Get edge by data index
       */

      Graph.prototype.getEdgeByIndex = function (dataIndex) {
        const rawIdx = this.edgeData.getRawIndex(dataIndex)
        return this.edges[rawIdx]
      }
      /**
       * Get edge by two linked nodes
       */

      Graph.prototype.getEdge = function (n1, n2) {
        if (n1 instanceof GraphNode) {
          n1 = n1.id
        }

        if (n2 instanceof GraphNode) {
          n2 = n2.id
        }

        const edgesMap = this._edgesMap

        if (this._directed) {
          return edgesMap[n1 + '-' + n2]
        } else {
          return edgesMap[n1 + '-' + n2] || edgesMap[n2 + '-' + n1]
        }
      }
      /**
       * Iterate all nodes
       */

      Graph.prototype.eachNode = function (cb, context) {
        const nodes = this.nodes
        const len = nodes.length

        for (let i = 0; i < len; i++) {
          if (nodes[i].dataIndex >= 0) {
            cb.call(context, nodes[i], i)
          }
        }
      }
      /**
       * Iterate all edges
       */

      Graph.prototype.eachEdge = function (cb, context) {
        const edges = this.edges
        const len = edges.length

        for (let i = 0; i < len; i++) {
          if (edges[i].dataIndex >= 0 && edges[i].node1.dataIndex >= 0 && edges[i].node2.dataIndex >= 0) {
            cb.call(context, edges[i], i)
          }
        }
      }
      /**
       * Breadth first traverse
       * Return true to stop traversing
       */

      Graph.prototype.breadthFirstTraverse = function (cb, startNode, direction, context) {
        if (!(startNode instanceof GraphNode)) {
          startNode = this._nodesMap[generateNodeKey(startNode)]
        }

        if (!startNode) {
          return
        }

        const edgeType = direction === 'out' ? 'outEdges' : direction === 'in' ? 'inEdges' : 'edges'

        for (var i = 0; i < this.nodes.length; i++) {
          this.nodes[i].__visited = false
        }

        if (cb.call(context, startNode, null)) {
          return
        }

        const queue = [startNode]

        while (queue.length) {
          const currentNode = queue.shift()
          const edges = currentNode[edgeType]

          for (var i = 0; i < edges.length; i++) {
            const e = edges[i]
            const otherNode = e.node1 === currentNode ? e.node2 : e.node1

            if (!otherNode.__visited) {
              if (cb.call(context, otherNode, currentNode)) {
                // Stop traversing
                return
              }

              queue.push(otherNode)
              otherNode.__visited = true
            }
          }
        }
      }
      // depthFirstTraverse(
      //     cb, startNode, direction, context
      // ) {
      // };
      // Filter update

      Graph.prototype.update = function () {
        const data = this.data
        const edgeData = this.edgeData
        const nodes = this.nodes
        const edges = this.edges

        for (var i = 0, len = nodes.length; i < len; i++) {
          nodes[i].dataIndex = -1
        }

        for (var i = 0, len = data.count(); i < len; i++) {
          nodes[data.getRawIndex(i)].dataIndex = i
        }

        edgeData.filterSelf(function (idx) {
          const edge = edges[edgeData.getRawIndex(idx)]
          return edge.node1.dataIndex >= 0 && edge.node2.dataIndex >= 0
        }) // Update edge

        for (var i = 0, len = edges.length; i < len; i++) {
          edges[i].dataIndex = -1
        }

        for (var i = 0, len = edgeData.count(); i < len; i++) {
          edges[edgeData.getRawIndex(i)].dataIndex = i
        }
      }
      /**
       * @return {module:echarts/data/Graph}
       */

      Graph.prototype.clone = function () {
        const graph = new Graph(this._directed)
        const nodes = this.nodes
        const edges = this.edges

        for (var i = 0; i < nodes.length; i++) {
          graph.addNode(nodes[i].id, nodes[i].dataIndex)
        }

        for (var i = 0; i < edges.length; i++) {
          const e = edges[i]
          graph.addEdge(e.node1.id, e.node2.id, e.dataIndex)
        }

        return graph
      }
      return Graph
    }())

  var GraphNode =
    /** @class */
    (function () {
      function GraphNode (id, dataIndex) {
        this.inEdges = []
        this.outEdges = []
        this.edges = []
        this.dataIndex = -1
        this.id = id == null ? '' : id
        this.dataIndex = dataIndex == null ? -1 : dataIndex
      }
      /**
       * @return {number}
       */

      GraphNode.prototype.degree = function () {
        return this.edges.length
      }
      /**
       * @return {number}
       */

      GraphNode.prototype.inDegree = function () {
        return this.inEdges.length
      }
      /**
      * @return {number}
      */

      GraphNode.prototype.outDegree = function () {
        return this.outEdges.length
      }

      GraphNode.prototype.getModel = function (path) {
        if (this.dataIndex < 0) {
          return
        }

        const graph = this.hostGraph
        const itemModel = graph.data.getItemModel(this.dataIndex)
        return itemModel.getModel(path)
      }

      GraphNode.prototype.getAdjacentDataIndices = function () {
        const dataIndices = {
          edge: [],
          node: []
        }

        for (let i = 0; i < this.edges.length; i++) {
          const adjacentEdge = this.edges[i]

          if (adjacentEdge.dataIndex < 0) {
            continue
          }

          dataIndices.edge.push(adjacentEdge.dataIndex)
          dataIndices.node.push(adjacentEdge.node1.dataIndex, adjacentEdge.node2.dataIndex)
        }

        return dataIndices
      }

      return GraphNode
    }())

  var GraphEdge =
    /** @class */
    (function () {
      function GraphEdge (n1, n2, dataIndex) {
        this.dataIndex = -1
        this.node1 = n1
        this.node2 = n2
        this.dataIndex = dataIndex == null ? -1 : dataIndex
      } // eslint-disable-next-line @typescript-eslint/no-unused-vars

      GraphEdge.prototype.getModel = function (path) {
        if (this.dataIndex < 0) {
          return
        }

        const graph = this.hostGraph
        const itemModel = graph.edgeData.getItemModel(this.dataIndex)
        return itemModel.getModel(path)
      }

      GraphEdge.prototype.getAdjacentDataIndices = function () {
        return {
          edge: [this.dataIndex],
          node: [this.node1.dataIndex, this.node2.dataIndex]
        }
      }

      return GraphEdge
    }())

  function createGraphDataProxyMixin (hostName, dataName) {
    return {
      /**
         * @param Default 'value'. can be 'a', 'b', 'c', 'd', 'e'.
         */
      getValue: function (dimension) {
        const data = this[hostName][dataName]
        return data.getStore().get(data.getDimensionIndex(dimension || 'value'), this.dataIndex)
      },
      // TODO: TYPE stricter type.
      setVisual: function (key, value) {
        this.dataIndex >= 0 && this[hostName][dataName].setItemVisual(this.dataIndex, key, value)
      },
      getVisual: function (key) {
        return this[hostName][dataName].getItemVisual(this.dataIndex, key)
      },
      setLayout: function (layout, merge) {
        this.dataIndex >= 0 && this[hostName][dataName].setItemLayout(this.dataIndex, layout, merge)
      },
      getLayout: function () {
        return this[hostName][dataName].getItemLayout(this.dataIndex)
      },
      getGraphicEl: function () {
        return this[hostName][dataName].getItemGraphicEl(this.dataIndex)
      },
      getRawIndex: function () {
        return this[hostName][dataName].getRawIndex(this.dataIndex)
      }
    }
  }
  mixin(GraphNode, createGraphDataProxyMixin('hostGraph', 'data'))
  mixin(GraphEdge, createGraphDataProxyMixin('hostGraph', 'edgeData'))

  function createGraphFromNodeEdge (nodes, edges, seriesModel, directed, beforeLink) {
    // ??? TODO
    // support dataset?
    const graph = new Graph(directed)

    for (var i = 0; i < nodes.length; i++) {
      graph.addNode(retrieve( // Id, name, dataIndex
        nodes[i].id, nodes[i].name, i), i)
    }

    const linkNameList = []
    const validEdges = []
    let linkCount = 0

    for (var i = 0; i < edges.length; i++) {
      const link = edges[i]
      const source = link.source
      const target = link.target // addEdge may fail when source or target not exists

      if (graph.addEdge(source, target, linkCount)) {
        validEdges.push(link)
        linkNameList.push(retrieve(convertOptionIdName(link.id, null), source + ' > ' + target))
        linkCount++
      }
    }

    const coordSys = seriesModel.get('coordinateSystem')
    let nodeData

    if (coordSys === 'cartesian2d' || coordSys === 'polar') {
      nodeData = createSeriesData(nodes, seriesModel)
    } else {
      const coordSysCtor = CoordinateSystemManager.get(coordSys)
      const coordDimensions = coordSysCtor ? coordSysCtor.dimensions || [] : [] // FIXME: Some geo do not need `value` dimenson, whereas `calendar` needs
      // `value` dimension, but graph need `value` dimension. It's better to
      // uniform this behavior.

      if (indexOf(coordDimensions, 'value') < 0) {
        coordDimensions.concat(['value'])
      }

      const dimensions = prepareSeriesDataSchema(nodes, {
        coordDimensions: coordDimensions,
        encodeDefine: seriesModel.getEncode()
      }).dimensions
      nodeData = new SeriesData(dimensions, seriesModel)
      nodeData.initData(nodes)
    }

    const edgeData = new SeriesData(['value'], seriesModel)
    edgeData.initData(validEdges, linkNameList)
    beforeLink && beforeLink(nodeData, edgeData)
    linkSeriesData({
      mainData: nodeData,
      struct: graph,
      structAttr: 'graph',
      datas: {
        node: nodeData,
        edge: edgeData
      },
      datasAttr: {
        node: 'data',
        edge: 'edgeData'
      }
    }) // Update dataIndex of nodes and edges because invalid edge may be removed

    graph.update()
    return graph
  }

  const GraphSeriesModel =
    /** @class */
    (function (_super) {
      __extends(GraphSeriesModel, _super)

      function GraphSeriesModel () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = GraphSeriesModel.type
        _this.hasSymbolVisual = true
        return _this
      }

      GraphSeriesModel.prototype.init = function (option) {
        _super.prototype.init.apply(this, arguments)

        const self = this

        function getCategoriesData () {
          return self._categoriesData
        } // Provide data for legend select

        this.legendVisualProvider = new LegendVisualProvider(getCategoriesData, getCategoriesData)
        this.fillDataTextStyle(option.edges || option.links)

        this._updateCategoriesData()
      }

      GraphSeriesModel.prototype.mergeOption = function (option) {
        _super.prototype.mergeOption.apply(this, arguments)

        this.fillDataTextStyle(option.edges || option.links)

        this._updateCategoriesData()
      }

      GraphSeriesModel.prototype.mergeDefaultAndTheme = function (option) {
        _super.prototype.mergeDefaultAndTheme.apply(this, arguments)

        defaultEmphasis(option, 'edgeLabel', ['show'])
      }

      GraphSeriesModel.prototype.getInitialData = function (option, ecModel) {
        const edges = option.edges || option.links || []
        const nodes = option.data || option.nodes || []
        const self = this

        if (nodes && edges) {
          // auto curveness
          initCurvenessList(this)
          const graph = createGraphFromNodeEdge(nodes, edges, this, true, beforeLink)
          each(graph.edges, function (edge) {
            createEdgeMapForCurveness(edge.node1, edge.node2, this, edge.dataIndex)
          }, this)
          return graph.data
        }

        function beforeLink (nodeData, edgeData) {
          // Overwrite nodeData.getItemModel to
          nodeData.wrapMethod('getItemModel', function (model) {
            const categoriesModels = self._categoriesModels
            const categoryIdx = model.getShallow('category')
            const categoryModel = categoriesModels[categoryIdx]

            if (categoryModel) {
              categoryModel.parentModel = model.parentModel
              model.parentModel = categoryModel
            }

            return model
          }) // TODO Inherit resolveParentPath by default in Model#getModel?

          const oldGetModel = Model.prototype.getModel

          function newGetModel (path, parentModel) {
            const model = oldGetModel.call(this, path, parentModel)
            model.resolveParentPath = resolveParentPath
            return model
          }

          edgeData.wrapMethod('getItemModel', function (model) {
            model.resolveParentPath = resolveParentPath
            model.getModel = newGetModel
            return model
          })

          function resolveParentPath (pathArr) {
            if (pathArr && (pathArr[0] === 'label' || pathArr[1] === 'label')) {
              const newPathArr = pathArr.slice()

              if (pathArr[0] === 'label') {
                newPathArr[0] = 'edgeLabel'
              } else if (pathArr[1] === 'label') {
                newPathArr[1] = 'edgeLabel'
              }

              return newPathArr
            }

            return pathArr
          }
        }
      }

      GraphSeriesModel.prototype.getGraph = function () {
        return this.getData().graph
      }

      GraphSeriesModel.prototype.getEdgeData = function () {
        return this.getGraph().edgeData
      }

      GraphSeriesModel.prototype.getCategoriesData = function () {
        return this._categoriesData
      }

      GraphSeriesModel.prototype.formatTooltip = function (dataIndex, multipleSeries, dataType) {
        if (dataType === 'edge') {
          const nodeData = this.getData()
          const params = this.getDataParams(dataIndex, dataType)
          const edge = nodeData.graph.getEdgeByIndex(dataIndex)
          const sourceName = nodeData.getName(edge.node1.dataIndex)
          const targetName = nodeData.getName(edge.node2.dataIndex)
          const nameArr = []
          sourceName != null && nameArr.push(sourceName)
          targetName != null && nameArr.push(targetName)
          return createTooltipMarkup('nameValue', {
            name: nameArr.join(' > '),
            value: params.value,
            noValue: params.value == null
          })
        } // dataType === 'node' or empty

        const nodeMarkup = defaultSeriesFormatTooltip({
          series: this,
          dataIndex: dataIndex,
          multipleSeries: multipleSeries
        })
        return nodeMarkup
      }

      GraphSeriesModel.prototype._updateCategoriesData = function () {
        const categories = map(this.option.categories || [], function (category) {
          // Data must has value
          return category.value != null
            ? category
            : extend({
              value: 0
            }, category)
        })
        const categoriesData = new SeriesData(['value'], this)
        categoriesData.initData(categories)
        this._categoriesData = categoriesData
        this._categoriesModels = categoriesData.mapArray(function (idx) {
          return categoriesData.getItemModel(idx)
        })
      }

      GraphSeriesModel.prototype.setZoom = function (zoom) {
        this.option.zoom = zoom
      }

      GraphSeriesModel.prototype.setCenter = function (center) {
        this.option.center = center
      }

      GraphSeriesModel.prototype.isAnimationEnabled = function () {
        return _super.prototype.isAnimationEnabled.call(this) && // Not enable animation when do force layout
        !(this.get('layout') === 'force' && this.get(['force', 'layoutAnimation']))
      }

      GraphSeriesModel.type = 'series.graph'
      GraphSeriesModel.dependencies = ['grid', 'polar', 'geo', 'singleAxis', 'calendar']
      GraphSeriesModel.defaultOption = {
        // zlevel: 0,
        z: 2,
        coordinateSystem: 'view',
        // Default option for all coordinate systems
        // xAxisIndex: 0,
        // yAxisIndex: 0,
        // polarIndex: 0,
        // geoIndex: 0,
        legendHoverLink: true,
        layout: null,
        // Configuration of circular layout
        circular: {
          rotateLabel: false
        },
        // Configuration of force directed layout
        force: {
          initLayout: null,
          // Node repulsion. Can be an array to represent range.
          repulsion: [0, 50],
          gravity: 0.1,
          // Initial friction
          friction: 0.6,
          // Edge length. Can be an array to represent range.
          edgeLength: 30,
          layoutAnimation: true
        },
        left: 'center',
        top: 'center',
        // right: null,
        // bottom: null,
        // width: '80%',
        // height: '80%',
        symbol: 'circle',
        symbolSize: 10,
        edgeSymbol: ['none', 'none'],
        edgeSymbolSize: 10,
        edgeLabel: {
          position: 'middle',
          distance: 5
        },
        draggable: false,
        roam: false,
        // Default on center of graph
        center: null,
        zoom: 1,
        // Symbol size scale ratio in roam
        nodeScaleRatio: 0.6,
        // cursor: null,
        // categories: [],
        // data: []
        // Or
        // nodes: []
        //
        // links: []
        // Or
        // edges: []
        label: {
          show: false,
          formatter: '{b}'
        },
        itemStyle: {},
        lineStyle: {
          color: '#aaa',
          width: 1,
          opacity: 0.5
        },
        emphasis: {
          scale: true,
          label: {
            show: true
          }
        },
        select: {
          itemStyle: {
            borderColor: '#212121'
          }
        }
      }
      return GraphSeriesModel
    }(SeriesModel))

  const actionInfo = {
    type: 'graphRoam',
    event: 'graphRoam',
    update: 'none'
  }
  function install$d (registers) {
    registers.registerChartView(GraphView)
    registers.registerSeriesModel(GraphSeriesModel)
    registers.registerProcessor(categoryFilter)
    registers.registerVisual(categoryVisual)
    registers.registerVisual(graphEdgeVisual)
    registers.registerLayout(graphSimpleLayout)
    registers.registerLayout(registers.PRIORITY.VISUAL.POST_CHART_LAYOUT, graphCircularLayout)
    registers.registerLayout(graphForceLayout)
    registers.registerCoordinateSystem('graphView', {
      dimensions: View.dimensions,
      create: createViewCoordSys
    }) // Register legacy focus actions

    registers.registerAction({
      type: 'focusNodeAdjacency',
      event: 'focusNodeAdjacency',
      update: 'series:focusNodeAdjacency'
    }, noop)
    registers.registerAction({
      type: 'unfocusNodeAdjacency',
      event: 'unfocusNodeAdjacency',
      update: 'series:unfocusNodeAdjacency'
    }, noop) // Register roam action.

    registers.registerAction(actionInfo, function (payload, ecModel, api) {
      ecModel.eachComponent({
        mainType: 'series',
        query: payload
      }, function (seriesModel) {
        const coordSys = seriesModel.coordinateSystem
        const res = updateCenterAndZoom(coordSys, payload, undefined, api)
        seriesModel.setCenter && seriesModel.setCenter(res.center)
        seriesModel.setZoom && seriesModel.setZoom(res.zoom)
      })
    })
  }

  const PointerShape =
    /** @class */
    (function () {
      function PointerShape () {
        this.angle = 0
        this.width = 10
        this.r = 10
        this.x = 0
        this.y = 0
      }

      return PointerShape
    }())

  const PointerPath =
    /** @class */
    (function (_super) {
      __extends(PointerPath, _super)

      function PointerPath (opts) {
        const _this = _super.call(this, opts) || this

        _this.type = 'pointer'
        return _this
      }

      PointerPath.prototype.getDefaultShape = function () {
        return new PointerShape()
      }

      PointerPath.prototype.buildPath = function (ctx, shape) {
        const mathCos = Math.cos
        const mathSin = Math.sin
        const r = shape.r
        const width = shape.width
        let angle = shape.angle
        const x = shape.x - mathCos(angle) * width * (width >= r / 3 ? 1 : 2)
        const y = shape.y - mathSin(angle) * width * (width >= r / 3 ? 1 : 2)
        angle = shape.angle - Math.PI / 2
        ctx.moveTo(x, y)
        ctx.lineTo(shape.x + mathCos(angle) * width, shape.y + mathSin(angle) * width)
        ctx.lineTo(shape.x + mathCos(shape.angle) * r, shape.y + mathSin(shape.angle) * r)
        ctx.lineTo(shape.x - mathCos(angle) * width, shape.y - mathSin(angle) * width)
        ctx.lineTo(x, y)
      }

      return PointerPath
    }(Path))

  function parsePosition (seriesModel, api) {
    const center = seriesModel.get('center')
    const width = api.getWidth()
    const height = api.getHeight()
    const size = Math.min(width, height)
    const cx = parsePercent$1(center[0], api.getWidth())
    const cy = parsePercent$1(center[1], api.getHeight())
    const r = parsePercent$1(seriesModel.get('radius'), size / 2)
    return {
      cx: cx,
      cy: cy,
      r: r
    }
  }

  function formatLabel (value, labelFormatter) {
    let label = value == null ? '' : value + ''

    if (labelFormatter) {
      if (isString(labelFormatter)) {
        label = labelFormatter.replace('{value}', label)
      } else if (isFunction(labelFormatter)) {
        label = labelFormatter(value)
      }
    }

    return label
  }

  const GaugeView =
    /** @class */
    (function (_super) {
      __extends(GaugeView, _super)

      function GaugeView () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = GaugeView.type
        return _this
      }

      GaugeView.prototype.render = function (seriesModel, ecModel, api) {
        this.group.removeAll()
        const colorList = seriesModel.get(['axisLine', 'lineStyle', 'color'])
        const posInfo = parsePosition(seriesModel, api)

        this._renderMain(seriesModel, ecModel, api, colorList, posInfo)

        this._data = seriesModel.getData()
      }

      GaugeView.prototype.dispose = function () {}

      GaugeView.prototype._renderMain = function (seriesModel, ecModel, api, colorList, posInfo) {
        const group = this.group
        const clockwise = seriesModel.get('clockwise')
        let startAngle = -seriesModel.get('startAngle') / 180 * Math.PI
        let endAngle = -seriesModel.get('endAngle') / 180 * Math.PI
        const axisLineModel = seriesModel.getModel('axisLine')
        const roundCap = axisLineModel.get('roundCap')
        const MainPath = roundCap ? SausagePath : Sector
        const showAxis = axisLineModel.get('show')
        const lineStyleModel = axisLineModel.getModel('lineStyle')
        const axisLineWidth = lineStyleModel.get('width')
        const angles = [startAngle, endAngle]
        normalizeArcAngles(angles, !clockwise)
        startAngle = angles[0]
        endAngle = angles[1]
        const angleRangeSpan = endAngle - startAngle
        let prevEndAngle = startAngle

        for (let i = 0; showAxis && i < colorList.length; i++) {
          // Clamp
          const percent = Math.min(Math.max(colorList[i][0], 0), 1)
          endAngle = startAngle + angleRangeSpan * percent
          const sector = new MainPath({
            shape: {
              startAngle: prevEndAngle,
              endAngle: endAngle,
              cx: posInfo.cx,
              cy: posInfo.cy,
              clockwise: clockwise,
              r0: posInfo.r - axisLineWidth,
              r: posInfo.r
            },
            silent: true
          })
          sector.setStyle({
            fill: colorList[i][1]
          })
          sector.setStyle(lineStyleModel.getLineStyle( // Because we use sector to simulate arc
          // so the properties for stroking are useless
            ['color', 'width']))
          group.add(sector)
          prevEndAngle = endAngle
        }

        const getColor = function (percent) {
          // Less than 0
          if (percent <= 0) {
            return colorList[0][1]
          }

          let i

          for (i = 0; i < colorList.length; i++) {
            if (colorList[i][0] >= percent && (i === 0 ? 0 : colorList[i - 1][0]) < percent) {
              return colorList[i][1]
            }
          } // More than 1

          return colorList[i - 1][1]
        }

        this._renderTicks(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth)

        this._renderTitleAndDetail(seriesModel, ecModel, api, getColor, posInfo)

        this._renderAnchor(seriesModel, posInfo)

        this._renderPointer(seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth)
      }

      GaugeView.prototype._renderTicks = function (seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth) {
        const group = this.group
        const cx = posInfo.cx
        const cy = posInfo.cy
        const r = posInfo.r
        const minVal = +seriesModel.get('min')
        const maxVal = +seriesModel.get('max')
        const splitLineModel = seriesModel.getModel('splitLine')
        const tickModel = seriesModel.getModel('axisTick')
        const labelModel = seriesModel.getModel('axisLabel')
        const splitNumber = seriesModel.get('splitNumber')
        const subSplitNumber = tickModel.get('splitNumber')
        const splitLineLen = parsePercent$1(splitLineModel.get('length'), r)
        const tickLen = parsePercent$1(tickModel.get('length'), r)
        let angle = startAngle
        const step = (endAngle - startAngle) / splitNumber
        const subStep = step / subSplitNumber
        const splitLineStyle = splitLineModel.getModel('lineStyle').getLineStyle()
        const tickLineStyle = tickModel.getModel('lineStyle').getLineStyle()
        const splitLineDistance = splitLineModel.get('distance')
        let unitX
        let unitY

        for (let i = 0; i <= splitNumber; i++) {
          unitX = Math.cos(angle)
          unitY = Math.sin(angle) // Split line

          if (splitLineModel.get('show')) {
            var distance = splitLineDistance ? splitLineDistance + axisLineWidth : axisLineWidth
            const splitLine = new Line({
              shape: {
                x1: unitX * (r - distance) + cx,
                y1: unitY * (r - distance) + cy,
                x2: unitX * (r - splitLineLen - distance) + cx,
                y2: unitY * (r - splitLineLen - distance) + cy
              },
              style: splitLineStyle,
              silent: true
            })

            if (splitLineStyle.stroke === 'auto') {
              splitLine.setStyle({
                stroke: getColor(i / splitNumber)
              })
            }

            group.add(splitLine)
          } // Label

          if (labelModel.get('show')) {
            var distance = labelModel.get('distance') + splitLineDistance
            const label = formatLabel(round(i / splitNumber * (maxVal - minVal) + minVal), labelModel.get('formatter'))
            const autoColor = getColor(i / splitNumber)
            group.add(new ZRText({
              style: createTextStyle(labelModel, {
                text: label,
                x: unitX * (r - splitLineLen - distance) + cx,
                y: unitY * (r - splitLineLen - distance) + cy,
                verticalAlign: unitY < -0.8 ? 'top' : unitY > 0.8 ? 'bottom' : 'middle',
                align: unitX < -0.4 ? 'left' : unitX > 0.4 ? 'right' : 'center'
              }, {
                inheritColor: autoColor
              }),
              silent: true
            }))
          } // Axis tick

          if (tickModel.get('show') && i !== splitNumber) {
            var distance = tickModel.get('distance')
            distance = distance ? distance + axisLineWidth : axisLineWidth

            for (let j = 0; j <= subSplitNumber; j++) {
              unitX = Math.cos(angle)
              unitY = Math.sin(angle)
              const tickLine = new Line({
                shape: {
                  x1: unitX * (r - distance) + cx,
                  y1: unitY * (r - distance) + cy,
                  x2: unitX * (r - tickLen - distance) + cx,
                  y2: unitY * (r - tickLen - distance) + cy
                },
                silent: true,
                style: tickLineStyle
              })

              if (tickLineStyle.stroke === 'auto') {
                tickLine.setStyle({
                  stroke: getColor((i + j / subSplitNumber) / splitNumber)
                })
              }

              group.add(tickLine)
              angle += subStep
            }

            angle -= subStep
          } else {
            angle += step
          }
        }
      }

      GaugeView.prototype._renderPointer = function (seriesModel, ecModel, api, getColor, posInfo, startAngle, endAngle, clockwise, axisLineWidth) {
        const group = this.group
        const oldData = this._data
        const oldProgressData = this._progressEls
        const progressList = []
        const showPointer = seriesModel.get(['pointer', 'show'])
        const progressModel = seriesModel.getModel('progress')
        const showProgress = progressModel.get('show')
        const data = seriesModel.getData()
        const valueDim = data.mapDimension('value')
        const minVal = +seriesModel.get('min')
        const maxVal = +seriesModel.get('max')
        const valueExtent = [minVal, maxVal]
        const angleExtent = [startAngle, endAngle]

        function createPointer (idx, angle) {
          const itemModel = data.getItemModel(idx)
          const pointerModel = itemModel.getModel('pointer')
          const pointerWidth = parsePercent$1(pointerModel.get('width'), posInfo.r)
          const pointerLength = parsePercent$1(pointerModel.get('length'), posInfo.r)
          const pointerStr = seriesModel.get(['pointer', 'icon'])
          const pointerOffset = pointerModel.get('offsetCenter')
          const pointerOffsetX = parsePercent$1(pointerOffset[0], posInfo.r)
          const pointerOffsetY = parsePercent$1(pointerOffset[1], posInfo.r)
          const pointerKeepAspect = pointerModel.get('keepAspect')
          let pointer // not exist icon type will be set 'rect'

          if (pointerStr) {
            pointer = createSymbol(pointerStr, pointerOffsetX - pointerWidth / 2, pointerOffsetY - pointerLength, pointerWidth, pointerLength, null, pointerKeepAspect)
          } else {
            pointer = new PointerPath({
              shape: {
                angle: -Math.PI / 2,
                width: pointerWidth,
                r: pointerLength,
                x: pointerOffsetX,
                y: pointerOffsetY
              }
            })
          }

          pointer.rotation = -(angle + Math.PI / 2)
          pointer.x = posInfo.cx
          pointer.y = posInfo.cy
          return pointer
        }

        function createProgress (idx, endAngle) {
          const roundCap = progressModel.get('roundCap')
          const ProgressPath = roundCap ? SausagePath : Sector
          const isOverlap = progressModel.get('overlap')
          const progressWidth = isOverlap ? progressModel.get('width') : axisLineWidth / data.count()
          const r0 = isOverlap ? posInfo.r - progressWidth : posInfo.r - (idx + 1) * progressWidth
          const r = isOverlap ? posInfo.r : posInfo.r - idx * progressWidth
          const progress = new ProgressPath({
            shape: {
              startAngle: startAngle,
              endAngle: endAngle,
              cx: posInfo.cx,
              cy: posInfo.cy,
              clockwise: clockwise,
              r0: r0,
              r: r
            }
          })
          isOverlap && (progress.z2 = maxVal - data.get(valueDim, idx) % maxVal)
          return progress
        }

        if (showProgress || showPointer) {
          data.diff(oldData).add(function (idx) {
            const val = data.get(valueDim, idx)

            if (showPointer) {
              const pointer = createPointer(idx, startAngle) // TODO hide pointer on NaN value?

              initProps(pointer, {
                rotation: -((isNaN(+val) ? angleExtent[0] : linearMap(val, valueExtent, angleExtent, true)) + Math.PI / 2)
              }, seriesModel)
              group.add(pointer)
              data.setItemGraphicEl(idx, pointer)
            }

            if (showProgress) {
              const progress = createProgress(idx, startAngle)
              const isClip = progressModel.get('clip')
              initProps(progress, {
                shape: {
                  endAngle: linearMap(val, valueExtent, angleExtent, isClip)
                }
              }, seriesModel)
              group.add(progress) // Add data index and series index for indexing the data by element
              // Useful in tooltip

              setCommonECData(seriesModel.seriesIndex, data.dataType, idx, progress)
              progressList[idx] = progress
            }
          }).update(function (newIdx, oldIdx) {
            const val = data.get(valueDim, newIdx)

            if (showPointer) {
              const previousPointer = oldData.getItemGraphicEl(oldIdx)
              const previousRotate = previousPointer ? previousPointer.rotation : startAngle
              const pointer = createPointer(newIdx, previousRotate)
              pointer.rotation = previousRotate
              updateProps(pointer, {
                rotation: -((isNaN(+val) ? angleExtent[0] : linearMap(val, valueExtent, angleExtent, true)) + Math.PI / 2)
              }, seriesModel)
              group.add(pointer)
              data.setItemGraphicEl(newIdx, pointer)
            }

            if (showProgress) {
              const previousProgress = oldProgressData[oldIdx]
              const previousEndAngle = previousProgress ? previousProgress.shape.endAngle : startAngle
              const progress = createProgress(newIdx, previousEndAngle)
              const isClip = progressModel.get('clip')
              updateProps(progress, {
                shape: {
                  endAngle: linearMap(val, valueExtent, angleExtent, isClip)
                }
              }, seriesModel)
              group.add(progress) // Add data index and series index for indexing the data by element
              // Useful in tooltip

              setCommonECData(seriesModel.seriesIndex, data.dataType, newIdx, progress)
              progressList[newIdx] = progress
            }
          }).execute()
          data.each(function (idx) {
            const itemModel = data.getItemModel(idx)
            const emphasisModel = itemModel.getModel('emphasis')
            const focus = emphasisModel.get('focus')
            const blurScope = emphasisModel.get('blurScope')
            const emphasisDisabled = emphasisModel.get('disabled')

            if (showPointer) {
              const pointer = data.getItemGraphicEl(idx)
              const symbolStyle = data.getItemVisual(idx, 'style')
              const visualColor = symbolStyle.fill

              if (pointer instanceof ZRImage) {
                const pathStyle = pointer.style
                pointer.useStyle(extend({
                  image: pathStyle.image,
                  x: pathStyle.x,
                  y: pathStyle.y,
                  width: pathStyle.width,
                  height: pathStyle.height
                }, symbolStyle))
              } else {
                pointer.useStyle(symbolStyle)
                pointer.type !== 'pointer' && pointer.setColor(visualColor)
              }

              pointer.setStyle(itemModel.getModel(['pointer', 'itemStyle']).getItemStyle())

              if (pointer.style.fill === 'auto') {
                pointer.setStyle('fill', getColor(linearMap(data.get(valueDim, idx), valueExtent, [0, 1], true)))
              }

              pointer.z2EmphasisLift = 0
              setStatesStylesFromModel(pointer, itemModel)
              toggleHoverEmphasis(pointer, focus, blurScope, emphasisDisabled)
            }

            if (showProgress) {
              const progress = progressList[idx]
              progress.useStyle(data.getItemVisual(idx, 'style'))
              progress.setStyle(itemModel.getModel(['progress', 'itemStyle']).getItemStyle())
              progress.z2EmphasisLift = 0
              setStatesStylesFromModel(progress, itemModel)
              toggleHoverEmphasis(progress, focus, blurScope, emphasisDisabled)
            }
          })
          this._progressEls = progressList
        }
      }

      GaugeView.prototype._renderAnchor = function (seriesModel, posInfo) {
        const anchorModel = seriesModel.getModel('anchor')
        const showAnchor = anchorModel.get('show')

        if (showAnchor) {
          const anchorSize = anchorModel.get('size')
          const anchorType = anchorModel.get('icon')
          const offsetCenter = anchorModel.get('offsetCenter')
          const anchorKeepAspect = anchorModel.get('keepAspect')
          const anchor = createSymbol(anchorType, posInfo.cx - anchorSize / 2 + parsePercent$1(offsetCenter[0], posInfo.r), posInfo.cy - anchorSize / 2 + parsePercent$1(offsetCenter[1], posInfo.r), anchorSize, anchorSize, null, anchorKeepAspect)
          anchor.z2 = anchorModel.get('showAbove') ? 1 : 0
          anchor.setStyle(anchorModel.getModel('itemStyle').getItemStyle())
          this.group.add(anchor)
        }
      }

      GaugeView.prototype._renderTitleAndDetail = function (seriesModel, ecModel, api, getColor, posInfo) {
        const _this = this

        const data = seriesModel.getData()
        const valueDim = data.mapDimension('value')
        const minVal = +seriesModel.get('min')
        const maxVal = +seriesModel.get('max')
        const contentGroup = new Group()
        const newTitleEls = []
        const newDetailEls = []
        const hasAnimation = seriesModel.isAnimationEnabled()
        const showPointerAbove = seriesModel.get(['pointer', 'showAbove'])
        data.diff(this._data).add(function (idx) {
          newTitleEls[idx] = new ZRText({
            silent: true
          })
          newDetailEls[idx] = new ZRText({
            silent: true
          })
        }).update(function (idx, oldIdx) {
          newTitleEls[idx] = _this._titleEls[oldIdx]
          newDetailEls[idx] = _this._detailEls[oldIdx]
        }).execute()
        data.each(function (idx) {
          const itemModel = data.getItemModel(idx)
          const value = data.get(valueDim, idx)
          const itemGroup = new Group()
          const autoColor = getColor(linearMap(value, [minVal, maxVal], [0, 1], true))
          const itemTitleModel = itemModel.getModel('title')

          if (itemTitleModel.get('show')) {
            const titleOffsetCenter = itemTitleModel.get('offsetCenter')
            const titleX = posInfo.cx + parsePercent$1(titleOffsetCenter[0], posInfo.r)
            const titleY = posInfo.cy + parsePercent$1(titleOffsetCenter[1], posInfo.r)
            var labelEl = newTitleEls[idx]
            labelEl.attr({
              z2: showPointerAbove ? 0 : 2,
              style: createTextStyle(itemTitleModel, {
                x: titleX,
                y: titleY,
                text: data.getName(idx),
                align: 'center',
                verticalAlign: 'middle'
              }, {
                inheritColor: autoColor
              })
            })
            itemGroup.add(labelEl)
          }

          const itemDetailModel = itemModel.getModel('detail')

          if (itemDetailModel.get('show')) {
            const detailOffsetCenter = itemDetailModel.get('offsetCenter')
            const detailX = posInfo.cx + parsePercent$1(detailOffsetCenter[0], posInfo.r)
            const detailY = posInfo.cy + parsePercent$1(detailOffsetCenter[1], posInfo.r)
            const width = parsePercent$1(itemDetailModel.get('width'), posInfo.r)
            const height = parsePercent$1(itemDetailModel.get('height'), posInfo.r)
            const detailColor = seriesModel.get(['progress', 'show']) ? data.getItemVisual(idx, 'style').fill : autoColor
            var labelEl = newDetailEls[idx]
            const formatter_1 = itemDetailModel.get('formatter')
            labelEl.attr({
              z2: showPointerAbove ? 0 : 2,
              style: createTextStyle(itemDetailModel, {
                x: detailX,
                y: detailY,
                text: formatLabel(value, formatter_1),
                width: isNaN(width) ? null : width,
                height: isNaN(height) ? null : height,
                align: 'center',
                verticalAlign: 'middle'
              }, {
                inheritColor: detailColor
              })
            })
            setLabelValueAnimation(labelEl, {
              normal: itemDetailModel
            }, value, function (value) {
              return formatLabel(value, formatter_1)
            })
            hasAnimation && animateLabelValue(labelEl, idx, data, seriesModel, {
              getFormattedLabel: function (labelDataIndex, status, dataType, labelDimIndex, fmt, extendParams) {
                return formatLabel(extendParams ? extendParams.interpolatedValue : value, formatter_1)
              }
            })
            itemGroup.add(labelEl)
          }

          contentGroup.add(itemGroup)
        })
        this.group.add(contentGroup)
        this._titleEls = newTitleEls
        this._detailEls = newDetailEls
      }

      GaugeView.type = 'gauge'
      return GaugeView
    }(ChartView))

  const GaugeSeriesModel =
    /** @class */
    (function (_super) {
      __extends(GaugeSeriesModel, _super)

      function GaugeSeriesModel () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = GaugeSeriesModel.type
        _this.visualStyleAccessPath = 'itemStyle'
        return _this
      }

      GaugeSeriesModel.prototype.getInitialData = function (option, ecModel) {
        return createSeriesDataSimply(this, ['value'])
      }

      GaugeSeriesModel.type = 'series.gauge'
      GaugeSeriesModel.defaultOption = {
        // zlevel: 0,
        z: 2,
        colorBy: 'data',
        // 默认全局居中
        center: ['50%', '50%'],
        legendHoverLink: true,
        radius: '75%',
        startAngle: 225,
        endAngle: -45,
        clockwise: true,
        // 最小值
        min: 0,
        // 最大值
        max: 100,
        // 分割段数，默认为10
        splitNumber: 10,
        // 坐标轴线
        axisLine: {
          // 默认显示，属性show控制显示与否
          show: true,
          roundCap: false,
          lineStyle: {
            color: [[1, '#E6EBF8']],
            width: 10
          }
        },
        // 坐标轴线
        progress: {
          // 默认显示，属性show控制显示与否
          show: false,
          overlap: true,
          width: 10,
          roundCap: false,
          clip: true
        },
        // 分隔线
        splitLine: {
          // 默认显示，属性show控制显示与否
          show: true,
          // 属性length控制线长
          length: 10,
          distance: 10,
          // 属性lineStyle（详见lineStyle）控制线条样式
          lineStyle: {
            color: '#63677A',
            width: 3,
            type: 'solid'
          }
        },
        // 坐标轴小标记
        axisTick: {
          // 属性show控制显示与否，默认不显示
          show: true,
          // 每份split细分多少段
          splitNumber: 5,
          // 属性length控制线长
          length: 6,
          distance: 10,
          // 属性lineStyle控制线条样式
          lineStyle: {
            color: '#63677A',
            width: 1,
            type: 'solid'
          }
        },
        axisLabel: {
          show: true,
          distance: 15,
          // formatter: null,
          color: '#464646',
          fontSize: 12
        },
        pointer: {
          icon: null,
          offsetCenter: [0, 0],
          show: true,
          showAbove: true,
          length: '60%',
          width: 6,
          keepAspect: false
        },
        anchor: {
          show: false,
          showAbove: false,
          size: 6,
          icon: 'circle',
          offsetCenter: [0, 0],
          keepAspect: false,
          itemStyle: {
            color: '#fff',
            borderWidth: 0,
            borderColor: '#5470c6'
          }
        },
        title: {
          show: true,
          // x, y，单位px
          offsetCenter: [0, '20%'],
          // 其余属性默认使用全局文本样式，详见TEXTSTYLE
          color: '#464646',
          fontSize: 16,
          valueAnimation: false
        },
        detail: {
          show: true,
          backgroundColor: 'rgba(0,0,0,0)',
          borderWidth: 0,
          borderColor: '#ccc',
          width: 100,
          height: null,
          padding: [5, 10],
          // x, y，单位px
          offsetCenter: [0, '40%'],
          // formatter: null,
          // 其余属性默认使用全局文本样式，详见TEXTSTYLE
          color: '#464646',
          fontSize: 30,
          fontWeight: 'bold',
          lineHeight: 30,
          valueAnimation: false
        }
      }
      return GaugeSeriesModel
    }(SeriesModel))

  function install$e (registers) {
    registers.registerChartView(GaugeView)
    registers.registerSeriesModel(GaugeSeriesModel)
  }

  const opacityAccessPath = ['itemStyle', 'opacity']
  /**
     * Piece of pie including Sector, Label, LabelLine
     */

  const FunnelPiece =
    /** @class */
    (function (_super) {
      __extends(FunnelPiece, _super)

      function FunnelPiece (data, idx) {
        const _this = _super.call(this) || this

        const polygon = _this
        const labelLine = new Polyline()
        const text = new ZRText()
        polygon.setTextContent(text)

        _this.setTextGuideLine(labelLine)

        _this.updateData(data, idx, true)

        return _this
      }

      FunnelPiece.prototype.updateData = function (data, idx, firstCreate) {
        const polygon = this
        const seriesModel = data.hostModel
        const itemModel = data.getItemModel(idx)
        const layout = data.getItemLayout(idx)
        const emphasisModel = itemModel.getModel('emphasis')
        let opacity = itemModel.get(opacityAccessPath)
        opacity = opacity == null ? 1 : opacity

        if (!firstCreate) {
          saveOldStyle(polygon)
        } // Update common style

        polygon.useStyle(data.getItemVisual(idx, 'style'))
        polygon.style.lineJoin = 'round'

        if (firstCreate) {
          polygon.setShape({
            points: layout.points
          })
          polygon.style.opacity = 0
          initProps(polygon, {
            style: {
              opacity: opacity
            }
          }, seriesModel, idx)
        } else {
          updateProps(polygon, {
            style: {
              opacity: opacity
            },
            shape: {
              points: layout.points
            }
          }, seriesModel, idx)
        }

        setStatesStylesFromModel(polygon, itemModel)

        this._updateLabel(data, idx)

        toggleHoverEmphasis(this, emphasisModel.get('focus'), emphasisModel.get('blurScope'), emphasisModel.get('disabled'))
      }

      FunnelPiece.prototype._updateLabel = function (data, idx) {
        const polygon = this
        const labelLine = this.getTextGuideLine()
        const labelText = polygon.getTextContent()
        const seriesModel = data.hostModel
        const itemModel = data.getItemModel(idx)
        const layout = data.getItemLayout(idx)
        const labelLayout = layout.label
        const style = data.getItemVisual(idx, 'style')
        const visualColor = style.fill
        setLabelStyle( // position will not be used in setLabelStyle
          labelText, getLabelStatesModels(itemModel), {
            labelFetcher: data.hostModel,
            labelDataIndex: idx,
            defaultOpacity: style.opacity,
            defaultText: data.getName(idx)
          }, {
            normal: {
              align: labelLayout.textAlign,
              verticalAlign: labelLayout.verticalAlign
            }
          })
        polygon.setTextConfig({
          local: true,
          inside: !!labelLayout.inside,
          insideStroke: visualColor,
          // insideFill: 'auto',
          outsideFill: visualColor
        })
        const linePoints = labelLayout.linePoints
        labelLine.setShape({
          points: linePoints
        })
        polygon.textGuideLineConfig = {
          anchor: linePoints ? new Point(linePoints[0][0], linePoints[0][1]) : null
        } // Make sure update style on labelText after setLabelStyle.
        // Because setLabelStyle will replace a new style on it.

        updateProps(labelText, {
          style: {
            x: labelLayout.x,
            y: labelLayout.y
          }
        }, seriesModel, idx)
        labelText.attr({
          rotation: labelLayout.rotation,
          originX: labelLayout.x,
          originY: labelLayout.y,
          z2: 10
        })
        setLabelLineStyle(polygon, getLabelLineStatesModels(itemModel), {
          // Default use item visual color
          stroke: visualColor
        })
      }

      return FunnelPiece
    }(Polygon))

  const FunnelView =
    /** @class */
    (function (_super) {
      __extends(FunnelView, _super)

      function FunnelView () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = FunnelView.type
        _this.ignoreLabelLineUpdate = true
        return _this
      }

      FunnelView.prototype.render = function (seriesModel, ecModel, api) {
        const data = seriesModel.getData()
        const oldData = this._data
        const group = this.group
        data.diff(oldData).add(function (idx) {
          const funnelPiece = new FunnelPiece(data, idx)
          data.setItemGraphicEl(idx, funnelPiece)
          group.add(funnelPiece)
        }).update(function (newIdx, oldIdx) {
          const piece = oldData.getItemGraphicEl(oldIdx)
          piece.updateData(data, newIdx)
          group.add(piece)
          data.setItemGraphicEl(newIdx, piece)
        }).remove(function (idx) {
          const piece = oldData.getItemGraphicEl(idx)
          removeElementWithFadeOut(piece, seriesModel, idx)
        }).execute()
        this._data = data
      }

      FunnelView.prototype.remove = function () {
        this.group.removeAll()
        this._data = null
      }

      FunnelView.prototype.dispose = function () {}

      FunnelView.type = 'funnel'
      return FunnelView
    }(ChartView))

  const FunnelSeriesModel =
    /** @class */
    (function (_super) {
      __extends(FunnelSeriesModel, _super)

      function FunnelSeriesModel () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = FunnelSeriesModel.type
        return _this
      }

      FunnelSeriesModel.prototype.init = function (option) {
        _super.prototype.init.apply(this, arguments) // Enable legend selection for each data item
        // Use a function instead of direct access because data reference may changed

        this.legendVisualProvider = new LegendVisualProvider(bind(this.getData, this), bind(this.getRawData, this)) // Extend labelLine emphasis

        this._defaultLabelLine(option)
      }

      FunnelSeriesModel.prototype.getInitialData = function (option, ecModel) {
        return createSeriesDataSimply(this, {
          coordDimensions: ['value'],
          encodeDefaulter: curry(makeSeriesEncodeForNameBased, this)
        })
      }

      FunnelSeriesModel.prototype._defaultLabelLine = function (option) {
        // Extend labelLine emphasis
        defaultEmphasis(option, 'labelLine', ['show'])
        const labelLineNormalOpt = option.labelLine
        const labelLineEmphasisOpt = option.emphasis.labelLine // Not show label line if `label.normal.show = false`

        labelLineNormalOpt.show = labelLineNormalOpt.show && option.label.show
        labelLineEmphasisOpt.show = labelLineEmphasisOpt.show && option.emphasis.label.show
      } // Overwrite

      FunnelSeriesModel.prototype.getDataParams = function (dataIndex) {
        const data = this.getData()

        const params = _super.prototype.getDataParams.call(this, dataIndex)

        const valueDim = data.mapDimension('value')
        const sum = data.getSum(valueDim) // Percent is 0 if sum is 0

        params.percent = !sum ? 0 : +(data.get(valueDim, dataIndex) / sum * 100).toFixed(2)
        params.$vars.push('percent')
        return params
      }

      FunnelSeriesModel.type = 'series.funnel'
      FunnelSeriesModel.defaultOption = {
        // zlevel: 0,                  // 一级层叠
        z: 2,
        legendHoverLink: true,
        colorBy: 'data',
        left: 80,
        top: 60,
        right: 80,
        bottom: 60,
        // width: {totalWidth} - left - right,
        // height: {totalHeight} - top - bottom,
        // 默认取数据最小最大值
        // min: 0,
        // max: 100,
        minSize: '0%',
        maxSize: '100%',
        sort: 'descending',
        orient: 'vertical',
        gap: 0,
        funnelAlign: 'center',
        label: {
          show: true,
          position: 'outer' // formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调

        },
        labelLine: {
          show: true,
          length: 20,
          lineStyle: {
            // color: 各异,
            width: 1
          }
        },
        itemStyle: {
          // color: 各异,
          borderColor: '#fff',
          borderWidth: 1
        },
        emphasis: {
          label: {
            show: true
          }
        },
        select: {
          itemStyle: {
            borderColor: '#212121'
          }
        }
      }
      return FunnelSeriesModel
    }(SeriesModel))

  function getViewRect$3 (seriesModel, api) {
    return getLayoutRect(seriesModel.getBoxLayoutParams(), {
      width: api.getWidth(),
      height: api.getHeight()
    })
  }

  function getSortedIndices (data, sort) {
    const valueDim = data.mapDimension('value')
    const valueArr = data.mapArray(valueDim, function (val) {
      return val
    })
    const indices = []
    const isAscending = sort === 'ascending'

    for (let i = 0, len = data.count(); i < len; i++) {
      indices[i] = i
    } // Add custom sortable function & none sortable opetion by "options.sort"

    if (isFunction(sort)) {
      indices.sort(sort)
    } else if (sort !== 'none') {
      indices.sort(function (a, b) {
        return isAscending ? valueArr[a] - valueArr[b] : valueArr[b] - valueArr[a]
      })
    }

    return indices
  }

  function labelLayout (data) {
    const seriesModel = data.hostModel
    const orient = seriesModel.get('orient')
    data.each(function (idx) {
      const itemModel = data.getItemModel(idx)
      const labelModel = itemModel.getModel('label')
      let labelPosition = labelModel.get('position')
      const labelLineModel = itemModel.getModel('labelLine')
      const layout = data.getItemLayout(idx)
      const points = layout.points
      const isLabelInside = labelPosition === 'inner' || labelPosition === 'inside' || labelPosition === 'center' || labelPosition === 'insideLeft' || labelPosition === 'insideRight'
      let textAlign
      let textX
      let textY
      let linePoints

      if (isLabelInside) {
        if (labelPosition === 'insideLeft') {
          textX = (points[0][0] + points[3][0]) / 2 + 5
          textY = (points[0][1] + points[3][1]) / 2
          textAlign = 'left'
        } else if (labelPosition === 'insideRight') {
          textX = (points[1][0] + points[2][0]) / 2 - 5
          textY = (points[1][1] + points[2][1]) / 2
          textAlign = 'right'
        } else {
          textX = (points[0][0] + points[1][0] + points[2][0] + points[3][0]) / 4
          textY = (points[0][1] + points[1][1] + points[2][1] + points[3][1]) / 4
          textAlign = 'center'
        }

        linePoints = [[textX, textY], [textX, textY]]
      } else {
        let x1 = void 0
        let y1 = void 0
        let x2 = void 0
        let y2 = void 0
        const labelLineLen = labelLineModel.get('length')

        if ('development' !== 'production') {
          if (orient === 'vertical' && ['top', 'bottom'].indexOf(labelPosition) > -1) {
            labelPosition = 'left'
            console.warn('Position error: Funnel chart on vertical orient dose not support top and bottom.')
          }

          if (orient === 'horizontal' && ['left', 'right'].indexOf(labelPosition) > -1) {
            labelPosition = 'bottom'
            console.warn('Position error: Funnel chart on horizontal orient dose not support left and right.')
          }
        }

        if (labelPosition === 'left') {
          // Left side
          x1 = (points[3][0] + points[0][0]) / 2
          y1 = (points[3][1] + points[0][1]) / 2
          x2 = x1 - labelLineLen
          textX = x2 - 5
          textAlign = 'right'
        } else if (labelPosition === 'right') {
          // Right side
          x1 = (points[1][0] + points[2][0]) / 2
          y1 = (points[1][1] + points[2][1]) / 2
          x2 = x1 + labelLineLen
          textX = x2 + 5
          textAlign = 'left'
        } else if (labelPosition === 'top') {
          // Top side
          x1 = (points[3][0] + points[0][0]) / 2
          y1 = (points[3][1] + points[0][1]) / 2
          y2 = y1 - labelLineLen
          textY = y2 - 5
          textAlign = 'center'
        } else if (labelPosition === 'bottom') {
          // Bottom side
          x1 = (points[1][0] + points[2][0]) / 2
          y1 = (points[1][1] + points[2][1]) / 2
          y2 = y1 + labelLineLen
          textY = y2 + 5
          textAlign = 'center'
        } else if (labelPosition === 'rightTop') {
          // RightTop side
          x1 = orient === 'horizontal' ? points[3][0] : points[1][0]
          y1 = orient === 'horizontal' ? points[3][1] : points[1][1]

          if (orient === 'horizontal') {
            y2 = y1 - labelLineLen
            textY = y2 - 5
            textAlign = 'center'
          } else {
            x2 = x1 + labelLineLen
            textX = x2 + 5
            textAlign = 'top'
          }
        } else if (labelPosition === 'rightBottom') {
          // RightBottom side
          x1 = points[2][0]
          y1 = points[2][1]

          if (orient === 'horizontal') {
            y2 = y1 + labelLineLen
            textY = y2 + 5
            textAlign = 'center'
          } else {
            x2 = x1 + labelLineLen
            textX = x2 + 5
            textAlign = 'bottom'
          }
        } else if (labelPosition === 'leftTop') {
          // LeftTop side
          x1 = points[0][0]
          y1 = orient === 'horizontal' ? points[0][1] : points[1][1]

          if (orient === 'horizontal') {
            y2 = y1 - labelLineLen
            textY = y2 - 5
            textAlign = 'center'
          } else {
            x2 = x1 - labelLineLen
            textX = x2 - 5
            textAlign = 'right'
          }
        } else if (labelPosition === 'leftBottom') {
          // LeftBottom side
          x1 = orient === 'horizontal' ? points[1][0] : points[3][0]
          y1 = orient === 'horizontal' ? points[1][1] : points[2][1]

          if (orient === 'horizontal') {
            y2 = y1 + labelLineLen
            textY = y2 + 5
            textAlign = 'center'
          } else {
            x2 = x1 - labelLineLen
            textX = x2 - 5
            textAlign = 'right'
          }
        } else {
          // Right side or Bottom side
          x1 = (points[1][0] + points[2][0]) / 2
          y1 = (points[1][1] + points[2][1]) / 2

          if (orient === 'horizontal') {
            y2 = y1 + labelLineLen
            textY = y2 + 5
            textAlign = 'center'
          } else {
            x2 = x1 + labelLineLen
            textX = x2 + 5
            textAlign = 'left'
          }
        }

        if (orient === 'horizontal') {
          x2 = x1
          textX = x2
        } else {
          y2 = y1
          textY = y2
        }

        linePoints = [[x1, y1], [x2, y2]]
      }

      layout.label = {
        linePoints: linePoints,
        x: textX,
        y: textY,
        verticalAlign: 'middle',
        textAlign: textAlign,
        inside: isLabelInside
      }
    })
  }

  function funnelLayout (ecModel, api) {
    ecModel.eachSeriesByType('funnel', function (seriesModel) {
      const data = seriesModel.getData()
      const valueDim = data.mapDimension('value')
      const sort = seriesModel.get('sort')
      const viewRect = getViewRect$3(seriesModel, api)
      const orient = seriesModel.get('orient')
      const viewWidth = viewRect.width
      const viewHeight = viewRect.height
      let indices = getSortedIndices(data, sort)
      let x = viewRect.x
      let y = viewRect.y
      const sizeExtent = orient === 'horizontal' ? [parsePercent$1(seriesModel.get('minSize'), viewHeight), parsePercent$1(seriesModel.get('maxSize'), viewHeight)] : [parsePercent$1(seriesModel.get('minSize'), viewWidth), parsePercent$1(seriesModel.get('maxSize'), viewWidth)]
      const dataExtent = data.getDataExtent(valueDim)
      let min = seriesModel.get('min')
      let max = seriesModel.get('max')

      if (min == null) {
        min = Math.min(dataExtent[0], 0)
      }

      if (max == null) {
        max = dataExtent[1]
      }

      const funnelAlign = seriesModel.get('funnelAlign')
      let gap = seriesModel.get('gap')
      const viewSize = orient === 'horizontal' ? viewWidth : viewHeight
      let itemSize = (viewSize - gap * (data.count() - 1)) / data.count()

      const getLinePoints = function (idx, offset) {
        // End point index is data.count() and we assign it 0
        if (orient === 'horizontal') {
          const val_1 = data.get(valueDim, idx) || 0
          const itemHeight = linearMap(val_1, [min, max], sizeExtent, true)
          let y0 = void 0

          switch (funnelAlign) {
            case 'top':
              y0 = y
              break

            case 'center':
              y0 = y + (viewHeight - itemHeight) / 2
              break

            case 'bottom':
              y0 = y + (viewHeight - itemHeight)
              break
          }

          return [[offset, y0], [offset, y0 + itemHeight]]
        }

        const val = data.get(valueDim, idx) || 0
        const itemWidth = linearMap(val, [min, max], sizeExtent, true)
        let x0

        switch (funnelAlign) {
          case 'left':
            x0 = x
            break

          case 'center':
            x0 = x + (viewWidth - itemWidth) / 2
            break

          case 'right':
            x0 = x + viewWidth - itemWidth
            break
        }

        return [[x0, offset], [x0 + itemWidth, offset]]
      }

      if (sort === 'ascending') {
        // From bottom to top
        itemSize = -itemSize
        gap = -gap

        if (orient === 'horizontal') {
          x += viewWidth
        } else {
          y += viewHeight
        }

        indices = indices.reverse()
      }

      for (let i = 0; i < indices.length; i++) {
        const idx = indices[i]
        const nextIdx = indices[i + 1]
        const itemModel = data.getItemModel(idx)

        if (orient === 'horizontal') {
          let width = itemModel.get(['itemStyle', 'width'])

          if (width == null) {
            width = itemSize
          } else {
            width = parsePercent$1(width, viewWidth)

            if (sort === 'ascending') {
              width = -width
            }
          }

          var start = getLinePoints(idx, x)
          var end = getLinePoints(nextIdx, x + width)
          x += width + gap
          data.setItemLayout(idx, {
            points: start.concat(end.slice().reverse())
          })
        } else {
          let height = itemModel.get(['itemStyle', 'height'])

          if (height == null) {
            height = itemSize
          } else {
            height = parsePercent$1(height, viewHeight)

            if (sort === 'ascending') {
              height = -height
            }
          }

          var start = getLinePoints(idx, y)
          var end = getLinePoints(nextIdx, y + height)
          y += height + gap
          data.setItemLayout(idx, {
            points: start.concat(end.slice().reverse())
          })
        }
      }

      labelLayout(data)
    })
  }

  function install$f (registers) {
    registers.registerChartView(FunnelView)
    registers.registerSeriesModel(FunnelSeriesModel)
    registers.registerLayout(funnelLayout)
    registers.registerProcessor(dataFilter('funnel'))
  }

  const DEFAULT_SMOOTH = 0.3

  const ParallelView =
    /** @class */
    (function (_super) {
      __extends(ParallelView, _super)

      function ParallelView () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = ParallelView.type
        _this._dataGroup = new Group()
        _this._initialized = false
        return _this
      }

      ParallelView.prototype.init = function () {
        this.group.add(this._dataGroup)
      }
      /**
       * @override
       */

      ParallelView.prototype.render = function (seriesModel, ecModel, api, payload) {
        // Clear previously rendered progressive elements.
        this._progressiveEls = null
        const dataGroup = this._dataGroup
        const data = seriesModel.getData()
        const oldData = this._data
        const coordSys = seriesModel.coordinateSystem
        const dimensions = coordSys.dimensions
        const seriesScope = makeSeriesScope$2(seriesModel)
        data.diff(oldData).add(add).update(update).remove(remove).execute()

        function add (newDataIndex) {
          const line = addEl(data, dataGroup, newDataIndex, dimensions, coordSys)
          updateElCommon(line, data, newDataIndex, seriesScope)
        }

        function update (newDataIndex, oldDataIndex) {
          const line = oldData.getItemGraphicEl(oldDataIndex)
          const points = createLinePoints(data, newDataIndex, dimensions, coordSys)
          data.setItemGraphicEl(newDataIndex, line)
          updateProps(line, {
            shape: {
              points: points
            }
          }, seriesModel, newDataIndex)
          saveOldStyle(line)
          updateElCommon(line, data, newDataIndex, seriesScope)
        }

        function remove (oldDataIndex) {
          const line = oldData.getItemGraphicEl(oldDataIndex)
          dataGroup.remove(line)
        } // First create

        if (!this._initialized) {
          this._initialized = true
          const clipPath = createGridClipShape(coordSys, seriesModel, function () {
            // Callback will be invoked immediately if there is no animation
            setTimeout(function () {
              dataGroup.removeClipPath()
            })
          })
          dataGroup.setClipPath(clipPath)
        }

        this._data = data
      }

      ParallelView.prototype.incrementalPrepareRender = function (seriesModel, ecModel, api) {
        this._initialized = true
        this._data = null

        this._dataGroup.removeAll()
      }

      ParallelView.prototype.incrementalRender = function (taskParams, seriesModel, ecModel) {
        const data = seriesModel.getData()
        const coordSys = seriesModel.coordinateSystem
        const dimensions = coordSys.dimensions
        const seriesScope = makeSeriesScope$2(seriesModel)
        const progressiveEls = this._progressiveEls = []

        for (let dataIndex = taskParams.start; dataIndex < taskParams.end; dataIndex++) {
          const line = addEl(data, this._dataGroup, dataIndex, dimensions, coordSys)
          line.incremental = true
          updateElCommon(line, data, dataIndex, seriesScope)
          progressiveEls.push(line)
        }
      }

      ParallelView.prototype.remove = function () {
        this._dataGroup && this._dataGroup.removeAll()
        this._data = null
      }

      ParallelView.type = 'parallel'
      return ParallelView
    }(ChartView))

  function createGridClipShape (coordSys, seriesModel, cb) {
    const parallelModel = coordSys.model
    const rect = coordSys.getRect()
    const rectEl = new Rect({
      shape: {
        x: rect.x,
        y: rect.y,
        width: rect.width,
        height: rect.height
      }
    })
    const dim = parallelModel.get('layout') === 'horizontal' ? 'width' : 'height'
    rectEl.setShape(dim, 0)
    initProps(rectEl, {
      shape: {
        width: rect.width,
        height: rect.height
      }
    }, seriesModel, cb)
    return rectEl
  }

  function createLinePoints (data, dataIndex, dimensions, coordSys) {
    const points = []

    for (let i = 0; i < dimensions.length; i++) {
      const dimName = dimensions[i]
      const value = data.get(data.mapDimension(dimName), dataIndex)

      if (!isEmptyValue(value, coordSys.getAxis(dimName).type)) {
        points.push(coordSys.dataToPoint(value, dimName))
      }
    }

    return points
  }

  function addEl (data, dataGroup, dataIndex, dimensions, coordSys) {
    const points = createLinePoints(data, dataIndex, dimensions, coordSys)
    const line = new Polyline({
      shape: {
        points: points
      },
      // silent: true,
      z2: 10
    })
    dataGroup.add(line)
    data.setItemGraphicEl(dataIndex, line)
    return line
  }

  function makeSeriesScope$2 (seriesModel) {
    let smooth = seriesModel.get('smooth', true)
    smooth === true && (smooth = DEFAULT_SMOOTH)
    smooth = numericToNumber(smooth)
    eqNaN(smooth) && (smooth = 0)
    return {
      smooth: smooth
    }
  }

  function updateElCommon (el, data, dataIndex, seriesScope) {
    el.useStyle(data.getItemVisual(dataIndex, 'style'))
    el.style.fill = null
    el.setShape('smooth', seriesScope.smooth)
    const itemModel = data.getItemModel(dataIndex)
    const emphasisModel = itemModel.getModel('emphasis')
    setStatesStylesFromModel(el, itemModel, 'lineStyle')
    toggleHoverEmphasis(el, emphasisModel.get('focus'), emphasisModel.get('blurScope'), emphasisModel.get('disabled'))
  } // function simpleDiff(oldData, newData, dimensions) {
  //     let oldLen;
  //     if (!oldData
  //         || !oldData.__plProgressive
  //         || (oldLen = oldData.count()) !== newData.count()
  //     ) {
  //         return true;
  //     }
  //     let dimLen = dimensions.length;
  //     for (let i = 0; i < oldLen; i++) {
  //         for (let j = 0; j < dimLen; j++) {
  //             if (oldData.get(dimensions[j], i) !== newData.get(dimensions[j], i)) {
  //                 return true;
  //             }
  //         }
  //     }
  //     return false;
  // }
  // FIXME put in common util?

  function isEmptyValue (val, axisType) {
    return axisType === 'category' ? val == null : val == null || isNaN(val) // axisType === 'value'
  }

  const ParallelSeriesModel =
    /** @class */
    (function (_super) {
      __extends(ParallelSeriesModel, _super)

      function ParallelSeriesModel () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = ParallelSeriesModel.type
        _this.visualStyleAccessPath = 'lineStyle'
        _this.visualDrawType = 'stroke'
        return _this
      }

      ParallelSeriesModel.prototype.getInitialData = function (option, ecModel) {
        return createSeriesData(null, this, {
          useEncodeDefaulter: bind(makeDefaultEncode, null, this)
        })
      }
      /**
       * User can get data raw indices on 'axisAreaSelected' event received.
       *
       * @return Raw indices
       */

      ParallelSeriesModel.prototype.getRawIndicesByActiveState = function (activeState) {
        const coordSys = this.coordinateSystem
        const data = this.getData()
        const indices = []
        coordSys.eachActiveState(data, function (theActiveState, dataIndex) {
          if (activeState === theActiveState) {
            indices.push(data.getRawIndex(dataIndex))
          }
        })
        return indices
      }

      ParallelSeriesModel.type = 'series.parallel'
      ParallelSeriesModel.dependencies = ['parallel']
      ParallelSeriesModel.defaultOption = {
        // zlevel: 0,
        z: 2,
        coordinateSystem: 'parallel',
        parallelIndex: 0,
        label: {
          show: false
        },
        inactiveOpacity: 0.05,
        activeOpacity: 1,
        lineStyle: {
          width: 1,
          opacity: 0.45,
          type: 'solid'
        },
        emphasis: {
          label: {
            show: false
          }
        },
        progressive: 500,
        smooth: false,
        animationEasing: 'linear'
      }
      return ParallelSeriesModel
    }(SeriesModel))

  function makeDefaultEncode (seriesModel) {
    // The mapping of parallelAxis dimension to data dimension can
    // be specified in parallelAxis.option.dim. For example, if
    // parallelAxis.option.dim is 'dim3', it mapping to the third
    // dimension of data. But `data.encode` has higher priority.
    // Moreover, parallelModel.dimension should not be regarded as data
    // dimensions. Consider dimensions = ['dim4', 'dim2', 'dim6'];
    const parallelModel = seriesModel.ecModel.getComponent('parallel', seriesModel.get('parallelIndex'))

    if (!parallelModel) {
      return
    }

    const encodeDefine = {}
    each(parallelModel.dimensions, function (axisDim) {
      const dataDimIndex = convertDimNameToNumber(axisDim)
      encodeDefine[axisDim] = dataDimIndex
    })
    return encodeDefine
  }

  function convertDimNameToNumber (dimName) {
    return +dimName.replace('dim', '')
  }

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

  /**
     * AUTO-GENERATED FILE. DO NOT MODIFY.
     */

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
  const opacityAccessPath$1 = ['lineStyle', 'opacity']
  const parallelVisual = {
    seriesType: 'parallel',
    reset: function (seriesModel, ecModel) {
      const coordSys = seriesModel.coordinateSystem
      const opacityMap = {
        normal: seriesModel.get(['lineStyle', 'opacity']),
        active: seriesModel.get('activeOpacity'),
        inactive: seriesModel.get('inactiveOpacity')
      }
      return {
        progress: function (params, data) {
          coordSys.eachActiveState(data, function (activeState, dataIndex) {
            let opacity = opacityMap[activeState]

            if (activeState === 'normal' && data.hasItemOption) {
              const itemOpacity = data.getItemModel(dataIndex).get(opacityAccessPath$1, true)
              itemOpacity != null && (opacity = itemOpacity)
            }

            const existsStyle = data.ensureUniqueItemVisual(dataIndex, 'style')
            existsStyle.opacity = opacity
          }, params.start, params.end)
        }
      }
    }
  }

  function parallelPreprocessor (option) {
    createParallelIfNeeded(option)
    mergeAxisOptionFromParallel(option)
  }
  /**
     * Create a parallel coordinate if not exists.
     * @inner
     */

  function createParallelIfNeeded (option) {
    if (option.parallel) {
      return
    }

    let hasParallelSeries = false
    each(option.series, function (seriesOpt) {
      if (seriesOpt && seriesOpt.type === 'parallel') {
        hasParallelSeries = true
      }
    })

    if (hasParallelSeries) {
      option.parallel = [{}]
    }
  }
  /**
     * Merge aixs definition from parallel option (if exists) to axis option.
     * @inner
     */

  function mergeAxisOptionFromParallel (option) {
    const axes = normalizeToArray(option.parallelAxis)
    each(axes, function (axisOption) {
      if (!isObject(axisOption)) {
        return
      }

      const parallelIndex = axisOption.parallelIndex || 0
      const parallelOption = normalizeToArray(option.parallel)[parallelIndex]

      if (parallelOption && parallelOption.parallelAxisDefault) {
        merge(axisOption, parallelOption.parallelAxisDefault, false)
      }
    })
  }

  const CLICK_THRESHOLD = 5 // > 4

  const ParallelView$1 =
    /** @class */
    (function (_super) {
      __extends(ParallelView, _super)

      function ParallelView () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = ParallelView.type
        return _this
      }

      ParallelView.prototype.render = function (parallelModel, ecModel, api) {
        this._model = parallelModel
        this._api = api

        if (!this._handlers) {
          this._handlers = {}
          each(handlers, function (handler, eventName) {
            api.getZr().on(eventName, this._handlers[eventName] = bind(handler, this))
          }, this)
        }

        createOrUpdate(this, '_throttledDispatchExpand', parallelModel.get('axisExpandRate'), 'fixRate')
      }

      ParallelView.prototype.dispose = function (ecModel, api) {
        clear(this, '_throttledDispatchExpand')
        each(this._handlers, function (handler, eventName) {
          api.getZr().off(eventName, handler)
        })
        this._handlers = null
      }
      /**
       * @internal
       * @param {Object} [opt] If null, cancle the last action triggering for debounce.
       */

      ParallelView.prototype._throttledDispatchExpand = function (opt) {
        this._dispatchExpand(opt)
      }
      /**
       * @internal
       */

      ParallelView.prototype._dispatchExpand = function (opt) {
        opt && this._api.dispatchAction(extend({
          type: 'parallelAxisExpand'
        }, opt))
      }

      ParallelView.type = 'parallel'
      return ParallelView
    }(ComponentView))

  var handlers = {
    mousedown: function (e) {
      if (checkTrigger(this, 'click')) {
        this._mouseDownPoint = [e.offsetX, e.offsetY]
      }
    },
    mouseup: function (e) {
      const mouseDownPoint = this._mouseDownPoint

      if (checkTrigger(this, 'click') && mouseDownPoint) {
        const point = [e.offsetX, e.offsetY]
        const dist = Math.pow(mouseDownPoint[0] - point[0], 2) + Math.pow(mouseDownPoint[1] - point[1], 2)

        if (dist > CLICK_THRESHOLD) {
          return
        }

        const result = this._model.coordinateSystem.getSlidedAxisExpandWindow([e.offsetX, e.offsetY])

        result.behavior !== 'none' && this._dispatchExpand({
          axisExpandWindow: result.axisExpandWindow
        })
      }

      this._mouseDownPoint = null
    },
    mousemove: function (e) {
      // Should do nothing when brushing.
      if (this._mouseDownPoint || !checkTrigger(this, 'mousemove')) {
        return
      }

      const model = this._model
      const result = model.coordinateSystem.getSlidedAxisExpandWindow([e.offsetX, e.offsetY])
      const behavior = result.behavior
      behavior === 'jump' && this._throttledDispatchExpand.debounceNextCall(model.get('axisExpandDebounce'))

      this._throttledDispatchExpand(behavior === 'none' ? null // Cancle the last trigger, in case that mouse slide out of the area quickly.
        : {
            axisExpandWindow: result.axisExpandWindow,
            // Jumping uses animation, and sliding suppresses animation.
            animation: behavior === 'jump' ? null : {
              duration: 0 // Disable animation.

            }
          })
    }
  }

  function checkTrigger (view, triggerOn) {
    const model = view._model
    return model.get('axisExpandable') && model.get('axisExpandTriggerOn') === triggerOn
  }

  const ParallelModel =
    /** @class */
    (function (_super) {
      __extends(ParallelModel, _super)

      function ParallelModel () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = ParallelModel.type
        return _this
      }

      ParallelModel.prototype.init = function () {
        _super.prototype.init.apply(this, arguments)

        this.mergeOption({})
      }

      ParallelModel.prototype.mergeOption = function (newOption) {
        const thisOption = this.option
        newOption && merge(thisOption, newOption, true)

        this._initDimensions()
      }
      /**
       * Whether series or axis is in this coordinate system.
       */

      ParallelModel.prototype.contains = function (model, ecModel) {
        const parallelIndex = model.get('parallelIndex')
        return parallelIndex != null && ecModel.getComponent('parallel', parallelIndex) === this
      }

      ParallelModel.prototype.setAxisExpand = function (opt) {
        each(['axisExpandable', 'axisExpandCenter', 'axisExpandCount', 'axisExpandWidth', 'axisExpandWindow'], function (name) {
          if (opt.hasOwnProperty(name)) {
            // @ts-ignore FIXME: why "never" inferred in this.option[name]?
            this.option[name] = opt[name]
          }
        }, this)
      }

      ParallelModel.prototype._initDimensions = function () {
        const dimensions = this.dimensions = []
        const parallelAxisIndex = this.parallelAxisIndex = []
        const axisModels = filter(this.ecModel.queryComponents({
          mainType: 'parallelAxis'
        }), function (axisModel) {
          // Can not use this.contains here, because
          // initialization has not been completed yet.
          return (axisModel.get('parallelIndex') || 0) === this.componentIndex
        }, this)
        each(axisModels, function (axisModel) {
          dimensions.push('dim' + axisModel.get('dim'))
          parallelAxisIndex.push(axisModel.componentIndex)
        })
      }

      ParallelModel.type = 'parallel'
      ParallelModel.dependencies = ['parallelAxis']
      ParallelModel.layoutMode = 'box'
      ParallelModel.defaultOption = {
        // zlevel: 0,
        z: 0,
        left: 80,
        top: 60,
        right: 80,
        bottom: 60,
        // width: {totalWidth} - left - right,
        // height: {totalHeight} - top - bottom,
        layout: 'horizontal',
        // FIXME
        // naming?
        axisExpandable: false,
        axisExpandCenter: null,
        axisExpandCount: 0,
        axisExpandWidth: 50,
        axisExpandRate: 17,
        axisExpandDebounce: 50,
        // [out, in, jumpTarget]. In percentage. If use [null, 0.05], null means full.
        // Do not doc to user until necessary.
        axisExpandSlideTriggerArea: [-0.15, 0.05, 0.4],
        axisExpandTriggerOn: 'click',
        parallelAxisDefault: null
      }
      return ParallelModel
    }(ComponentModel))

  const ParallelAxis =
    /** @class */
    (function (_super) {
      __extends(ParallelAxis, _super)

      function ParallelAxis (dim, scale, coordExtent, axisType, axisIndex) {
        const _this = _super.call(this, dim, scale, coordExtent) || this

        _this.type = axisType || 'value'
        _this.axisIndex = axisIndex
        return _this
      }

      ParallelAxis.prototype.isHorizontal = function () {
        return this.coordinateSystem.getModel().get('layout') !== 'horizontal'
      }

      return ParallelAxis
    }(Axis))

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

  /**
     * AUTO-GENERATED FILE. DO NOT MODIFY.
     */

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

  /**
     * Calculate slider move result.
     * Usage:
     * (1) If both handle0 and handle1 are needed to be moved, set minSpan the same as
     * maxSpan and the same as `Math.abs(handleEnd[1] - handleEnds[0])`.
     * (2) If handle0 is forbidden to cross handle1, set minSpan as `0`.
     *
     * @param delta Move length.
     * @param handleEnds handleEnds[0] can be bigger then handleEnds[1].
     *              handleEnds will be modified in this method.
     * @param extent handleEnds is restricted by extent.
     *              extent[0] should less or equals than extent[1].
     * @param handleIndex Can be 'all', means that both move the two handleEnds.
     * @param minSpan The range of dataZoom can not be smaller than that.
     *              If not set, handle0 and cross handle1. If set as a non-negative
     *              number (including `0`), handles will push each other when reaching
     *              the minSpan.
     * @param maxSpan The range of dataZoom can not be larger than that.
     * @return The input handleEnds.
     */
  function sliderMove (delta, handleEnds, extent, handleIndex, minSpan, maxSpan) {
    delta = delta || 0
    const extentSpan = extent[1] - extent[0] // Notice maxSpan and minSpan can be null/undefined.

    if (minSpan != null) {
      minSpan = restrict(minSpan, [0, extentSpan])
    }

    if (maxSpan != null) {
      maxSpan = Math.max(maxSpan, minSpan != null ? minSpan : 0)
    }

    if (handleIndex === 'all') {
      let handleSpan = Math.abs(handleEnds[1] - handleEnds[0])
      handleSpan = restrict(handleSpan, [0, extentSpan])
      minSpan = maxSpan = restrict(handleSpan, [minSpan, maxSpan])
      handleIndex = 0
    }

    handleEnds[0] = restrict(handleEnds[0], extent)
    handleEnds[1] = restrict(handleEnds[1], extent)
    const originalDistSign = getSpanSign(handleEnds, handleIndex)
    handleEnds[handleIndex] += delta // Restrict in extent.

    const extentMinSpan = minSpan || 0
    const realExtent = extent.slice()
    originalDistSign.sign < 0 ? realExtent[0] += extentMinSpan : realExtent[1] -= extentMinSpan
    handleEnds[handleIndex] = restrict(handleEnds[handleIndex], realExtent) // Expand span.

    let currDistSign
    currDistSign = getSpanSign(handleEnds, handleIndex)

    if (minSpan != null && (currDistSign.sign !== originalDistSign.sign || currDistSign.span < minSpan)) {
      // If minSpan exists, 'cross' is forbidden.
      handleEnds[1 - handleIndex] = handleEnds[handleIndex] + originalDistSign.sign * minSpan
    } // Shrink span.

    currDistSign = getSpanSign(handleEnds, handleIndex)

    if (maxSpan != null && currDistSign.span > maxSpan) {
      handleEnds[1 - handleIndex] = handleEnds[handleIndex] + currDistSign.sign * maxSpan
    }

    return handleEnds
  }

  function getSpanSign (handleEnds, handleIndex) {
    const dist = handleEnds[handleIndex] - handleEnds[1 - handleIndex] // If `handleEnds[0] === handleEnds[1]`, always believe that handleEnd[0]
    // is at left of handleEnds[1] for non-cross case.

    return {
      span: Math.abs(dist),
      sign: dist > 0 ? -1 : dist < 0 ? 1 : handleIndex ? -1 : 1
    }
  }

  function restrict (value, extend) {
    return Math.min(extend[1] != null ? extend[1] : Infinity, Math.max(extend[0] != null ? extend[0] : -Infinity, value))
  }

  const each$5 = each
  const mathMin$8 = Math.min
  const mathMax$8 = Math.max
  const mathFloor$1 = Math.floor
  const mathCeil$1 = Math.ceil
  const round$3 = round
  const PI$7 = Math.PI

  const Parallel =
    /** @class */
    (function () {
      function Parallel (parallelModel, ecModel, api) {
        this.type = 'parallel'
        /**
         * key: dimension
         */

        this._axesMap = createHashMap()
        /**
         * key: dimension
         * value: {position: [], rotation, }
         */

        this._axesLayout = {}
        this.dimensions = parallelModel.dimensions
        this._model = parallelModel

        this._init(parallelModel, ecModel, api)
      }

      Parallel.prototype._init = function (parallelModel, ecModel, api) {
        const dimensions = parallelModel.dimensions
        const parallelAxisIndex = parallelModel.parallelAxisIndex
        each$5(dimensions, function (dim, idx) {
          const axisIndex = parallelAxisIndex[idx]
          const axisModel = ecModel.getComponent('parallelAxis', axisIndex)

          const axis = this._axesMap.set(dim, new ParallelAxis(dim, createScaleByModel(axisModel), [0, 0], axisModel.get('type'), axisIndex))

          const isCategory = axis.type === 'category'
          axis.onBand = isCategory && axisModel.get('boundaryGap')
          axis.inverse = axisModel.get('inverse') // Injection

          axisModel.axis = axis
          axis.model = axisModel
          axis.coordinateSystem = axisModel.coordinateSystem = this
        }, this)
      }
      /**
       * Update axis scale after data processed
       */

      Parallel.prototype.update = function (ecModel, api) {
        this._updateAxesFromSeries(this._model, ecModel)
      }

      Parallel.prototype.containPoint = function (point) {
        const layoutInfo = this._makeLayoutInfo()

        const axisBase = layoutInfo.axisBase
        const layoutBase = layoutInfo.layoutBase
        const pixelDimIndex = layoutInfo.pixelDimIndex
        const pAxis = point[1 - pixelDimIndex]
        const pLayout = point[pixelDimIndex]
        return pAxis >= axisBase && pAxis <= axisBase + layoutInfo.axisLength && pLayout >= layoutBase && pLayout <= layoutBase + layoutInfo.layoutLength
      }

      Parallel.prototype.getModel = function () {
        return this._model
      }
      /**
       * Update properties from series
       */

      Parallel.prototype._updateAxesFromSeries = function (parallelModel, ecModel) {
        ecModel.eachSeries(function (seriesModel) {
          if (!parallelModel.contains(seriesModel, ecModel)) {
            return
          }

          const data = seriesModel.getData()
          each$5(this.dimensions, function (dim) {
            const axis = this._axesMap.get(dim)

            axis.scale.unionExtentFromData(data, data.mapDimension(dim))
            niceScaleExtent(axis.scale, axis.model)
          }, this)
        }, this)
      }
      /**
       * Resize the parallel coordinate system.
       */

      Parallel.prototype.resize = function (parallelModel, api) {
        this._rect = getLayoutRect(parallelModel.getBoxLayoutParams(), {
          width: api.getWidth(),
          height: api.getHeight()
        })

        this._layoutAxes()
      }

      Parallel.prototype.getRect = function () {
        return this._rect
      }

      Parallel.prototype._makeLayoutInfo = function () {
        const parallelModel = this._model
        const rect = this._rect
        const xy = ['x', 'y']
        const wh = ['width', 'height']
        const layout = parallelModel.get('layout')
        const pixelDimIndex = layout === 'horizontal' ? 0 : 1
        const layoutLength = rect[wh[pixelDimIndex]]
        const layoutExtent = [0, layoutLength]
        const axisCount = this.dimensions.length
        const axisExpandWidth = restrict$1(parallelModel.get('axisExpandWidth'), layoutExtent)
        const axisExpandCount = restrict$1(parallelModel.get('axisExpandCount') || 0, [0, axisCount])
        const axisExpandable = parallelModel.get('axisExpandable') && axisCount > 3 && axisCount > axisExpandCount && axisExpandCount > 1 && axisExpandWidth > 0 && layoutLength > 0 // `axisExpandWindow` is According to the coordinates of [0, axisExpandLength],
        // for sake of consider the case that axisCollapseWidth is 0 (when screen is narrow),
        // where collapsed axes should be overlapped.

        let axisExpandWindow = parallelModel.get('axisExpandWindow')
        let winSize

        if (!axisExpandWindow) {
          winSize = restrict$1(axisExpandWidth * (axisExpandCount - 1), layoutExtent)
          const axisExpandCenter = parallelModel.get('axisExpandCenter') || mathFloor$1(axisCount / 2)
          axisExpandWindow = [axisExpandWidth * axisExpandCenter - winSize / 2]
          axisExpandWindow[1] = axisExpandWindow[0] + winSize
        } else {
          winSize = restrict$1(axisExpandWindow[1] - axisExpandWindow[0], layoutExtent)
          axisExpandWindow[1] = axisExpandWindow[0] + winSize
        }

        let axisCollapseWidth = (layoutLength - winSize) / (axisCount - axisExpandCount) // Avoid axisCollapseWidth is too small.

        axisCollapseWidth < 3 && (axisCollapseWidth = 0) // Find the first and last indices > ewin[0] and < ewin[1].

        const winInnerIndices = [mathFloor$1(round$3(axisExpandWindow[0] / axisExpandWidth, 1)) + 1, mathCeil$1(round$3(axisExpandWindow[1] / axisExpandWidth, 1)) - 1] // Pos in ec coordinates.

        const axisExpandWindow0Pos = axisCollapseWidth / axisExpandWidth * axisExpandWindow[0]
        return {
          layout: layout,
          pixelDimIndex: pixelDimIndex,
          layoutBase: rect[xy[pixelDimIndex]],
          layoutLength: layoutLength,
          axisBase: rect[xy[1 - pixelDimIndex]],
          axisLength: rect[wh[1 - pixelDimIndex]],
          axisExpandable: axisExpandable,
          axisExpandWidth: axisExpandWidth,
          axisCollapseWidth: axisCollapseWidth,
          axisExpandWindow: axisExpandWindow,
          axisCount: axisCount,
          winInnerIndices: winInnerIndices,
          axisExpandWindow0Pos: axisExpandWindow0Pos
        }
      }

      Parallel.prototype._layoutAxes = function () {
        const rect = this._rect
        const axes = this._axesMap
        const dimensions = this.dimensions

        const layoutInfo = this._makeLayoutInfo()

        const layout = layoutInfo.layout
        axes.each(function (axis) {
          const axisExtent = [0, layoutInfo.axisLength]
          const idx = axis.inverse ? 1 : 0
          axis.setExtent(axisExtent[idx], axisExtent[1 - idx])
        })
        each$5(dimensions, function (dim, idx) {
          const posInfo = (layoutInfo.axisExpandable ? layoutAxisWithExpand : layoutAxisWithoutExpand)(idx, layoutInfo)
          const positionTable = {
            horizontal: {
              x: posInfo.position,
              y: layoutInfo.axisLength
            },
            vertical: {
              x: 0,
              y: posInfo.position
            }
          }
          const rotationTable = {
            horizontal: PI$7 / 2,
            vertical: 0
          }
          const position = [positionTable[layout].x + rect.x, positionTable[layout].y + rect.y]
          const rotation = rotationTable[layout]
          const transform = create$1()
          rotate(transform, transform, rotation)
          translate(transform, transform, position) // TODO
          // tick layout info
          // TODO
          // update dimensions info based on axis order.

          this._axesLayout[dim] = {
            position: position,
            rotation: rotation,
            transform: transform,
            axisNameAvailableWidth: posInfo.axisNameAvailableWidth,
            axisLabelShow: posInfo.axisLabelShow,
            nameTruncateMaxWidth: posInfo.nameTruncateMaxWidth,
            tickDirection: 1,
            labelDirection: 1
          }
        }, this)
      }
      /**
       * Get axis by dim.
       */

      Parallel.prototype.getAxis = function (dim) {
        return this._axesMap.get(dim)
      }
      /**
       * Convert a dim value of a single item of series data to Point.
       */

      Parallel.prototype.dataToPoint = function (value, dim) {
        return this.axisCoordToPoint(this._axesMap.get(dim).dataToCoord(value), dim)
      }
      /**
       * Travel data for one time, get activeState of each data item.
       * @param start the start dataIndex that travel from.
       * @param end the next dataIndex of the last dataIndex will be travel.
       */

      Parallel.prototype.eachActiveState = function (data, callback, start, end) {
        start == null && (start = 0)
        end == null && (end = data.count())
        const axesMap = this._axesMap
        const dimensions = this.dimensions
        const dataDimensions = []
        const axisModels = []
        each(dimensions, function (axisDim) {
          dataDimensions.push(data.mapDimension(axisDim))
          axisModels.push(axesMap.get(axisDim).model)
        })
        const hasActiveSet = this.hasAxisBrushed()

        for (let dataIndex = start; dataIndex < end; dataIndex++) {
          let activeState = void 0

          if (!hasActiveSet) {
            activeState = 'normal'
          } else {
            activeState = 'active'
            const values = data.getValues(dataDimensions, dataIndex)

            for (let j = 0, lenj = dimensions.length; j < lenj; j++) {
              const state = axisModels[j].getActiveState(values[j])

              if (state === 'inactive') {
                activeState = 'inactive'
                break
              }
            }
          }

          callback(activeState, dataIndex)
        }
      }
      /**
       * Whether has any activeSet.
       */

      Parallel.prototype.hasAxisBrushed = function () {
        const dimensions = this.dimensions
        const axesMap = this._axesMap
        let hasActiveSet = false

        for (let j = 0, lenj = dimensions.length; j < lenj; j++) {
          if (axesMap.get(dimensions[j]).model.getActiveState() !== 'normal') {
            hasActiveSet = true
          }
        }

        return hasActiveSet
      }
      /**
       * Convert coords of each axis to Point.
       *  Return point. For example: [10, 20]
       */

      Parallel.prototype.axisCoordToPoint = function (coord, dim) {
        const axisLayout = this._axesLayout[dim]
        return applyTransform$1([coord, 0], axisLayout.transform)
      }
      /**
       * Get axis layout.
       */

      Parallel.prototype.getAxisLayout = function (dim) {
        return clone(this._axesLayout[dim])
      }
      /**
       * @return {Object} {axisExpandWindow, delta, behavior: 'jump' | 'slide' | 'none'}.
       */

      Parallel.prototype.getSlidedAxisExpandWindow = function (point) {
        const layoutInfo = this._makeLayoutInfo()

        const pixelDimIndex = layoutInfo.pixelDimIndex
        let axisExpandWindow = layoutInfo.axisExpandWindow.slice()
        const winSize = axisExpandWindow[1] - axisExpandWindow[0]
        const extent = [0, layoutInfo.axisExpandWidth * (layoutInfo.axisCount - 1)] // Out of the area of coordinate system.

        if (!this.containPoint(point)) {
          return {
            behavior: 'none',
            axisExpandWindow: axisExpandWindow
          }
        } // Conver the point from global to expand coordinates.

        const pointCoord = point[pixelDimIndex] - layoutInfo.layoutBase - layoutInfo.axisExpandWindow0Pos // For dragging operation convenience, the window should not be
        // slided when mouse is the center area of the window.

        let delta
        let behavior = 'slide'
        const axisCollapseWidth = layoutInfo.axisCollapseWidth

        const triggerArea = this._model.get('axisExpandSlideTriggerArea') // But consider touch device, jump is necessary.

        const useJump = triggerArea[0] != null

        if (axisCollapseWidth) {
          if (useJump && axisCollapseWidth && pointCoord < winSize * triggerArea[0]) {
            behavior = 'jump'
            delta = pointCoord - winSize * triggerArea[2]
          } else if (useJump && axisCollapseWidth && pointCoord > winSize * (1 - triggerArea[0])) {
            behavior = 'jump'
            delta = pointCoord - winSize * (1 - triggerArea[2])
          } else {
            (delta = pointCoord - winSize * triggerArea[1]) >= 0 && (delta = pointCoord - winSize * (1 - triggerArea[1])) <= 0 && (delta = 0)
          }

          delta *= layoutInfo.axisExpandWidth / axisCollapseWidth
          delta ? sliderMove(delta, axisExpandWindow, extent, 'all') // Avoid nonsense triger on mousemove.
            : behavior = 'none'
        } // When screen is too narrow, make it visible and slidable, although it is hard to interact.
        else {
          const winSize2 = axisExpandWindow[1] - axisExpandWindow[0]
          const pos = extent[1] * pointCoord / winSize2
          axisExpandWindow = [mathMax$8(0, pos - winSize2 / 2)]
          axisExpandWindow[1] = mathMin$8(extent[1], axisExpandWindow[0] + winSize2)
          axisExpandWindow[0] = axisExpandWindow[1] - winSize2
        }

        return {
          axisExpandWindow: axisExpandWindow,
          behavior: behavior
        }
      }

      return Parallel
    }())

  function restrict$1 (len, extent) {
    return mathMin$8(mathMax$8(len, extent[0]), extent[1])
  }

  function layoutAxisWithoutExpand (axisIndex, layoutInfo) {
    const step = layoutInfo.layoutLength / (layoutInfo.axisCount - 1)
    return {
      position: step * axisIndex,
      axisNameAvailableWidth: step,
      axisLabelShow: true
    }
  }

  function layoutAxisWithExpand (axisIndex, layoutInfo) {
    const layoutLength = layoutInfo.layoutLength
    const axisExpandWidth = layoutInfo.axisExpandWidth
    const axisCount = layoutInfo.axisCount
    const axisCollapseWidth = layoutInfo.axisCollapseWidth
    const winInnerIndices = layoutInfo.winInnerIndices
    let position
    let axisNameAvailableWidth = axisCollapseWidth
    let axisLabelShow = false
    let nameTruncateMaxWidth

    if (axisIndex < winInnerIndices[0]) {
      position = axisIndex * axisCollapseWidth
      nameTruncateMaxWidth = axisCollapseWidth
    } else if (axisIndex <= winInnerIndices[1]) {
      position = layoutInfo.axisExpandWindow0Pos + axisIndex * axisExpandWidth - layoutInfo.axisExpandWindow[0]
      axisNameAvailableWidth = axisExpandWidth
      axisLabelShow = true
    } else {
      position = layoutLength - (axisCount - 1 - axisIndex) * axisCollapseWidth
      nameTruncateMaxWidth = axisCollapseWidth
    }

    return {
      position: position,
      axisNameAvailableWidth: axisNameAvailableWidth,
      axisLabelShow: axisLabelShow,
      nameTruncateMaxWidth: nameTruncateMaxWidth
    }
  }

  function createParallelCoordSys (ecModel, api) {
    const coordSysList = []
    ecModel.eachComponent('parallel', function (parallelModel, idx) {
      const coordSys = new Parallel(parallelModel, ecModel, api)
      coordSys.name = 'parallel_' + idx
      coordSys.resize(parallelModel, api)
      parallelModel.coordinateSystem = coordSys
      coordSys.model = parallelModel
      coordSysList.push(coordSys)
    }) // Inject the coordinateSystems into seriesModel

    ecModel.eachSeries(function (seriesModel) {
      if (seriesModel.get('coordinateSystem') === 'parallel') {
        const parallelModel = seriesModel.getReferringComponents('parallel', SINGLE_REFERRING).models[0]
        seriesModel.coordinateSystem = parallelModel.coordinateSystem
      }
    })
    return coordSysList
  }

  const parallelCoordSysCreator = {
    create: createParallelCoordSys
  }

  const ParallelAxisModel =
    /** @class */
    (function (_super) {
      __extends(ParallelAxisModel, _super)

      function ParallelAxisModel () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = ParallelAxisModel.type
        /**
         * @readOnly
         */

        _this.activeIntervals = []
        return _this
      }

      ParallelAxisModel.prototype.getAreaSelectStyle = function () {
        return makeStyleMapper([['fill', 'color'], ['lineWidth', 'borderWidth'], ['stroke', 'borderColor'], ['width', 'width'], ['opacity', 'opacity'] // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
        // So do not transfer decal directly.
        ])(this.getModel('areaSelectStyle'))
      }
      /**
       * The code of this feature is put on AxisModel but not ParallelAxis,
       * because axisModel can be alive after echarts updating but instance of
       * ParallelAxis having been disposed. this._activeInterval should be kept
       * when action dispatched (i.e. legend click).
       *
       * @param intervals `interval.length === 0` means set all active.
       */

      ParallelAxisModel.prototype.setActiveIntervals = function (intervals) {
        const activeIntervals = this.activeIntervals = clone(intervals) // Normalize

        if (activeIntervals) {
          for (let i = activeIntervals.length - 1; i >= 0; i--) {
            asc(activeIntervals[i])
          }
        }
      }
      /**
       * @param value When only attempting detect whether 'no activeIntervals set',
       *        `value` is not needed to be input.
       */

      ParallelAxisModel.prototype.getActiveState = function (value) {
        const activeIntervals = this.activeIntervals

        if (!activeIntervals.length) {
          return 'normal'
        }

        if (value == null || isNaN(+value)) {
          return 'inactive'
        } // Simple optimization

        if (activeIntervals.length === 1) {
          const interval = activeIntervals[0]

          if (interval[0] <= value && value <= interval[1]) {
            return 'active'
          }
        } else {
          for (let i = 0, len = activeIntervals.length; i < len; i++) {
            if (activeIntervals[i][0] <= value && value <= activeIntervals[i][1]) {
              return 'active'
            }
          }
        }

        return 'inactive'
      }

      return ParallelAxisModel
    }(ComponentModel))

  mixin(ParallelAxisModel, AxisModelCommonMixin)

  const BRUSH_PANEL_GLOBAL = true
  const mathMin$9 = Math.min
  const mathMax$9 = Math.max
  const mathPow$2 = Math.pow
  const COVER_Z = 10000
  const UNSELECT_THRESHOLD = 6
  const MIN_RESIZE_LINE_WIDTH = 6
  const MUTEX_RESOURCE_KEY = 'globalPan'
  const DIRECTION_MAP = {
    w: [0, 0],
    e: [0, 1],
    n: [1, 0],
    s: [1, 1]
  }
  const CURSOR_MAP = {
    w: 'ew',
    e: 'ew',
    n: 'ns',
    s: 'ns',
    ne: 'nesw',
    sw: 'nesw',
    nw: 'nwse',
    se: 'nwse'
  }
  const DEFAULT_BRUSH_OPT = {
    brushStyle: {
      lineWidth: 2,
      stroke: 'rgba(210,219,238,0.3)',
      fill: '#D2DBEE'
    },
    transformable: true,
    brushMode: 'single',
    removeOnClick: false
  }
  let baseUID = 0
  /**
     * params:
     *     areas: Array.<Array>, coord relates to container group,
     *                             If no container specified, to global.
     *     opt {
     *         isEnd: boolean,
     *         removeOnClick: boolean
     *     }
     */

  const BrushController =
    /** @class */
    (function (_super) {
      __extends(BrushController, _super)

      function BrushController (zr) {
        const _this = _super.call(this) || this
        /**
         * @internal
         */

        _this._track = []
        /**
         * @internal
         */

        _this._covers = []
        _this._handlers = {}

        if ('development' !== 'production') {
          assert(zr)
        }

        _this._zr = zr
        _this.group = new Group()
        _this._uid = 'brushController_' + baseUID++
        each(pointerHandlers, function (handler, eventName) {
          this._handlers[eventName] = bind(handler, this)
        }, _this)
        return _this
      }
      /**
       * If set to `false`, select disabled.
       */

      BrushController.prototype.enableBrush = function (brushOption) {
        if ('development' !== 'production') {
          assert(this._mounted)
        }

        this._brushType && this._doDisableBrush()
        brushOption.brushType && this._doEnableBrush(brushOption)
        return this
      }

      BrushController.prototype._doEnableBrush = function (brushOption) {
        const zr = this._zr // Consider roam, which takes globalPan too.

        if (!this._enableGlobalPan) {
          take(zr, MUTEX_RESOURCE_KEY, this._uid)
        }

        each(this._handlers, function (handler, eventName) {
          zr.on(eventName, handler)
        })
        this._brushType = brushOption.brushType
        this._brushOption = merge(clone(DEFAULT_BRUSH_OPT), brushOption, true)
      }

      BrushController.prototype._doDisableBrush = function () {
        const zr = this._zr
        release(zr, MUTEX_RESOURCE_KEY, this._uid)
        each(this._handlers, function (handler, eventName) {
          zr.off(eventName, handler)
        })
        this._brushType = this._brushOption = null
      }
      /**
       * @param panelOpts If not pass, it is global brush.
       */

      BrushController.prototype.setPanels = function (panelOpts) {
        if (panelOpts && panelOpts.length) {
          const panels_1 = this._panels = {}
          each(panelOpts, function (panelOpts) {
            panels_1[panelOpts.panelId] = clone(panelOpts)
          })
        } else {
          this._panels = null
        }

        return this
      }

      BrushController.prototype.mount = function (opt) {
        opt = opt || {}

        if ('development' !== 'production') {
          this._mounted = true // should be at first.
        }

        this._enableGlobalPan = opt.enableGlobalPan
        const thisGroup = this.group

        this._zr.add(thisGroup)

        thisGroup.attr({
          x: opt.x || 0,
          y: opt.y || 0,
          rotation: opt.rotation || 0,
          scaleX: opt.scaleX || 1,
          scaleY: opt.scaleY || 1
        })
        this._transform = thisGroup.getLocalTransform()
        return this
      } // eachCover(cb, context): void {
      //     each(this._covers, cb, context);
      // }

      /**
       * Update covers.
       * @param coverConfigList
       *        If coverConfigList is null/undefined, all covers removed.
       */

      BrushController.prototype.updateCovers = function (coverConfigList) {
        if ('development' !== 'production') {
          assert(this._mounted)
        }

        coverConfigList = map(coverConfigList, function (coverConfig) {
          return merge(clone(DEFAULT_BRUSH_OPT), coverConfig, true)
        })
        const tmpIdPrefix = '\0-brush-index-'
        const oldCovers = this._covers
        const newCovers = this._covers = []
        const controller = this
        const creatingCover = this._creatingCover
        new DataDiffer(oldCovers, coverConfigList, oldGetKey, getKey).add(addOrUpdate).update(addOrUpdate).remove(remove).execute()
        return this

        function getKey (brushOption, index) {
          return (brushOption.id != null ? brushOption.id : tmpIdPrefix + index) + '-' + brushOption.brushType
        }

        function oldGetKey (cover, index) {
          return getKey(cover.__brushOption, index)
        }

        function addOrUpdate (newIndex, oldIndex) {
          const newBrushInternal = coverConfigList[newIndex] // Consider setOption in event listener of brushSelect,
          // where updating cover when creating should be forbiden.

          if (oldIndex != null && oldCovers[oldIndex] === creatingCover) {
            newCovers[newIndex] = oldCovers[oldIndex]
          } else {
            const cover = newCovers[newIndex] = oldIndex != null ? (oldCovers[oldIndex].__brushOption = newBrushInternal, oldCovers[oldIndex]) : endCreating(controller, createCover(controller, newBrushInternal))
            updateCoverAfterCreation(controller, cover)
          }
        }

        function remove (oldIndex) {
          if (oldCovers[oldIndex] !== creatingCover) {
            controller.group.remove(oldCovers[oldIndex])
          }
        }
      }

      BrushController.prototype.unmount = function () {
        if ('development' !== 'production') {
          if (!this._mounted) {
            return
          }
        }

        this.enableBrush(false) // container may 'removeAll' outside.

        clearCovers(this)

        this._zr.remove(this.group)

        if ('development' !== 'production') {
          this._mounted = false // should be at last.
        }

        return this
      }

      BrushController.prototype.dispose = function () {
        this.unmount()
        this.off()
      }

      return BrushController
    }(Eventful))

  function createCover (controller, brushOption) {
    const cover = coverRenderers[brushOption.brushType].createCover(controller, brushOption)
    cover.__brushOption = brushOption
    updateZ(cover, brushOption)
    controller.group.add(cover)
    return cover
  }

  function endCreating (controller, creatingCover) {
    const coverRenderer = getCoverRenderer(creatingCover)

    if (coverRenderer.endCreating) {
      coverRenderer.endCreating(controller, creatingCover)
      updateZ(creatingCover, creatingCover.__brushOption)
    }

    return creatingCover
  }

  function updateCoverShape (controller, cover) {
    const brushOption = cover.__brushOption
    getCoverRenderer(cover).updateCoverShape(controller, cover, brushOption.range, brushOption)
  }

  function updateZ (cover, brushOption) {
    let z = brushOption.z
    z == null && (z = COVER_Z)
    cover.traverse(function (el) {
      el.z = z
      el.z2 = z // Consider in given container.
    })
  }

  function updateCoverAfterCreation (controller, cover) {
    getCoverRenderer(cover).updateCommon(controller, cover)
    updateCoverShape(controller, cover)
  }

  function getCoverRenderer (cover) {
    return coverRenderers[cover.__brushOption.brushType]
  } // return target panel or `true` (means global panel)

  function getPanelByPoint (controller, e, localCursorPoint) {
    const panels = controller._panels

    if (!panels) {
      return BRUSH_PANEL_GLOBAL // Global panel
    }

    let panel
    const transform = controller._transform
    each(panels, function (pn) {
      pn.isTargetByCursor(e, localCursorPoint, transform) && (panel = pn)
    })
    return panel
  } // Return a panel or true

  function getPanelByCover (controller, cover) {
    const panels = controller._panels

    if (!panels) {
      return BRUSH_PANEL_GLOBAL // Global panel
    }

    const panelId = cover.__brushOption.panelId // User may give cover without coord sys info,
    // which is then treated as global panel.

    return panelId != null ? panels[panelId] : BRUSH_PANEL_GLOBAL
  }

  function clearCovers (controller) {
    const covers = controller._covers
    const originalLength = covers.length
    each(covers, function (cover) {
      controller.group.remove(cover)
    }, controller)
    covers.length = 0
    return !!originalLength
  }

  function trigger$1 (controller, opt) {
    const areas = map(controller._covers, function (cover) {
      const brushOption = cover.__brushOption
      const range = clone(brushOption.range)
      return {
        brushType: brushOption.brushType,
        panelId: brushOption.panelId,
        range: range
      }
    })
    controller.trigger('brush', {
      areas: areas,
      isEnd: !!opt.isEnd,
      removeOnClick: !!opt.removeOnClick
    })
  }

  function shouldShowCover (controller) {
    const track = controller._track

    if (!track.length) {
      return false
    }

    const p2 = track[track.length - 1]
    const p1 = track[0]
    const dx = p2[0] - p1[0]
    const dy = p2[1] - p1[1]
    const dist = mathPow$2(dx * dx + dy * dy, 0.5)
    return dist > UNSELECT_THRESHOLD
  }

  function getTrackEnds (track) {
    let tail = track.length - 1
    tail < 0 && (tail = 0)
    return [track[0], track[tail]]
  }

  function createBaseRectCover (rectRangeConverter, controller, brushOption, edgeNameSequences) {
    const cover = new Group()
    cover.add(new Rect({
      name: 'main',
      style: makeStyle(brushOption),
      silent: true,
      draggable: true,
      cursor: 'move',
      drift: curry(driftRect, rectRangeConverter, controller, cover, ['n', 's', 'w', 'e']),
      ondragend: curry(trigger$1, controller, {
        isEnd: true
      })
    }))
    each(edgeNameSequences, function (nameSequence) {
      cover.add(new Rect({
        name: nameSequence.join(''),
        style: {
          opacity: 0
        },
        draggable: true,
        silent: true,
        invisible: true,
        drift: curry(driftRect, rectRangeConverter, controller, cover, nameSequence),
        ondragend: curry(trigger$1, controller, {
          isEnd: true
        })
      }))
    })
    return cover
  }

  function updateBaseRect (controller, cover, localRange, brushOption) {
    const lineWidth = brushOption.brushStyle.lineWidth || 0
    const handleSize = mathMax$9(lineWidth, MIN_RESIZE_LINE_WIDTH)
    const x = localRange[0][0]
    const y = localRange[1][0]
    const xa = x - lineWidth / 2
    const ya = y - lineWidth / 2
    const x2 = localRange[0][1]
    const y2 = localRange[1][1]
    const x2a = x2 - handleSize + lineWidth / 2
    const y2a = y2 - handleSize + lineWidth / 2
    const width = x2 - x
    const height = y2 - y
    const widtha = width + lineWidth
    const heighta = height + lineWidth
    updateRectShape(controller, cover, 'main', x, y, width, height)

    if (brushOption.transformable) {
      updateRectShape(controller, cover, 'w', xa, ya, handleSize, heighta)
      updateRectShape(controller, cover, 'e', x2a, ya, handleSize, heighta)
      updateRectShape(controller, cover, 'n', xa, ya, widtha, handleSize)
      updateRectShape(controller, cover, 's', xa, y2a, widtha, handleSize)
      updateRectShape(controller, cover, 'nw', xa, ya, handleSize, handleSize)
      updateRectShape(controller, cover, 'ne', x2a, ya, handleSize, handleSize)
      updateRectShape(controller, cover, 'sw', xa, y2a, handleSize, handleSize)
      updateRectShape(controller, cover, 'se', x2a, y2a, handleSize, handleSize)
    }
  }

  function updateCommon (controller, cover) {
    const brushOption = cover.__brushOption
    const transformable = brushOption.transformable
    const mainEl = cover.childAt(0)
    mainEl.useStyle(makeStyle(brushOption))
    mainEl.attr({
      silent: !transformable,
      cursor: transformable ? 'move' : 'default'
    })
    each([['w'], ['e'], ['n'], ['s'], ['s', 'e'], ['s', 'w'], ['n', 'e'], ['n', 'w']], function (nameSequence) {
      const el = cover.childOfName(nameSequence.join(''))
      const globalDir = nameSequence.length === 1 ? getGlobalDirection1(controller, nameSequence[0]) : getGlobalDirection2(controller, nameSequence)
      el && el.attr({
        silent: !transformable,
        invisible: !transformable,
        cursor: transformable ? CURSOR_MAP[globalDir] + '-resize' : null
      })
    })
  }

  function updateRectShape (controller, cover, name, x, y, w, h) {
    const el = cover.childOfName(name)
    el && el.setShape(pointsToRect(clipByPanel(controller, cover, [[x, y], [x + w, y + h]])))
  }

  function makeStyle (brushOption) {
    return defaults({
      strokeNoScale: true
    }, brushOption.brushStyle)
  }

  function formatRectRange (x, y, x2, y2) {
    const min = [mathMin$9(x, x2), mathMin$9(y, y2)]
    const max = [mathMax$9(x, x2), mathMax$9(y, y2)]
    return [[min[0], max[0]], [min[1], max[1]] // y range
    ]
  }

  function getTransform$1 (controller) {
    return getTransform(controller.group)
  }

  function getGlobalDirection1 (controller, localDirName) {
    const map = {
      w: 'left',
      e: 'right',
      n: 'top',
      s: 'bottom'
    }
    const inverseMap = {
      left: 'w',
      right: 'e',
      top: 'n',
      bottom: 's'
    }
    const dir = transformDirection(map[localDirName], getTransform$1(controller))
    return inverseMap[dir]
  }

  function getGlobalDirection2 (controller, localDirNameSeq) {
    const globalDir = [getGlobalDirection1(controller, localDirNameSeq[0]), getGlobalDirection1(controller, localDirNameSeq[1])];
    (globalDir[0] === 'e' || globalDir[0] === 'w') && globalDir.reverse()
    return globalDir.join('')
  }

  function driftRect (rectRangeConverter, controller, cover, dirNameSequence, dx, dy) {
    const brushOption = cover.__brushOption
    const rectRange = rectRangeConverter.toRectRange(brushOption.range)
    const localDelta = toLocalDelta(controller, dx, dy)
    each(dirNameSequence, function (dirName) {
      const ind = DIRECTION_MAP[dirName]
      rectRange[ind[0]][ind[1]] += localDelta[ind[0]]
    })
    brushOption.range = rectRangeConverter.fromRectRange(formatRectRange(rectRange[0][0], rectRange[1][0], rectRange[0][1], rectRange[1][1]))
    updateCoverAfterCreation(controller, cover)
    trigger$1(controller, {
      isEnd: false
    })
  }

  function driftPolygon (controller, cover, dx, dy) {
    const range = cover.__brushOption.range
    const localDelta = toLocalDelta(controller, dx, dy)
    each(range, function (point) {
      point[0] += localDelta[0]
      point[1] += localDelta[1]
    })
    updateCoverAfterCreation(controller, cover)
    trigger$1(controller, {
      isEnd: false
    })
  }

  function toLocalDelta (controller, dx, dy) {
    const thisGroup = controller.group
    const localD = thisGroup.transformCoordToLocal(dx, dy)
    const localZero = thisGroup.transformCoordToLocal(0, 0)
    return [localD[0] - localZero[0], localD[1] - localZero[1]]
  }

  function clipByPanel (controller, cover, data) {
    const panel = getPanelByCover(controller, cover)
    return panel && panel !== BRUSH_PANEL_GLOBAL ? panel.clipPath(data, controller._transform) : clone(data)
  }

  function pointsToRect (points) {
    const xmin = mathMin$9(points[0][0], points[1][0])
    const ymin = mathMin$9(points[0][1], points[1][1])
    const xmax = mathMax$9(points[0][0], points[1][0])
    const ymax = mathMax$9(points[0][1], points[1][1])
    return {
      x: xmin,
      y: ymin,
      width: xmax - xmin,
      height: ymax - ymin
    }
  }

  function resetCursor (controller, e, localCursorPoint) {
    if ( // Check active
      !controller._brushType || // resetCursor should be always called when mouse is in zr area,
      // but not called when mouse is out of zr area to avoid bad influence
      // if `mousemove`, `mouseup` are triggered from `document` event.
      isOutsideZrArea(controller, e.offsetX, e.offsetY)) {
      return
    }

    const zr = controller._zr
    const covers = controller._covers
    const currPanel = getPanelByPoint(controller, e, localCursorPoint) // Check whether in covers.

    if (!controller._dragging) {
      for (let i = 0; i < covers.length; i++) {
        const brushOption = covers[i].__brushOption

        if (currPanel && (currPanel === BRUSH_PANEL_GLOBAL || brushOption.panelId === currPanel.panelId) && coverRenderers[brushOption.brushType].contain(covers[i], localCursorPoint[0], localCursorPoint[1])) {
          // Use cursor style set on cover.
          return
        }
      }
    }

    currPanel && zr.setCursorStyle('crosshair')
  }

  function preventDefault (e) {
    const rawE = e.event
    rawE.preventDefault && rawE.preventDefault()
  }

  function mainShapeContain (cover, x, y) {
    return cover.childOfName('main').contain(x, y)
  }

  function updateCoverByMouse (controller, e, localCursorPoint, isEnd) {
    let creatingCover = controller._creatingCover
    const panel = controller._creatingPanel
    const thisBrushOption = controller._brushOption
    let eventParams

    controller._track.push(localCursorPoint.slice())

    if (shouldShowCover(controller) || creatingCover) {
      if (panel && !creatingCover) {
        thisBrushOption.brushMode === 'single' && clearCovers(controller)
        const brushOption = clone(thisBrushOption)
        brushOption.brushType = determineBrushType(brushOption.brushType, panel)
        brushOption.panelId = panel === BRUSH_PANEL_GLOBAL ? null : panel.panelId
        creatingCover = controller._creatingCover = createCover(controller, brushOption)

        controller._covers.push(creatingCover)
      }

      if (creatingCover) {
        const coverRenderer = coverRenderers[determineBrushType(controller._brushType, panel)]
        const coverBrushOption = creatingCover.__brushOption
        coverBrushOption.range = coverRenderer.getCreatingRange(clipByPanel(controller, creatingCover, controller._track))

        if (isEnd) {
          endCreating(controller, creatingCover)
          coverRenderer.updateCommon(controller, creatingCover)
        }

        updateCoverShape(controller, creatingCover)
        eventParams = {
          isEnd: isEnd
        }
      }
    } else if (isEnd && thisBrushOption.brushMode === 'single' && thisBrushOption.removeOnClick) {
      // Help user to remove covers easily, only by a tiny drag, in 'single' mode.
      // But a single click do not clear covers, because user may have casual
      // clicks (for example, click on other component and do not expect covers
      // disappear).
      // Only some cover removed, trigger action, but not every click trigger action.
      if (getPanelByPoint(controller, e, localCursorPoint) && clearCovers(controller)) {
        eventParams = {
          isEnd: isEnd,
          removeOnClick: true
        }
      }
    }

    return eventParams
  }

  function determineBrushType (brushType, panel) {
    if (brushType === 'auto') {
      if ('development' !== 'production') {
        assert(panel && panel.defaultBrushType, 'MUST have defaultBrushType when brushType is "atuo"')
      }

      return panel.defaultBrushType
    }

    return brushType
  }

  var pointerHandlers = {
    mousedown: function (e) {
      if (this._dragging) {
        // In case some browser do not support globalOut,
        // and release mouse out side the browser.
        handleDragEnd(this, e)
      } else if (!e.target || !e.target.draggable) {
        preventDefault(e)
        const localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY)
        this._creatingCover = null
        const panel = this._creatingPanel = getPanelByPoint(this, e, localCursorPoint)

        if (panel) {
          this._dragging = true
          this._track = [localCursorPoint.slice()]
        }
      }
    },
    mousemove: function (e) {
      const x = e.offsetX
      const y = e.offsetY
      const localCursorPoint = this.group.transformCoordToLocal(x, y)
      resetCursor(this, e, localCursorPoint)

      if (this._dragging) {
        preventDefault(e)
        const eventParams = updateCoverByMouse(this, e, localCursorPoint, false)
        eventParams && trigger$1(this, eventParams)
      }
    },
    mouseup: function (e) {
      handleDragEnd(this, e)
    }
  }

  function handleDragEnd (controller, e) {
    if (controller._dragging) {
      preventDefault(e)
      const x = e.offsetX
      const y = e.offsetY
      const localCursorPoint = controller.group.transformCoordToLocal(x, y)
      const eventParams = updateCoverByMouse(controller, e, localCursorPoint, true)
      controller._dragging = false
      controller._track = []
      controller._creatingCover = null // trigger event shoule be at final, after procedure will be nested.

      eventParams && trigger$1(controller, eventParams)
    }
  }

  function isOutsideZrArea (controller, x, y) {
    const zr = controller._zr
    return x < 0 || x > zr.getWidth() || y < 0 || y > zr.getHeight()
  }
  /**
     * key: brushType
     */

  var coverRenderers = {
    lineX: getLineRenderer(0),
    lineY: getLineRenderer(1),
    rect: {
      createCover: function (controller, brushOption) {
        function returnInput (range) {
          return range
        }

        return createBaseRectCover({
          toRectRange: returnInput,
          fromRectRange: returnInput
        }, controller, brushOption, [['w'], ['e'], ['n'], ['s'], ['s', 'e'], ['s', 'w'], ['n', 'e'], ['n', 'w']])
      },
      getCreatingRange: function (localTrack) {
        const ends = getTrackEnds(localTrack)
        return formatRectRange(ends[1][0], ends[1][1], ends[0][0], ends[0][1])
      },
      updateCoverShape: function (controller, cover, localRange, brushOption) {
        updateBaseRect(controller, cover, localRange, brushOption)
      },
      updateCommon: updateCommon,
      contain: mainShapeContain
    },
    polygon: {
      createCover: function (controller, brushOption) {
        const cover = new Group() // Do not use graphic.Polygon because graphic.Polyline do not close the
        // border of the shape when drawing, which is a better experience for user.

        cover.add(new Polyline({
          name: 'main',
          style: makeStyle(brushOption),
          silent: true
        }))
        return cover
      },
      getCreatingRange: function (localTrack) {
        return localTrack
      },
      endCreating: function (controller, cover) {
        cover.remove(cover.childAt(0)) // Use graphic.Polygon close the shape.

        cover.add(new Polygon({
          name: 'main',
          draggable: true,
          drift: curry(driftPolygon, controller, cover),
          ondragend: curry(trigger$1, controller, {
            isEnd: true
          })
        }))
      },
      updateCoverShape: function (controller, cover, localRange, brushOption) {
        cover.childAt(0).setShape({
          points: clipByPanel(controller, cover, localRange)
        })
      },
      updateCommon: updateCommon,
      contain: mainShapeContain
    }
  }

  function getLineRenderer (xyIndex) {
    return {
      createCover: function (controller, brushOption) {
        return createBaseRectCover({
          toRectRange: function (range) {
            const rectRange = [range, [0, 100]]
            xyIndex && rectRange.reverse()
            return rectRange
          },
          fromRectRange: function (rectRange) {
            return rectRange[xyIndex]
          }
        }, controller, brushOption, [[['w'], ['e']], [['n'], ['s']]][xyIndex])
      },
      getCreatingRange: function (localTrack) {
        const ends = getTrackEnds(localTrack)
        const min = mathMin$9(ends[0][xyIndex], ends[1][xyIndex])
        const max = mathMax$9(ends[0][xyIndex], ends[1][xyIndex])
        return [min, max]
      },
      updateCoverShape: function (controller, cover, localRange, brushOption) {
        let otherExtent // If brushWidth not specified, fit the panel.

        const panel = getPanelByCover(controller, cover)

        if (panel !== BRUSH_PANEL_GLOBAL && panel.getLinearBrushOtherExtent) {
          otherExtent = panel.getLinearBrushOtherExtent(xyIndex)
        } else {
          const zr = controller._zr
          otherExtent = [0, [zr.getWidth(), zr.getHeight()][1 - xyIndex]]
        }

        const rectRange = [localRange, otherExtent]
        xyIndex && rectRange.reverse()
        updateBaseRect(controller, cover, rectRange, brushOption)
      },
      updateCommon: updateCommon,
      contain: mainShapeContain
    }
  }

  function makeRectPanelClipPath (rect) {
    rect = normalizeRect(rect)
    return function (localPoints) {
      return clipPointsByRect(localPoints, rect)
    }
  }
  function makeLinearBrushOtherExtent (rect, specifiedXYIndex) {
    rect = normalizeRect(rect)
    return function (xyIndex) {
      const idx = specifiedXYIndex != null ? specifiedXYIndex : xyIndex
      const brushWidth = idx ? rect.width : rect.height
      const base = idx ? rect.x : rect.y
      return [base, base + (brushWidth || 0)]
    }
  }
  function makeRectIsTargetByCursor (rect, api, targetModel) {
    const boundingRect = normalizeRect(rect)
    return function (e, localCursorPoint) {
      return boundingRect.contain(localCursorPoint[0], localCursorPoint[1]) && !onIrrelevantElement(e, api, targetModel)
    }
  } // Consider width/height is negative.

  function normalizeRect (rect) {
    return BoundingRect.create(rect)
  }

  const elementList = ['axisLine', 'axisTickLabel', 'axisName']

  const ParallelAxisView =
    /** @class */
    (function (_super) {
      __extends(ParallelAxisView, _super)

      function ParallelAxisView () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = ParallelAxisView.type
        return _this
      }

      ParallelAxisView.prototype.init = function (ecModel, api) {
        _super.prototype.init.apply(this, arguments);

        (this._brushController = new BrushController(api.getZr())).on('brush', bind(this._onBrush, this))
      }

      ParallelAxisView.prototype.render = function (axisModel, ecModel, api, payload) {
        if (fromAxisAreaSelect(axisModel, ecModel, payload)) {
          return
        }

        this.axisModel = axisModel
        this.api = api
        this.group.removeAll()
        const oldAxisGroup = this._axisGroup
        this._axisGroup = new Group()
        this.group.add(this._axisGroup)

        if (!axisModel.get('show')) {
          return
        }

        const coordSysModel = getCoordSysModel(axisModel, ecModel)
        const coordSys = coordSysModel.coordinateSystem
        const areaSelectStyle = axisModel.getAreaSelectStyle()
        const areaWidth = areaSelectStyle.width
        const dim = axisModel.axis.dim
        const axisLayout = coordSys.getAxisLayout(dim)
        const builderOpt = extend({
          strokeContainThreshold: areaWidth
        }, axisLayout)
        const axisBuilder = new AxisBuilder(axisModel, builderOpt)
        each(elementList, axisBuilder.add, axisBuilder)

        this._axisGroup.add(axisBuilder.getGroup())

        this._refreshBrushController(builderOpt, areaSelectStyle, axisModel, coordSysModel, areaWidth, api)

        groupTransition(oldAxisGroup, this._axisGroup, axisModel)
      } // /**
      //  * @override
      //  */
      // updateVisual(axisModel, ecModel, api, payload) {
      //     this._brushController && this._brushController
      //         .updateCovers(getCoverInfoList(axisModel));
      // }

      ParallelAxisView.prototype._refreshBrushController = function (builderOpt, areaSelectStyle, axisModel, coordSysModel, areaWidth, api) {
        // After filtering, axis may change, select area needs to be update.
        const extent = axisModel.axis.getExtent()
        const extentLen = extent[1] - extent[0]
        const extra = Math.min(30, Math.abs(extentLen) * 0.1) // Arbitrary value.
        // width/height might be negative, which will be
        // normalized in BoundingRect.

        const rect = BoundingRect.create({
          x: extent[0],
          y: -areaWidth / 2,
          width: extentLen,
          height: areaWidth
        })
        rect.x -= extra
        rect.width += 2 * extra

        this._brushController.mount({
          enableGlobalPan: true,
          rotation: builderOpt.rotation,
          x: builderOpt.position[0],
          y: builderOpt.position[1]
        }).setPanels([{
          panelId: 'pl',
          clipPath: makeRectPanelClipPath(rect),
          isTargetByCursor: makeRectIsTargetByCursor(rect, api, coordSysModel),
          getLinearBrushOtherExtent: makeLinearBrushOtherExtent(rect, 0)
        }]).enableBrush({
          brushType: 'lineX',
          brushStyle: areaSelectStyle,
          removeOnClick: true
        }).updateCovers(getCoverInfoList(axisModel))
      }

      ParallelAxisView.prototype._onBrush = function (eventParam) {
        const coverInfoList = eventParam.areas // Do not cache these object, because the mey be changed.

        const axisModel = this.axisModel
        const axis = axisModel.axis
        const intervals = map(coverInfoList, function (coverInfo) {
          return [axis.coordToData(coverInfo.range[0], true), axis.coordToData(coverInfo.range[1], true)]
        }) // If realtime is true, action is not dispatched on drag end, because
        // the drag end emits the same params with the last drag move event,
        // and may have some delay when using touch pad.

        if (!axisModel.option.realtime === eventParam.isEnd || eventParam.removeOnClick) {
          // jshint ignore:line
          this.api.dispatchAction({
            type: 'axisAreaSelect',
            parallelAxisId: axisModel.id,
            intervals: intervals
          })
        }
      }

      ParallelAxisView.prototype.dispose = function () {
        this._brushController.dispose()
      }

      ParallelAxisView.type = 'parallelAxis'
      return ParallelAxisView
    }(ComponentView))

  function fromAxisAreaSelect (axisModel, ecModel, payload) {
    return payload && payload.type === 'axisAreaSelect' && ecModel.findComponents({
      mainType: 'parallelAxis',
      query: payload
    })[0] === axisModel
  }

  function getCoverInfoList (axisModel) {
    const axis = axisModel.axis
    return map(axisModel.activeIntervals, function (interval) {
      return {
        brushType: 'lineX',
        panelId: 'pl',
        range: [axis.dataToCoord(interval[0], true), axis.dataToCoord(interval[1], true)]
      }
    })
  }

  function getCoordSysModel (axisModel, ecModel) {
    return ecModel.getComponent('parallel', axisModel.get('parallelIndex'))
  }

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

  /**
     * AUTO-GENERATED FILE. DO NOT MODIFY.
     */

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
  const actionInfo$1 = {
    type: 'axisAreaSelect',
    event: 'axisAreaSelected' // update: 'updateVisual'

  }
  function installParallelActions (registers) {
    registers.registerAction(actionInfo$1, function (payload, ecModel) {
      ecModel.eachComponent({
        mainType: 'parallelAxis',
        query: payload
      }, function (parallelAxisModel) {
        parallelAxisModel.axis.model.setActiveIntervals(payload.intervals)
      })
    })
    /**
       * @payload
       */

    registers.registerAction('parallelAxisExpand', function (payload, ecModel) {
      ecModel.eachComponent({
        mainType: 'parallel',
        query: payload
      }, function (parallelModel) {
        parallelModel.setAxisExpand(payload)
      })
    })
  }

  const defaultAxisOption = {
    type: 'value',
    areaSelectStyle: {
      width: 20,
      borderWidth: 1,
      borderColor: 'rgba(160,197,232)',
      color: 'rgba(160,197,232)',
      opacity: 0.3
    },
    realtime: true,
    z: 10
  }
  function install$g (registers) {
    registers.registerComponentView(ParallelView$1)
    registers.registerComponentModel(ParallelModel)
    registers.registerCoordinateSystem('parallel', parallelCoordSysCreator)
    registers.registerPreprocessor(parallelPreprocessor)
    registers.registerComponentModel(ParallelAxisModel)
    registers.registerComponentView(ParallelAxisView)
    axisModelCreator(registers, 'parallel', ParallelAxisModel, defaultAxisOption)
    installParallelActions(registers)
  }

  function install$h (registers) {
    use(install$g)
    registers.registerChartView(ParallelView)
    registers.registerSeriesModel(ParallelSeriesModel)
    registers.registerVisual(registers.PRIORITY.VISUAL.BRUSH, parallelVisual)
  }

  const SankeyPathShape =
    /** @class */
    (function () {
      function SankeyPathShape () {
        this.x1 = 0
        this.y1 = 0
        this.x2 = 0
        this.y2 = 0
        this.cpx1 = 0
        this.cpy1 = 0
        this.cpx2 = 0
        this.cpy2 = 0
        this.extent = 0
      }

      return SankeyPathShape
    }())

  const SankeyPath =
    /** @class */
    (function (_super) {
      __extends(SankeyPath, _super)

      function SankeyPath (opts) {
        return _super.call(this, opts) || this
      }

      SankeyPath.prototype.getDefaultShape = function () {
        return new SankeyPathShape()
      }

      SankeyPath.prototype.buildPath = function (ctx, shape) {
        const extent = shape.extent
        ctx.moveTo(shape.x1, shape.y1)
        ctx.bezierCurveTo(shape.cpx1, shape.cpy1, shape.cpx2, shape.cpy2, shape.x2, shape.y2)

        if (shape.orient === 'vertical') {
          ctx.lineTo(shape.x2 + extent, shape.y2)
          ctx.bezierCurveTo(shape.cpx2 + extent, shape.cpy2, shape.cpx1 + extent, shape.cpy1, shape.x1 + extent, shape.y1)
        } else {
          ctx.lineTo(shape.x2, shape.y2 + extent)
          ctx.bezierCurveTo(shape.cpx2, shape.cpy2 + extent, shape.cpx1, shape.cpy1 + extent, shape.x1, shape.y1 + extent)
        }

        ctx.closePath()
      }

      SankeyPath.prototype.highlight = function () {
        enterEmphasis(this)
      }

      SankeyPath.prototype.downplay = function () {
        leaveEmphasis(this)
      }

      return SankeyPath
    }(Path))

  const SankeyView =
    /** @class */
    (function (_super) {
      __extends(SankeyView, _super)

      function SankeyView () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = SankeyView.type
        _this._focusAdjacencyDisabled = false
        return _this
      }

      SankeyView.prototype.render = function (seriesModel, ecModel, api) {
        const sankeyView = this
        const graph = seriesModel.getGraph()
        const group = this.group
        const layoutInfo = seriesModel.layoutInfo // view width

        const width = layoutInfo.width // view height

        const height = layoutInfo.height
        const nodeData = seriesModel.getData()
        const edgeData = seriesModel.getData('edge')
        const orient = seriesModel.get('orient')
        this._model = seriesModel
        group.removeAll()
        group.x = layoutInfo.x
        group.y = layoutInfo.y // generate a bezire Curve for each edge

        graph.eachEdge(function (edge) {
          const curve = new SankeyPath()
          const ecData = getECData(curve)
          ecData.dataIndex = edge.dataIndex
          ecData.seriesIndex = seriesModel.seriesIndex
          ecData.dataType = 'edge'
          const edgeModel = edge.getModel()
          const lineStyleModel = edgeModel.getModel('lineStyle')
          const curvature = lineStyleModel.get('curveness')
          const n1Layout = edge.node1.getLayout()
          const node1Model = edge.node1.getModel()
          const dragX1 = node1Model.get('localX')
          const dragY1 = node1Model.get('localY')
          const n2Layout = edge.node2.getLayout()
          const node2Model = edge.node2.getModel()
          const dragX2 = node2Model.get('localX')
          const dragY2 = node2Model.get('localY')
          const edgeLayout = edge.getLayout()
          let x1
          let y1
          let x2
          let y2
          let cpx1
          let cpy1
          let cpx2
          let cpy2
          curve.shape.extent = Math.max(1, edgeLayout.dy)
          curve.shape.orient = orient

          if (orient === 'vertical') {
            x1 = (dragX1 != null ? dragX1 * width : n1Layout.x) + edgeLayout.sy
            y1 = (dragY1 != null ? dragY1 * height : n1Layout.y) + n1Layout.dy
            x2 = (dragX2 != null ? dragX2 * width : n2Layout.x) + edgeLayout.ty
            y2 = dragY2 != null ? dragY2 * height : n2Layout.y
            cpx1 = x1
            cpy1 = y1 * (1 - curvature) + y2 * curvature
            cpx2 = x2
            cpy2 = y1 * curvature + y2 * (1 - curvature)
          } else {
            x1 = (dragX1 != null ? dragX1 * width : n1Layout.x) + n1Layout.dx
            y1 = (dragY1 != null ? dragY1 * height : n1Layout.y) + edgeLayout.sy
            x2 = dragX2 != null ? dragX2 * width : n2Layout.x
            y2 = (dragY2 != null ? dragY2 * height : n2Layout.y) + edgeLayout.ty
            cpx1 = x1 * (1 - curvature) + x2 * curvature
            cpy1 = y1
            cpx2 = x1 * curvature + x2 * (1 - curvature)
            cpy2 = y2
          }

          curve.setShape({
            x1: x1,
            y1: y1,
            x2: x2,
            y2: y2,
            cpx1: cpx1,
            cpy1: cpy1,
            cpx2: cpx2,
            cpy2: cpy2
          })
          curve.useStyle(lineStyleModel.getItemStyle()) // Special color, use source node color or target node color

          switch (curve.style.fill) {
            case 'source':
              curve.style.fill = edge.node1.getVisual('color')
              curve.style.decal = edge.node1.getVisual('style').decal
              break

            case 'target':
              curve.style.fill = edge.node2.getVisual('color')
              curve.style.decal = edge.node2.getVisual('style').decal
              break

            case 'gradient':
              var sourceColor = edge.node1.getVisual('color')
              var targetColor = edge.node2.getVisual('color')

              if (isString(sourceColor) && isString(targetColor)) {
                curve.style.fill = new LinearGradient(0, 0, +(orient === 'horizontal'), +(orient === 'vertical'), [{
                  color: sourceColor,
                  offset: 0
                }, {
                  color: targetColor,
                  offset: 1
                }])
              }
          }

          const emphasisModel = edgeModel.getModel('emphasis')
          setStatesStylesFromModel(curve, edgeModel, 'lineStyle', function (model) {
            return model.getItemStyle()
          })
          group.add(curve)
          edgeData.setItemGraphicEl(edge.dataIndex, curve)
          const focus = emphasisModel.get('focus')
          toggleHoverEmphasis(curve, focus === 'adjacency' ? edge.getAdjacentDataIndices() : focus, emphasisModel.get('blurScope'), emphasisModel.get('disabled'))
          getECData(curve).dataType = 'edge'
        }) // Generate a rect for each node

        graph.eachNode(function (node) {
          const layout = node.getLayout()
          const itemModel = node.getModel()
          const dragX = itemModel.get('localX')
          const dragY = itemModel.get('localY')
          const emphasisModel = itemModel.getModel('emphasis')
          const rect = new Rect({
            shape: {
              x: dragX != null ? dragX * width : layout.x,
              y: dragY != null ? dragY * height : layout.y,
              width: layout.dx,
              height: layout.dy
            },
            style: itemModel.getModel('itemStyle').getItemStyle(),
            z2: 10
          })
          setLabelStyle(rect, getLabelStatesModels(itemModel), {
            labelFetcher: seriesModel,
            labelDataIndex: node.dataIndex,
            defaultText: node.id
          })
          rect.disableLabelAnimation = true
          rect.setStyle('fill', node.getVisual('color'))
          rect.setStyle('decal', node.getVisual('style').decal)
          setStatesStylesFromModel(rect, itemModel)
          group.add(rect)
          nodeData.setItemGraphicEl(node.dataIndex, rect)
          getECData(rect).dataType = 'node'
          const focus = emphasisModel.get('focus')
          toggleHoverEmphasis(rect, focus === 'adjacency' ? node.getAdjacentDataIndices() : focus, emphasisModel.get('blurScope'), emphasisModel.get('disabled'))
        })
        nodeData.eachItemGraphicEl(function (el, dataIndex) {
          const itemModel = nodeData.getItemModel(dataIndex)

          if (itemModel.get('draggable')) {
            el.drift = function (dx, dy) {
              sankeyView._focusAdjacencyDisabled = true
              this.shape.x += dx
              this.shape.y += dy
              this.dirty()
              api.dispatchAction({
                type: 'dragNode',
                seriesId: seriesModel.id,
                dataIndex: nodeData.getRawIndex(dataIndex),
                localX: this.shape.x / width,
                localY: this.shape.y / height
              })
            }

            el.ondragend = function () {
              sankeyView._focusAdjacencyDisabled = false
            }

            el.draggable = true
            el.cursor = 'move'
          }
        })

        if (!this._data && seriesModel.isAnimationEnabled()) {
          group.setClipPath(createGridClipShape$1(group.getBoundingRect(), seriesModel, function () {
            group.removeClipPath()
          }))
        }

        this._data = seriesModel.getData()
      }

      SankeyView.prototype.dispose = function () {}

      SankeyView.type = 'sankey'
      return SankeyView
    }(ChartView)) // Add animation to the view

  function createGridClipShape$1 (rect, seriesModel, cb) {
    const rectEl = new Rect({
      shape: {
        x: rect.x - 10,
        y: rect.y - 10,
        width: 0,
        height: rect.height + 20
      }
    })
    initProps(rectEl, {
      shape: {
        width: rect.width + 20
      }
    }, seriesModel, cb)
    return rectEl
  }

  const SankeySeriesModel =
    /** @class */
    (function (_super) {
      __extends(SankeySeriesModel, _super)

      function SankeySeriesModel () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = SankeySeriesModel.type
        return _this
      }
      /**
       * Init a graph data structure from data in option series
       */

      SankeySeriesModel.prototype.getInitialData = function (option, ecModel) {
        const links = option.edges || option.links
        const nodes = option.data || option.nodes
        const levels = option.levels
        this.levelModels = []
        const levelModels = this.levelModels

        for (let i = 0; i < levels.length; i++) {
          if (levels[i].depth != null && levels[i].depth >= 0) {
            levelModels[levels[i].depth] = new Model(levels[i], this, ecModel)
          } else {
            if ('development' !== 'production') {
              throw new Error('levels[i].depth is mandatory and should be natural number')
            }
          }
        }

        if (nodes && links) {
          const graph = createGraphFromNodeEdge(nodes, links, this, true, beforeLink)
          return graph.data
        }

        function beforeLink (nodeData, edgeData) {
          nodeData.wrapMethod('getItemModel', function (model, idx) {
            const seriesModel = model.parentModel
            const layout = seriesModel.getData().getItemLayout(idx)

            if (layout) {
              const nodeDepth = layout.depth
              const levelModel = seriesModel.levelModels[nodeDepth]

              if (levelModel) {
                model.parentModel = levelModel
              }
            }

            return model
          })
          edgeData.wrapMethod('getItemModel', function (model, idx) {
            const seriesModel = model.parentModel
            const edge = seriesModel.getGraph().getEdgeByIndex(idx)
            const layout = edge.node1.getLayout()

            if (layout) {
              const depth = layout.depth
              const levelModel = seriesModel.levelModels[depth]

              if (levelModel) {
                model.parentModel = levelModel
              }
            }

            return model
          })
        }
      }

      SankeySeriesModel.prototype.setNodePosition = function (dataIndex, localPosition) {
        const nodes = this.option.data || this.option.nodes
        const dataItem = nodes[dataIndex]
        dataItem.localX = localPosition[0]
        dataItem.localY = localPosition[1]
      }
      /**
       * Return the graphic data structure
       *
       * @return graphic data structure
       */

      SankeySeriesModel.prototype.getGraph = function () {
        return this.getData().graph
      }
      /**
       * Get edge data of graphic data structure
       *
       * @return data structure of list
       */

      SankeySeriesModel.prototype.getEdgeData = function () {
        return this.getGraph().edgeData
      }

      SankeySeriesModel.prototype.formatTooltip = function (dataIndex, multipleSeries, dataType) {
        function noValue (val) {
          return isNaN(val) || val == null
        } // dataType === 'node' or empty do not show tooltip by default

        if (dataType === 'edge') {
          const params = this.getDataParams(dataIndex, dataType)
          const rawDataOpt = params.data
          const edgeValue = params.value
          const edgeName = rawDataOpt.source + ' -- ' + rawDataOpt.target
          return createTooltipMarkup('nameValue', {
            name: edgeName,
            value: edgeValue,
            noValue: noValue(edgeValue)
          })
        } // dataType === 'node'
        else {
          const node = this.getGraph().getNodeByIndex(dataIndex)
          const value = node.getLayout().value
          const name_1 = this.getDataParams(dataIndex, dataType).data.name
          return createTooltipMarkup('nameValue', {
            name: name_1 != null ? name_1 + '' : null,
            value: value,
            noValue: noValue(value)
          })
        }
      }

      SankeySeriesModel.prototype.optionUpdated = function () {} // Override Series.getDataParams()

      SankeySeriesModel.prototype.getDataParams = function (dataIndex, dataType) {
        const params = _super.prototype.getDataParams.call(this, dataIndex, dataType)

        if (params.value == null && dataType === 'node') {
          const node = this.getGraph().getNodeByIndex(dataIndex)
          const nodeValue = node.getLayout().value
          params.value = nodeValue
        }

        return params
      }

      SankeySeriesModel.type = 'series.sankey'
      SankeySeriesModel.defaultOption = {
        // zlevel: 0,
        z: 2,
        coordinateSystem: 'view',
        left: '5%',
        top: '5%',
        right: '20%',
        bottom: '5%',
        orient: 'horizontal',
        nodeWidth: 20,
        nodeGap: 8,
        draggable: true,
        layoutIterations: 32,
        label: {
          show: true,
          position: 'right',
          fontSize: 12
        },
        levels: [],
        nodeAlign: 'justify',
        lineStyle: {
          color: '#314656',
          opacity: 0.2,
          curveness: 0.5
        },
        emphasis: {
          label: {
            show: true
          },
          lineStyle: {
            opacity: 0.5
          }
        },
        select: {
          itemStyle: {
            borderColor: '#212121'
          }
        },
        animationEasing: 'linear',
        animationDuration: 1000
      }
      return SankeySeriesModel
    }(SeriesModel))

  function sankeyLayout (ecModel, api) {
    ecModel.eachSeriesByType('sankey', function (seriesModel) {
      const nodeWidth = seriesModel.get('nodeWidth')
      const nodeGap = seriesModel.get('nodeGap')
      const layoutInfo = getViewRect$4(seriesModel, api)
      seriesModel.layoutInfo = layoutInfo
      const width = layoutInfo.width
      const height = layoutInfo.height
      const graph = seriesModel.getGraph()
      const nodes = graph.nodes
      const edges = graph.edges
      computeNodeValues(nodes)
      const filteredNodes = filter(nodes, function (node) {
        return node.getLayout().value === 0
      })
      const iterations = filteredNodes.length !== 0 ? 0 : seriesModel.get('layoutIterations')
      const orient = seriesModel.get('orient')
      const nodeAlign = seriesModel.get('nodeAlign')
      layoutSankey(nodes, edges, nodeWidth, nodeGap, width, height, iterations, orient, nodeAlign)
    })
  }
  /**
     * Get the layout position of the whole view
     */

  function getViewRect$4 (seriesModel, api) {
    return getLayoutRect(seriesModel.getBoxLayoutParams(), {
      width: api.getWidth(),
      height: api.getHeight()
    })
  }

  function layoutSankey (nodes, edges, nodeWidth, nodeGap, width, height, iterations, orient, nodeAlign) {
    computeNodeBreadths(nodes, edges, nodeWidth, width, height, orient, nodeAlign)
    computeNodeDepths(nodes, edges, height, width, nodeGap, iterations, orient)
    computeEdgeDepths(nodes, orient)
  }
  /**
     * Compute the value of each node by summing the associated edge's value
     */

  function computeNodeValues (nodes) {
    each(nodes, function (node) {
      const value1 = sum(node.outEdges, getEdgeValue)
      const value2 = sum(node.inEdges, getEdgeValue)
      const nodeRawValue = node.getValue() || 0
      const value = Math.max(value1, value2, nodeRawValue)
      node.setLayout({
        value: value
      }, true)
    })
  }
  /**
     * Compute the x-position for each node.
     *
     * Here we use Kahn algorithm to detect cycle when we traverse
     * the node to computer the initial x position.
     */

  function computeNodeBreadths (nodes, edges, nodeWidth, width, height, orient, nodeAlign) {
    // Used to mark whether the edge is deleted. if it is deleted,
    // the value is 0, otherwise it is 1.
    const remainEdges = [] // Storage each node's indegree.

    const indegreeArr = [] // Used to storage the node with indegree is equal to 0.

    let zeroIndegrees = []
    let nextTargetNode = []
    let x = 0 // let kx = 0;

    for (var i = 0; i < edges.length; i++) {
      remainEdges[i] = 1
    }

    for (var i = 0; i < nodes.length; i++) {
      indegreeArr[i] = nodes[i].inEdges.length

      if (indegreeArr[i] === 0) {
        zeroIndegrees.push(nodes[i])
      }
    }

    let maxNodeDepth = -1 // Traversing nodes using topological sorting to calculate the
    // horizontal(if orient === 'horizontal') or vertical(if orient === 'vertical')
    // position of the nodes.

    while (zeroIndegrees.length) {
      for (let idx = 0; idx < zeroIndegrees.length; idx++) {
        const node = zeroIndegrees[idx]
        const item = node.hostGraph.data.getRawDataItem(node.dataIndex)
        const isItemDepth = item.depth != null && item.depth >= 0

        if (isItemDepth && item.depth > maxNodeDepth) {
          maxNodeDepth = item.depth
        }

        node.setLayout({
          depth: isItemDepth ? item.depth : x
        }, true)
        orient === 'vertical'
          ? node.setLayout({
            dy: nodeWidth
          }, true)
          : node.setLayout({
            dx: nodeWidth
          }, true)

        for (let edgeIdx = 0; edgeIdx < node.outEdges.length; edgeIdx++) {
          const edge = node.outEdges[edgeIdx]
          const indexEdge = edges.indexOf(edge)
          remainEdges[indexEdge] = 0
          const targetNode = edge.node2
          const nodeIndex = nodes.indexOf(targetNode)

          if (--indegreeArr[nodeIndex] === 0 && nextTargetNode.indexOf(targetNode) < 0) {
            nextTargetNode.push(targetNode)
          }
        }
      }

      ++x
      zeroIndegrees = nextTargetNode
      nextTargetNode = []
    }

    for (var i = 0; i < remainEdges.length; i++) {
      if (remainEdges[i] === 1) {
        throw new Error('Sankey is a DAG, the original data has cycle!')
      }
    }

    const maxDepth = maxNodeDepth > x - 1 ? maxNodeDepth : x - 1

    if (nodeAlign && nodeAlign !== 'left') {
      adjustNodeWithNodeAlign(nodes, nodeAlign, orient, maxDepth)
    }

    const kx = orient === 'vertical' ? (height - nodeWidth) / maxDepth : (width - nodeWidth) / maxDepth
    scaleNodeBreadths(nodes, kx, orient)
  }

  function isNodeDepth (node) {
    const item = node.hostGraph.data.getRawDataItem(node.dataIndex)
    return item.depth != null && item.depth >= 0
  }

  function adjustNodeWithNodeAlign (nodes, nodeAlign, orient, maxDepth) {
    if (nodeAlign === 'right') {
      let nextSourceNode = []
      let remainNodes = nodes
      let nodeHeight = 0

      while (remainNodes.length) {
        for (let i = 0; i < remainNodes.length; i++) {
          const node = remainNodes[i]
          node.setLayout({
            skNodeHeight: nodeHeight
          }, true)

          for (let j = 0; j < node.inEdges.length; j++) {
            const edge = node.inEdges[j]

            if (nextSourceNode.indexOf(edge.node1) < 0) {
              nextSourceNode.push(edge.node1)
            }
          }
        }

        remainNodes = nextSourceNode
        nextSourceNode = []
        ++nodeHeight
      }

      each(nodes, function (node) {
        if (!isNodeDepth(node)) {
          node.setLayout({
            depth: Math.max(0, maxDepth - node.getLayout().skNodeHeight)
          }, true)
        }
      })
    } else if (nodeAlign === 'justify') {
      moveSinksRight(nodes, maxDepth)
    }
  }
  /**
     * All the node without outEgdes are assigned maximum x-position and
     *     be aligned in the last column.
     *
     * @param nodes.  node of sankey view.
     * @param maxDepth.  use to assign to node without outEdges as x-position.
     */

  function moveSinksRight (nodes, maxDepth) {
    each(nodes, function (node) {
      if (!isNodeDepth(node) && !node.outEdges.length) {
        node.setLayout({
          depth: maxDepth
        }, true)
      }
    })
  }
  /**
     * Scale node x-position to the width
     *
     * @param nodes  node of sankey view
     * @param kx   multiple used to scale nodes
     */

  function scaleNodeBreadths (nodes, kx, orient) {
    each(nodes, function (node) {
      const nodeDepth = node.getLayout().depth * kx
      orient === 'vertical'
        ? node.setLayout({
          y: nodeDepth
        }, true)
        : node.setLayout({
          x: nodeDepth
        }, true)
    })
  }
  /**
     * Using Gauss-Seidel iterations method to compute the node depth(y-position)
     *
     * @param nodes  node of sankey view
     * @param edges  edge of sankey view
     * @param height  the whole height of the area to draw the view
     * @param nodeGap  the vertical distance between two nodes
     *     in the same column.
     * @param iterations  the number of iterations for the algorithm
     */

  function computeNodeDepths (nodes, edges, height, width, nodeGap, iterations, orient) {
    const nodesByBreadth = prepareNodesByBreadth(nodes, orient)
    initializeNodeDepth(nodesByBreadth, edges, height, width, nodeGap, orient)
    resolveCollisions(nodesByBreadth, nodeGap, height, width, orient)

    for (let alpha = 1; iterations > 0; iterations--) {
      // 0.99 is a experience parameter, ensure that each iterations of
      // changes as small as possible.
      alpha *= 0.99
      relaxRightToLeft(nodesByBreadth, alpha, orient)
      resolveCollisions(nodesByBreadth, nodeGap, height, width, orient)
      relaxLeftToRight(nodesByBreadth, alpha, orient)
      resolveCollisions(nodesByBreadth, nodeGap, height, width, orient)
    }
  }

  function prepareNodesByBreadth (nodes, orient) {
    const nodesByBreadth = []
    const keyAttr = orient === 'vertical' ? 'y' : 'x'
    const groupResult = groupData(nodes, function (node) {
      return node.getLayout()[keyAttr]
    })
    groupResult.keys.sort(function (a, b) {
      return a - b
    })
    each(groupResult.keys, function (key) {
      nodesByBreadth.push(groupResult.buckets.get(key))
    })
    return nodesByBreadth
  }
  /**
     * Compute the original y-position for each node
     */

  function initializeNodeDepth (nodesByBreadth, edges, height, width, nodeGap, orient) {
    let minKy = Infinity
    each(nodesByBreadth, function (nodes) {
      const n = nodes.length
      let sum = 0
      each(nodes, function (node) {
        sum += node.getLayout().value
      })
      const ky = orient === 'vertical' ? (width - (n - 1) * nodeGap) / sum : (height - (n - 1) * nodeGap) / sum

      if (ky < minKy) {
        minKy = ky
      }
    })
    each(nodesByBreadth, function (nodes) {
      each(nodes, function (node, i) {
        const nodeDy = node.getLayout().value * minKy

        if (orient === 'vertical') {
          node.setLayout({
            x: i
          }, true)
          node.setLayout({
            dx: nodeDy
          }, true)
        } else {
          node.setLayout({
            y: i
          }, true)
          node.setLayout({
            dy: nodeDy
          }, true)
        }
      })
    })
    each(edges, function (edge) {
      const edgeDy = +edge.getValue() * minKy
      edge.setLayout({
        dy: edgeDy
      }, true)
    })
  }
  /**
     * Resolve the collision of initialized depth (y-position)
     */

  function resolveCollisions (nodesByBreadth, nodeGap, height, width, orient) {
    const keyAttr = orient === 'vertical' ? 'x' : 'y'
    each(nodesByBreadth, function (nodes) {
      nodes.sort(function (a, b) {
        return a.getLayout()[keyAttr] - b.getLayout()[keyAttr]
      })
      let nodeX
      let node
      let dy
      let y0 = 0
      const n = nodes.length
      const nodeDyAttr = orient === 'vertical' ? 'dx' : 'dy'

      for (var i = 0; i < n; i++) {
        node = nodes[i]
        dy = y0 - node.getLayout()[keyAttr]

        if (dy > 0) {
          nodeX = node.getLayout()[keyAttr] + dy
          orient === 'vertical'
            ? node.setLayout({
              x: nodeX
            }, true)
            : node.setLayout({
              y: nodeX
            }, true)
        }

        y0 = node.getLayout()[keyAttr] + node.getLayout()[nodeDyAttr] + nodeGap
      }

      const viewWidth = orient === 'vertical' ? width : height // If the bottommost node goes outside the bounds, push it back up

      dy = y0 - nodeGap - viewWidth

      if (dy > 0) {
        nodeX = node.getLayout()[keyAttr] - dy
        orient === 'vertical'
          ? node.setLayout({
            x: nodeX
          }, true)
          : node.setLayout({
            y: nodeX
          }, true)
        y0 = nodeX

        for (var i = n - 2; i >= 0; --i) {
          node = nodes[i]
          dy = node.getLayout()[keyAttr] + node.getLayout()[nodeDyAttr] + nodeGap - y0

          if (dy > 0) {
            nodeX = node.getLayout()[keyAttr] - dy
            orient === 'vertical'
              ? node.setLayout({
                x: nodeX
              }, true)
              : node.setLayout({
                y: nodeX
              }, true)
          }

          y0 = node.getLayout()[keyAttr]
        }
      }
    })
  }
  /**
     * Change the y-position of the nodes, except most the right side nodes
     * @param nodesByBreadth
     * @param alpha  parameter used to adjust the nodes y-position
     */

  function relaxRightToLeft (nodesByBreadth, alpha, orient) {
    each(nodesByBreadth.slice().reverse(), function (nodes) {
      each(nodes, function (node) {
        if (node.outEdges.length) {
          let y = sum(node.outEdges, weightedTarget, orient) / sum(node.outEdges, getEdgeValue)

          if (isNaN(y)) {
            const len = node.outEdges.length
            y = len ? sum(node.outEdges, centerTarget, orient) / len : 0
          }

          if (orient === 'vertical') {
            const nodeX = node.getLayout().x + (y - center$1(node, orient)) * alpha
            node.setLayout({
              x: nodeX
            }, true)
          } else {
            const nodeY = node.getLayout().y + (y - center$1(node, orient)) * alpha
            node.setLayout({
              y: nodeY
            }, true)
          }
        }
      })
    })
  }

  function weightedTarget (edge, orient) {
    return center$1(edge.node2, orient) * edge.getValue()
  }

  function centerTarget (edge, orient) {
    return center$1(edge.node2, orient)
  }

  function weightedSource (edge, orient) {
    return center$1(edge.node1, orient) * edge.getValue()
  }

  function centerSource (edge, orient) {
    return center$1(edge.node1, orient)
  }

  function center$1 (node, orient) {
    return orient === 'vertical' ? node.getLayout().x + node.getLayout().dx / 2 : node.getLayout().y + node.getLayout().dy / 2
  }

  function getEdgeValue (edge) {
    return edge.getValue()
  }

  function sum (array, cb, orient) {
    let sum = 0
    const len = array.length
    let i = -1

    while (++i < len) {
      const value = +cb(array[i], orient)

      if (!isNaN(value)) {
        sum += value
      }
    }

    return sum
  }
  /**
     * Change the y-position of the nodes, except most the left side nodes
     */

  function relaxLeftToRight (nodesByBreadth, alpha, orient) {
    each(nodesByBreadth, function (nodes) {
      each(nodes, function (node) {
        if (node.inEdges.length) {
          let y = sum(node.inEdges, weightedSource, orient) / sum(node.inEdges, getEdgeValue)

          if (isNaN(y)) {
            const len = node.inEdges.length
            y = len ? sum(node.inEdges, centerSource, orient) / len : 0
          }

          if (orient === 'vertical') {
            const nodeX = node.getLayout().x + (y - center$1(node, orient)) * alpha
            node.setLayout({
              x: nodeX
            }, true)
          } else {
            const nodeY = node.getLayout().y + (y - center$1(node, orient)) * alpha
            node.setLayout({
              y: nodeY
            }, true)
          }
        }
      })
    })
  }
  /**
     * Compute the depth(y-position) of each edge
     */

  function computeEdgeDepths (nodes, orient) {
    const keyAttr = orient === 'vertical' ? 'x' : 'y'
    each(nodes, function (node) {
      node.outEdges.sort(function (a, b) {
        return a.node2.getLayout()[keyAttr] - b.node2.getLayout()[keyAttr]
      })
      node.inEdges.sort(function (a, b) {
        return a.node1.getLayout()[keyAttr] - b.node1.getLayout()[keyAttr]
      })
    })
    each(nodes, function (node) {
      let sy = 0
      let ty = 0
      each(node.outEdges, function (edge) {
        edge.setLayout({
          sy: sy
        }, true)
        sy += edge.getLayout().dy
      })
      each(node.inEdges, function (edge) {
        edge.setLayout({
          ty: ty
        }, true)
        ty += edge.getLayout().dy
      })
    })
  }

  function sankeyVisual (ecModel) {
    ecModel.eachSeriesByType('sankey', function (seriesModel) {
      const graph = seriesModel.getGraph()
      const nodes = graph.nodes

      if (nodes.length) {
        let minValue_1 = Infinity
        let maxValue_1 = -Infinity
        each(nodes, function (node) {
          const nodeValue = node.getLayout().value

          if (nodeValue < minValue_1) {
            minValue_1 = nodeValue
          }

          if (nodeValue > maxValue_1) {
            maxValue_1 = nodeValue
          }
        })
        each(nodes, function (node) {
          const mapping = new VisualMapping({
            type: 'color',
            mappingMethod: 'linear',
            dataExtent: [minValue_1, maxValue_1],
            visual: seriesModel.get('color')
          })
          const mapValueToColor = mapping.mapValueToVisual(node.getLayout().value)
          const customColor = node.getModel().get(['itemStyle', 'color'])

          if (customColor != null) {
            node.setVisual('color', customColor)
            node.setVisual('style', {
              fill: customColor
            })
          } else {
            node.setVisual('color', mapValueToColor)
            node.setVisual('style', {
              fill: mapValueToColor
            })
          }
        })
      }
    })
  }

  function install$i (registers) {
    registers.registerChartView(SankeyView)
    registers.registerSeriesModel(SankeySeriesModel)
    registers.registerLayout(sankeyLayout)
    registers.registerVisual(sankeyVisual)
    registers.registerAction({
      type: 'dragNode',
      event: 'dragnode',
      // here can only use 'update' now, other value is not support in echarts.
      update: 'update'
    }, function (payload, ecModel) {
      ecModel.eachComponent({
        mainType: 'series',
        subType: 'sankey',
        query: payload
      }, function (seriesModel) {
        seriesModel.setNodePosition(payload.dataIndex, [payload.localX, payload.localY])
      })
    })
  }

  const WhiskerBoxCommonMixin =
    /** @class */
    (function () {
      function WhiskerBoxCommonMixin () {}
      /**
       * @override
       */

      WhiskerBoxCommonMixin.prototype.getInitialData = function (option, ecModel) {
        // When both types of xAxis and yAxis are 'value', layout is
        // needed to be specified by user. Otherwise, layout can be
        // judged by which axis is category.
        let ordinalMeta
        const xAxisModel = ecModel.getComponent('xAxis', this.get('xAxisIndex'))
        const yAxisModel = ecModel.getComponent('yAxis', this.get('yAxisIndex'))
        const xAxisType = xAxisModel.get('type')
        const yAxisType = yAxisModel.get('type')
        let addOrdinal // FIXME
        // Consider time axis.

        if (xAxisType === 'category') {
          option.layout = 'horizontal'
          ordinalMeta = xAxisModel.getOrdinalMeta()
          addOrdinal = true
        } else if (yAxisType === 'category') {
          option.layout = 'vertical'
          ordinalMeta = yAxisModel.getOrdinalMeta()
          addOrdinal = true
        } else {
          option.layout = option.layout || 'horizontal'
        }

        const coordDims = ['x', 'y']
        const baseAxisDimIndex = option.layout === 'horizontal' ? 0 : 1
        const baseAxisDim = this._baseAxisDim = coordDims[baseAxisDimIndex]
        const otherAxisDim = coordDims[1 - baseAxisDimIndex]
        const axisModels = [xAxisModel, yAxisModel]
        const baseAxisType = axisModels[baseAxisDimIndex].get('type')
        const otherAxisType = axisModels[1 - baseAxisDimIndex].get('type')
        const data = option.data // Clone a new data for next setOption({}) usage.
        // Avoid modifying current data will affect further update.

        if (data && addOrdinal) {
          const newOptionData_1 = []
          each(data, function (item, index) {
            let newItem

            if (isArray(item)) {
              newItem = item.slice() // Modify current using data.

              item.unshift(index)
            } else if (isArray(item.value)) {
              newItem = extend({}, item)
              newItem.value = newItem.value.slice() // Modify current using data.

              item.value.unshift(index)
            } else {
              newItem = item
            }

            newOptionData_1.push(newItem)
          })
          option.data = newOptionData_1
        }

        const defaultValueDimensions = this.defaultValueDimensions
        const coordDimensions = [{
          name: baseAxisDim,
          type: getDimensionTypeByAxis(baseAxisType),
          ordinalMeta: ordinalMeta,
          otherDims: {
            tooltip: false,
            itemName: 0
          },
          dimsDef: ['base']
        }, {
          name: otherAxisDim,
          type: getDimensionTypeByAxis(otherAxisType),
          dimsDef: defaultValueDimensions.slice()
        }]
        return createSeriesDataSimply(this, {
          coordDimensions: coordDimensions,
          dimensionsCount: defaultValueDimensions.length + 1,
          encodeDefaulter: curry(makeSeriesEncodeForAxisCoordSys, coordDimensions, this)
        })
      }
      /**
       * If horizontal, base axis is x, otherwise y.
       * @override
       */

      WhiskerBoxCommonMixin.prototype.getBaseAxis = function () {
        const dim = this._baseAxisDim
        return this.ecModel.getComponent(dim + 'Axis', this.get(dim + 'AxisIndex')).axis
      }

      return WhiskerBoxCommonMixin
    }())

  const BoxplotSeriesModel =
    /** @class */
    (function (_super) {
      __extends(BoxplotSeriesModel, _super)

      function BoxplotSeriesModel () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = BoxplotSeriesModel.type // TODO
        // box width represents group size, so dimension should have 'size'.

        /**
         * @see <https://en.wikipedia.org/wiki/Box_plot>
         * The meanings of 'min' and 'max' depend on user,
         * and echarts do not need to know it.
         * @readOnly
         */

        _this.defaultValueDimensions = [{
          name: 'min',
          defaultTooltip: true
        }, {
          name: 'Q1',
          defaultTooltip: true
        }, {
          name: 'median',
          defaultTooltip: true
        }, {
          name: 'Q3',
          defaultTooltip: true
        }, {
          name: 'max',
          defaultTooltip: true
        }]
        _this.visualDrawType = 'stroke'
        return _this
      }

      BoxplotSeriesModel.type = 'series.boxplot'
      BoxplotSeriesModel.dependencies = ['xAxis', 'yAxis', 'grid']
      BoxplotSeriesModel.defaultOption = {
        // zlevel: 0,
        z: 2,
        coordinateSystem: 'cartesian2d',
        legendHoverLink: true,
        layout: null,
        boxWidth: [7, 50],
        itemStyle: {
          color: '#fff',
          borderWidth: 1
        },
        emphasis: {
          scale: true,
          itemStyle: {
            borderWidth: 2,
            shadowBlur: 5,
            shadowOffsetX: 1,
            shadowOffsetY: 1,
            shadowColor: 'rgba(0,0,0,0.2)'
          }
        },
        animationDuration: 800
      }
      return BoxplotSeriesModel
    }(SeriesModel))

  mixin(BoxplotSeriesModel, WhiskerBoxCommonMixin, true)

  const BoxplotView =
    /** @class */
    (function (_super) {
      __extends(BoxplotView, _super)

      function BoxplotView () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = BoxplotView.type
        return _this
      }

      BoxplotView.prototype.render = function (seriesModel, ecModel, api) {
        const data = seriesModel.getData()
        const group = this.group
        const oldData = this._data // There is no old data only when first rendering or switching from
        // stream mode to normal mode, where previous elements should be removed.

        if (!this._data) {
          group.removeAll()
        }

        const constDim = seriesModel.get('layout') === 'horizontal' ? 1 : 0
        data.diff(oldData).add(function (newIdx) {
          if (data.hasValue(newIdx)) {
            const itemLayout = data.getItemLayout(newIdx)
            const symbolEl = createNormalBox(itemLayout, data, newIdx, constDim, true)
            data.setItemGraphicEl(newIdx, symbolEl)
            group.add(symbolEl)
          }
        }).update(function (newIdx, oldIdx) {
          let symbolEl = oldData.getItemGraphicEl(oldIdx) // Empty data

          if (!data.hasValue(newIdx)) {
            group.remove(symbolEl)
            return
          }

          const itemLayout = data.getItemLayout(newIdx)

          if (!symbolEl) {
            symbolEl = createNormalBox(itemLayout, data, newIdx, constDim)
          } else {
            saveOldStyle(symbolEl)
            updateNormalBoxData(itemLayout, symbolEl, data, newIdx)
          }

          group.add(symbolEl)
          data.setItemGraphicEl(newIdx, symbolEl)
        }).remove(function (oldIdx) {
          const el = oldData.getItemGraphicEl(oldIdx)
          el && group.remove(el)
        }).execute()
        this._data = data
      }

      BoxplotView.prototype.remove = function (ecModel) {
        const group = this.group
        const data = this._data
        this._data = null
        data && data.eachItemGraphicEl(function (el) {
          el && group.remove(el)
        })
      }

      BoxplotView.type = 'boxplot'
      return BoxplotView
    }(ChartView))

  const BoxPathShape =
    /** @class */
    (function () {
      function BoxPathShape () {}

      return BoxPathShape
    }())

  const BoxPath =
    /** @class */
    (function (_super) {
      __extends(BoxPath, _super)

      function BoxPath (opts) {
        const _this = _super.call(this, opts) || this

        _this.type = 'boxplotBoxPath'
        return _this
      }

      BoxPath.prototype.getDefaultShape = function () {
        return new BoxPathShape()
      }

      BoxPath.prototype.buildPath = function (ctx, shape) {
        const ends = shape.points
        let i = 0
        ctx.moveTo(ends[i][0], ends[i][1])
        i++

        for (; i < 4; i++) {
          ctx.lineTo(ends[i][0], ends[i][1])
        }

        ctx.closePath()

        for (; i < ends.length; i++) {
          ctx.moveTo(ends[i][0], ends[i][1])
          i++
          ctx.lineTo(ends[i][0], ends[i][1])
        }
      }

      return BoxPath
    }(Path))

  function createNormalBox (itemLayout, data, dataIndex, constDim, isInit) {
    const ends = itemLayout.ends
    const el = new BoxPath({
      shape: {
        points: isInit ? transInit(ends, constDim, itemLayout) : ends
      }
    })
    updateNormalBoxData(itemLayout, el, data, dataIndex, isInit)
    return el
  }

  function updateNormalBoxData (itemLayout, el, data, dataIndex, isInit) {
    const seriesModel = data.hostModel
    const updateMethod = graphic[isInit ? 'initProps' : 'updateProps']
    updateMethod(el, {
      shape: {
        points: itemLayout.ends
      }
    }, seriesModel, dataIndex)
    el.useStyle(data.getItemVisual(dataIndex, 'style'))
    el.style.strokeNoScale = true
    el.z2 = 100
    const itemModel = data.getItemModel(dataIndex)
    const emphasisModel = itemModel.getModel('emphasis')
    setStatesStylesFromModel(el, itemModel)
    toggleHoverEmphasis(el, emphasisModel.get('focus'), emphasisModel.get('blurScope'), emphasisModel.get('disabled'))
  }

  function transInit (points, dim, itemLayout) {
    return map(points, function (point) {
      point = point.slice()
      point[dim] = itemLayout.initBaseline
      return point
    })
  }

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

  /**
     * AUTO-GENERATED FILE. DO NOT MODIFY.
     */

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
  function boxplotVisual (ecModel, api) {}

  const each$6 = each
  function boxplotLayout (ecModel) {
    const groupResult = groupSeriesByAxis(ecModel)
    each$6(groupResult, function (groupItem) {
      const seriesModels = groupItem.seriesModels

      if (!seriesModels.length) {
        return
      }

      calculateBase(groupItem)
      each$6(seriesModels, function (seriesModel, idx) {
        layoutSingleSeries(seriesModel, groupItem.boxOffsetList[idx], groupItem.boxWidthList[idx])
      })
    })
  }
  /**
     * Group series by axis.
     */

  function groupSeriesByAxis (ecModel) {
    const result = []
    const axisList = []
    ecModel.eachSeriesByType('boxplot', function (seriesModel) {
      const baseAxis = seriesModel.getBaseAxis()
      let idx = indexOf(axisList, baseAxis)

      if (idx < 0) {
        idx = axisList.length
        axisList[idx] = baseAxis
        result[idx] = {
          axis: baseAxis,
          seriesModels: []
        }
      }

      result[idx].seriesModels.push(seriesModel)
    })
    return result
  }
  /**
     * Calculate offset and box width for each series.
     */

  function calculateBase (groupItem) {
    const baseAxis = groupItem.axis
    const seriesModels = groupItem.seriesModels
    const seriesCount = seriesModels.length
    const boxWidthList = groupItem.boxWidthList = []
    const boxOffsetList = groupItem.boxOffsetList = []
    const boundList = []
    let bandWidth

    if (baseAxis.type === 'category') {
      bandWidth = baseAxis.getBandWidth()
    } else {
      let maxDataCount_1 = 0
      each$6(seriesModels, function (seriesModel) {
        maxDataCount_1 = Math.max(maxDataCount_1, seriesModel.getData().count())
      })
      const extent = baseAxis.getExtent()
      bandWidth = Math.abs(extent[1] - extent[0]) / maxDataCount_1
    }

    each$6(seriesModels, function (seriesModel) {
      let boxWidthBound = seriesModel.get('boxWidth')

      if (!isArray(boxWidthBound)) {
        boxWidthBound = [boxWidthBound, boxWidthBound]
      }

      boundList.push([parsePercent$1(boxWidthBound[0], bandWidth) || 0, parsePercent$1(boxWidthBound[1], bandWidth) || 0])
    })
    const availableWidth = bandWidth * 0.8 - 2
    const boxGap = availableWidth / seriesCount * 0.3
    const boxWidth = (availableWidth - boxGap * (seriesCount - 1)) / seriesCount
    let base = boxWidth / 2 - availableWidth / 2
    each$6(seriesModels, function (seriesModel, idx) {
      boxOffsetList.push(base)
      base += boxGap + boxWidth
      boxWidthList.push(Math.min(Math.max(boxWidth, boundList[idx][0]), boundList[idx][1]))
    })
  }
  /**
     * Calculate points location for each series.
     */

  function layoutSingleSeries (seriesModel, offset, boxWidth) {
    const coordSys = seriesModel.coordinateSystem
    const data = seriesModel.getData()
    const halfWidth = boxWidth / 2
    const cDimIdx = seriesModel.get('layout') === 'horizontal' ? 0 : 1
    const vDimIdx = 1 - cDimIdx
    const coordDims = ['x', 'y']
    const cDim = data.mapDimension(coordDims[cDimIdx])
    const vDims = data.mapDimensionsAll(coordDims[vDimIdx])

    if (cDim == null || vDims.length < 5) {
      return
    }

    for (let dataIndex = 0; dataIndex < data.count(); dataIndex++) {
      const axisDimVal = data.get(cDim, dataIndex)
      const median = getPoint(axisDimVal, vDims[2], dataIndex)
      const end1 = getPoint(axisDimVal, vDims[0], dataIndex)
      const end2 = getPoint(axisDimVal, vDims[1], dataIndex)
      const end4 = getPoint(axisDimVal, vDims[3], dataIndex)
      const end5 = getPoint(axisDimVal, vDims[4], dataIndex)
      const ends = []
      addBodyEnd(ends, end2, false)
      addBodyEnd(ends, end4, true)
      ends.push(end1, end2, end5, end4)
      layEndLine(ends, end1)
      layEndLine(ends, end5)
      layEndLine(ends, median)
      data.setItemLayout(dataIndex, {
        initBaseline: median[vDimIdx],
        ends: ends
      })
    }

    function getPoint (axisDimVal, dim, dataIndex) {
      const val = data.get(dim, dataIndex)
      const p = []
      p[cDimIdx] = axisDimVal
      p[vDimIdx] = val
      let point

      if (isNaN(axisDimVal) || isNaN(val)) {
        point = [NaN, NaN]
      } else {
        point = coordSys.dataToPoint(p)
        point[cDimIdx] += offset
      }

      return point
    }

    function addBodyEnd (ends, point, start) {
      const point1 = point.slice()
      const point2 = point.slice()
      point1[cDimIdx] += halfWidth
      point2[cDimIdx] -= halfWidth
      start ? ends.push(point1, point2) : ends.push(point2, point1)
    }

    function layEndLine (ends, endCenter) {
      const from = endCenter.slice()
      const to = endCenter.slice()
      from[cDimIdx] -= halfWidth
      to[cDimIdx] += halfWidth
      ends.push(from, to)
    }
  }

  /**
     * See:
     *  <https://en.wikipedia.org/wiki/Box_plot#cite_note-frigge_hoaglin_iglewicz-2>
     *  <http://stat.ethz.ch/R-manual/R-devel/library/grDevices/html/boxplot.stats.html>
     *
     * Helper method for preparing data.
     *
     * @param rawData like
     *        [
     *            [12,232,443], (raw data set for the first box)
     *            [3843,5545,1232], (raw data set for the second box)
     *            ...
     *        ]
     * @param opt.boundIQR=1.5 Data less than min bound is outlier.
     *      default 1.5, means Q1 - 1.5 * (Q3 - Q1).
     *      If 'none'/0 passed, min bound will not be used.
     */

  function prepareBoxplotData (rawData, opt) {
    opt = opt || {}
    const boxData = []
    const outliers = []
    const boundIQR = opt.boundIQR
    const useExtreme = boundIQR === 'none' || boundIQR === 0

    for (let i = 0; i < rawData.length; i++) {
      const ascList = asc(rawData[i].slice())
      const Q1 = quantile(ascList, 0.25)
      const Q2 = quantile(ascList, 0.5)
      const Q3 = quantile(ascList, 0.75)
      const min = ascList[0]
      const max = ascList[ascList.length - 1]
      const bound = (boundIQR == null ? 1.5 : boundIQR) * (Q3 - Q1)
      const low = useExtreme ? min : Math.max(min, Q1 - bound)
      const high = useExtreme ? max : Math.min(max, Q3 + bound)
      const itemNameFormatter = opt.itemNameFormatter
      const itemName = isFunction(itemNameFormatter)
        ? itemNameFormatter({
          value: i
        })
        : isString(itemNameFormatter) ? itemNameFormatter.replace('{value}', i + '') : i + ''
      boxData.push([itemName, low, Q1, Q2, Q3, high])

      for (let j = 0; j < ascList.length; j++) {
        const dataItem = ascList[j]

        if (dataItem < low || dataItem > high) {
          const outlier = [itemName, dataItem]
          outliers.push(outlier)
        }
      }
    }

    return {
      boxData: boxData,
      outliers: outliers
    }
  }

  const boxplotTransform = {
    type: 'echarts:boxplot',
    transform: function transform (params) {
      const upstream = params.upstream

      if (upstream.sourceFormat !== SOURCE_FORMAT_ARRAY_ROWS) {
        let errMsg = ''

        if ('development' !== 'production') {
          errMsg = makePrintable('source data is not applicable for this boxplot transform. Expect number[][].')
        }

        throwError(errMsg)
      }

      const result = prepareBoxplotData(upstream.getRawData(), params.config)
      return [{
        dimensions: ['ItemName', 'Low', 'Q1', 'Q2', 'Q3', 'High'],
        data: result.boxData
      }, {
        data: result.outliers
      }]
    }
  }

  function install$j (registers) {
    registers.registerSeriesModel(BoxplotSeriesModel)
    registers.registerChartView(BoxplotView)
    registers.registerVisual(boxplotVisual)
    registers.registerLayout(boxplotLayout)
    registers.registerTransform(boxplotTransform)
  }

  const SKIP_PROPS = ['color', 'borderColor']

  const CandlestickView =
    /** @class */
    (function (_super) {
      __extends(CandlestickView, _super)

      function CandlestickView () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = CandlestickView.type
        return _this
      }

      CandlestickView.prototype.render = function (seriesModel, ecModel, api) {
        // If there is clipPath created in large mode. Remove it.
        this.group.removeClipPath() // Clear previously rendered progressive elements.

        this._progressiveEls = null

        this._updateDrawMode(seriesModel)

        this._isLargeDraw ? this._renderLarge(seriesModel) : this._renderNormal(seriesModel)
      }

      CandlestickView.prototype.incrementalPrepareRender = function (seriesModel, ecModel, api) {
        this._clear()

        this._updateDrawMode(seriesModel)
      }

      CandlestickView.prototype.incrementalRender = function (params, seriesModel, ecModel, api) {
        this._progressiveEls = []
        this._isLargeDraw ? this._incrementalRenderLarge(params, seriesModel) : this._incrementalRenderNormal(params, seriesModel)
      }

      CandlestickView.prototype.eachRendered = function (cb) {
        traverseElements(this._progressiveEls || this.group, cb)
      }

      CandlestickView.prototype._updateDrawMode = function (seriesModel) {
        const isLargeDraw = seriesModel.pipelineContext.large

        if (this._isLargeDraw == null || isLargeDraw !== this._isLargeDraw) {
          this._isLargeDraw = isLargeDraw

          this._clear()
        }
      }

      CandlestickView.prototype._renderNormal = function (seriesModel) {
        const data = seriesModel.getData()
        const oldData = this._data
        const group = this.group
        const isSimpleBox = data.getLayout('isSimpleBox')
        const needsClip = seriesModel.get('clip', true)
        const coord = seriesModel.coordinateSystem
        const clipArea = coord.getArea && coord.getArea() // There is no old data only when first rendering or switching from
        // stream mode to normal mode, where previous elements should be removed.

        if (!this._data) {
          group.removeAll()
        }

        data.diff(oldData).add(function (newIdx) {
          if (data.hasValue(newIdx)) {
            const itemLayout = data.getItemLayout(newIdx)

            if (needsClip && isNormalBoxClipped(clipArea, itemLayout)) {
              return
            }

            const el = createNormalBox$1(itemLayout, newIdx, true)
            initProps(el, {
              shape: {
                points: itemLayout.ends
              }
            }, seriesModel, newIdx)
            setBoxCommon(el, data, newIdx, isSimpleBox)
            group.add(el)
            data.setItemGraphicEl(newIdx, el)
          }
        }).update(function (newIdx, oldIdx) {
          let el = oldData.getItemGraphicEl(oldIdx) // Empty data

          if (!data.hasValue(newIdx)) {
            group.remove(el)
            return
          }

          const itemLayout = data.getItemLayout(newIdx)

          if (needsClip && isNormalBoxClipped(clipArea, itemLayout)) {
            group.remove(el)
            return
          }

          if (!el) {
            el = createNormalBox$1(itemLayout)
          } else {
            updateProps(el, {
              shape: {
                points: itemLayout.ends
              }
            }, seriesModel, newIdx)
            saveOldStyle(el)
          }

          setBoxCommon(el, data, newIdx, isSimpleBox)
          group.add(el)
          data.setItemGraphicEl(newIdx, el)
        }).remove(function (oldIdx) {
          const el = oldData.getItemGraphicEl(oldIdx)
          el && group.remove(el)
        }).execute()
        this._data = data
      }

      CandlestickView.prototype._renderLarge = function (seriesModel) {
        this._clear()

        createLarge$1(seriesModel, this.group)
        const clipPath = seriesModel.get('clip', true) ? createClipPath(seriesModel.coordinateSystem, false, seriesModel) : null

        if (clipPath) {
          this.group.setClipPath(clipPath)
        } else {
          this.group.removeClipPath()
        }
      }

      CandlestickView.prototype._incrementalRenderNormal = function (params, seriesModel) {
        const data = seriesModel.getData()
        const isSimpleBox = data.getLayout('isSimpleBox')
        let dataIndex

        while ((dataIndex = params.next()) != null) {
          const itemLayout = data.getItemLayout(dataIndex)
          const el = createNormalBox$1(itemLayout)
          setBoxCommon(el, data, dataIndex, isSimpleBox)
          el.incremental = true
          this.group.add(el)

          this._progressiveEls.push(el)
        }
      }

      CandlestickView.prototype._incrementalRenderLarge = function (params, seriesModel) {
        createLarge$1(seriesModel, this.group, this._progressiveEls, true)
      }

      CandlestickView.prototype.remove = function (ecModel) {
        this._clear()
      }

      CandlestickView.prototype._clear = function () {
        this.group.removeAll()
        this._data = null
      }

      CandlestickView.type = 'candlestick'
      return CandlestickView
    }(ChartView))

  const NormalBoxPathShape =
    /** @class */
    (function () {
      function NormalBoxPathShape () {}

      return NormalBoxPathShape
    }())

  const NormalBoxPath =
    /** @class */
    (function (_super) {
      __extends(NormalBoxPath, _super)

      function NormalBoxPath (opts) {
        const _this = _super.call(this, opts) || this

        _this.type = 'normalCandlestickBox'
        return _this
      }

      NormalBoxPath.prototype.getDefaultShape = function () {
        return new NormalBoxPathShape()
      }

      NormalBoxPath.prototype.buildPath = function (ctx, shape) {
        const ends = shape.points

        if (this.__simpleBox) {
          ctx.moveTo(ends[4][0], ends[4][1])
          ctx.lineTo(ends[6][0], ends[6][1])
        } else {
          ctx.moveTo(ends[0][0], ends[0][1])
          ctx.lineTo(ends[1][0], ends[1][1])
          ctx.lineTo(ends[2][0], ends[2][1])
          ctx.lineTo(ends[3][0], ends[3][1])
          ctx.closePath()
          ctx.moveTo(ends[4][0], ends[4][1])
          ctx.lineTo(ends[5][0], ends[5][1])
          ctx.moveTo(ends[6][0], ends[6][1])
          ctx.lineTo(ends[7][0], ends[7][1])
        }
      }

      return NormalBoxPath
    }(Path))

  function createNormalBox$1 (itemLayout, dataIndex, isInit) {
    const ends = itemLayout.ends
    return new NormalBoxPath({
      shape: {
        points: isInit ? transInit$1(ends, itemLayout) : ends
      },
      z2: 100
    })
  }

  function isNormalBoxClipped (clipArea, itemLayout) {
    let clipped = true

    for (let i = 0; i < itemLayout.ends.length; i++) {
      // If any point are in the region.
      if (clipArea.contain(itemLayout.ends[i][0], itemLayout.ends[i][1])) {
        clipped = false
        break
      }
    }

    return clipped
  }

  function setBoxCommon (el, data, dataIndex, isSimpleBox) {
    const itemModel = data.getItemModel(dataIndex)
    el.useStyle(data.getItemVisual(dataIndex, 'style'))
    el.style.strokeNoScale = true
    el.__simpleBox = isSimpleBox
    setStatesStylesFromModel(el, itemModel)
  }

  function transInit$1 (points, itemLayout) {
    return map(points, function (point) {
      point = point.slice()
      point[1] = itemLayout.initBaseline
      return point
    })
  }

  const LargeBoxPathShape =
    /** @class */
    (function () {
      function LargeBoxPathShape () {}

      return LargeBoxPathShape
    }())

  const LargeBoxPath =
    /** @class */
    (function (_super) {
      __extends(LargeBoxPath, _super)

      function LargeBoxPath (opts) {
        const _this = _super.call(this, opts) || this

        _this.type = 'largeCandlestickBox'
        return _this
      }

      LargeBoxPath.prototype.getDefaultShape = function () {
        return new LargeBoxPathShape()
      }

      LargeBoxPath.prototype.buildPath = function (ctx, shape) {
        // Drawing lines is more efficient than drawing
        // a whole line or drawing rects.
        const points = shape.points

        for (let i = 0; i < points.length;) {
          if (this.__sign === points[i++]) {
            const x = points[i++]
            ctx.moveTo(x, points[i++])
            ctx.lineTo(x, points[i++])
          } else {
            i += 3
          }
        }
      }

      return LargeBoxPath
    }(Path))

  function createLarge$1 (seriesModel, group, progressiveEls, incremental) {
    const data = seriesModel.getData()
    const largePoints = data.getLayout('largePoints')
    const elP = new LargeBoxPath({
      shape: {
        points: largePoints
      },
      __sign: 1
    })
    group.add(elP)
    const elN = new LargeBoxPath({
      shape: {
        points: largePoints
      },
      __sign: -1
    })
    group.add(elN)
    setLargeStyle(1, elP, seriesModel)
    setLargeStyle(-1, elN, seriesModel)

    if (incremental) {
      elP.incremental = true
      elN.incremental = true
    }

    if (progressiveEls) {
      progressiveEls.push(elP, elN)
    }
  }

  function setLargeStyle (sign, el, seriesModel, data) {
    // TODO put in visual?
    const borderColor = seriesModel.get(['itemStyle', sign > 0 ? 'borderColor' : 'borderColor0']) || seriesModel.get(['itemStyle', sign > 0 ? 'color' : 'color0']) // Color must be excluded.
    // Because symbol provide setColor individually to set fill and stroke

    const itemStyle = seriesModel.getModel('itemStyle').getItemStyle(SKIP_PROPS)
    el.useStyle(itemStyle)
    el.style.fill = null
    el.style.stroke = borderColor
  }

  const CandlestickSeriesModel =
    /** @class */
    (function (_super) {
      __extends(CandlestickSeriesModel, _super)

      function CandlestickSeriesModel () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = CandlestickSeriesModel.type
        _this.defaultValueDimensions = [{
          name: 'open',
          defaultTooltip: true
        }, {
          name: 'close',
          defaultTooltip: true
        }, {
          name: 'lowest',
          defaultTooltip: true
        }, {
          name: 'highest',
          defaultTooltip: true
        }]
        return _this
      }
      /**
       * Get dimension for shadow in dataZoom
       * @return dimension name
       */

      CandlestickSeriesModel.prototype.getShadowDim = function () {
        return 'open'
      }

      CandlestickSeriesModel.prototype.brushSelector = function (dataIndex, data, selectors) {
        const itemLayout = data.getItemLayout(dataIndex)
        return itemLayout && selectors.rect(itemLayout.brushRect)
      }

      CandlestickSeriesModel.type = 'series.candlestick'
      CandlestickSeriesModel.dependencies = ['xAxis', 'yAxis', 'grid']
      CandlestickSeriesModel.defaultOption = {
        // zlevel: 0,
        z: 2,
        coordinateSystem: 'cartesian2d',
        legendHoverLink: true,
        // xAxisIndex: 0,
        // yAxisIndex: 0,
        layout: null,
        clip: true,
        itemStyle: {
          color: '#eb5454',
          color0: '#47b262',
          borderColor: '#eb5454',
          borderColor0: '#47b262',
          // borderColor: '#d24040',
          // borderColor0: '#398f4f',
          borderWidth: 1
        },
        emphasis: {
          scale: true,
          itemStyle: {
            borderWidth: 2
          }
        },
        barMaxWidth: null,
        barMinWidth: null,
        barWidth: null,
        large: true,
        largeThreshold: 600,
        progressive: 3e3,
        progressiveThreshold: 1e4,
        progressiveChunkMode: 'mod',
        animationEasing: 'linear',
        animationDuration: 300
      }
      return CandlestickSeriesModel
    }(SeriesModel))

  mixin(CandlestickSeriesModel, WhiskerBoxCommonMixin, true)

  function candlestickPreprocessor (option) {
    if (!option || !isArray(option.series)) {
      return
    } // Translate 'k' to 'candlestick'.

    each(option.series, function (seriesItem) {
      if (isObject(seriesItem) && seriesItem.type === 'k') {
        seriesItem.type = 'candlestick'
      }
    })
  }

  const positiveBorderColorQuery = ['itemStyle', 'borderColor']
  const negativeBorderColorQuery = ['itemStyle', 'borderColor0']
  const positiveColorQuery = ['itemStyle', 'color']
  const negativeColorQuery = ['itemStyle', 'color0']
  const candlestickVisual = {
    seriesType: 'candlestick',
    plan: createRenderPlanner(),
    // For legend.
    performRawSeries: true,
    reset: function (seriesModel, ecModel) {
      function getColor (sign, model) {
        return model.get(sign > 0 ? positiveColorQuery : negativeColorQuery)
      }

      function getBorderColor (sign, model) {
        return model.get(sign > 0 ? positiveBorderColorQuery : negativeBorderColorQuery)
      } // Only visible series has each data be visual encoded

      if (ecModel.isSeriesFiltered(seriesModel)) {
        return
      }

      const isLargeRender = seriesModel.pipelineContext.large
      return !isLargeRender && {
        progress: function (params, data) {
          let dataIndex

          while ((dataIndex = params.next()) != null) {
            const itemModel = data.getItemModel(dataIndex)
            const sign = data.getItemLayout(dataIndex).sign
            const style = itemModel.getItemStyle()
            style.fill = getColor(sign, itemModel)
            style.stroke = getBorderColor(sign, itemModel) || style.fill
            const existsStyle = data.ensureUniqueItemVisual(dataIndex, 'style')
            extend(existsStyle, style)
          }
        }
      }
    }
  }

  const candlestickLayout = {
    seriesType: 'candlestick',
    plan: createRenderPlanner(),
    reset: function (seriesModel) {
      const coordSys = seriesModel.coordinateSystem
      const data = seriesModel.getData()
      const candleWidth = calculateCandleWidth(seriesModel, data)
      const cDimIdx = 0
      const vDimIdx = 1
      const coordDims = ['x', 'y']
      const cDimI = data.getDimensionIndex(data.mapDimension(coordDims[cDimIdx]))
      const vDimsI = map(data.mapDimensionsAll(coordDims[vDimIdx]), data.getDimensionIndex, data)
      const openDimI = vDimsI[0]
      const closeDimI = vDimsI[1]
      const lowestDimI = vDimsI[2]
      const highestDimI = vDimsI[3]
      data.setLayout({
        candleWidth: candleWidth,
        // The value is experimented visually.
        isSimpleBox: candleWidth <= 1.3
      })

      if (cDimI < 0 || vDimsI.length < 4) {
        return
      }

      return {
        progress: seriesModel.pipelineContext.large ? largeProgress : normalProgress
      }

      function normalProgress (params, data) {
        let dataIndex
        const store = data.getStore()

        while ((dataIndex = params.next()) != null) {
          const axisDimVal = store.get(cDimI, dataIndex)
          const openVal = store.get(openDimI, dataIndex)
          const closeVal = store.get(closeDimI, dataIndex)
          const lowestVal = store.get(lowestDimI, dataIndex)
          const highestVal = store.get(highestDimI, dataIndex)
          const ocLow = Math.min(openVal, closeVal)
          const ocHigh = Math.max(openVal, closeVal)
          const ocLowPoint = getPoint(ocLow, axisDimVal)
          const ocHighPoint = getPoint(ocHigh, axisDimVal)
          const lowestPoint = getPoint(lowestVal, axisDimVal)
          const highestPoint = getPoint(highestVal, axisDimVal)
          const ends = []
          addBodyEnd(ends, ocHighPoint, 0)
          addBodyEnd(ends, ocLowPoint, 1)
          ends.push(subPixelOptimizePoint(highestPoint), subPixelOptimizePoint(ocHighPoint), subPixelOptimizePoint(lowestPoint), subPixelOptimizePoint(ocLowPoint))
          data.setItemLayout(dataIndex, {
            sign: getSign(store, dataIndex, openVal, closeVal, closeDimI),
            initBaseline: openVal > closeVal ? ocHighPoint[vDimIdx] : ocLowPoint[vDimIdx],
            ends: ends,
            brushRect: makeBrushRect(lowestVal, highestVal, axisDimVal)
          })
        }

        function getPoint (val, axisDimVal) {
          const p = []
          p[cDimIdx] = axisDimVal
          p[vDimIdx] = val
          return isNaN(axisDimVal) || isNaN(val) ? [NaN, NaN] : coordSys.dataToPoint(p)
        }

        function addBodyEnd (ends, point, start) {
          const point1 = point.slice()
          const point2 = point.slice()
          point1[cDimIdx] = subPixelOptimize$1(point1[cDimIdx] + candleWidth / 2, 1, false)
          point2[cDimIdx] = subPixelOptimize$1(point2[cDimIdx] - candleWidth / 2, 1, true)
          start ? ends.push(point1, point2) : ends.push(point2, point1)
        }

        function makeBrushRect (lowestVal, highestVal, axisDimVal) {
          const pmin = getPoint(lowestVal, axisDimVal)
          const pmax = getPoint(highestVal, axisDimVal)
          pmin[cDimIdx] -= candleWidth / 2
          pmax[cDimIdx] -= candleWidth / 2
          return {
            x: pmin[0],
            y: pmin[1],
            width: candleWidth,
            height: pmax[1] - pmin[1]
          }
        }

        function subPixelOptimizePoint (point) {
          point[cDimIdx] = subPixelOptimize$1(point[cDimIdx], 1)
          return point
        }
      }

      function largeProgress (params, data) {
        // Structure: [sign, x, yhigh, ylow, sign, x, yhigh, ylow, ...]
        const points = createFloat32Array(params.count * 4)
        let offset = 0
        let point
        const tmpIn = []
        const tmpOut = []
        let dataIndex
        const store = data.getStore()

        while ((dataIndex = params.next()) != null) {
          const axisDimVal = store.get(cDimI, dataIndex)
          const openVal = store.get(openDimI, dataIndex)
          const closeVal = store.get(closeDimI, dataIndex)
          const lowestVal = store.get(lowestDimI, dataIndex)
          const highestVal = store.get(highestDimI, dataIndex)

          if (isNaN(axisDimVal) || isNaN(lowestVal) || isNaN(highestVal)) {
            points[offset++] = NaN
            offset += 3
            continue
          }

          points[offset++] = getSign(store, dataIndex, openVal, closeVal, closeDimI)
          tmpIn[cDimIdx] = axisDimVal
          tmpIn[vDimIdx] = lowestVal
          point = coordSys.dataToPoint(tmpIn, null, tmpOut)
          points[offset++] = point ? point[0] : NaN
          points[offset++] = point ? point[1] : NaN
          tmpIn[vDimIdx] = highestVal
          point = coordSys.dataToPoint(tmpIn, null, tmpOut)
          points[offset++] = point ? point[1] : NaN
        }

        data.setLayout('largePoints', points)
      }
    }
  }

  function getSign (store, dataIndex, openVal, closeVal, closeDimI) {
    let sign

    if (openVal > closeVal) {
      sign = -1
    } else if (openVal < closeVal) {
      sign = 1
    } else {
      sign = dataIndex > 0 // If close === open, compare with close of last record
        ? store.get(closeDimI, dataIndex - 1) <= closeVal ? 1 : -1 // No record of previous, set to be positive
        : 1
    }

    return sign
  }

  function calculateCandleWidth (seriesModel, data) {
    const baseAxis = seriesModel.getBaseAxis()
    let extent
    const bandWidth = baseAxis.type === 'category' ? baseAxis.getBandWidth() : (extent = baseAxis.getExtent(), Math.abs(extent[1] - extent[0]) / data.count())
    const barMaxWidth = parsePercent$1(retrieve2(seriesModel.get('barMaxWidth'), bandWidth), bandWidth)
    const barMinWidth = parsePercent$1(retrieve2(seriesModel.get('barMinWidth'), 1), bandWidth)
    const barWidth = seriesModel.get('barWidth')
    return barWidth != null ? parsePercent$1(barWidth, bandWidth) // Put max outer to ensure bar visible in spite of overlap.
      : Math.max(Math.min(bandWidth / 2, barMaxWidth), barMinWidth)
  }

  function install$k (registers) {
    registers.registerChartView(CandlestickView)
    registers.registerSeriesModel(CandlestickSeriesModel)
    registers.registerPreprocessor(candlestickPreprocessor)
    registers.registerVisual(candlestickVisual)
    registers.registerLayout(candlestickLayout)
  }

  function updateRipplePath (rippleGroup, effectCfg) {
    const color = effectCfg.rippleEffectColor || effectCfg.color
    rippleGroup.eachChild(function (ripplePath) {
      ripplePath.attr({
        z: effectCfg.z,
        zlevel: effectCfg.zlevel,
        style: {
          stroke: effectCfg.brushType === 'stroke' ? color : null,
          fill: effectCfg.brushType === 'fill' ? color : null
        }
      })
    })
  }

  const EffectSymbol =
    /** @class */
    (function (_super) {
      __extends(EffectSymbol, _super)

      function EffectSymbol (data, idx) {
        const _this = _super.call(this) || this

        const symbol = new Symbol(data, idx)
        const rippleGroup = new Group()

        _this.add(symbol)

        _this.add(rippleGroup)

        _this.updateData(data, idx)

        return _this
      }

      EffectSymbol.prototype.stopEffectAnimation = function () {
        this.childAt(1).removeAll()
      }

      EffectSymbol.prototype.startEffectAnimation = function (effectCfg) {
        const symbolType = effectCfg.symbolType
        const color = effectCfg.color
        const rippleNumber = effectCfg.rippleNumber
        const rippleGroup = this.childAt(1)

        for (let i = 0; i < rippleNumber; i++) {
          // If width/height are set too small (e.g., set to 1) on ios10
          // and macOS Sierra, a circle stroke become a rect, no matter what
          // the scale is set. So we set width/height as 2. See #4136.
          const ripplePath = createSymbol(symbolType, -1, -1, 2, 2, color)
          ripplePath.attr({
            style: {
              strokeNoScale: true
            },
            z2: 99,
            silent: true,
            scaleX: 0.5,
            scaleY: 0.5
          })
          const delay = -i / rippleNumber * effectCfg.period + effectCfg.effectOffset
          ripplePath.animate('', true).when(effectCfg.period, {
            scaleX: effectCfg.rippleScale / 2,
            scaleY: effectCfg.rippleScale / 2
          }).delay(delay).start()
          ripplePath.animateStyle(true).when(effectCfg.period, {
            opacity: 0
          }).delay(delay).start()
          rippleGroup.add(ripplePath)
        }

        updateRipplePath(rippleGroup, effectCfg)
      }
      /**
       * Update effect symbol
       */

      EffectSymbol.prototype.updateEffectAnimation = function (effectCfg) {
        const oldEffectCfg = this._effectCfg
        const rippleGroup = this.childAt(1) // Must reinitialize effect if following configuration changed

        const DIFFICULT_PROPS = ['symbolType', 'period', 'rippleScale', 'rippleNumber']

        for (let i = 0; i < DIFFICULT_PROPS.length; i++) {
          const propName = DIFFICULT_PROPS[i]

          if (oldEffectCfg[propName] !== effectCfg[propName]) {
            this.stopEffectAnimation()
            this.startEffectAnimation(effectCfg)
            return
          }
        }

        updateRipplePath(rippleGroup, effectCfg)
      }
      /**
       * Highlight symbol
       */

      EffectSymbol.prototype.highlight = function () {
        enterEmphasis(this)
      }
      /**
       * Downplay symbol
       */

      EffectSymbol.prototype.downplay = function () {
        leaveEmphasis(this)
      }

      EffectSymbol.prototype.getSymbolType = function () {
        const symbol = this.childAt(0)
        return symbol && symbol.getSymbolType()
      }
      /**
       * Update symbol properties
       */

      EffectSymbol.prototype.updateData = function (data, idx) {
        const _this = this

        const seriesModel = data.hostModel
        this.childAt(0).updateData(data, idx)
        const rippleGroup = this.childAt(1)
        const itemModel = data.getItemModel(idx)
        const symbolType = data.getItemVisual(idx, 'symbol')
        const symbolSize = normalizeSymbolSize(data.getItemVisual(idx, 'symbolSize'))
        const symbolStyle = data.getItemVisual(idx, 'style')
        const color = symbolStyle && symbolStyle.fill
        const emphasisModel = itemModel.getModel('emphasis')
        rippleGroup.setScale(symbolSize)
        rippleGroup.traverse(function (ripplePath) {
          ripplePath.setStyle('fill', color)
        })
        const symbolOffset = normalizeSymbolOffset(data.getItemVisual(idx, 'symbolOffset'), symbolSize)

        if (symbolOffset) {
          rippleGroup.x = symbolOffset[0]
          rippleGroup.y = symbolOffset[1]
        }

        const symbolRotate = data.getItemVisual(idx, 'symbolRotate')
        rippleGroup.rotation = (symbolRotate || 0) * Math.PI / 180 || 0
        const effectCfg = {}
        effectCfg.showEffectOn = seriesModel.get('showEffectOn')
        effectCfg.rippleScale = itemModel.get(['rippleEffect', 'scale'])
        effectCfg.brushType = itemModel.get(['rippleEffect', 'brushType'])
        effectCfg.period = itemModel.get(['rippleEffect', 'period']) * 1000
        effectCfg.effectOffset = idx / data.count()
        effectCfg.z = seriesModel.getShallow('z') || 0
        effectCfg.zlevel = seriesModel.getShallow('zlevel') || 0
        effectCfg.symbolType = symbolType
        effectCfg.color = color
        effectCfg.rippleEffectColor = itemModel.get(['rippleEffect', 'color'])
        effectCfg.rippleNumber = itemModel.get(['rippleEffect', 'number'])

        if (effectCfg.showEffectOn === 'render') {
          this._effectCfg ? this.updateEffectAnimation(effectCfg) : this.startEffectAnimation(effectCfg)
          this._effectCfg = effectCfg
        } else {
          // Not keep old effect config
          this._effectCfg = null
          this.stopEffectAnimation()

          this.onHoverStateChange = function (toState) {
            if (toState === 'emphasis') {
              if (effectCfg.showEffectOn !== 'render') {
                _this.startEffectAnimation(effectCfg)
              }
            } else if (toState === 'normal') {
              if (effectCfg.showEffectOn !== 'render') {
                _this.stopEffectAnimation()
              }
            }
          }
        }

        this._effectCfg = effectCfg
        toggleHoverEmphasis(this, emphasisModel.get('focus'), emphasisModel.get('blurScope'), emphasisModel.get('disabled'))
      }

      EffectSymbol.prototype.fadeOut = function (cb) {
        cb && cb()
      }
      return EffectSymbol
    }(Group))

  const EffectScatterView =
    /** @class */
    (function (_super) {
      __extends(EffectScatterView, _super)

      function EffectScatterView () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = EffectScatterView.type
        return _this
      }

      EffectScatterView.prototype.init = function () {
        this._symbolDraw = new SymbolDraw(EffectSymbol)
      }

      EffectScatterView.prototype.render = function (seriesModel, ecModel, api) {
        const data = seriesModel.getData()
        const effectSymbolDraw = this._symbolDraw
        effectSymbolDraw.updateData(data, {
          clipShape: this._getClipShape(seriesModel)
        })
        this.group.add(effectSymbolDraw.group)
      }

      EffectScatterView.prototype._getClipShape = function (seriesModel) {
        const coordSys = seriesModel.coordinateSystem
        const clipArea = coordSys && coordSys.getArea && coordSys.getArea()
        return seriesModel.get('clip', true) ? clipArea : null
      }

      EffectScatterView.prototype.updateTransform = function (seriesModel, ecModel, api) {
        const data = seriesModel.getData()
        this.group.dirty()
        const res = pointsLayout('').reset(seriesModel, ecModel, api)

        if (res.progress) {
          res.progress({
            start: 0,
            end: data.count(),
            count: data.count()
          }, data)
        }

        this._symbolDraw.updateLayout()
      }

      EffectScatterView.prototype._updateGroupTransform = function (seriesModel) {
        const coordSys = seriesModel.coordinateSystem

        if (coordSys && coordSys.getRoamTransform) {
          this.group.transform = clone$2(coordSys.getRoamTransform())
          this.group.decomposeTransform()
        }
      }

      EffectScatterView.prototype.remove = function (ecModel, api) {
        this._symbolDraw && this._symbolDraw.remove(true)
      }

      EffectScatterView.type = 'effectScatter'
      return EffectScatterView
    }(ChartView))

  const EffectScatterSeriesModel =
    /** @class */
    (function (_super) {
      __extends(EffectScatterSeriesModel, _super)

      function EffectScatterSeriesModel () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = EffectScatterSeriesModel.type
        _this.hasSymbolVisual = true
        return _this
      }

      EffectScatterSeriesModel.prototype.getInitialData = function (option, ecModel) {
        return createSeriesData(null, this, {
          useEncodeDefaulter: true
        })
      }

      EffectScatterSeriesModel.prototype.brushSelector = function (dataIndex, data, selectors) {
        return selectors.point(data.getItemLayout(dataIndex))
      }

      EffectScatterSeriesModel.type = 'series.effectScatter'
      EffectScatterSeriesModel.dependencies = ['grid', 'polar']
      EffectScatterSeriesModel.defaultOption = {
        coordinateSystem: 'cartesian2d',
        // zlevel: 0,
        z: 2,
        legendHoverLink: true,
        effectType: 'ripple',
        progressive: 0,
        // When to show the effect, option: 'render'|'emphasis'
        showEffectOn: 'render',
        clip: true,
        // Ripple effect config
        rippleEffect: {
          period: 4,
          // Scale of ripple
          scale: 2.5,
          // Brush type can be fill or stroke
          brushType: 'fill',
          // Ripple number
          number: 3
        },
        universalTransition: {
          divideShape: 'clone'
        },
        // Cartesian coordinate system
        // xAxisIndex: 0,
        // yAxisIndex: 0,
        // Polar coordinate system
        // polarIndex: 0,
        // Geo coordinate system
        // geoIndex: 0,
        // symbol: null,        // 图形类型
        symbolSize: 10 // 图形大小，半宽（半径）参数，当图形为方向或菱形则总宽度为symbolSize * 2
        // symbolRotate: null,  // 图形旋转控制
        // itemStyle: {
        //     opacity: 1
        // }

      }
      return EffectScatterSeriesModel
    }(SeriesModel))

  function install$l (registers) {
    registers.registerChartView(EffectScatterView)
    registers.registerSeriesModel(EffectScatterSeriesModel)
    registers.registerLayout(pointsLayout('effectScatter'))
  }

  const EffectLine =
    /** @class */
    (function (_super) {
      __extends(EffectLine, _super)

      function EffectLine (lineData, idx, seriesScope) {
        const _this = _super.call(this) || this

        _this.add(_this.createLine(lineData, idx, seriesScope))

        _this._updateEffectSymbol(lineData, idx)

        return _this
      }

      EffectLine.prototype.createLine = function (lineData, idx, seriesScope) {
        return new Line$1(lineData, idx, seriesScope)
      }

      EffectLine.prototype._updateEffectSymbol = function (lineData, idx) {
        const itemModel = lineData.getItemModel(idx)
        const effectModel = itemModel.getModel('effect')
        let size = effectModel.get('symbolSize')
        const symbolType = effectModel.get('symbol')

        if (!isArray(size)) {
          size = [size, size]
        }

        const lineStyle = lineData.getItemVisual(idx, 'style')
        const color = effectModel.get('color') || lineStyle && lineStyle.stroke
        let symbol = this.childAt(1)

        if (this._symbolType !== symbolType) {
          // Remove previous
          this.remove(symbol)
          symbol = createSymbol(symbolType, -0.5, -0.5, 1, 1, color)
          symbol.z2 = 100
          symbol.culling = true
          this.add(symbol)
        } // Symbol may be removed if loop is false

        if (!symbol) {
          return
        } // Shadow color is same with color in default

        symbol.setStyle('shadowColor', color)
        symbol.setStyle(effectModel.getItemStyle(['color']))
        symbol.scaleX = size[0]
        symbol.scaleY = size[1]
        symbol.setColor(color)
        this._symbolType = symbolType
        this._symbolScale = size

        this._updateEffectAnimation(lineData, effectModel, idx)
      }

      EffectLine.prototype._updateEffectAnimation = function (lineData, effectModel, idx) {
        const symbol = this.childAt(1)

        if (!symbol) {
          return
        }

        const points = lineData.getItemLayout(idx)
        let period = effectModel.get('period') * 1000
        const loop = effectModel.get('loop')
        const constantSpeed = effectModel.get('constantSpeed')
        const delayExpr = retrieve(effectModel.get('delay'), function (idx) {
          return idx / lineData.count() * period / 3
        }) // Ignore when updating

        symbol.ignore = true

        this._updateAnimationPoints(symbol, points)

        if (constantSpeed > 0) {
          period = this._getLineLength(symbol) / constantSpeed * 1000
        }

        if (period !== this._period || loop !== this._loop) {
          symbol.stopAnimation()
          let delayNum = void 0

          if (isFunction(delayExpr)) {
            delayNum = delayExpr(idx)
          } else {
            delayNum = delayExpr
          }

          if (symbol.__t > 0) {
            delayNum = -period * symbol.__t
          }

          this._animateSymbol(symbol, period, delayNum, loop)
        }

        this._period = period
        this._loop = loop
      }

      EffectLine.prototype._animateSymbol = function (symbol, period, delayNum, loop) {
        if (period > 0) {
          symbol.__t = 0
          const self_1 = this
          const animator = symbol.animate('', loop).when(period, {
            __t: 1
          }).delay(delayNum).during(function () {
            self_1._updateSymbolPosition(symbol)
          })

          if (!loop) {
            animator.done(function () {
              self_1.remove(symbol)
            })
          }

          animator.start()
        }
      }

      EffectLine.prototype._getLineLength = function (symbol) {
        // Not so accurate
        return dist(symbol.__p1, symbol.__cp1) + dist(symbol.__cp1, symbol.__p2)
      }

      EffectLine.prototype._updateAnimationPoints = function (symbol, points) {
        symbol.__p1 = points[0]
        symbol.__p2 = points[1]
        symbol.__cp1 = points[2] || [(points[0][0] + points[1][0]) / 2, (points[0][1] + points[1][1]) / 2]
      }

      EffectLine.prototype.updateData = function (lineData, idx, seriesScope) {
        this.childAt(0).updateData(lineData, idx, seriesScope)

        this._updateEffectSymbol(lineData, idx)
      }

      EffectLine.prototype._updateSymbolPosition = function (symbol) {
        const p1 = symbol.__p1
        const p2 = symbol.__p2
        const cp1 = symbol.__cp1
        const t = symbol.__t
        const pos = [symbol.x, symbol.y]
        const lastPos = pos.slice()
        const quadraticAt$1 = quadraticAt
        const quadraticDerivativeAt$1 = quadraticDerivativeAt
        pos[0] = quadraticAt$1(p1[0], cp1[0], p2[0], t)
        pos[1] = quadraticAt$1(p1[1], cp1[1], p2[1], t) // Tangent

        const tx = quadraticDerivativeAt$1(p1[0], cp1[0], p2[0], t)
        const ty = quadraticDerivativeAt$1(p1[1], cp1[1], p2[1], t)
        symbol.rotation = -Math.atan2(ty, tx) - Math.PI / 2 // enable continuity trail for 'line', 'rect', 'roundRect' symbolType

        if (this._symbolType === 'line' || this._symbolType === 'rect' || this._symbolType === 'roundRect') {
          if (symbol.__lastT !== undefined && symbol.__lastT < symbol.__t) {
            symbol.scaleY = dist(lastPos, pos) * 1.05 // make sure the last segment render within endPoint

            if (t === 1) {
              pos[0] = lastPos[0] + (pos[0] - lastPos[0]) / 2
              pos[1] = lastPos[1] + (pos[1] - lastPos[1]) / 2
            }
          } else if (symbol.__lastT === 1) {
            // After first loop, symbol.__t does NOT start with 0, so connect p1 to pos directly.
            symbol.scaleY = 2 * dist(p1, pos)
          } else {
            symbol.scaleY = this._symbolScale[1]
          }
        }

        symbol.__lastT = symbol.__t
        symbol.ignore = false
        symbol.x = pos[0]
        symbol.y = pos[1]
      }

      EffectLine.prototype.updateLayout = function (lineData, idx) {
        this.childAt(0).updateLayout(lineData, idx)
        const effectModel = lineData.getItemModel(idx).getModel('effect')

        this._updateEffectAnimation(lineData, effectModel, idx)
      }

      return EffectLine
    }(Group))

  const Polyline$1 =
    /** @class */
    (function (_super) {
      __extends(Polyline$1, _super)

      function Polyline$1 (lineData, idx, seriesScope) {
        const _this = _super.call(this) || this

        _this._createPolyline(lineData, idx, seriesScope)

        return _this
      }

      Polyline$1.prototype._createPolyline = function (lineData, idx, seriesScope) {
        // let seriesModel = lineData.hostModel;
        const points = lineData.getItemLayout(idx)
        const line = new Polyline({
          shape: {
            points: points
          }
        })
        this.add(line)

        this._updateCommonStl(lineData, idx, seriesScope)
      }

      Polyline$1.prototype.updateData = function (lineData, idx, seriesScope) {
        const seriesModel = lineData.hostModel
        const line = this.childAt(0)
        const target = {
          shape: {
            points: lineData.getItemLayout(idx)
          }
        }
        updateProps(line, target, seriesModel, idx)

        this._updateCommonStl(lineData, idx, seriesScope)
      }

      Polyline$1.prototype._updateCommonStl = function (lineData, idx, seriesScope) {
        const line = this.childAt(0)
        const itemModel = lineData.getItemModel(idx)
        let emphasisLineStyle = seriesScope && seriesScope.emphasisLineStyle
        let focus = seriesScope && seriesScope.focus
        let blurScope = seriesScope && seriesScope.blurScope
        let emphasisDisabled = seriesScope && seriesScope.emphasisDisabled

        if (!seriesScope || lineData.hasItemOption) {
          const emphasisModel = itemModel.getModel('emphasis')
          emphasisLineStyle = emphasisModel.getModel('lineStyle').getLineStyle()
          emphasisDisabled = emphasisModel.get('disabled')
          focus = emphasisModel.get('focus')
          blurScope = emphasisModel.get('blurScope')
        }

        line.useStyle(lineData.getItemVisual(idx, 'style'))
        line.style.fill = null
        line.style.strokeNoScale = true
        const lineEmphasisState = line.ensureState('emphasis')
        lineEmphasisState.style = emphasisLineStyle
        toggleHoverEmphasis(this, focus, blurScope, emphasisDisabled)
      }

      Polyline$1.prototype.updateLayout = function (lineData, idx) {
        const polyline = this.childAt(0)
        polyline.setShape('points', lineData.getItemLayout(idx))
      }
      return Polyline$1
    }(Group))

  const EffectPolyline =
    /** @class */
    (function (_super) {
      __extends(EffectPolyline, _super)

      function EffectPolyline () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this._lastFrame = 0
        _this._lastFramePercent = 0
        return _this
      } // Override

      EffectPolyline.prototype.createLine = function (lineData, idx, seriesScope) {
        return new Polyline$1(lineData, idx, seriesScope)
      }

      EffectPolyline.prototype._updateAnimationPoints = function (symbol, points) {
        this._points = points
        const accLenArr = [0]
        let len = 0

        for (var i = 1; i < points.length; i++) {
          const p1 = points[i - 1]
          const p2 = points[i]
          len += dist(p1, p2)
          accLenArr.push(len)
        }

        if (len === 0) {
          this._length = 0
          return
        }

        for (var i = 0; i < accLenArr.length; i++) {
          accLenArr[i] /= len
        }

        this._offsets = accLenArr
        this._length = len
      }

      EffectPolyline.prototype._getLineLength = function () {
        return this._length
      }

      EffectPolyline.prototype._updateSymbolPosition = function (symbol) {
        const t = symbol.__t
        const points = this._points
        const offsets = this._offsets
        const len = points.length

        if (!offsets) {
          // Has length 0
          return
        }

        const lastFrame = this._lastFrame
        let frame

        if (t < this._lastFramePercent) {
          // Start from the next frame
          // PENDING start from lastFrame ?
          const start = Math.min(lastFrame + 1, len - 1)

          for (frame = start; frame >= 0; frame--) {
            if (offsets[frame] <= t) {
              break
            }
          } // PENDING really need to do this ?

          frame = Math.min(frame, len - 2)
        } else {
          for (frame = lastFrame; frame < len; frame++) {
            if (offsets[frame] > t) {
              break
            }
          }

          frame = Math.min(frame - 1, len - 2)
        }

        const p = (t - offsets[frame]) / (offsets[frame + 1] - offsets[frame])
        const p0 = points[frame]
        const p1 = points[frame + 1]
        symbol.x = p0[0] * (1 - p) + p * p1[0]
        symbol.y = p0[1] * (1 - p) + p * p1[1]
        const tx = p1[0] - p0[0]
        const ty = p1[1] - p0[1]
        symbol.rotation = -Math.atan2(ty, tx) - Math.PI / 2
        this._lastFrame = frame
        this._lastFramePercent = t
        symbol.ignore = false
      }
      return EffectPolyline
    }(EffectLine))

  const LargeLinesPathShape =
    /** @class */
    (function () {
      function LargeLinesPathShape () {
        this.polyline = false
        this.curveness = 0
        this.segs = []
      }

      return LargeLinesPathShape
    }())

  const LargeLinesPath =
    /** @class */
    (function (_super) {
      __extends(LargeLinesPath, _super)

      function LargeLinesPath (opts) {
        const _this = _super.call(this, opts) || this

        _this._off = 0
        _this.hoverDataIdx = -1
        return _this
      }

      LargeLinesPath.prototype.reset = function () {
        this.notClear = false
        this._off = 0
      }

      LargeLinesPath.prototype.getDefaultStyle = function () {
        return {
          stroke: '#000',
          fill: null
        }
      }

      LargeLinesPath.prototype.getDefaultShape = function () {
        return new LargeLinesPathShape()
      }

      LargeLinesPath.prototype.buildPath = function (ctx, shape) {
        const segs = shape.segs
        const curveness = shape.curveness
        let i

        if (shape.polyline) {
          for (i = this._off; i < segs.length;) {
            const count = segs[i++]

            if (count > 0) {
              ctx.moveTo(segs[i++], segs[i++])

              for (let k = 1; k < count; k++) {
                ctx.lineTo(segs[i++], segs[i++])
              }
            }
          }
        } else {
          for (i = this._off; i < segs.length;) {
            const x0 = segs[i++]
            const y0 = segs[i++]
            const x1 = segs[i++]
            const y1 = segs[i++]
            ctx.moveTo(x0, y0)

            if (curveness > 0) {
              const x2 = (x0 + x1) / 2 - (y0 - y1) * curveness
              const y2 = (y0 + y1) / 2 - (x1 - x0) * curveness
              ctx.quadraticCurveTo(x2, y2, x1, y1)
            } else {
              ctx.lineTo(x1, y1)
            }
          }
        }

        if (this.incremental) {
          this._off = i
          this.notClear = true
        }
      }

      LargeLinesPath.prototype.findDataIndex = function (x, y) {
        const shape = this.shape
        const segs = shape.segs
        const curveness = shape.curveness
        const lineWidth = this.style.lineWidth

        if (shape.polyline) {
          var dataIndex = 0

          for (var i = 0; i < segs.length;) {
            const count = segs[i++]

            if (count > 0) {
              var x0 = segs[i++]
              var y0 = segs[i++]

              for (let k = 1; k < count; k++) {
                var x1 = segs[i++]
                var y1 = segs[i++]

                if (containStroke(x0, y0, x1, y1, lineWidth, x, y)) {
                  return dataIndex
                }
              }
            }

            dataIndex++
          }
        } else {
          var dataIndex = 0

          for (var i = 0; i < segs.length;) {
            var x0 = segs[i++]
            var y0 = segs[i++]
            var x1 = segs[i++]
            var y1 = segs[i++]

            if (curveness > 0) {
              const x2 = (x0 + x1) / 2 - (y0 - y1) * curveness
              const y2 = (y0 + y1) / 2 - (x1 - x0) * curveness

              if (containStroke$2(x0, y0, x2, y2, x1, y1, lineWidth, x, y)) {
                return dataIndex
              }
            } else {
              if (containStroke(x0, y0, x1, y1, lineWidth, x, y)) {
                return dataIndex
              }
            }

            dataIndex++
          }
        }

        return -1
      }

      LargeLinesPath.prototype.contain = function (x, y) {
        const localPos = this.transformCoordToLocal(x, y)
        const rect = this.getBoundingRect()
        x = localPos[0]
        y = localPos[1]

        if (rect.contain(x, y)) {
          // Cache found data index.
          const dataIdx = this.hoverDataIdx = this.findDataIndex(x, y)
          return dataIdx >= 0
        }

        this.hoverDataIdx = -1
        return false
      }

      LargeLinesPath.prototype.getBoundingRect = function () {
        // Ignore stroke for large symbol draw.
        let rect = this._rect

        if (!rect) {
          const shape = this.shape
          const points = shape.segs
          let minX = Infinity
          let minY = Infinity
          let maxX = -Infinity
          let maxY = -Infinity

          for (let i = 0; i < points.length;) {
            const x = points[i++]
            const y = points[i++]
            minX = Math.min(x, minX)
            maxX = Math.max(x, maxX)
            minY = Math.min(y, minY)
            maxY = Math.max(y, maxY)
          }

          rect = this._rect = new BoundingRect(minX, minY, maxX, maxY)
        }

        return rect
      }

      return LargeLinesPath
    }(Path))

  const LargeLineDraw =
    /** @class */
    (function () {
      function LargeLineDraw () {
        this.group = new Group()
      }
      /**
       * Update symbols draw by new data
       */

      LargeLineDraw.prototype.updateData = function (data) {
        this._clear()

        const lineEl = this._create()

        lineEl.setShape({
          segs: data.getLayout('linesPoints')
        })

        this._setCommon(lineEl, data)
      }
      /**
       * @override
       */

      LargeLineDraw.prototype.incrementalPrepareUpdate = function (data) {
        this.group.removeAll()

        this._clear()
      }
      /**
       * @override
       */

      LargeLineDraw.prototype.incrementalUpdate = function (taskParams, data) {
        const lastAdded = this._newAdded[0]
        const linePoints = data.getLayout('linesPoints')
        const oldSegs = lastAdded && lastAdded.shape.segs // Merging the exists. Each element has 1e4 points.
        // Consider the performance balance between too much elements and too much points in one shape(may affect hover optimization)

        if (oldSegs && oldSegs.length < 2e4) {
          const oldLen = oldSegs.length
          const newSegs = new Float32Array(oldLen + linePoints.length) // Concat two array

          newSegs.set(oldSegs)
          newSegs.set(linePoints, oldLen)
          lastAdded.setShape({
            segs: newSegs
          })
        } else {
          // Clear
          this._newAdded = []

          const lineEl = this._create()

          lineEl.incremental = true
          lineEl.setShape({
            segs: linePoints
          })

          this._setCommon(lineEl, data)

          lineEl.__startIndex = taskParams.start
        }
      }
      /**
       * @override
       */

      LargeLineDraw.prototype.remove = function () {
        this._clear()
      }

      LargeLineDraw.prototype.eachRendered = function (cb) {
        this._newAdded[0] && cb(this._newAdded[0])
      }

      LargeLineDraw.prototype._create = function () {
        const lineEl = new LargeLinesPath({
          cursor: 'default'
        })

        this._newAdded.push(lineEl)

        this.group.add(lineEl)
        return lineEl
      }

      LargeLineDraw.prototype._setCommon = function (lineEl, data, isIncremental) {
        const hostModel = data.hostModel
        lineEl.setShape({
          polyline: hostModel.get('polyline'),
          curveness: hostModel.get(['lineStyle', 'curveness'])
        })
        lineEl.useStyle(hostModel.getModel('lineStyle').getLineStyle())
        lineEl.style.strokeNoScale = true
        const style = data.getVisual('style')

        if (style && style.stroke) {
          lineEl.setStyle('stroke', style.stroke)
        }

        lineEl.setStyle('fill', null)
        const ecData = getECData(lineEl) // Enable tooltip
        // PENDING May have performance issue when path is extremely large

        ecData.seriesIndex = hostModel.seriesIndex
        lineEl.on('mousemove', function (e) {
          ecData.dataIndex = null
          const dataIndex = lineEl.hoverDataIdx

          if (dataIndex > 0) {
            // Provide dataIndex for tooltip
            ecData.dataIndex = dataIndex + lineEl.__startIndex
          }
        })
      }

      LargeLineDraw.prototype._clear = function () {
        this._newAdded = []
        this.group.removeAll()
      }
      return LargeLineDraw
    }())

  const linesLayout = {
    seriesType: 'lines',
    plan: createRenderPlanner(),
    reset: function (seriesModel) {
      const coordSys = seriesModel.coordinateSystem

      if (!coordSys) {
        if ('development' !== 'production') {
          error('The lines series must have a coordinate system.')
        }

        return
      }

      const isPolyline = seriesModel.get('polyline')
      const isLarge = seriesModel.pipelineContext.large
      return {
        progress: function (params, lineData) {
          const lineCoords = []

          if (isLarge) {
            let points = void 0
            const segCount = params.end - params.start

            if (isPolyline) {
              let totalCoordsCount = 0

              for (var i = params.start; i < params.end; i++) {
                totalCoordsCount += seriesModel.getLineCoordsCount(i)
              }

              points = new Float32Array(segCount + totalCoordsCount * 2)
            } else {
              points = new Float32Array(segCount * 4)
            }

            let offset = 0
            let pt = []

            for (var i = params.start; i < params.end; i++) {
              var len = seriesModel.getLineCoords(i, lineCoords)

              if (isPolyline) {
                points[offset++] = len
              }

              for (let k = 0; k < len; k++) {
                pt = coordSys.dataToPoint(lineCoords[k], false, pt)
                points[offset++] = pt[0]
                points[offset++] = pt[1]
              }
            }

            lineData.setLayout('linesPoints', points)
          } else {
            for (var i = params.start; i < params.end; i++) {
              const itemModel = lineData.getItemModel(i)
              var len = seriesModel.getLineCoords(i, lineCoords)
              const pts = []

              if (isPolyline) {
                for (let j = 0; j < len; j++) {
                  pts.push(coordSys.dataToPoint(lineCoords[j]))
                }
              } else {
                pts[0] = coordSys.dataToPoint(lineCoords[0])
                pts[1] = coordSys.dataToPoint(lineCoords[1])
                const curveness = itemModel.get(['lineStyle', 'curveness'])

                if (+curveness) {
                  pts[2] = [(pts[0][0] + pts[1][0]) / 2 - (pts[0][1] - pts[1][1]) * curveness, (pts[0][1] + pts[1][1]) / 2 - (pts[1][0] - pts[0][0]) * curveness]
                }
              }

              lineData.setItemLayout(i, pts)
            }
          }
        }
      }
    }
  }

  const LinesView =
    /** @class */
    (function (_super) {
      __extends(LinesView, _super)

      function LinesView () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = LinesView.type
        return _this
      }

      LinesView.prototype.render = function (seriesModel, ecModel, api) {
        const data = seriesModel.getData()

        const lineDraw = this._updateLineDraw(data, seriesModel)

        const zlevel = seriesModel.get('zlevel')
        const trailLength = seriesModel.get(['effect', 'trailLength'])
        const zr = api.getZr() // Avoid the drag cause ghost shadow
        // FIXME Better way ?
        // SVG doesn't support

        const isSvg = zr.painter.getType() === 'svg'

        if (!isSvg) {
          zr.painter.getLayer(zlevel).clear(true)
        } // Config layer with motion blur

        if (this._lastZlevel != null && !isSvg) {
          zr.configLayer(this._lastZlevel, {
            motionBlur: false
          })
        }

        if (this._showEffect(seriesModel) && trailLength > 0) {
          if (!isSvg) {
            zr.configLayer(zlevel, {
              motionBlur: true,
              lastFrameAlpha: Math.max(Math.min(trailLength / 10 + 0.9, 1), 0)
            })
          } else if ('development' !== 'production') {
            console.warn('SVG render mode doesn\'t support lines with trail effect')
          }
        }

        lineDraw.updateData(data)
        const clipPath = seriesModel.get('clip', true) && createClipPath(seriesModel.coordinateSystem, false, seriesModel)

        if (clipPath) {
          this.group.setClipPath(clipPath)
        } else {
          this.group.removeClipPath()
        }

        this._lastZlevel = zlevel
        this._finished = true
      }

      LinesView.prototype.incrementalPrepareRender = function (seriesModel, ecModel, api) {
        const data = seriesModel.getData()

        const lineDraw = this._updateLineDraw(data, seriesModel)

        lineDraw.incrementalPrepareUpdate(data)

        this._clearLayer(api)

        this._finished = false
      }

      LinesView.prototype.incrementalRender = function (taskParams, seriesModel, ecModel) {
        this._lineDraw.incrementalUpdate(taskParams, seriesModel.getData())

        this._finished = taskParams.end === seriesModel.getData().count()
      }

      LinesView.prototype.eachRendered = function (cb) {
        this._lineDraw && this._lineDraw.eachRendered(cb)
      }

      LinesView.prototype.updateTransform = function (seriesModel, ecModel, api) {
        const data = seriesModel.getData()
        const pipelineContext = seriesModel.pipelineContext

        if (!this._finished || pipelineContext.large || pipelineContext.progressiveRender) {
          // TODO Don't have to do update in large mode. Only do it when there are millions of data.
          return {
            update: true
          }
        } else {
          // TODO Use same logic with ScatterView.
          // Manually update layout
          const res = linesLayout.reset(seriesModel, ecModel, api)

          if (res.progress) {
            res.progress({
              start: 0,
              end: data.count(),
              count: data.count()
            }, data)
          } // Not in large mode

          this._lineDraw.updateLayout()

          this._clearLayer(api)
        }
      }

      LinesView.prototype._updateLineDraw = function (data, seriesModel) {
        let lineDraw = this._lineDraw

        const hasEffect = this._showEffect(seriesModel)

        const isPolyline = !!seriesModel.get('polyline')
        const pipelineContext = seriesModel.pipelineContext
        const isLargeDraw = pipelineContext.large

        if ('development' !== 'production') {
          if (hasEffect && isLargeDraw) {
            console.warn('Large lines not support effect')
          }
        }

        if (!lineDraw || hasEffect !== this._hasEffet || isPolyline !== this._isPolyline || isLargeDraw !== this._isLargeDraw) {
          if (lineDraw) {
            lineDraw.remove()
          }

          lineDraw = this._lineDraw = isLargeDraw ? new LargeLineDraw() : new LineDraw(isPolyline ? hasEffect ? EffectPolyline : Polyline$1 : hasEffect ? EffectLine : Line$1)
          this._hasEffet = hasEffect
          this._isPolyline = isPolyline
          this._isLargeDraw = isLargeDraw
        }

        this.group.add(lineDraw.group)
        return lineDraw
      }

      LinesView.prototype._showEffect = function (seriesModel) {
        return !!seriesModel.get(['effect', 'show'])
      }

      LinesView.prototype._clearLayer = function (api) {
        // Not use motion when dragging or zooming
        const zr = api.getZr()
        const isSvg = zr.painter.getType() === 'svg'

        if (!isSvg && this._lastZlevel != null) {
          zr.painter.getLayer(this._lastZlevel).clear(true)
        }
      }

      LinesView.prototype.remove = function (ecModel, api) {
        this._lineDraw && this._lineDraw.remove()
        this._lineDraw = null // Clear motion when lineDraw is removed

        this._clearLayer(api)
      }

      LinesView.prototype.dispose = function (ecModel, api) {
        this.remove(ecModel, api)
      }

      LinesView.type = 'lines'
      return LinesView
    }(ChartView))

  const Uint32Arr = typeof Uint32Array === 'undefined' ? Array : Uint32Array
  const Float64Arr = typeof Float64Array === 'undefined' ? Array : Float64Array

  function compatEc2 (seriesOpt) {
    const data = seriesOpt.data

    if (data && data[0] && data[0][0] && data[0][0].coord) {
      if ('development' !== 'production') {
        console.warn('Lines data configuration has been changed to' + ' { coords:[[1,2],[2,3]] }')
      }

      seriesOpt.data = map(data, function (itemOpt) {
        const coords = [itemOpt[0].coord, itemOpt[1].coord]
        const target = {
          coords: coords
        }

        if (itemOpt[0].name) {
          target.fromName = itemOpt[0].name
        }

        if (itemOpt[1].name) {
          target.toName = itemOpt[1].name
        }

        return mergeAll([target, itemOpt[0], itemOpt[1]])
      })
    }
  }

  const LinesSeriesModel =
    /** @class */
    (function (_super) {
      __extends(LinesSeriesModel, _super)

      function LinesSeriesModel () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = LinesSeriesModel.type
        _this.visualStyleAccessPath = 'lineStyle'
        _this.visualDrawType = 'stroke'
        return _this
      }

      LinesSeriesModel.prototype.init = function (option) {
        // The input data may be null/undefined.
        option.data = option.data || [] // Not using preprocessor because mergeOption may not have series.type

        compatEc2(option)

        const result = this._processFlatCoordsArray(option.data)

        this._flatCoords = result.flatCoords
        this._flatCoordsOffset = result.flatCoordsOffset

        if (result.flatCoords) {
          option.data = new Float32Array(result.count)
        }

        _super.prototype.init.apply(this, arguments)
      }

      LinesSeriesModel.prototype.mergeOption = function (option) {
        compatEc2(option)

        if (option.data) {
          // Only update when have option data to merge.
          const result = this._processFlatCoordsArray(option.data)

          this._flatCoords = result.flatCoords
          this._flatCoordsOffset = result.flatCoordsOffset

          if (result.flatCoords) {
            option.data = new Float32Array(result.count)
          }
        }

        _super.prototype.mergeOption.apply(this, arguments)
      }

      LinesSeriesModel.prototype.appendData = function (params) {
        const result = this._processFlatCoordsArray(params.data)

        if (result.flatCoords) {
          if (!this._flatCoords) {
            this._flatCoords = result.flatCoords
            this._flatCoordsOffset = result.flatCoordsOffset
          } else {
            this._flatCoords = concatArray(this._flatCoords, result.flatCoords)
            this._flatCoordsOffset = concatArray(this._flatCoordsOffset, result.flatCoordsOffset)
          }

          params.data = new Float32Array(result.count)
        }

        this.getRawData().appendData(params.data)
      }

      LinesSeriesModel.prototype._getCoordsFromItemModel = function (idx) {
        const itemModel = this.getData().getItemModel(idx)
        const coords = itemModel.option instanceof Array ? itemModel.option : itemModel.getShallow('coords')

        if ('development' !== 'production') {
          if (!(coords instanceof Array && coords.length > 0 && coords[0] instanceof Array)) {
            throw new Error('Invalid coords ' + JSON.stringify(coords) + '. Lines must have 2d coords array in data item.')
          }
        }

        return coords
      }

      LinesSeriesModel.prototype.getLineCoordsCount = function (idx) {
        if (this._flatCoordsOffset) {
          return this._flatCoordsOffset[idx * 2 + 1]
        } else {
          return this._getCoordsFromItemModel(idx).length
        }
      }

      LinesSeriesModel.prototype.getLineCoords = function (idx, out) {
        if (this._flatCoordsOffset) {
          const offset = this._flatCoordsOffset[idx * 2]
          const len = this._flatCoordsOffset[idx * 2 + 1]

          for (var i = 0; i < len; i++) {
            out[i] = out[i] || []
            out[i][0] = this._flatCoords[offset + i * 2]
            out[i][1] = this._flatCoords[offset + i * 2 + 1]
          }

          return len
        } else {
          const coords = this._getCoordsFromItemModel(idx)

          for (var i = 0; i < coords.length; i++) {
            out[i] = out[i] || []
            out[i][0] = coords[i][0]
            out[i][1] = coords[i][1]
          }

          return coords.length
        }
      }

      LinesSeriesModel.prototype._processFlatCoordsArray = function (data) {
        let startOffset = 0

        if (this._flatCoords) {
          startOffset = this._flatCoords.length
        } // Stored as a typed array. In format
        // Points Count(2) | x | y | x | y | Points Count(3) | x |  y | x | y | x | y |

        if (isNumber(data[0])) {
          const len = data.length // Store offset and len of each segment

          const coordsOffsetAndLenStorage = new Uint32Arr(len)
          const coordsStorage = new Float64Arr(len)
          let coordsCursor = 0
          let offsetCursor = 0
          let dataCount = 0

          for (let i = 0; i < len;) {
            dataCount++
            const count = data[i++] // Offset

            coordsOffsetAndLenStorage[offsetCursor++] = coordsCursor + startOffset // Len

            coordsOffsetAndLenStorage[offsetCursor++] = count

            for (let k = 0; k < count; k++) {
              const x = data[i++]
              const y = data[i++]
              coordsStorage[coordsCursor++] = x
              coordsStorage[coordsCursor++] = y

              if (i > len) {
                if ('development' !== 'production') {
                  throw new Error('Invalid data format.')
                }
              }
            }
          }

          return {
            flatCoordsOffset: new Uint32Array(coordsOffsetAndLenStorage.buffer, 0, offsetCursor),
            flatCoords: coordsStorage,
            count: dataCount
          }
        }

        return {
          flatCoordsOffset: null,
          flatCoords: null,
          count: data.length
        }
      }

      LinesSeriesModel.prototype.getInitialData = function (option, ecModel) {
        if ('development' !== 'production') {
          const CoordSys = CoordinateSystemManager.get(option.coordinateSystem)

          if (!CoordSys) {
            throw new Error('Unkown coordinate system ' + option.coordinateSystem)
          }
        }

        const lineData = new SeriesData(['value'], this)
        lineData.hasItemOption = false
        lineData.initData(option.data, [], function (dataItem, dimName, dataIndex, dimIndex) {
          // dataItem is simply coords
          if (dataItem instanceof Array) {
            return NaN
          } else {
            lineData.hasItemOption = true
            const value = dataItem.value

            if (value != null) {
              return value instanceof Array ? value[dimIndex] : value
            }
          }
        })
        return lineData
      }

      LinesSeriesModel.prototype.formatTooltip = function (dataIndex, multipleSeries, dataType) {
        const data = this.getData()
        const itemModel = data.getItemModel(dataIndex)
        const name = itemModel.get('name')

        if (name) {
          return name
        }

        const fromName = itemModel.get('fromName')
        const toName = itemModel.get('toName')
        const nameArr = []
        fromName != null && nameArr.push(fromName)
        toName != null && nameArr.push(toName)
        return createTooltipMarkup('nameValue', {
          name: nameArr.join(' > ')
        })
      }

      LinesSeriesModel.prototype.preventIncremental = function () {
        return !!this.get(['effect', 'show'])
      }

      LinesSeriesModel.prototype.getProgressive = function () {
        const progressive = this.option.progressive

        if (progressive == null) {
          return this.option.large ? 1e4 : this.get('progressive')
        }

        return progressive
      }

      LinesSeriesModel.prototype.getProgressiveThreshold = function () {
        const progressiveThreshold = this.option.progressiveThreshold

        if (progressiveThreshold == null) {
          return this.option.large ? 2e4 : this.get('progressiveThreshold')
        }

        return progressiveThreshold
      }

      LinesSeriesModel.prototype.getZLevelKey = function () {
        const effectModel = this.getModel('effect')
        const trailLength = effectModel.get('trailLength')
        return this.getData().count() > this.getProgressiveThreshold() // Each progressive series has individual key.
          ? this.id : effectModel.get('show') && trailLength > 0 ? trailLength + '' : ''
      }

      LinesSeriesModel.type = 'series.lines'
      LinesSeriesModel.dependencies = ['grid', 'polar', 'geo', 'calendar']
      LinesSeriesModel.defaultOption = {
        coordinateSystem: 'geo',
        // zlevel: 0,
        z: 2,
        legendHoverLink: true,
        // Cartesian coordinate system
        xAxisIndex: 0,
        yAxisIndex: 0,
        symbol: ['none', 'none'],
        symbolSize: [10, 10],
        // Geo coordinate system
        geoIndex: 0,
        effect: {
          show: false,
          period: 4,
          constantSpeed: 0,
          symbol: 'circle',
          symbolSize: 3,
          loop: true,
          trailLength: 0.2
        },
        large: false,
        // Available when large is true
        largeThreshold: 2000,
        polyline: false,
        clip: true,
        label: {
          show: false,
          position: 'end' // distance: 5,
          // formatter: 标签文本格式器，同Tooltip.formatter，不支持异步回调

        },
        lineStyle: {
          opacity: 0.5
        }
      }
      return LinesSeriesModel
    }(SeriesModel))

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

  /**
     * AUTO-GENERATED FILE. DO NOT MODIFY.
     */

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
  function normalize$3 (a) {
    if (!(a instanceof Array)) {
      a = [a, a]
    }

    return a
  }

  const linesVisual = {
    seriesType: 'lines',
    reset: function (seriesModel) {
      const symbolType = normalize$3(seriesModel.get('symbol'))
      const symbolSize = normalize$3(seriesModel.get('symbolSize'))
      const data = seriesModel.getData()
      data.setVisual('fromSymbol', symbolType && symbolType[0])
      data.setVisual('toSymbol', symbolType && symbolType[1])
      data.setVisual('fromSymbolSize', symbolSize && symbolSize[0])
      data.setVisual('toSymbolSize', symbolSize && symbolSize[1])

      function dataEach (data, idx) {
        const itemModel = data.getItemModel(idx)
        const symbolType = normalize$3(itemModel.getShallow('symbol', true))
        const symbolSize = normalize$3(itemModel.getShallow('symbolSize', true))
        symbolType[0] && data.setItemVisual(idx, 'fromSymbol', symbolType[0])
        symbolType[1] && data.setItemVisual(idx, 'toSymbol', symbolType[1])
        symbolSize[0] && data.setItemVisual(idx, 'fromSymbolSize', symbolSize[0])
        symbolSize[1] && data.setItemVisual(idx, 'toSymbolSize', symbolSize[1])
      }

      return {
        dataEach: data.hasItemOption ? dataEach : null
      }
    }
  }

  function install$m (registers) {
    registers.registerChartView(LinesView)
    registers.registerSeriesModel(LinesSeriesModel)
    registers.registerLayout(linesLayout)
    registers.registerVisual(linesVisual)
  }

  const GRADIENT_LEVELS = 256

  const HeatmapLayer =
    /** @class */
    (function () {
      function HeatmapLayer () {
        this.blurSize = 30
        this.pointSize = 20
        this.maxOpacity = 1
        this.minOpacity = 0
        this._gradientPixels = {
          inRange: null,
          outOfRange: null
        }
        const canvas = platformApi.createCanvas()
        this.canvas = canvas
      }
      /**
       * Renders Heatmap and returns the rendered canvas
       * @param data array of data, each has x, y, value
       * @param width canvas width
       * @param height canvas height
       */

      HeatmapLayer.prototype.update = function (data, width, height, normalize, colorFunc, isInRange) {
        const brush = this._getBrush()

        const gradientInRange = this._getGradient(colorFunc, 'inRange')

        const gradientOutOfRange = this._getGradient(colorFunc, 'outOfRange')

        const r = this.pointSize + this.blurSize
        const canvas = this.canvas
        const ctx = canvas.getContext('2d')
        const len = data.length
        canvas.width = width
        canvas.height = height

        for (let i = 0; i < len; ++i) {
          const p = data[i]
          const x = p[0]
          const y = p[1]
          const value = p[2] // calculate alpha using value

          var alpha = normalize(value) // draw with the circle brush with alpha

          ctx.globalAlpha = alpha
          ctx.drawImage(brush, x - r, y - r)
        }

        if (!canvas.width || !canvas.height) {
          // Avoid "Uncaught DOMException: Failed to execute 'getImageData' on
          // 'CanvasRenderingContext2D': The source height is 0."
          return canvas
        } // colorize the canvas using alpha value and set with gradient

        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height)
        const pixels = imageData.data
        let offset = 0
        const pixelLen = pixels.length
        const minOpacity = this.minOpacity
        const maxOpacity = this.maxOpacity
        const diffOpacity = maxOpacity - minOpacity

        while (offset < pixelLen) {
          var alpha = pixels[offset + 3] / 256
          const gradientOffset = Math.floor(alpha * (GRADIENT_LEVELS - 1)) * 4 // Simple optimize to ignore the empty data

          if (alpha > 0) {
            const gradient = isInRange(alpha) ? gradientInRange : gradientOutOfRange // Any alpha > 0 will be mapped to [minOpacity, maxOpacity]

            alpha > 0 && (alpha = alpha * diffOpacity + minOpacity)
            pixels[offset++] = gradient[gradientOffset]
            pixels[offset++] = gradient[gradientOffset + 1]
            pixels[offset++] = gradient[gradientOffset + 2]
            pixels[offset++] = gradient[gradientOffset + 3] * alpha * 256
          } else {
            offset += 4
          }
        }

        ctx.putImageData(imageData, 0, 0)
        return canvas
      }
      /**
       * get canvas of a black circle brush used for canvas to draw later
       */

      HeatmapLayer.prototype._getBrush = function () {
        const brushCanvas = this._brushCanvas || (this._brushCanvas = platformApi.createCanvas()) // set brush size

        const r = this.pointSize + this.blurSize
        const d = r * 2
        brushCanvas.width = d
        brushCanvas.height = d
        const ctx = brushCanvas.getContext('2d')
        ctx.clearRect(0, 0, d, d) // in order to render shadow without the distinct circle,
        // draw the distinct circle in an invisible place,
        // and use shadowOffset to draw shadow in the center of the canvas

        ctx.shadowOffsetX = d
        ctx.shadowBlur = this.blurSize // draw the shadow in black, and use alpha and shadow blur to generate
        // color in color map

        ctx.shadowColor = '#000' // draw circle in the left to the canvas

        ctx.beginPath()
        ctx.arc(-r, r, this.pointSize, 0, Math.PI * 2, true)
        ctx.closePath()
        ctx.fill()
        return brushCanvas
      }
      /**
       * get gradient color map
       * @private
       */

      HeatmapLayer.prototype._getGradient = function (colorFunc, state) {
        const gradientPixels = this._gradientPixels
        const pixelsSingleState = gradientPixels[state] || (gradientPixels[state] = new Uint8ClampedArray(256 * 4))
        const color = [0, 0, 0, 0]
        let off = 0

        for (let i = 0; i < 256; i++) {
          colorFunc[state](i / 255, true, color)
          pixelsSingleState[off++] = color[0]
          pixelsSingleState[off++] = color[1]
          pixelsSingleState[off++] = color[2]
          pixelsSingleState[off++] = color[3]
        }

        return pixelsSingleState
      }

      return HeatmapLayer
    }())

  function getIsInPiecewiseRange (dataExtent, pieceList, selected) {
    const dataSpan = dataExtent[1] - dataExtent[0]
    pieceList = map(pieceList, function (piece) {
      return {
        interval: [(piece.interval[0] - dataExtent[0]) / dataSpan, (piece.interval[1] - dataExtent[0]) / dataSpan]
      }
    })
    const len = pieceList.length
    let lastIndex = 0
    return function (val) {
      let i // Try to find in the location of the last found

      for (i = lastIndex; i < len; i++) {
        var interval = pieceList[i].interval

        if (interval[0] <= val && val <= interval[1]) {
          lastIndex = i
          break
        }
      }

      if (i === len) {
        // Not found, back interation
        for (i = lastIndex - 1; i >= 0; i--) {
          var interval = pieceList[i].interval

          if (interval[0] <= val && val <= interval[1]) {
            lastIndex = i
            break
          }
        }
      }

      return i >= 0 && i < len && selected[i]
    }
  }

  function getIsInContinuousRange (dataExtent, range) {
    const dataSpan = dataExtent[1] - dataExtent[0]
    range = [(range[0] - dataExtent[0]) / dataSpan, (range[1] - dataExtent[0]) / dataSpan]
    return function (val) {
      return val >= range[0] && val <= range[1]
    }
  }

  function isGeoCoordSys (coordSys) {
    const dimensions = coordSys.dimensions // Not use coorSys.type === 'geo' because coordSys maybe extended

    return dimensions[0] === 'lng' && dimensions[1] === 'lat'
  }

  const HeatmapView =
    /** @class */
    (function (_super) {
      __extends(HeatmapView, _super)

      function HeatmapView () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = HeatmapView.type
        return _this
      }

      HeatmapView.prototype.render = function (seriesModel, ecModel, api) {
        let visualMapOfThisSeries
        ecModel.eachComponent('visualMap', function (visualMap) {
          visualMap.eachTargetSeries(function (targetSeries) {
            if (targetSeries === seriesModel) {
              visualMapOfThisSeries = visualMap
            }
          })
        })

        if ('development' !== 'production') {
          if (!visualMapOfThisSeries) {
            throw new Error('Heatmap must use with visualMap')
          }
        } // Clear previously rendered progressive elements.

        this._progressiveEls = null
        this.group.removeAll()
        const coordSys = seriesModel.coordinateSystem

        if (coordSys.type === 'cartesian2d' || coordSys.type === 'calendar') {
          this._renderOnCartesianAndCalendar(seriesModel, api, 0, seriesModel.getData().count())
        } else if (isGeoCoordSys(coordSys)) {
          this._renderOnGeo(coordSys, seriesModel, visualMapOfThisSeries, api)
        }
      }

      HeatmapView.prototype.incrementalPrepareRender = function (seriesModel, ecModel, api) {
        this.group.removeAll()
      }

      HeatmapView.prototype.incrementalRender = function (params, seriesModel, ecModel, api) {
        const coordSys = seriesModel.coordinateSystem

        if (coordSys) {
          // geo does not support incremental rendering?
          if (isGeoCoordSys(coordSys)) {
            this.render(seriesModel, ecModel, api)
          } else {
            this._progressiveEls = []

            this._renderOnCartesianAndCalendar(seriesModel, api, params.start, params.end, true)
          }
        }
      }

      HeatmapView.prototype.eachRendered = function (cb) {
        traverseElements(this._progressiveEls || this.group, cb)
      }

      HeatmapView.prototype._renderOnCartesianAndCalendar = function (seriesModel, api, start, end, incremental) {
        const coordSys = seriesModel.coordinateSystem
        const isCartesian2d = isCoordinateSystemType(coordSys, 'cartesian2d')
        let width
        let height
        let xAxisExtent
        let yAxisExtent

        if (isCartesian2d) {
          const xAxis = coordSys.getAxis('x')
          const yAxis = coordSys.getAxis('y')

          if ('development' !== 'production') {
            if (!(xAxis.type === 'category' && yAxis.type === 'category')) {
              throw new Error('Heatmap on cartesian must have two category axes')
            }

            if (!(xAxis.onBand && yAxis.onBand)) {
              throw new Error('Heatmap on cartesian must have two axes with boundaryGap true')
            }
          } // add 0.5px to avoid the gaps

          width = xAxis.getBandWidth() + 0.5
          height = yAxis.getBandWidth() + 0.5
          xAxisExtent = xAxis.scale.getExtent()
          yAxisExtent = yAxis.scale.getExtent()
        }

        const group = this.group
        const data = seriesModel.getData()
        let emphasisStyle = seriesModel.getModel(['emphasis', 'itemStyle']).getItemStyle()
        let blurStyle = seriesModel.getModel(['blur', 'itemStyle']).getItemStyle()
        let selectStyle = seriesModel.getModel(['select', 'itemStyle']).getItemStyle()
        let borderRadius = seriesModel.get(['itemStyle', 'borderRadius'])
        let labelStatesModels = getLabelStatesModels(seriesModel)
        const emphasisModel = seriesModel.getModel('emphasis')
        let focus = emphasisModel.get('focus')
        let blurScope = emphasisModel.get('blurScope')
        let emphasisDisabled = emphasisModel.get('disabled')
        const dataDims = isCartesian2d ? [data.mapDimension('x'), data.mapDimension('y'), data.mapDimension('value')] : [data.mapDimension('time'), data.mapDimension('value')]

        for (let idx = start; idx < end; idx++) {
          let rect = void 0
          const style = data.getItemVisual(idx, 'style')

          if (isCartesian2d) {
            const dataDimX = data.get(dataDims[0], idx)
            const dataDimY = data.get(dataDims[1], idx) // Ignore empty data and out of extent data

            if (isNaN(data.get(dataDims[2], idx)) || dataDimX < xAxisExtent[0] || dataDimX > xAxisExtent[1] || dataDimY < yAxisExtent[0] || dataDimY > yAxisExtent[1]) {
              continue
            }

            const point = coordSys.dataToPoint([dataDimX, dataDimY])
            rect = new Rect({
              shape: {
                x: point[0] - width / 2,
                y: point[1] - height / 2,
                width: width,
                height: height
              },
              style: style
            })
          } else {
            // Ignore empty data
            if (isNaN(data.get(dataDims[1], idx))) {
              continue
            }

            rect = new Rect({
              z2: 1,
              shape: coordSys.dataToRect([data.get(dataDims[0], idx)]).contentShape,
              style: style
            })
          } // Optimization for large datset

          if (data.hasItemOption) {
            const itemModel = data.getItemModel(idx)
            const emphasisModel_1 = itemModel.getModel('emphasis')
            emphasisStyle = emphasisModel_1.getModel('itemStyle').getItemStyle()
            blurStyle = itemModel.getModel(['blur', 'itemStyle']).getItemStyle()
            selectStyle = itemModel.getModel(['select', 'itemStyle']).getItemStyle() // Each item value struct in the data would be firstly
            // {
            //     itemStyle: { borderRadius: [30, 30] },
            //     value: [2022, 02, 22]
            // }

            borderRadius = itemModel.get(['itemStyle', 'borderRadius'])
            focus = emphasisModel_1.get('focus')
            blurScope = emphasisModel_1.get('blurScope')
            emphasisDisabled = emphasisModel_1.get('disabled')
            labelStatesModels = getLabelStatesModels(itemModel)
          }

          rect.shape.r = borderRadius
          const rawValue = seriesModel.getRawValue(idx)
          let defaultText = '-'

          if (rawValue && rawValue[2] != null) {
            defaultText = rawValue[2] + ''
          }

          setLabelStyle(rect, labelStatesModels, {
            labelFetcher: seriesModel,
            labelDataIndex: idx,
            defaultOpacity: style.opacity,
            defaultText: defaultText
          })
          rect.ensureState('emphasis').style = emphasisStyle
          rect.ensureState('blur').style = blurStyle
          rect.ensureState('select').style = selectStyle
          toggleHoverEmphasis(rect, focus, blurScope, emphasisDisabled)
          rect.incremental = incremental // PENDING

          if (incremental) {
            // Rect must use hover layer if it's incremental.
            rect.states.emphasis.hoverLayer = true
          }

          group.add(rect)
          data.setItemGraphicEl(idx, rect)

          if (this._progressiveEls) {
            this._progressiveEls.push(rect)
          }
        }
      }

      HeatmapView.prototype._renderOnGeo = function (geo, seriesModel, visualMapModel, api) {
        const inRangeVisuals = visualMapModel.targetVisuals.inRange
        const outOfRangeVisuals = visualMapModel.targetVisuals.outOfRange // if (!visualMapping) {
        //     throw new Error('Data range must have color visuals');
        // }

        const data = seriesModel.getData()
        const hmLayer = this._hmLayer || this._hmLayer || new HeatmapLayer()
        hmLayer.blurSize = seriesModel.get('blurSize')
        hmLayer.pointSize = seriesModel.get('pointSize')
        hmLayer.minOpacity = seriesModel.get('minOpacity')
        hmLayer.maxOpacity = seriesModel.get('maxOpacity')
        const rect = geo.getViewRect().clone()
        const roamTransform = geo.getRoamTransform()
        rect.applyTransform(roamTransform) // Clamp on viewport

        const x = Math.max(rect.x, 0)
        const y = Math.max(rect.y, 0)
        const x2 = Math.min(rect.width + rect.x, api.getWidth())
        const y2 = Math.min(rect.height + rect.y, api.getHeight())
        const width = x2 - x
        const height = y2 - y
        const dims = [data.mapDimension('lng'), data.mapDimension('lat'), data.mapDimension('value')]
        const points = data.mapArray(dims, function (lng, lat, value) {
          const pt = geo.dataToPoint([lng, lat])
          pt[0] -= x
          pt[1] -= y
          pt.push(value)
          return pt
        })
        const dataExtent = visualMapModel.getExtent()
        const isInRange = visualMapModel.type === 'visualMap.continuous' ? getIsInContinuousRange(dataExtent, visualMapModel.option.range) : getIsInPiecewiseRange(dataExtent, visualMapModel.getPieceList(), visualMapModel.option.selected)
        hmLayer.update(points, width, height, inRangeVisuals.color.getNormalizer(), {
          inRange: inRangeVisuals.color.getColorMapper(),
          outOfRange: outOfRangeVisuals.color.getColorMapper()
        }, isInRange)
        const img = new ZRImage({
          style: {
            width: width,
            height: height,
            x: x,
            y: y,
            image: hmLayer.canvas
          },
          silent: true
        })
        this.group.add(img)
      }

      HeatmapView.type = 'heatmap'
      return HeatmapView
    }(ChartView))

  const HeatmapSeriesModel =
    /** @class */
    (function (_super) {
      __extends(HeatmapSeriesModel, _super)

      function HeatmapSeriesModel () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = HeatmapSeriesModel.type
        return _this
      }

      HeatmapSeriesModel.prototype.getInitialData = function (option, ecModel) {
        return createSeriesData(null, this, {
          generateCoord: 'value'
        })
      }

      HeatmapSeriesModel.prototype.preventIncremental = function () {
        const coordSysCreator = CoordinateSystemManager.get(this.get('coordinateSystem'))

        if (coordSysCreator && coordSysCreator.dimensions) {
          return coordSysCreator.dimensions[0] === 'lng' && coordSysCreator.dimensions[1] === 'lat'
        }
      }

      HeatmapSeriesModel.type = 'series.heatmap'
      HeatmapSeriesModel.dependencies = ['grid', 'geo', 'calendar']
      HeatmapSeriesModel.defaultOption = {
        coordinateSystem: 'cartesian2d',
        // zlevel: 0,
        z: 2,
        // Cartesian coordinate system
        // xAxisIndex: 0,
        // yAxisIndex: 0,
        // Geo coordinate system
        geoIndex: 0,
        blurSize: 30,
        pointSize: 20,
        maxOpacity: 1,
        minOpacity: 0,
        select: {
          itemStyle: {
            borderColor: '#212121'
          }
        }
      }
      return HeatmapSeriesModel
    }(SeriesModel))

  function install$n (registers) {
    registers.registerChartView(HeatmapView)
    registers.registerSeriesModel(HeatmapSeriesModel)
  }

  const BAR_BORDER_WIDTH_QUERY = ['itemStyle', 'borderWidth'] // index: +isHorizontal

  const LAYOUT_ATTRS = [{
    xy: 'x',
    wh: 'width',
    index: 0,
    posDesc: ['left', 'right']
  }, {
    xy: 'y',
    wh: 'height',
    index: 1,
    posDesc: ['top', 'bottom']
  }]
  const pathForLineWidth = new Circle()

  const PictorialBarView =
    /** @class */
    (function (_super) {
      __extends(PictorialBarView, _super)

      function PictorialBarView () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = PictorialBarView.type
        return _this
      }

      PictorialBarView.prototype.render = function (seriesModel, ecModel, api) {
        const group = this.group
        const data = seriesModel.getData()
        const oldData = this._data
        const cartesian = seriesModel.coordinateSystem
        const baseAxis = cartesian.getBaseAxis()
        const isHorizontal = baseAxis.isHorizontal()
        const coordSysRect = cartesian.master.getRect()
        const opt = {
          ecSize: {
            width: api.getWidth(),
            height: api.getHeight()
          },
          seriesModel: seriesModel,
          coordSys: cartesian,
          coordSysExtent: [[coordSysRect.x, coordSysRect.x + coordSysRect.width], [coordSysRect.y, coordSysRect.y + coordSysRect.height]],
          isHorizontal: isHorizontal,
          valueDim: LAYOUT_ATTRS[+isHorizontal],
          categoryDim: LAYOUT_ATTRS[1 - +isHorizontal]
        }
        data.diff(oldData).add(function (dataIndex) {
          if (!data.hasValue(dataIndex)) {
            return
          }

          const itemModel = getItemModel(data, dataIndex)
          const symbolMeta = getSymbolMeta(data, dataIndex, itemModel, opt)
          const bar = createBar(data, opt, symbolMeta)
          data.setItemGraphicEl(dataIndex, bar)
          group.add(bar)
          updateCommon$1(bar, opt, symbolMeta)
        }).update(function (newIndex, oldIndex) {
          let bar = oldData.getItemGraphicEl(oldIndex)

          if (!data.hasValue(newIndex)) {
            group.remove(bar)
            return
          }

          const itemModel = getItemModel(data, newIndex)
          const symbolMeta = getSymbolMeta(data, newIndex, itemModel, opt)
          const pictorialShapeStr = getShapeStr(data, symbolMeta)

          if (bar && pictorialShapeStr !== bar.__pictorialShapeStr) {
            group.remove(bar)
            data.setItemGraphicEl(newIndex, null)
            bar = null
          }

          if (bar) {
            updateBar(bar, opt, symbolMeta)
          } else {
            bar = createBar(data, opt, symbolMeta, true)
          }

          data.setItemGraphicEl(newIndex, bar)
          bar.__pictorialSymbolMeta = symbolMeta // Add back

          group.add(bar)
          updateCommon$1(bar, opt, symbolMeta)
        }).remove(function (dataIndex) {
          const bar = oldData.getItemGraphicEl(dataIndex)
          bar && removeBar(oldData, dataIndex, bar.__pictorialSymbolMeta.animationModel, bar)
        }).execute()
        this._data = data
        return this.group
      }

      PictorialBarView.prototype.remove = function (ecModel, api) {
        const group = this.group
        const data = this._data

        if (ecModel.get('animation')) {
          if (data) {
            data.eachItemGraphicEl(function (bar) {
              removeBar(data, getECData(bar).dataIndex, ecModel, bar)
            })
          }
        } else {
          group.removeAll()
        }
      }

      PictorialBarView.type = 'pictorialBar'
      return PictorialBarView
    }(ChartView)) // Set or calculate default value about symbol, and calculate layout info.

  function getSymbolMeta (data, dataIndex, itemModel, opt) {
    const layout = data.getItemLayout(dataIndex)
    const symbolRepeat = itemModel.get('symbolRepeat')
    const symbolClip = itemModel.get('symbolClip')
    const symbolPosition = itemModel.get('symbolPosition') || 'start'
    const symbolRotate = itemModel.get('symbolRotate')
    const rotation = (symbolRotate || 0) * Math.PI / 180 || 0
    const symbolPatternSize = itemModel.get('symbolPatternSize') || 2
    const isAnimationEnabled = itemModel.isAnimationEnabled()
    const symbolMeta = {
      dataIndex: dataIndex,
      layout: layout,
      itemModel: itemModel,
      symbolType: data.getItemVisual(dataIndex, 'symbol') || 'circle',
      style: data.getItemVisual(dataIndex, 'style'),
      symbolClip: symbolClip,
      symbolRepeat: symbolRepeat,
      symbolRepeatDirection: itemModel.get('symbolRepeatDirection'),
      symbolPatternSize: symbolPatternSize,
      rotation: rotation,
      animationModel: isAnimationEnabled ? itemModel : null,
      hoverScale: isAnimationEnabled && itemModel.get(['emphasis', 'scale']),
      z2: itemModel.getShallow('z', true) || 0
    }
    prepareBarLength(itemModel, symbolRepeat, layout, opt, symbolMeta)
    prepareSymbolSize(data, dataIndex, layout, symbolRepeat, symbolClip, symbolMeta.boundingLength, symbolMeta.pxSign, symbolPatternSize, opt, symbolMeta)
    prepareLineWidth(itemModel, symbolMeta.symbolScale, rotation, opt, symbolMeta)
    const symbolSize = symbolMeta.symbolSize
    const symbolOffset = normalizeSymbolOffset(itemModel.get('symbolOffset'), symbolSize)
    prepareLayoutInfo(itemModel, symbolSize, layout, symbolRepeat, symbolClip, symbolOffset, symbolPosition, symbolMeta.valueLineWidth, symbolMeta.boundingLength, symbolMeta.repeatCutLength, opt, symbolMeta)
    return symbolMeta
  } // bar length can be negative.

  function prepareBarLength (itemModel, symbolRepeat, layout, opt, outputSymbolMeta) {
    const valueDim = opt.valueDim
    const symbolBoundingData = itemModel.get('symbolBoundingData')
    const valueAxis = opt.coordSys.getOtherAxis(opt.coordSys.getBaseAxis())
    const zeroPx = valueAxis.toGlobalCoord(valueAxis.dataToCoord(0))
    const pxSignIdx = 1 - +(layout[valueDim.wh] <= 0)
    let boundingLength

    if (isArray(symbolBoundingData)) {
      const symbolBoundingExtent = [convertToCoordOnAxis(valueAxis, symbolBoundingData[0]) - zeroPx, convertToCoordOnAxis(valueAxis, symbolBoundingData[1]) - zeroPx]
      symbolBoundingExtent[1] < symbolBoundingExtent[0] && symbolBoundingExtent.reverse()
      boundingLength = symbolBoundingExtent[pxSignIdx]
    } else if (symbolBoundingData != null) {
      boundingLength = convertToCoordOnAxis(valueAxis, symbolBoundingData) - zeroPx
    } else if (symbolRepeat) {
      boundingLength = opt.coordSysExtent[valueDim.index][pxSignIdx] - zeroPx
    } else {
      boundingLength = layout[valueDim.wh]
    }

    outputSymbolMeta.boundingLength = boundingLength

    if (symbolRepeat) {
      outputSymbolMeta.repeatCutLength = layout[valueDim.wh]
    } // if 'pxSign' means sign of pixel,  it can't be zero, or symbolScale will be zero
    // and when borderWidth be settled, the actual linewidth will be NaN

    outputSymbolMeta.pxSign = boundingLength > 0 ? 1 : -1
  }

  function convertToCoordOnAxis (axis, value) {
    return axis.toGlobalCoord(axis.dataToCoord(axis.scale.parse(value)))
  } // Support ['100%', '100%']

  function prepareSymbolSize (data, dataIndex, layout, symbolRepeat, symbolClip, boundingLength, pxSign, symbolPatternSize, opt, outputSymbolMeta) {
    const valueDim = opt.valueDim
    const categoryDim = opt.categoryDim
    const categorySize = Math.abs(layout[categoryDim.wh])
    const symbolSize = data.getItemVisual(dataIndex, 'symbolSize')
    let parsedSymbolSize

    if (isArray(symbolSize)) {
      parsedSymbolSize = symbolSize.slice()
    } else {
      if (symbolSize == null) {
        // will parse to number below
        parsedSymbolSize = ['100%', '100%']
      } else {
        parsedSymbolSize = [symbolSize, symbolSize]
      }
    } // Note: percentage symbolSize (like '100%') do not consider lineWidth, because it is
    // to complicated to calculate real percent value if considering scaled lineWidth.
    // So the actual size will bigger than layout size if lineWidth is bigger than zero,
    // which can be tolerated in pictorial chart.

    parsedSymbolSize[categoryDim.index] = parsePercent$1(parsedSymbolSize[categoryDim.index], categorySize)
    parsedSymbolSize[valueDim.index] = parsePercent$1(parsedSymbolSize[valueDim.index], symbolRepeat ? categorySize : Math.abs(boundingLength))
    outputSymbolMeta.symbolSize = parsedSymbolSize // If x or y is less than zero, show reversed shape.

    const symbolScale = outputSymbolMeta.symbolScale = [parsedSymbolSize[0] / symbolPatternSize, parsedSymbolSize[1] / symbolPatternSize] // Follow convention, 'right' and 'top' is the normal scale.

    symbolScale[valueDim.index] *= (opt.isHorizontal ? -1 : 1) * pxSign
  }

  function prepareLineWidth (itemModel, symbolScale, rotation, opt, outputSymbolMeta) {
    // In symbols are drawn with scale, so do not need to care about the case that width
    // or height are too small. But symbol use strokeNoScale, where acture lineWidth should
    // be calculated.
    let valueLineWidth = itemModel.get(BAR_BORDER_WIDTH_QUERY) || 0

    if (valueLineWidth) {
      pathForLineWidth.attr({
        scaleX: symbolScale[0],
        scaleY: symbolScale[1],
        rotation: rotation
      })
      pathForLineWidth.updateTransform()
      valueLineWidth /= pathForLineWidth.getLineScale()
      valueLineWidth *= symbolScale[opt.valueDim.index]
    }

    outputSymbolMeta.valueLineWidth = valueLineWidth || 0
  }

  function prepareLayoutInfo (itemModel, symbolSize, layout, symbolRepeat, symbolClip, symbolOffset, symbolPosition, valueLineWidth, boundingLength, repeatCutLength, opt, outputSymbolMeta) {
    const categoryDim = opt.categoryDim
    const valueDim = opt.valueDim
    const pxSign = outputSymbolMeta.pxSign
    const unitLength = Math.max(symbolSize[valueDim.index] + valueLineWidth, 0)
    let pathLen = unitLength // Note: rotation will not effect the layout of symbols, because user may
    // want symbols to rotate on its center, which should not be translated
    // when rotating.

    if (symbolRepeat) {
      const absBoundingLength = Math.abs(boundingLength)
      let symbolMargin = retrieve(itemModel.get('symbolMargin'), '15%') + ''
      let hasEndGap = false

      if (symbolMargin.lastIndexOf('!') === symbolMargin.length - 1) {
        hasEndGap = true
        symbolMargin = symbolMargin.slice(0, symbolMargin.length - 1)
      }

      let symbolMarginNumeric = parsePercent$1(symbolMargin, symbolSize[valueDim.index])
      let uLenWithMargin = Math.max(unitLength + symbolMarginNumeric * 2, 0) // When symbol margin is less than 0, margin at both ends will be subtracted
      // to ensure that all of the symbols will not be overflow the given area.

      let endFix = hasEndGap ? 0 : symbolMarginNumeric * 2 // Both final repeatTimes and final symbolMarginNumeric area calculated based on
      // boundingLength.

      const repeatSpecified = isNumeric(symbolRepeat)
      let repeatTimes = repeatSpecified ? symbolRepeat : toIntTimes((absBoundingLength + endFix) / uLenWithMargin) // Adjust calculate margin, to ensure each symbol is displayed
      // entirely in the given layout area.

      const mDiff = absBoundingLength - repeatTimes * unitLength
      symbolMarginNumeric = mDiff / 2 / (hasEndGap ? repeatTimes : Math.max(repeatTimes - 1, 1))
      uLenWithMargin = unitLength + symbolMarginNumeric * 2
      endFix = hasEndGap ? 0 : symbolMarginNumeric * 2 // Update repeatTimes when not all symbol will be shown.

      if (!repeatSpecified && symbolRepeat !== 'fixed') {
        repeatTimes = repeatCutLength ? toIntTimes((Math.abs(repeatCutLength) + endFix) / uLenWithMargin) : 0
      }

      pathLen = repeatTimes * uLenWithMargin - endFix
      outputSymbolMeta.repeatTimes = repeatTimes
      outputSymbolMeta.symbolMargin = symbolMarginNumeric
    }

    const sizeFix = pxSign * (pathLen / 2)
    const pathPosition = outputSymbolMeta.pathPosition = []
    pathPosition[categoryDim.index] = layout[categoryDim.wh] / 2
    pathPosition[valueDim.index] = symbolPosition === 'start' ? sizeFix : symbolPosition === 'end' ? boundingLength - sizeFix : boundingLength / 2 // 'center'

    if (symbolOffset) {
      pathPosition[0] += symbolOffset[0]
      pathPosition[1] += symbolOffset[1]
    }

    const bundlePosition = outputSymbolMeta.bundlePosition = []
    bundlePosition[categoryDim.index] = layout[categoryDim.xy]
    bundlePosition[valueDim.index] = layout[valueDim.xy]
    const barRectShape = outputSymbolMeta.barRectShape = extend({}, layout)
    barRectShape[valueDim.wh] = pxSign * Math.max(Math.abs(layout[valueDim.wh]), Math.abs(pathPosition[valueDim.index] + sizeFix))
    barRectShape[categoryDim.wh] = layout[categoryDim.wh]
    const clipShape = outputSymbolMeta.clipShape = {} // Consider that symbol may be overflow layout rect.

    clipShape[categoryDim.xy] = -layout[categoryDim.xy]
    clipShape[categoryDim.wh] = opt.ecSize[categoryDim.wh]
    clipShape[valueDim.xy] = 0
    clipShape[valueDim.wh] = layout[valueDim.wh]
  }

  function createPath (symbolMeta) {
    const symbolPatternSize = symbolMeta.symbolPatternSize
    const path = createSymbol( // Consider texture img, make a big size.
      symbolMeta.symbolType, -symbolPatternSize / 2, -symbolPatternSize / 2, symbolPatternSize, symbolPatternSize)
    path.attr({
      culling: true
    })
    path.type !== 'image' && path.setStyle({
      strokeNoScale: true
    })
    return path
  }

  function createOrUpdateRepeatSymbols (bar, opt, symbolMeta, isUpdate) {
    const bundle = bar.__pictorialBundle
    const symbolSize = symbolMeta.symbolSize
    const valueLineWidth = symbolMeta.valueLineWidth
    const pathPosition = symbolMeta.pathPosition
    const valueDim = opt.valueDim
    const repeatTimes = symbolMeta.repeatTimes || 0
    let index = 0
    const unit = symbolSize[opt.valueDim.index] + valueLineWidth + symbolMeta.symbolMargin * 2
    eachPath(bar, function (path) {
      path.__pictorialAnimationIndex = index
      path.__pictorialRepeatTimes = repeatTimes

      if (index < repeatTimes) {
        updateAttr(path, null, makeTarget(index), symbolMeta, isUpdate)
      } else {
        updateAttr(path, null, {
          scaleX: 0,
          scaleY: 0
        }, symbolMeta, isUpdate, function () {
          bundle.remove(path)
        })
      } // updateHoverAnimation(path, symbolMeta);

      index++
    })

    for (; index < repeatTimes; index++) {
      const path = createPath(symbolMeta)
      path.__pictorialAnimationIndex = index
      path.__pictorialRepeatTimes = repeatTimes
      bundle.add(path)
      const target = makeTarget(index)
      updateAttr(path, {
        x: target.x,
        y: target.y,
        scaleX: 0,
        scaleY: 0
      }, {
        scaleX: target.scaleX,
        scaleY: target.scaleY,
        rotation: target.rotation
      }, symbolMeta, isUpdate)
    }

    function makeTarget (index) {
      const position = pathPosition.slice() // (start && pxSign > 0) || (end && pxSign < 0): i = repeatTimes - index
      // Otherwise: i = index;

      const pxSign = symbolMeta.pxSign
      let i = index

      if (symbolMeta.symbolRepeatDirection === 'start' ? pxSign > 0 : pxSign < 0) {
        i = repeatTimes - 1 - index
      }

      position[valueDim.index] = unit * (i - repeatTimes / 2 + 0.5) + pathPosition[valueDim.index]
      return {
        x: position[0],
        y: position[1],
        scaleX: symbolMeta.symbolScale[0],
        scaleY: symbolMeta.symbolScale[1],
        rotation: symbolMeta.rotation
      }
    }
  }

  function createOrUpdateSingleSymbol (bar, opt, symbolMeta, isUpdate) {
    const bundle = bar.__pictorialBundle
    let mainPath = bar.__pictorialMainPath

    if (!mainPath) {
      mainPath = bar.__pictorialMainPath = createPath(symbolMeta)
      bundle.add(mainPath)
      updateAttr(mainPath, {
        x: symbolMeta.pathPosition[0],
        y: symbolMeta.pathPosition[1],
        scaleX: 0,
        scaleY: 0,
        rotation: symbolMeta.rotation
      }, {
        scaleX: symbolMeta.symbolScale[0],
        scaleY: symbolMeta.symbolScale[1]
      }, symbolMeta, isUpdate)
    } else {
      updateAttr(mainPath, null, {
        x: symbolMeta.pathPosition[0],
        y: symbolMeta.pathPosition[1],
        scaleX: symbolMeta.symbolScale[0],
        scaleY: symbolMeta.symbolScale[1],
        rotation: symbolMeta.rotation
      }, symbolMeta, isUpdate)
    }
  } // bar rect is used for label.

  function createOrUpdateBarRect (bar, symbolMeta, isUpdate) {
    const rectShape = extend({}, symbolMeta.barRectShape)
    let barRect = bar.__pictorialBarRect

    if (!barRect) {
      barRect = bar.__pictorialBarRect = new Rect({
        z2: 2,
        shape: rectShape,
        silent: true,
        style: {
          stroke: 'transparent',
          fill: 'transparent',
          lineWidth: 0
        }
      })
      barRect.disableMorphing = true
      bar.add(barRect)
    } else {
      updateAttr(barRect, null, {
        shape: rectShape
      }, symbolMeta, isUpdate)
    }
  }

  function createOrUpdateClip (bar, opt, symbolMeta, isUpdate) {
    // If not clip, symbol will be remove and rebuilt.
    if (symbolMeta.symbolClip) {
      let clipPath = bar.__pictorialClipPath
      const clipShape = extend({}, symbolMeta.clipShape)
      const valueDim = opt.valueDim
      const animationModel = symbolMeta.animationModel
      const dataIndex = symbolMeta.dataIndex

      if (clipPath) {
        updateProps(clipPath, {
          shape: clipShape
        }, animationModel, dataIndex)
      } else {
        clipShape[valueDim.wh] = 0
        clipPath = new Rect({
          shape: clipShape
        })

        bar.__pictorialBundle.setClipPath(clipPath)

        bar.__pictorialClipPath = clipPath
        const target = {}
        target[valueDim.wh] = symbolMeta.clipShape[valueDim.wh]
        graphic[isUpdate ? 'updateProps' : 'initProps'](clipPath, {
          shape: target
        }, animationModel, dataIndex)
      }
    }
  }

  function getItemModel (data, dataIndex) {
    const itemModel = data.getItemModel(dataIndex)
    itemModel.getAnimationDelayParams = getAnimationDelayParams
    itemModel.isAnimationEnabled = isAnimationEnabled
    return itemModel
  }

  function getAnimationDelayParams (path) {
    // The order is the same as the z-order, see `symbolRepeatDiretion`.
    return {
      index: path.__pictorialAnimationIndex,
      count: path.__pictorialRepeatTimes
    }
  }

  function isAnimationEnabled () {
    // `animation` prop can be set on itemModel in pictorial bar chart.
    return this.parentModel.isAnimationEnabled() && !!this.getShallow('animation')
  }

  function createBar (data, opt, symbolMeta, isUpdate) {
    // bar is the main element for each data.
    const bar = new Group() // bundle is used for location and clip.

    const bundle = new Group()
    bar.add(bundle)
    bar.__pictorialBundle = bundle
    bundle.x = symbolMeta.bundlePosition[0]
    bundle.y = symbolMeta.bundlePosition[1]

    if (symbolMeta.symbolRepeat) {
      createOrUpdateRepeatSymbols(bar, opt, symbolMeta)
    } else {
      createOrUpdateSingleSymbol(bar, opt, symbolMeta)
    }

    createOrUpdateBarRect(bar, symbolMeta, isUpdate)
    createOrUpdateClip(bar, opt, symbolMeta, isUpdate)
    bar.__pictorialShapeStr = getShapeStr(data, symbolMeta)
    bar.__pictorialSymbolMeta = symbolMeta
    return bar
  }

  function updateBar (bar, opt, symbolMeta) {
    const animationModel = symbolMeta.animationModel
    const dataIndex = symbolMeta.dataIndex
    const bundle = bar.__pictorialBundle
    updateProps(bundle, {
      x: symbolMeta.bundlePosition[0],
      y: symbolMeta.bundlePosition[1]
    }, animationModel, dataIndex)

    if (symbolMeta.symbolRepeat) {
      createOrUpdateRepeatSymbols(bar, opt, symbolMeta, true)
    } else {
      createOrUpdateSingleSymbol(bar, opt, symbolMeta, true)
    }

    createOrUpdateBarRect(bar, symbolMeta, true)
    createOrUpdateClip(bar, opt, symbolMeta, true)
  }

  function removeBar (data, dataIndex, animationModel, bar) {
    // Not show text when animating
    const labelRect = bar.__pictorialBarRect
    labelRect && labelRect.removeTextContent()
    const paths = []
    eachPath(bar, function (path) {
      paths.push(path)
    })
    bar.__pictorialMainPath && paths.push(bar.__pictorialMainPath) // I do not find proper remove animation for clip yet.

    bar.__pictorialClipPath && (animationModel = null)
    each(paths, function (path) {
      removeElement(path, {
        scaleX: 0,
        scaleY: 0
      }, animationModel, dataIndex, function () {
        bar.parent && bar.parent.remove(bar)
      })
    })
    data.setItemGraphicEl(dataIndex, null)
  }

  function getShapeStr (data, symbolMeta) {
    return [data.getItemVisual(symbolMeta.dataIndex, 'symbol') || 'none', !!symbolMeta.symbolRepeat, !!symbolMeta.symbolClip].join(':')
  }

  function eachPath (bar, cb, context) {
    // Do not use Group#eachChild, because it do not support remove.
    each(bar.__pictorialBundle.children(), function (el) {
      el !== bar.__pictorialBarRect && cb.call(context, el)
    })
  }

  function updateAttr (el, immediateAttrs, animationAttrs, symbolMeta, isUpdate, cb) {
    immediateAttrs && el.attr(immediateAttrs) // when symbolCip used, only clip path has init animation, otherwise it would be weird effect.

    if (symbolMeta.symbolClip && !isUpdate) {
      animationAttrs && el.attr(animationAttrs)
    } else {
      animationAttrs && graphic[isUpdate ? 'updateProps' : 'initProps'](el, animationAttrs, symbolMeta.animationModel, symbolMeta.dataIndex, cb)
    }
  }

  function updateCommon$1 (bar, opt, symbolMeta) {
    const dataIndex = symbolMeta.dataIndex
    const itemModel = symbolMeta.itemModel // Color must be excluded.
    // Because symbol provide setColor individually to set fill and stroke

    const emphasisModel = itemModel.getModel('emphasis')
    const emphasisStyle = emphasisModel.getModel('itemStyle').getItemStyle()
    const blurStyle = itemModel.getModel(['blur', 'itemStyle']).getItemStyle()
    const selectStyle = itemModel.getModel(['select', 'itemStyle']).getItemStyle()
    const cursorStyle = itemModel.getShallow('cursor')
    const focus = emphasisModel.get('focus')
    const blurScope = emphasisModel.get('blurScope')
    const hoverScale = emphasisModel.get('scale')
    eachPath(bar, function (path) {
      if (path instanceof ZRImage) {
        const pathStyle = path.style
        path.useStyle(extend({
          // TODO other properties like dx, dy ?
          image: pathStyle.image,
          x: pathStyle.x,
          y: pathStyle.y,
          width: pathStyle.width,
          height: pathStyle.height
        }, symbolMeta.style))
      } else {
        path.useStyle(symbolMeta.style)
      }

      const emphasisState = path.ensureState('emphasis')
      emphasisState.style = emphasisStyle

      if (hoverScale) {
        // NOTE: Must after scale is set after updateAttr
        emphasisState.scaleX = path.scaleX * 1.1
        emphasisState.scaleY = path.scaleY * 1.1
      }

      path.ensureState('blur').style = blurStyle
      path.ensureState('select').style = selectStyle
      cursorStyle && (path.cursor = cursorStyle)
      path.z2 = symbolMeta.z2
    })
    const barPositionOutside = opt.valueDim.posDesc[+(symbolMeta.boundingLength > 0)]
    const barRect = bar.__pictorialBarRect
    setLabelStyle(barRect, getLabelStatesModels(itemModel), {
      labelFetcher: opt.seriesModel,
      labelDataIndex: dataIndex,
      defaultText: getDefaultLabel(opt.seriesModel.getData(), dataIndex),
      inheritColor: symbolMeta.style.fill,
      defaultOpacity: symbolMeta.style.opacity,
      defaultOutsidePosition: barPositionOutside
    })
    toggleHoverEmphasis(bar, focus, blurScope, emphasisModel.get('disabled'))
  }

  function toIntTimes (times) {
    const roundedTimes = Math.round(times) // Escapse accurate error

    return Math.abs(times - roundedTimes) < 1e-4 ? roundedTimes : Math.ceil(times)
  }

  const PictorialBarSeriesModel =
    /** @class */
    (function (_super) {
      __extends(PictorialBarSeriesModel, _super)

      function PictorialBarSeriesModel () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = PictorialBarSeriesModel.type
        _this.hasSymbolVisual = true
        _this.defaultSymbol = 'roundRect'
        return _this
      }

      PictorialBarSeriesModel.prototype.getInitialData = function (option) {
        // Disable stack.
        option.stack = null
        return _super.prototype.getInitialData.apply(this, arguments)
      }

      PictorialBarSeriesModel.type = 'series.pictorialBar'
      PictorialBarSeriesModel.dependencies = ['grid']
      PictorialBarSeriesModel.defaultOption = inheritDefaultOption(BaseBarSeriesModel.defaultOption, {
        symbol: 'circle',
        symbolSize: null,
        symbolRotate: null,
        symbolPosition: null,
        symbolOffset: null,
        symbolMargin: null,
        symbolRepeat: false,
        symbolRepeatDirection: 'end',
        symbolClip: false,
        symbolBoundingData: null,
        symbolPatternSize: 400,
        barGap: '-100%',
        // z can be set in data item, which is z2 actually.
        // Disable progressive
        progressive: 0,
        emphasis: {
          // By default pictorialBar do not hover scale. Hover scale is not suitable
          // for the case that both has foreground and background.
          scale: false
        },
        select: {
          itemStyle: {
            borderColor: '#212121'
          }
        }
      })
      return PictorialBarSeriesModel
    }(BaseBarSeriesModel))

  function install$o (registers) {
    registers.registerChartView(PictorialBarView)
    registers.registerSeriesModel(PictorialBarSeriesModel)
    registers.registerLayout(registers.PRIORITY.VISUAL.LAYOUT, curry(layout, 'pictorialBar')) // Do layout after other overall layout, which can preapre some informations.

    registers.registerLayout(registers.PRIORITY.VISUAL.PROGRESSIVE_LAYOUT, createProgressiveLayout('pictorialBar'))
  }

  const ThemeRiverView =
    /** @class */
    (function (_super) {
      __extends(ThemeRiverView, _super)

      function ThemeRiverView () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = ThemeRiverView.type
        _this._layers = []
        return _this
      }

      ThemeRiverView.prototype.render = function (seriesModel, ecModel, api) {
        const data = seriesModel.getData()
        const self = this
        const group = this.group
        const layersSeries = seriesModel.getLayerSeries()
        const layoutInfo = data.getLayout('layoutInfo')
        const rect = layoutInfo.rect
        const boundaryGap = layoutInfo.boundaryGap
        group.x = 0
        group.y = rect.y + boundaryGap[0]

        function keyGetter (item) {
          return item.name
        }

        const dataDiffer = new DataDiffer(this._layersSeries || [], layersSeries, keyGetter, keyGetter)
        const newLayersGroups = []
        dataDiffer.add(bind(process, this, 'add')).update(bind(process, this, 'update')).remove(bind(process, this, 'remove')).execute()

        function process (status, idx, oldIdx) {
          const oldLayersGroups = self._layers

          if (status === 'remove') {
            group.remove(oldLayersGroups[idx])
            return
          }

          const points0 = []
          const points1 = []
          let style
          const indices = layersSeries[idx].indices
          let j = 0

          for (; j < indices.length; j++) {
            const layout = data.getItemLayout(indices[j])
            const x = layout.x
            const y0 = layout.y0
            const y = layout.y
            points0.push(x, y0)
            points1.push(x, y0 + y)
            style = data.getItemVisual(indices[j], 'style')
          }

          let polygon
          const textLayout = data.getItemLayout(indices[0])
          const labelModel = seriesModel.getModel('label')
          const margin = labelModel.get('margin')
          const emphasisModel = seriesModel.getModel('emphasis')

          if (status === 'add') {
            var layerGroup = newLayersGroups[idx] = new Group()
            polygon = new ECPolygon({
              shape: {
                points: points0,
                stackedOnPoints: points1,
                smooth: 0.4,
                stackedOnSmooth: 0.4,
                smoothConstraint: false
              },
              z2: 0
            })
            layerGroup.add(polygon)
            group.add(layerGroup)

            if (seriesModel.isAnimationEnabled()) {
              polygon.setClipPath(createGridClipShape$2(polygon.getBoundingRect(), seriesModel, function () {
                polygon.removeClipPath()
              }))
            }
          } else {
            var layerGroup = oldLayersGroups[oldIdx]
            polygon = layerGroup.childAt(0)
            group.add(layerGroup)
            newLayersGroups[idx] = layerGroup
            updateProps(polygon, {
              shape: {
                points: points0,
                stackedOnPoints: points1
              }
            }, seriesModel)
            saveOldStyle(polygon)
          }

          setLabelStyle(polygon, getLabelStatesModels(seriesModel), {
            labelDataIndex: indices[j - 1],
            defaultText: data.getName(indices[j - 1]),
            inheritColor: style.fill
          }, {
            normal: {
              verticalAlign: 'middle' // align: 'right'

            }
          })
          polygon.setTextConfig({
            position: null,
            local: true
          })
          const labelEl = polygon.getTextContent() // TODO More label position options.

          if (labelEl) {
            labelEl.x = textLayout.x - margin
            labelEl.y = textLayout.y0 + textLayout.y / 2
          }

          polygon.useStyle(style)
          data.setItemGraphicEl(idx, polygon)
          setStatesStylesFromModel(polygon, seriesModel)
          toggleHoverEmphasis(polygon, emphasisModel.get('focus'), emphasisModel.get('blurScope'), emphasisModel.get('disabled'))
        }

        this._layersSeries = layersSeries
        this._layers = newLayersGroups
      }

      ThemeRiverView.type = 'themeRiver'
      return ThemeRiverView
    }(ChartView))

  function createGridClipShape$2 (rect, seriesModel, cb) {
    const rectEl = new Rect({
      shape: {
        x: rect.x - 10,
        y: rect.y - 10,
        width: 0,
        height: rect.height + 20
      }
    })
    initProps(rectEl, {
      shape: {
        x: rect.x - 50,
        width: rect.width + 100,
        height: rect.height + 20
      }
    }, seriesModel, cb)
    return rectEl
  }

  const DATA_NAME_INDEX = 2

  const ThemeRiverSeriesModel =
    /** @class */
    (function (_super) {
      __extends(ThemeRiverSeriesModel, _super)

      function ThemeRiverSeriesModel () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = ThemeRiverSeriesModel.type
        return _this
      }
      /**
       * @override
       */

      ThemeRiverSeriesModel.prototype.init = function (option) {
        // eslint-disable-next-line
        _super.prototype.init.apply(this, arguments); // Put this function here is for the sake of consistency of code style.
        // Enable legend selection for each data item
        // Use a function instead of direct access because data reference may changed

        this.legendVisualProvider = new LegendVisualProvider(bind(this.getData, this), bind(this.getRawData, this))
      }
      /**
       * If there is no value of a certain point in the time for some event,set it value to 0.
       *
       * @param {Array} data  initial data in the option
       * @return {Array}
       */

      ThemeRiverSeriesModel.prototype.fixData = function (data) {
        let rawDataLength = data.length
        /**
         * Make sure every layer data get the same keys.
         * The value index tells which layer has visited.
         * {
         *  2014/01/01: -1
         * }
         */

        const timeValueKeys = {} // grouped data by name

        const groupResult = groupData(data, function (item) {
          if (!timeValueKeys.hasOwnProperty(item[0] + '')) {
            timeValueKeys[item[0] + ''] = -1
          }

          return item[2]
        })
        const layerData = []
        groupResult.buckets.each(function (items, key) {
          layerData.push({
            name: key,
            dataList: items
          })
        })
        const layerNum = layerData.length

        for (let k = 0; k < layerNum; ++k) {
          const name_1 = layerData[k].name

          for (let j = 0; j < layerData[k].dataList.length; ++j) {
            var timeValue = layerData[k].dataList[j][0] + ''
            timeValueKeys[timeValue] = k
          }

          for (var timeValue in timeValueKeys) {
            if (timeValueKeys.hasOwnProperty(timeValue) && timeValueKeys[timeValue] !== k) {
              timeValueKeys[timeValue] = k
              data[rawDataLength] = [timeValue, 0, name_1]
              rawDataLength++
            }
          }
        }

        return data
      }
      /**
       * @override
       * @param  option  the initial option that user gived
       * @param  ecModel  the model object for themeRiver option
       */

      ThemeRiverSeriesModel.prototype.getInitialData = function (option, ecModel) {
        const singleAxisModel = this.getReferringComponents('singleAxis', SINGLE_REFERRING).models[0]
        const axisType = singleAxisModel.get('type') // filter the data item with the value of label is undefined

        const filterData = filter(option.data, function (dataItem) {
          return dataItem[2] !== undefined
        }) // ??? TODO design a stage to transfer data for themeRiver and lines?

        const data = this.fixData(filterData || [])
        const nameList = []
        const nameMap = this.nameMap = createHashMap()
        let count = 0

        for (let i = 0; i < data.length; ++i) {
          nameList.push(data[i][DATA_NAME_INDEX])

          if (!nameMap.get(data[i][DATA_NAME_INDEX])) {
            nameMap.set(data[i][DATA_NAME_INDEX], count)
            count++
          }
        }

        const dimensions = prepareSeriesDataSchema(data, {
          coordDimensions: ['single'],
          dimensionsDefine: [{
            name: 'time',
            type: getDimensionTypeByAxis(axisType)
          }, {
            name: 'value',
            type: 'float'
          }, {
            name: 'name',
            type: 'ordinal'
          }],
          encodeDefine: {
            single: 0,
            value: 1,
            itemName: 2
          }
        }).dimensions
        const list = new SeriesData(dimensions, this)
        list.initData(data)
        return list
      }
      /**
       * The raw data is divided into multiple layers and each layer
       *     has same name.
       */

      ThemeRiverSeriesModel.prototype.getLayerSeries = function () {
        const data = this.getData()
        const lenCount = data.count()
        const indexArr = []

        for (let i = 0; i < lenCount; ++i) {
          indexArr[i] = i
        }

        const timeDim = data.mapDimension('single') // data group by name

        const groupResult = groupData(indexArr, function (index) {
          return data.get('name', index)
        })
        const layerSeries = []
        groupResult.buckets.each(function (items, key) {
          items.sort(function (index1, index2) {
            return data.get(timeDim, index1) - data.get(timeDim, index2)
          })
          layerSeries.push({
            name: key,
            indices: items
          })
        })
        return layerSeries
      }
      /**
       * Get data indices for show tooltip content
       */

      ThemeRiverSeriesModel.prototype.getAxisTooltipData = function (dim, value, baseAxis) {
        if (!isArray(dim)) {
          dim = dim ? [dim] : []
        }

        const data = this.getData()
        const layerSeries = this.getLayerSeries()
        const indices = []
        const layerNum = layerSeries.length
        let nestestValue

        for (let i = 0; i < layerNum; ++i) {
          let minDist = Number.MAX_VALUE
          let nearestIdx = -1
          const pointNum = layerSeries[i].indices.length

          for (let j = 0; j < pointNum; ++j) {
            const theValue = data.get(dim[0], layerSeries[i].indices[j])
            const dist = Math.abs(theValue - value)

            if (dist <= minDist) {
              nestestValue = theValue
              minDist = dist
              nearestIdx = layerSeries[i].indices[j]
            }
          }

          indices.push(nearestIdx)
        }

        return {
          dataIndices: indices,
          nestestValue: nestestValue
        }
      }

      ThemeRiverSeriesModel.prototype.formatTooltip = function (dataIndex, multipleSeries, dataType) {
        const data = this.getData()
        const name = data.getName(dataIndex)
        const value = data.get(data.mapDimension('value'), dataIndex)
        return createTooltipMarkup('nameValue', {
          name: name,
          value: value
        })
      }

      ThemeRiverSeriesModel.type = 'series.themeRiver'
      ThemeRiverSeriesModel.dependencies = ['singleAxis']
      ThemeRiverSeriesModel.defaultOption = {
        // zlevel: 0,
        z: 2,
        colorBy: 'data',
        coordinateSystem: 'singleAxis',
        // gap in axis's orthogonal orientation
        boundaryGap: ['10%', '10%'],
        // legendHoverLink: true,
        singleAxisIndex: 0,
        animationEasing: 'linear',
        label: {
          margin: 4,
          show: true,
          position: 'left',
          fontSize: 11
        },
        emphasis: {
          label: {
            show: true
          }
        }
      }
      return ThemeRiverSeriesModel
    }(SeriesModel))

  function themeRiverLayout (ecModel, api) {
    ecModel.eachSeriesByType('themeRiver', function (seriesModel) {
      const data = seriesModel.getData()
      const single = seriesModel.coordinateSystem
      const layoutInfo = {} // use the axis boundingRect for view

      const rect = single.getRect()
      layoutInfo.rect = rect
      const boundaryGap = seriesModel.get('boundaryGap')
      const axis = single.getAxis()
      layoutInfo.boundaryGap = boundaryGap

      if (axis.orient === 'horizontal') {
        boundaryGap[0] = parsePercent$1(boundaryGap[0], rect.height)
        boundaryGap[1] = parsePercent$1(boundaryGap[1], rect.height)
        const height = rect.height - boundaryGap[0] - boundaryGap[1]
        doThemeRiverLayout(data, seriesModel, height)
      } else {
        boundaryGap[0] = parsePercent$1(boundaryGap[0], rect.width)
        boundaryGap[1] = parsePercent$1(boundaryGap[1], rect.width)
        const width = rect.width - boundaryGap[0] - boundaryGap[1]
        doThemeRiverLayout(data, seriesModel, width)
      }

      data.setLayout('layoutInfo', layoutInfo)
    })
  }
  /**
     * The layout information about themeriver
     *
     * @param data  data in the series
     * @param seriesModel  the model object of themeRiver series
     * @param height  value used to compute every series height
     */

  function doThemeRiverLayout (data, seriesModel, height) {
    if (!data.count()) {
      return
    }

    const coordSys = seriesModel.coordinateSystem // the data in each layer are organized into a series.

    const layerSeries = seriesModel.getLayerSeries() // the points in each layer.

    const timeDim = data.mapDimension('single')
    const valueDim = data.mapDimension('value')
    const layerPoints = map(layerSeries, function (singleLayer) {
      return map(singleLayer.indices, function (idx) {
        const pt = coordSys.dataToPoint(data.get(timeDim, idx))
        pt[1] = data.get(valueDim, idx)
        return pt
      })
    })
    const base = computeBaseline(layerPoints)
    const baseLine = base.y0
    const ky = height / base.max // set layout information for each item.

    const n = layerSeries.length
    const m = layerSeries[0].indices.length
    let baseY0

    for (let j = 0; j < m; ++j) {
      baseY0 = baseLine[j] * ky
      data.setItemLayout(layerSeries[0].indices[j], {
        layerIndex: 0,
        x: layerPoints[0][j][0],
        y0: baseY0,
        y: layerPoints[0][j][1] * ky
      })

      for (let i = 1; i < n; ++i) {
        baseY0 += layerPoints[i - 1][j][1] * ky
        data.setItemLayout(layerSeries[i].indices[j], {
          layerIndex: i,
          x: layerPoints[i][j][0],
          y0: baseY0,
          y: layerPoints[i][j][1] * ky
        })
      }
    }
  }
  /**
     * Compute the baseLine of the rawdata
     * Inspired by Lee Byron's paper Stacked Graphs - Geometry & Aesthetics
     *
     * @param  data  the points in each layer
     */

  function computeBaseline (data) {
    const layerNum = data.length
    const pointNum = data[0].length
    const sums = []
    const y0 = []
    let max = 0

    for (let i = 0; i < pointNum; ++i) {
      let temp = 0

      for (let j = 0; j < layerNum; ++j) {
        temp += data[j][i][1]
      }

      if (temp > max) {
        max = temp
      }

      sums.push(temp)
    }

    for (let k = 0; k < pointNum; ++k) {
      y0[k] = (max - sums[k]) / 2
    }

    max = 0

    for (let l = 0; l < pointNum; ++l) {
      const sum = sums[l] + y0[l]

      if (sum > max) {
        max = sum
      }
    }

    return {
      y0: y0,
      max: max
    }
  }

  function install$p (registers) {
    registers.registerChartView(ThemeRiverView)
    registers.registerSeriesModel(ThemeRiverSeriesModel)
    registers.registerLayout(themeRiverLayout)
    registers.registerProcessor(dataFilter('themeRiver'))
  }

  const DEFAULT_SECTOR_Z = 2
  const DEFAULT_TEXT_Z = 4
  /**
     * Sunburstce of Sunburst including Sector, Label, LabelLine
     */

  const SunburstPiece =
    /** @class */
    (function (_super) {
      __extends(SunburstPiece, _super)

      function SunburstPiece (node, seriesModel, ecModel, api) {
        const _this = _super.call(this) || this

        _this.z2 = DEFAULT_SECTOR_Z
        _this.textConfig = {
          inside: true
        }
        getECData(_this).seriesIndex = seriesModel.seriesIndex
        const text = new ZRText({
          z2: DEFAULT_TEXT_Z,
          silent: node.getModel().get(['label', 'silent'])
        })

        _this.setTextContent(text)

        _this.updateData(true, node, seriesModel, ecModel, api)

        return _this
      }

      SunburstPiece.prototype.updateData = function (firstCreate, node, // state: 'emphasis' | 'normal' | 'highlight' | 'downplay',
        seriesModel, ecModel, api) {
        this.node = node
        node.piece = this
        seriesModel = seriesModel || this._seriesModel
        ecModel = ecModel || this._ecModel
        const sector = this
        getECData(sector).dataIndex = node.dataIndex
        const itemModel = node.getModel()
        const emphasisModel = itemModel.getModel('emphasis')
        const layout = node.getLayout()
        const sectorShape = extend({}, layout)
        sectorShape.label = null
        const normalStyle = node.getVisual('style')
        normalStyle.lineJoin = 'bevel'
        const decal = node.getVisual('decal')

        if (decal) {
          normalStyle.decal = createOrUpdatePatternFromDecal(decal, api)
        }

        const cornerRadius = getSectorCornerRadius(itemModel.getModel('itemStyle'), sectorShape, true)
        extend(sectorShape, cornerRadius)
        each(SPECIAL_STATES, function (stateName) {
          const state = sector.ensureState(stateName)
          const itemStyleModel = itemModel.getModel([stateName, 'itemStyle'])
          state.style = itemStyleModel.getItemStyle() // border radius

          const cornerRadius = getSectorCornerRadius(itemStyleModel, sectorShape)

          if (cornerRadius) {
            state.shape = cornerRadius
          }
        })

        if (firstCreate) {
          sector.setShape(sectorShape)
          sector.shape.r = layout.r0
          updateProps(sector, {
            shape: {
              r: layout.r
            }
          }, seriesModel, node.dataIndex)
        } else {
          // Disable animation for gradient since no interpolation method
          // is supported for gradient
          updateProps(sector, {
            shape: sectorShape
          }, seriesModel)
          saveOldStyle(sector)
        }

        sector.useStyle(normalStyle)

        this._updateLabel(seriesModel)

        const cursorStyle = itemModel.getShallow('cursor')
        cursorStyle && sector.attr('cursor', cursorStyle)
        this._seriesModel = seriesModel || this._seriesModel
        this._ecModel = ecModel || this._ecModel
        const focus = emphasisModel.get('focus')
        const focusOrIndices = focus === 'ancestor' ? node.getAncestorsIndices() : focus === 'descendant' ? node.getDescendantIndices() : focus
        toggleHoverEmphasis(this, focusOrIndices, emphasisModel.get('blurScope'), emphasisModel.get('disabled'))
      }

      SunburstPiece.prototype._updateLabel = function (seriesModel) {
        const _this = this

        const itemModel = this.node.getModel()
        const normalLabelModel = itemModel.getModel('label')
        const layout = this.node.getLayout()
        const angle = layout.endAngle - layout.startAngle
        const midAngle = (layout.startAngle + layout.endAngle) / 2
        const dx = Math.cos(midAngle)
        const dy = Math.sin(midAngle)
        const sector = this
        const label = sector.getTextContent()
        const dataIndex = this.node.dataIndex
        const labelMinAngle = normalLabelModel.get('minAngle') / 180 * Math.PI
        const isNormalShown = normalLabelModel.get('show') && !(labelMinAngle != null && Math.abs(angle) < labelMinAngle)
        label.ignore = !isNormalShown // TODO use setLabelStyle

        each(DISPLAY_STATES, function (stateName) {
          const labelStateModel = stateName === 'normal' ? itemModel.getModel('label') : itemModel.getModel([stateName, 'label'])
          const isNormal = stateName === 'normal'
          const state = isNormal ? label : label.ensureState(stateName)
          let text = seriesModel.getFormattedLabel(dataIndex, stateName)

          if (isNormal) {
            text = text || _this.node.name
          }

          state.style = createTextStyle(labelStateModel, {}, null, stateName !== 'normal', true)

          if (text) {
            state.style.text = text
          } // Not displaying text when angle is too small

          const isShown = labelStateModel.get('show')

          if (isShown != null && !isNormal) {
            state.ignore = !isShown
          }

          const labelPosition = getLabelAttr(labelStateModel, 'position')
          const sectorState = isNormal ? sector : sector.states[stateName]
          const labelColor = sectorState.style.fill
          sectorState.textConfig = {
            outsideFill: labelStateModel.get('color') === 'inherit' ? labelColor : null,
            inside: labelPosition !== 'outside'
          }
          let r
          const labelPadding = getLabelAttr(labelStateModel, 'distance') || 0
          let textAlign = getLabelAttr(labelStateModel, 'align')

          if (labelPosition === 'outside') {
            r = layout.r + labelPadding
            textAlign = midAngle > Math.PI / 2 ? 'right' : 'left'
          } else {
            if (!textAlign || textAlign === 'center') {
              // Put label in the center if it's a circle
              if (angle === 2 * Math.PI && layout.r0 === 0) {
                r = 0
              } else {
                r = (layout.r + layout.r0) / 2
              }

              textAlign = 'center'
            } else if (textAlign === 'left') {
              r = layout.r0 + labelPadding

              if (midAngle > Math.PI / 2) {
                textAlign = 'right'
              }
            } else if (textAlign === 'right') {
              r = layout.r - labelPadding

              if (midAngle > Math.PI / 2) {
                textAlign = 'left'
              }
            }
          }

          state.style.align = textAlign
          state.style.verticalAlign = getLabelAttr(labelStateModel, 'verticalAlign') || 'middle'
          state.x = r * dx + layout.cx
          state.y = r * dy + layout.cy
          const rotateType = getLabelAttr(labelStateModel, 'rotate')
          let rotate = 0

          if (rotateType === 'radial') {
            rotate = -midAngle

            if (rotate < -Math.PI / 2) {
              rotate += Math.PI
            }
          } else if (rotateType === 'tangential') {
            rotate = Math.PI / 2 - midAngle

            if (rotate > Math.PI / 2) {
              rotate -= Math.PI
            } else if (rotate < -Math.PI / 2) {
              rotate += Math.PI
            }
          } else if (isNumber(rotateType)) {
            rotate = rotateType * Math.PI / 180
          }

          state.rotation = rotate
        })

        function getLabelAttr (model, name) {
          const stateAttr = model.get(name)

          if (stateAttr == null) {
            return normalLabelModel.get(name)
          }

          return stateAttr
        }

        label.dirtyStyle()
      }

      return SunburstPiece
    }(Sector))

  const ROOT_TO_NODE_ACTION = 'sunburstRootToNode'
  const HIGHLIGHT_ACTION = 'sunburstHighlight'
  const UNHIGHLIGHT_ACTION = 'sunburstUnhighlight'
  function installSunburstAction (registers) {
    registers.registerAction({
      type: ROOT_TO_NODE_ACTION,
      update: 'updateView'
    }, function (payload, ecModel) {
      ecModel.eachComponent({
        mainType: 'series',
        subType: 'sunburst',
        query: payload
      }, handleRootToNode)

      function handleRootToNode (model, index) {
        const targetInfo = retrieveTargetInfo(payload, [ROOT_TO_NODE_ACTION], model)

        if (targetInfo) {
          const originViewRoot = model.getViewRoot()

          if (originViewRoot) {
            payload.direction = aboveViewRoot(originViewRoot, targetInfo.node) ? 'rollUp' : 'drillDown'
          }

          model.resetViewRoot(targetInfo.node)
        }
      }
    })
    registers.registerAction({
      type: HIGHLIGHT_ACTION,
      update: 'none'
    }, function (payload, ecModel, api) {
      // Clone
      payload = extend({}, payload)
      ecModel.eachComponent({
        mainType: 'series',
        subType: 'sunburst',
        query: payload
      }, handleHighlight)

      function handleHighlight (model) {
        const targetInfo = retrieveTargetInfo(payload, [HIGHLIGHT_ACTION], model)

        if (targetInfo) {
          payload.dataIndex = targetInfo.node.dataIndex
        }
      }

      if ('development' !== 'production') {
        deprecateReplaceLog('highlight', 'sunburstHighlight')
      } // Fast forward action

      api.dispatchAction(extend(payload, {
        type: 'highlight'
      }))
    })
    registers.registerAction({
      type: UNHIGHLIGHT_ACTION,
      update: 'updateView'
    }, function (payload, ecModel, api) {
      payload = extend({}, payload)

      if ('development' !== 'production') {
        deprecateReplaceLog('downplay', 'sunburstUnhighlight')
      }

      api.dispatchAction(extend(payload, {
        type: 'downplay'
      }))
    })
  }

  const SunburstView =
    /** @class */
    (function (_super) {
      __extends(SunburstView, _super)

      function SunburstView () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = SunburstView.type
        return _this
      }

      SunburstView.prototype.render = function (seriesModel, ecModel, api, // @ts-ignore
        payload) {
        const self = this
        this.seriesModel = seriesModel
        this.api = api
        this.ecModel = ecModel
        const data = seriesModel.getData()
        const virtualRoot = data.tree.root
        const newRoot = seriesModel.getViewRoot()
        const group = this.group
        const renderLabelForZeroData = seriesModel.get('renderLabelForZeroData')
        const newChildren = []
        newRoot.eachNode(function (node) {
          newChildren.push(node)
        })
        const oldChildren = this._oldChildren || []
        dualTravel(newChildren, oldChildren)
        renderRollUp(virtualRoot, newRoot)

        this._initEvents()

        this._oldChildren = newChildren

        function dualTravel (newChildren, oldChildren) {
          if (newChildren.length === 0 && oldChildren.length === 0) {
            return
          }

          new DataDiffer(oldChildren, newChildren, getKey, getKey).add(processNode).update(processNode).remove(curry(processNode, null)).execute()

          function getKey (node) {
            return node.getId()
          }

          function processNode (newIdx, oldIdx) {
            const newNode = newIdx == null ? null : newChildren[newIdx]
            const oldNode = oldIdx == null ? null : oldChildren[oldIdx]
            doRenderNode(newNode, oldNode)
          }
        }

        function doRenderNode (newNode, oldNode) {
          if (!renderLabelForZeroData && newNode && !newNode.getValue()) {
            // Not render data with value 0
            newNode = null
          }

          if (newNode !== virtualRoot && oldNode !== virtualRoot) {
            if (oldNode && oldNode.piece) {
              if (newNode) {
                // Update
                oldNode.piece.updateData(false, newNode, seriesModel, ecModel, api) // For tooltip

                data.setItemGraphicEl(newNode.dataIndex, oldNode.piece)
              } else {
                // Remove
                removeNode(oldNode)
              }
            } else if (newNode) {
              // Add
              const piece = new SunburstPiece(newNode, seriesModel, ecModel, api)
              group.add(piece) // For tooltip

              data.setItemGraphicEl(newNode.dataIndex, piece)
            }
          }
        }

        function removeNode (node) {
          if (!node) {
            return
          }

          if (node.piece) {
            group.remove(node.piece)
            node.piece = null
          }
        }

        function renderRollUp (virtualRoot, viewRoot) {
          if (viewRoot.depth > 0) {
            // Render
            if (self.virtualPiece) {
              // Update
              self.virtualPiece.updateData(false, virtualRoot, seriesModel, ecModel, api)
            } else {
              // Add
              self.virtualPiece = new SunburstPiece(virtualRoot, seriesModel, ecModel, api)
              group.add(self.virtualPiece)
            } // TODO event scope

            viewRoot.piece.off('click')
            self.virtualPiece.on('click', function (e) {
              self._rootToNode(viewRoot.parentNode)
            })
          } else if (self.virtualPiece) {
            // Remove
            group.remove(self.virtualPiece)
            self.virtualPiece = null
          }
        }
      }
      /**
       * @private
       */

      SunburstView.prototype._initEvents = function () {
        const _this = this

        this.group.off('click')
        this.group.on('click', function (e) {
          let targetFound = false

          const viewRoot = _this.seriesModel.getViewRoot()

          viewRoot.eachNode(function (node) {
            if (!targetFound && node.piece && node.piece === e.target) {
              const nodeClick = node.getModel().get('nodeClick')

              if (nodeClick === 'rootToNode') {
                _this._rootToNode(node)
              } else if (nodeClick === 'link') {
                const itemModel = node.getModel()
                const link = itemModel.get('link')

                if (link) {
                  const linkTarget = itemModel.get('target', true) || '_blank'
                  windowOpen(link, linkTarget)
                }
              }

              targetFound = true
            }
          })
        })
      }
      /**
       * @private
       */

      SunburstView.prototype._rootToNode = function (node) {
        if (node !== this.seriesModel.getViewRoot()) {
          this.api.dispatchAction({
            type: ROOT_TO_NODE_ACTION,
            from: this.uid,
            seriesId: this.seriesModel.id,
            targetNode: node
          })
        }
      }
      /**
       * @implement
       */

      SunburstView.prototype.containPoint = function (point, seriesModel) {
        const treeRoot = seriesModel.getData()
        const itemLayout = treeRoot.getItemLayout(0)

        if (itemLayout) {
          const dx = point[0] - itemLayout.cx
          const dy = point[1] - itemLayout.cy
          const radius = Math.sqrt(dx * dx + dy * dy)
          return radius <= itemLayout.r && radius >= itemLayout.r0
        }
      }

      SunburstView.type = 'sunburst'
      return SunburstView
    }(ChartView))

  const SunburstSeriesModel =
    /** @class */
    (function (_super) {
      __extends(SunburstSeriesModel, _super)

      function SunburstSeriesModel () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = SunburstSeriesModel.type
        _this.ignoreStyleOnData = true
        return _this
      }

      SunburstSeriesModel.prototype.getInitialData = function (option, ecModel) {
        // Create a virtual root.
        const root = {
          name: option.name,
          children: option.data
        }
        completeTreeValue$1(root)
        const levelModels = this._levelModels = map(option.levels || [], function (levelDefine) {
          return new Model(levelDefine, this, ecModel)
        }, this) // Make sure always a new tree is created when setOption,
        // in TreemapView, we check whether oldTree === newTree
        // to choose mappings approach among old shapes and new shapes.

        const tree = Tree.createTree(root, this, beforeLink)

        function beforeLink (nodeData) {
          nodeData.wrapMethod('getItemModel', function (model, idx) {
            const node = tree.getNodeByDataIndex(idx)
            const levelModel = levelModels[node.depth]
            levelModel && (model.parentModel = levelModel)
            return model
          })
        }

        return tree.data
      }

      SunburstSeriesModel.prototype.optionUpdated = function () {
        this.resetViewRoot()
      }
      /*
       * @override
       */

      SunburstSeriesModel.prototype.getDataParams = function (dataIndex) {
        const params = _super.prototype.getDataParams.apply(this, arguments)

        const node = this.getData().tree.getNodeByDataIndex(dataIndex)
        params.treePathInfo = wrapTreePathInfo(node, this)
        return params
      }

      SunburstSeriesModel.prototype.getLevelModel = function (node) {
        return this._levelModels && this._levelModels[node.depth]
      }

      SunburstSeriesModel.prototype.getViewRoot = function () {
        return this._viewRoot
      }

      SunburstSeriesModel.prototype.resetViewRoot = function (viewRoot) {
        viewRoot ? this._viewRoot = viewRoot : viewRoot = this._viewRoot
        const root = this.getRawData().tree.root

        if (!viewRoot || viewRoot !== root && !root.contains(viewRoot)) {
          this._viewRoot = root
        }
      }

      SunburstSeriesModel.prototype.enableAriaDecal = function () {
        enableAriaDecalForTree(this)
      }

      SunburstSeriesModel.type = 'series.sunburst'
      SunburstSeriesModel.defaultOption = {
        // zlevel: 0,
        z: 2,
        // 默认全局居中
        center: ['50%', '50%'],
        radius: [0, '75%'],
        // 默认顺时针
        clockwise: true,
        startAngle: 90,
        // 最小角度改为0
        minAngle: 0,
        // If still show when all data zero.
        stillShowZeroSum: true,
        // 'rootToNode', 'link', or false
        nodeClick: 'rootToNode',
        renderLabelForZeroData: false,
        label: {
          // could be: 'radial', 'tangential', or 'none'
          rotate: 'radial',
          show: true,
          opacity: 1,
          // 'left' is for inner side of inside, and 'right' is for outter
          // side for inside
          align: 'center',
          position: 'inside',
          distance: 5,
          silent: true
        },
        itemStyle: {
          borderWidth: 1,
          borderColor: 'white',
          borderType: 'solid',
          shadowBlur: 0,
          shadowColor: 'rgba(0, 0, 0, 0.2)',
          shadowOffsetX: 0,
          shadowOffsetY: 0,
          opacity: 1
        },
        emphasis: {
          focus: 'descendant'
        },
        blur: {
          itemStyle: {
            opacity: 0.2
          },
          label: {
            opacity: 0.1
          }
        },
        // Animation type canbe expansion, scale
        animationType: 'expansion',
        animationDuration: 1000,
        animationDurationUpdate: 500,
        data: [],

        /**
         * Sort order.
         *
         * Valid values: 'desc', 'asc', null, or callback function.
         * 'desc' and 'asc' for descend and ascendant order;
         * null for not sorting;
         * example of callback function:
         * function(nodeA, nodeB) {
         *     return nodeA.getValue() - nodeB.getValue();
         * }
         */
        sort: 'desc'
      }
      return SunburstSeriesModel
    }(SeriesModel))

  function completeTreeValue$1 (dataNode) {
    // Postorder travel tree.
    // If value of none-leaf node is not set,
    // calculate it by suming up the value of all children.
    let sum = 0
    each(dataNode.children, function (child) {
      completeTreeValue$1(child)
      let childValue = child.value // TODO First value of array must be a number

      isArray(childValue) && (childValue = childValue[0])
      sum += childValue
    })
    let thisValue = dataNode.value

    if (isArray(thisValue)) {
      thisValue = thisValue[0]
    }

    if (thisValue == null || isNaN(thisValue)) {
      thisValue = sum
    } // Value should not less than 0.

    if (thisValue < 0) {
      thisValue = 0
    }

    isArray(dataNode.value) ? dataNode.value[0] = thisValue : dataNode.value = thisValue
  }

  const RADIAN$2 = Math.PI / 180
  function sunburstLayout (seriesType, ecModel, api) {
    ecModel.eachSeriesByType(seriesType, function (seriesModel) {
      let center = seriesModel.get('center')
      let radius = seriesModel.get('radius')

      if (!isArray(radius)) {
        radius = [0, radius]
      }

      if (!isArray(center)) {
        center = [center, center]
      }

      const width = api.getWidth()
      const height = api.getHeight()
      const size = Math.min(width, height)
      const cx = parsePercent$1(center[0], width)
      const cy = parsePercent$1(center[1], height)
      const r0 = parsePercent$1(radius[0], size / 2)
      const r = parsePercent$1(radius[1], size / 2)
      const startAngle = -seriesModel.get('startAngle') * RADIAN$2
      const minAngle = seriesModel.get('minAngle') * RADIAN$2
      const virtualRoot = seriesModel.getData().tree.root
      const treeRoot = seriesModel.getViewRoot()
      const rootDepth = treeRoot.depth
      const sort = seriesModel.get('sort')

      if (sort != null) {
        initChildren$1(treeRoot, sort)
      }

      let validDataCount = 0
      each(treeRoot.children, function (child) {
        !isNaN(child.getValue()) && validDataCount++
      })
      const sum = treeRoot.getValue() // Sum may be 0

      const unitRadian = Math.PI / (sum || validDataCount) * 2
      const renderRollupNode = treeRoot.depth > 0
      const levels = treeRoot.height - (renderRollupNode ? -1 : 1)
      const rPerLevel = (r - r0) / (levels || 1)
      const clockwise = seriesModel.get('clockwise')
      const stillShowZeroSum = seriesModel.get('stillShowZeroSum') // In the case some sector angle is smaller than minAngle
      // let restAngle = PI2;
      // let valueSumLargerThanMinAngle = 0;

      const dir = clockwise ? 1 : -1
      /**
         * Render a tree
         * @return increased angle
         */

      var renderNode = function (node, startAngle) {
        if (!node) {
          return
        }

        let endAngle = startAngle // Render self

        if (node !== virtualRoot) {
          // Tree node is virtual, so it doesn't need to be drawn
          const value = node.getValue()
          let angle = sum === 0 && stillShowZeroSum ? unitRadian : value * unitRadian

          if (angle < minAngle) {
            angle = minAngle // restAngle -= minAngle;
          } // else {
          //     valueSumLargerThanMinAngle += value;
          // }

          endAngle = startAngle + dir * angle
          const depth = node.depth - rootDepth - (renderRollupNode ? -1 : 1)
          let rStart = r0 + rPerLevel * depth
          let rEnd = r0 + rPerLevel * (depth + 1)
          const levelModel = seriesModel.getLevelModel(node)

          if (levelModel) {
            let r0_1 = levelModel.get('r0', true)
            let r_1 = levelModel.get('r', true)
            const radius_1 = levelModel.get('radius', true)

            if (radius_1 != null) {
              r0_1 = radius_1[0]
              r_1 = radius_1[1]
            }

            r0_1 != null && (rStart = parsePercent$1(r0_1, size / 2))
            r_1 != null && (rEnd = parsePercent$1(r_1, size / 2))
          }

          node.setLayout({
            angle: angle,
            startAngle: startAngle,
            endAngle: endAngle,
            clockwise: clockwise,
            cx: cx,
            cy: cy,
            r0: rStart,
            r: rEnd
          })
        } // Render children

        if (node.children && node.children.length) {
          // currentAngle = startAngle;
          let siblingAngle_1 = 0
          each(node.children, function (node) {
            siblingAngle_1 += renderNode(node, startAngle + siblingAngle_1)
          })
        }

        return endAngle - startAngle
      } // Virtual root node for roll up

      if (renderRollupNode) {
        const rStart = r0
        const rEnd = r0 + rPerLevel
        const angle = Math.PI * 2
        virtualRoot.setLayout({
          angle: angle,
          startAngle: startAngle,
          endAngle: startAngle + angle,
          clockwise: clockwise,
          cx: cx,
          cy: cy,
          r0: rStart,
          r: rEnd
        })
      }

      renderNode(treeRoot, startAngle)
    })
  }
  /**
     * Init node children by order and update visual
     */

  function initChildren$1 (node, sortOrder) {
    const children = node.children || []
    node.children = sort$2(children, sortOrder) // Init children recursively

    if (children.length) {
      each(node.children, function (child) {
        initChildren$1(child, sortOrder)
      })
    }
  }
  /**
     * Sort children nodes
     *
     * @param {TreeNode[]}               children children of node to be sorted
     * @param {string | function | null} sort sort method
     *                                   See SunburstSeries.js for details.
     */

  function sort$2 (children, sortOrder) {
    if (isFunction(sortOrder)) {
      const sortTargets = map(children, function (child, idx) {
        const value = child.getValue()
        return {
          params: {
            depth: child.depth,
            height: child.height,
            dataIndex: child.dataIndex,
            getValue: function () {
              return value
            }
          },
          index: idx
        }
      })
      sortTargets.sort(function (a, b) {
        return sortOrder(a.params, b.params)
      })
      return map(sortTargets, function (target) {
        return children[target.index]
      })
    } else {
      const isAsc_1 = sortOrder === 'asc'
      return children.sort(function (a, b) {
        const diff = (a.getValue() - b.getValue()) * (isAsc_1 ? 1 : -1)
        return diff === 0 ? (a.dataIndex - b.dataIndex) * (isAsc_1 ? -1 : 1) : diff
      })
    }
  }

  function sunburstVisual (ecModel) {
    const paletteScope = {} // Default color strategy

    function pickColor (node, seriesModel, treeHeight) {
      // Choose color from palette based on the first level.
      let current = node

      while (current && current.depth > 1) {
        current = current.parentNode
      }

      let color = seriesModel.getColorFromPalette(current.name || current.dataIndex + '', paletteScope)

      if (node.depth > 1 && isString(color)) {
        // Lighter on the deeper level.
        color = lift(color, (node.depth - 1) / (treeHeight - 1) * 0.5)
      }

      return color
    }

    ecModel.eachSeriesByType('sunburst', function (seriesModel) {
      const data = seriesModel.getData()
      const tree = data.tree
      tree.eachNode(function (node) {
        const model = node.getModel()
        const style = model.getModel('itemStyle').getItemStyle()

        if (!style.fill) {
          style.fill = pickColor(node, seriesModel, tree.root.height)
        }

        const existsStyle = data.ensureUniqueItemVisual(node.dataIndex, 'style')
        extend(existsStyle, style)
      })
    })
  }

  function install$q (registers) {
    registers.registerChartView(SunburstView)
    registers.registerSeriesModel(SunburstSeriesModel)
    registers.registerLayout(curry(sunburstLayout, 'sunburst'))
    registers.registerProcessor(curry(dataFilter, 'sunburst'))
    registers.registerVisual(sunburstVisual)
    installSunburstAction(registers)
  }

  // `visual('color') visual('borderColor')` is supported.

  const STYLE_VISUAL_TYPE = {
    color: 'fill',
    borderColor: 'stroke'
  }
  const NON_STYLE_VISUAL_PROPS = {
    symbol: 1,
    symbolSize: 1,
    symbolKeepAspect: 1,
    legendIcon: 1,
    visualMeta: 1,
    liftZ: 1,
    decal: 1
  }
  const customInnerStore = makeInner()

  const CustomSeriesModel =
    /** @class */
    (function (_super) {
      __extends(CustomSeriesModel, _super)

      function CustomSeriesModel () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = CustomSeriesModel.type
        return _this
      }

      CustomSeriesModel.prototype.optionUpdated = function () {
        this.currentZLevel = this.get('zlevel', true)
        this.currentZ = this.get('z', true)
      }

      CustomSeriesModel.prototype.getInitialData = function (option, ecModel) {
        return createSeriesData(null, this)
      }

      CustomSeriesModel.prototype.getDataParams = function (dataIndex, dataType, el) {
        const params = _super.prototype.getDataParams.call(this, dataIndex, dataType)

        el && (params.info = customInnerStore(el).info)
        return params
      }

      CustomSeriesModel.type = 'series.custom'
      CustomSeriesModel.dependencies = ['grid', 'polar', 'geo', 'singleAxis', 'calendar']
      CustomSeriesModel.defaultOption = {
        coordinateSystem: 'cartesian2d',
        // zlevel: 0,
        z: 2,
        legendHoverLink: true,
        // Custom series will not clip by default.
        // Some case will use custom series to draw label
        // For example https://echarts.apache.org/examples/en/editor.html?c=custom-gantt-flight
        clip: false // Cartesian coordinate system
        // xAxisIndex: 0,
        // yAxisIndex: 0,
        // Polar coordinate system
        // polarIndex: 0,
        // Geo coordinate system
        // geoIndex: 0,

      }
      return CustomSeriesModel
    }(SeriesModel))

  function dataToCoordSize (dataSize, dataItem) {
    // dataItem is necessary in log axis.
    dataItem = dataItem || [0, 0]
    return map(['x', 'y'], function (dim, dimIdx) {
      const axis = this.getAxis(dim)
      const val = dataItem[dimIdx]
      const halfSize = dataSize[dimIdx] / 2
      return axis.type === 'category' ? axis.getBandWidth() : Math.abs(axis.dataToCoord(val - halfSize) - axis.dataToCoord(val + halfSize))
    }, this)
  }

  function cartesianPrepareCustom (coordSys) {
    const rect = coordSys.master.getRect()
    return {
      coordSys: {
        // The name exposed to user is always 'cartesian2d' but not 'grid'.
        type: 'cartesian2d',
        x: rect.x,
        y: rect.y,
        width: rect.width,
        height: rect.height
      },
      api: {
        coord: function (data) {
          // do not provide "out" param
          return coordSys.dataToPoint(data)
        },
        size: bind(dataToCoordSize, coordSys)
      }
    }
  }

  function dataToCoordSize$1 (dataSize, dataItem) {
    dataItem = dataItem || [0, 0]
    return map([0, 1], function (dimIdx) {
      const val = dataItem[dimIdx]
      const halfSize = dataSize[dimIdx] / 2
      const p1 = []
      const p2 = []
      p1[dimIdx] = val - halfSize
      p2[dimIdx] = val + halfSize
      p1[1 - dimIdx] = p2[1 - dimIdx] = dataItem[1 - dimIdx]
      return Math.abs(this.dataToPoint(p1)[dimIdx] - this.dataToPoint(p2)[dimIdx])
    }, this)
  }

  function geoPrepareCustom (coordSys) {
    const rect = coordSys.getBoundingRect()
    return {
      coordSys: {
        type: 'geo',
        x: rect.x,
        y: rect.y,
        width: rect.width,
        height: rect.height,
        zoom: coordSys.getZoom()
      },
      api: {
        coord: function (data) {
          // do not provide "out" and noRoam param,
          // Compatible with this usage:
          // echarts.util.map(item.points, api.coord)
          return coordSys.dataToPoint(data)
        },
        size: bind(dataToCoordSize$1, coordSys)
      }
    }
  }

  function dataToCoordSize$2 (dataSize, dataItem) {
    // dataItem is necessary in log axis.
    const axis = this.getAxis()
    const val = dataItem instanceof Array ? dataItem[0] : dataItem
    const halfSize = (dataSize instanceof Array ? dataSize[0] : dataSize) / 2
    return axis.type === 'category' ? axis.getBandWidth() : Math.abs(axis.dataToCoord(val - halfSize) - axis.dataToCoord(val + halfSize))
  }

  function singlePrepareCustom (coordSys) {
    const rect = coordSys.getRect()
    return {
      coordSys: {
        type: 'singleAxis',
        x: rect.x,
        y: rect.y,
        width: rect.width,
        height: rect.height
      },
      api: {
        coord: function (val) {
          // do not provide "out" param
          return coordSys.dataToPoint(val)
        },
        size: bind(dataToCoordSize$2, coordSys)
      }
    }
  }

  function dataToCoordSize$3 (dataSize, dataItem) {
    // dataItem is necessary in log axis.
    dataItem = dataItem || [0, 0]
    return map(['Radius', 'Angle'], function (dim, dimIdx) {
      const getterName = 'get' + dim + 'Axis' // TODO: TYPE Check Angle Axis

      const axis = this[getterName]()
      const val = dataItem[dimIdx]
      const halfSize = dataSize[dimIdx] / 2
      let result = axis.type === 'category' ? axis.getBandWidth() : Math.abs(axis.dataToCoord(val - halfSize) - axis.dataToCoord(val + halfSize))

      if (dim === 'Angle') {
        result = result * Math.PI / 180
      }

      return result
    }, this)
  }

  function polarPrepareCustom (coordSys) {
    const radiusAxis = coordSys.getRadiusAxis()
    const angleAxis = coordSys.getAngleAxis()
    const radius = radiusAxis.getExtent()
    radius[0] > radius[1] && radius.reverse()
    return {
      coordSys: {
        type: 'polar',
        cx: coordSys.cx,
        cy: coordSys.cy,
        r: radius[1],
        r0: radius[0]
      },
      api: {
        coord: function (data) {
          const radius = radiusAxis.dataToRadius(data[0])
          const angle = angleAxis.dataToAngle(data[1])
          const coord = coordSys.coordToPoint([radius, angle])
          coord.push(radius, angle * Math.PI / 180)
          return coord
        },
        size: bind(dataToCoordSize$3, coordSys)
      }
    }
  }

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

  /**
     * AUTO-GENERATED FILE. DO NOT MODIFY.
     */

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
  function calendarPrepareCustom (coordSys) {
    const rect = coordSys.getRect()
    const rangeInfo = coordSys.getRangeInfo()
    return {
      coordSys: {
        type: 'calendar',
        x: rect.x,
        y: rect.y,
        width: rect.width,
        height: rect.height,
        cellWidth: coordSys.getCellWidth(),
        cellHeight: coordSys.getCellHeight(),
        rangeInfo: {
          start: rangeInfo.start,
          end: rangeInfo.end,
          weeks: rangeInfo.weeks,
          dayCount: rangeInfo.allDay
        }
      },
      api: {
        coord: function (data, clamp) {
          return coordSys.dataToPoint(data, clamp)
        }
      }
    }
  }

  const deprecatedLogs = {}
  /**
     * Whether need to call `convertEC4CompatibleStyle`.
     */

  function isEC4CompatibleStyle (style, elType, hasOwnTextContentOption, hasOwnTextConfig) {
    // Since echarts5, `RectText` is separated from its host element and style.text
    // does not exist any more. The compat work brings some extra burden on performance.
    // So we provide:
    // `legacy: true` force make compat.
    // `legacy: false`, force do not compat.
    // `legacy` not set: auto detect wheter legacy.
    //     But in this case we do not compat (difficult to detect and rare case):
    //     Becuse custom series and graphic component support "merge", users may firstly
    //     only set `textStrokeWidth` style or secondly only set `text`.
    return style && (style.legacy || style.legacy !== false && !hasOwnTextContentOption && !hasOwnTextConfig && elType !== 'tspan' && // Difficult to detect whether legacy for a "text" el.
      (elType === 'text' || hasOwn(style, 'text')))
  }
  /**
     * `EC4CompatibleStyle` is style that might be in echarts4 format or echarts5 format.
     * @param hostStyle The properties might be modified.
     * @return If be text el, `textContentStyle` and `textConfig` will not be retured.
     *         Otherwise a `textContentStyle` and `textConfig` will be created, whose props area
     *         retried from the `hostStyle`.
     */

  function convertFromEC4CompatibleStyle (hostStyle, elType, isNormal) {
    const srcStyle = hostStyle
    let textConfig
    let textContent
    let textContentStyle

    if (elType === 'text') {
      textContentStyle = srcStyle
    } else {
      textContentStyle = {}
      hasOwn(srcStyle, 'text') && (textContentStyle.text = srcStyle.text)
      hasOwn(srcStyle, 'rich') && (textContentStyle.rich = srcStyle.rich)
      hasOwn(srcStyle, 'textFill') && (textContentStyle.fill = srcStyle.textFill)
      hasOwn(srcStyle, 'textStroke') && (textContentStyle.stroke = srcStyle.textStroke)
      hasOwn(srcStyle, 'fontFamily') && (textContentStyle.fontFamily = srcStyle.fontFamily)
      hasOwn(srcStyle, 'fontSize') && (textContentStyle.fontSize = srcStyle.fontSize)
      hasOwn(srcStyle, 'fontStyle') && (textContentStyle.fontStyle = srcStyle.fontStyle)
      hasOwn(srcStyle, 'fontWeight') && (textContentStyle.fontWeight = srcStyle.fontWeight)
      textContent = {
        type: 'text',
        style: textContentStyle,
        // ec4 do not support rectText trigger.
        // And when text postion is different in normal and emphasis
        // => hover text trigger emphasis;
        // => text position changed, leave mouse pointer immediately;
        // That might cause state incorrect.
        silent: true
      }
      textConfig = {}
      const hasOwnPos = hasOwn(srcStyle, 'textPosition')

      if (isNormal) {
        textConfig.position = hasOwnPos ? srcStyle.textPosition : 'inside'
      } else {
        hasOwnPos && (textConfig.position = srcStyle.textPosition)
      }

      hasOwn(srcStyle, 'textPosition') && (textConfig.position = srcStyle.textPosition)
      hasOwn(srcStyle, 'textOffset') && (textConfig.offset = srcStyle.textOffset)
      hasOwn(srcStyle, 'textRotation') && (textConfig.rotation = srcStyle.textRotation)
      hasOwn(srcStyle, 'textDistance') && (textConfig.distance = srcStyle.textDistance)
    }

    convertEC4CompatibleRichItem(textContentStyle, hostStyle)
    each(textContentStyle.rich, function (richItem) {
      convertEC4CompatibleRichItem(richItem, richItem)
    })
    return {
      textConfig: textConfig,
      textContent: textContent
    }
  }
  /**
     * The result will be set to `out`.
     */

  function convertEC4CompatibleRichItem (out, richItem) {
    if (!richItem) {
      return
    } // (1) For simplicity, make textXXX properties (deprecated since ec5) has
    // higher priority. For example, consider in ec4 `borderColor: 5, textBorderColor: 10`
    // on a rect means `borderColor: 4` on the rect and `borderColor: 10` on an attached
    // richText in ec5.
    // (2) `out === richItem` if and only if `out` is text el or rich item.
    // So we can overwite existing props in `out` since textXXX has higher priority.

    richItem.font = richItem.textFont || richItem.font
    hasOwn(richItem, 'textStrokeWidth') && (out.lineWidth = richItem.textStrokeWidth)
    hasOwn(richItem, 'textAlign') && (out.align = richItem.textAlign)
    hasOwn(richItem, 'textVerticalAlign') && (out.verticalAlign = richItem.textVerticalAlign)
    hasOwn(richItem, 'textLineHeight') && (out.lineHeight = richItem.textLineHeight)
    hasOwn(richItem, 'textWidth') && (out.width = richItem.textWidth)
    hasOwn(richItem, 'textHeight') && (out.height = richItem.textHeight)
    hasOwn(richItem, 'textBackgroundColor') && (out.backgroundColor = richItem.textBackgroundColor)
    hasOwn(richItem, 'textPadding') && (out.padding = richItem.textPadding)
    hasOwn(richItem, 'textBorderColor') && (out.borderColor = richItem.textBorderColor)
    hasOwn(richItem, 'textBorderWidth') && (out.borderWidth = richItem.textBorderWidth)
    hasOwn(richItem, 'textBorderRadius') && (out.borderRadius = richItem.textBorderRadius)
    hasOwn(richItem, 'textBoxShadowColor') && (out.shadowColor = richItem.textBoxShadowColor)
    hasOwn(richItem, 'textBoxShadowBlur') && (out.shadowBlur = richItem.textBoxShadowBlur)
    hasOwn(richItem, 'textBoxShadowOffsetX') && (out.shadowOffsetX = richItem.textBoxShadowOffsetX)
    hasOwn(richItem, 'textBoxShadowOffsetY') && (out.shadowOffsetY = richItem.textBoxShadowOffsetY)
  }
  /**
     * Convert to pure echarts4 format style.
     * `itemStyle` will be modified, added with ec4 style properties from
     * `textStyle` and `textConfig`.
     *
     * [Caveat]: For simplicity, `insideRollback` in ec4 does not compat, where
     * `styleEmphasis: {textFill: 'red'}` will remove the normal auto added stroke.
     */

  function convertToEC4StyleForCustomSerise (itemStl, txStl, txCfg) {
    const out = itemStl // See `custom.ts`, a trick to set extra `textPosition` firstly.

    out.textPosition = out.textPosition || txCfg.position || 'inside'
    txCfg.offset != null && (out.textOffset = txCfg.offset)
    txCfg.rotation != null && (out.textRotation = txCfg.rotation)
    txCfg.distance != null && (out.textDistance = txCfg.distance)
    const isInside = out.textPosition.indexOf('inside') >= 0
    const hostFill = itemStl.fill || '#000'
    convertToEC4RichItem(out, txStl)
    const textFillNotSet = out.textFill == null

    if (isInside) {
      if (textFillNotSet) {
        out.textFill = txCfg.insideFill || '#fff'
        !out.textStroke && txCfg.insideStroke && (out.textStroke = txCfg.insideStroke)
        !out.textStroke && (out.textStroke = hostFill)
        out.textStrokeWidth == null && (out.textStrokeWidth = 2)
      }
    } else {
      if (textFillNotSet) {
        out.textFill = itemStl.fill || txCfg.outsideFill || '#000'
      }

      !out.textStroke && txCfg.outsideStroke && (out.textStroke = txCfg.outsideStroke)
    }

    out.text = txStl.text
    out.rich = txStl.rich
    each(txStl.rich, function (richItem) {
      convertToEC4RichItem(richItem, richItem)
    })
    return out
  }

  function convertToEC4RichItem (out, richItem) {
    if (!richItem) {
      return
    }

    hasOwn(richItem, 'fill') && (out.textFill = richItem.fill)
    hasOwn(richItem, 'stroke') && (out.textStroke = richItem.fill)
    hasOwn(richItem, 'lineWidth') && (out.textStrokeWidth = richItem.lineWidth)
    hasOwn(richItem, 'font') && (out.font = richItem.font)
    hasOwn(richItem, 'fontStyle') && (out.fontStyle = richItem.fontStyle)
    hasOwn(richItem, 'fontWeight') && (out.fontWeight = richItem.fontWeight)
    hasOwn(richItem, 'fontSize') && (out.fontSize = richItem.fontSize)
    hasOwn(richItem, 'fontFamily') && (out.fontFamily = richItem.fontFamily)
    hasOwn(richItem, 'align') && (out.textAlign = richItem.align)
    hasOwn(richItem, 'verticalAlign') && (out.textVerticalAlign = richItem.verticalAlign)
    hasOwn(richItem, 'lineHeight') && (out.textLineHeight = richItem.lineHeight)
    hasOwn(richItem, 'width') && (out.textWidth = richItem.width)
    hasOwn(richItem, 'height') && (out.textHeight = richItem.height)
    hasOwn(richItem, 'backgroundColor') && (out.textBackgroundColor = richItem.backgroundColor)
    hasOwn(richItem, 'padding') && (out.textPadding = richItem.padding)
    hasOwn(richItem, 'borderColor') && (out.textBorderColor = richItem.borderColor)
    hasOwn(richItem, 'borderWidth') && (out.textBorderWidth = richItem.borderWidth)
    hasOwn(richItem, 'borderRadius') && (out.textBorderRadius = richItem.borderRadius)
    hasOwn(richItem, 'shadowColor') && (out.textBoxShadowColor = richItem.shadowColor)
    hasOwn(richItem, 'shadowBlur') && (out.textBoxShadowBlur = richItem.shadowBlur)
    hasOwn(richItem, 'shadowOffsetX') && (out.textBoxShadowOffsetX = richItem.shadowOffsetX)
    hasOwn(richItem, 'shadowOffsetY') && (out.textBoxShadowOffsetY = richItem.shadowOffsetY)
    hasOwn(richItem, 'textShadowColor') && (out.textShadowColor = richItem.textShadowColor)
    hasOwn(richItem, 'textShadowBlur') && (out.textShadowBlur = richItem.textShadowBlur)
    hasOwn(richItem, 'textShadowOffsetX') && (out.textShadowOffsetX = richItem.textShadowOffsetX)
    hasOwn(richItem, 'textShadowOffsetY') && (out.textShadowOffsetY = richItem.textShadowOffsetY)
  }

  function warnDeprecated (deprecated, insteadApproach) {
    if ('development' !== 'production') {
      const key = deprecated + '^_^' + insteadApproach

      if (!deprecatedLogs[key]) {
        console.warn('[ECharts] DEPRECATED: "' + deprecated + '" has been deprecated. ' + insteadApproach)
        deprecatedLogs[key] = true
      }
    }
  }

  const LEGACY_TRANSFORM_PROPS_MAP = {
    position: ['x', 'y'],
    scale: ['scaleX', 'scaleY'],
    origin: ['originX', 'originY']
  }
  const LEGACY_TRANSFORM_PROPS = keys(LEGACY_TRANSFORM_PROPS_MAP)
  const TRANSFORM_PROPS_MAP = reduce(TRANSFORMABLE_PROPS, function (obj, key) {
    obj[key] = 1
    return obj
  }, {})
  const transformPropNamesStr = TRANSFORMABLE_PROPS.join(', ') // '' means root

  const ELEMENT_ANIMATABLE_PROPS = ['', 'style', 'shape', 'extra']
  const transitionInnerStore = makeInner()

  function getElementAnimationConfig (animationType, el, elOption, parentModel, dataIndex) {
    const animationProp = animationType + 'Animation'
    const config = getAnimationConfig(animationType, parentModel, dataIndex) || {}
    const userDuring = transitionInnerStore(el).userDuring // Only set when duration is > 0 and it's need to be animated.

    if (config.duration > 0) {
      // For simplicity, if during not specified, the previous during will not work any more.
      config.during = userDuring
        ? bind(duringCall, {
          el: el,
          userDuring: userDuring
        })
        : null
      config.setToFinal = true
      config.scope = animationType
    }

    extend(config, elOption[animationProp])
    return config
  }

  function applyUpdateTransition (el, elOption, animatableModel, opts) {
    opts = opts || {}
    const dataIndex = opts.dataIndex
    const isInit = opts.isInit
    const clearStyle = opts.clearStyle
    const hasAnimation = animatableModel.isAnimationEnabled() // Save the meta info for further morphing. Like apply on the sub morphing elements.

    const store = transitionInnerStore(el)
    const styleOpt = elOption.style
    store.userDuring = elOption.during
    const transFromProps = {}
    const propsToSet = {}
    prepareTransformAllPropsFinal(el, elOption, propsToSet)
    prepareShapeOrExtraAllPropsFinal('shape', elOption, propsToSet)
    prepareShapeOrExtraAllPropsFinal('extra', elOption, propsToSet)

    if (!isInit && hasAnimation) {
      prepareTransformTransitionFrom(el, elOption, transFromProps)
      prepareShapeOrExtraTransitionFrom('shape', el, elOption, transFromProps)
      prepareShapeOrExtraTransitionFrom('extra', el, elOption, transFromProps)
      prepareStyleTransitionFrom(el, elOption, styleOpt, transFromProps)
    }

    propsToSet.style = styleOpt
    applyPropsDirectly(el, propsToSet, clearStyle)
    applyMiscProps(el, elOption)

    if (hasAnimation) {
      if (isInit) {
        const enterFromProps_1 = {}
        each(ELEMENT_ANIMATABLE_PROPS, function (propName) {
          const prop = propName ? elOption[propName] : elOption

          if (prop && prop.enterFrom) {
            if (propName) {
              enterFromProps_1[propName] = enterFromProps_1[propName] || {}
            }

            extend(propName ? enterFromProps_1[propName] : enterFromProps_1, prop.enterFrom)
          }
        })
        const config = getElementAnimationConfig('enter', el, elOption, animatableModel, dataIndex)

        if (config.duration > 0) {
          el.animateFrom(enterFromProps_1, config)
        }
      } else {
        applyPropsTransition(el, elOption, dataIndex || 0, animatableModel, transFromProps)
      }
    } // Store leave to be used in leave transition.

    updateLeaveTo(el, elOption)
    styleOpt ? el.dirty() : el.markRedraw()
  }
  function updateLeaveTo (el, elOption) {
    // Try merge to previous set leaveTo
    let leaveToProps = transitionInnerStore(el).leaveToProps

    for (let i = 0; i < ELEMENT_ANIMATABLE_PROPS.length; i++) {
      const propName = ELEMENT_ANIMATABLE_PROPS[i]
      const prop = propName ? elOption[propName] : elOption

      if (prop && prop.leaveTo) {
        if (!leaveToProps) {
          leaveToProps = transitionInnerStore(el).leaveToProps = {}
        }

        if (propName) {
          leaveToProps[propName] = leaveToProps[propName] || {}
        }

        extend(propName ? leaveToProps[propName] : leaveToProps, prop.leaveTo)
      }
    }
  }
  function applyLeaveTransition (el, elOption, animatableModel, onRemove) {
    if (el) {
      const parent_1 = el.parent
      const leaveToProps = transitionInnerStore(el).leaveToProps

      if (leaveToProps) {
        // TODO TODO use leave after leaveAnimation in series is introduced
        // TODO Data index?
        const config = getElementAnimationConfig('update', el, elOption, animatableModel, 0)

        config.done = function () {
          parent_1.remove(el)
          onRemove && onRemove()
        }

        el.animateTo(leaveToProps, config)
      } else {
        parent_1.remove(el)
        onRemove && onRemove()
      }
    }
  }
  function isTransitionAll (transition) {
    return transition === 'all'
  }

  function applyPropsDirectly (el, // Can be null/undefined
    allPropsFinal, clearStyle) {
    const styleOpt = allPropsFinal.style

    if (!el.isGroup && styleOpt) {
      if (clearStyle) {
        el.useStyle({}) // When style object changed, how to trade the existing animation?
        // It is probably complicated and not needed to cover all the cases.
        // But still need consider the case:
        // (1) When using init animation on `style.opacity`, and before the animation
        //     ended users triggers an update by mousewhel. At that time the init
        //     animation should better be continued rather than terminated.
        //     So after `useStyle` called, we should change the animation target manually
        //     to continue the effect of the init animation.
        // (2) PENDING: If the previous animation targeted at a `val1`, and currently we need
        //     to update the value to `val2` and no animation declared, should be terminate
        //     the previous animation or just modify the target of the animation?
        //     Therotically That will happen not only on `style` but also on `shape` and
        //     `transfrom` props. But we haven't handle this case at present yet.
        // (3) PENDING: Is it proper to visit `animators` and `targetName`?

        const animators = el.animators

        for (let i = 0; i < animators.length; i++) {
          const animator = animators[i] // targetName is the "topKey".

          if (animator.targetName === 'style') {
            animator.changeTarget(el.style)
          }
        }
      }

      el.setStyle(styleOpt)
    }

    if (allPropsFinal) {
      // Not set style here.
      allPropsFinal.style = null // Set el to the final state firstly.

      allPropsFinal && el.attr(allPropsFinal)
      allPropsFinal.style = styleOpt
    }
  }

  function applyPropsTransition (el, elOption, dataIndex, model, // Can be null/undefined
    transFromProps) {
    if (transFromProps) {
      const config = getElementAnimationConfig('update', el, elOption, model, dataIndex)

      if (config.duration > 0) {
        el.animateFrom(transFromProps, config)
      }
    }
  }

  function applyMiscProps (el, elOption) {
    // Merge by default.
    hasOwn(elOption, 'silent') && (el.silent = elOption.silent)
    hasOwn(elOption, 'ignore') && (el.ignore = elOption.ignore)

    if (el instanceof Displayable) {
      hasOwn(elOption, 'invisible') && (el.invisible = elOption.invisible)
    }

    if (el instanceof Path) {
      hasOwn(elOption, 'autoBatch') && (el.autoBatch = elOption.autoBatch)
    }
  } // Use it to avoid it be exposed to user.

  const tmpDuringScope = {}
  const transitionDuringAPI = {
    // Usually other props do not need to be changed in animation during.
    setTransform: function (key, val) {
      if ('development' !== 'production') {
        assert(hasOwn(TRANSFORM_PROPS_MAP, key), 'Only ' + transformPropNamesStr + ' available in `setTransform`.')
      }

      tmpDuringScope.el[key] = val
      return this
    },
    getTransform: function (key) {
      if ('development' !== 'production') {
        assert(hasOwn(TRANSFORM_PROPS_MAP, key), 'Only ' + transformPropNamesStr + ' available in `getTransform`.')
      }

      return tmpDuringScope.el[key]
    },
    setShape: function (key, val) {
      if ('development' !== 'production') {
        assertNotReserved(key)
      }

      const el = tmpDuringScope.el
      const shape = el.shape || (el.shape = {})
      shape[key] = val
      el.dirtyShape && el.dirtyShape()
      return this
    },
    getShape: function (key) {
      if ('development' !== 'production') {
        assertNotReserved(key)
      }

      const shape = tmpDuringScope.el.shape

      if (shape) {
        return shape[key]
      }
    },
    setStyle: function (key, val) {
      if ('development' !== 'production') {
        assertNotReserved(key)
      }

      const el = tmpDuringScope.el
      const style = el.style

      if (style) {
        if ('development' !== 'production') {
          if (eqNaN(val)) {
            warn('style.' + key + ' must not be assigned with NaN.')
          }
        }

        style[key] = val
        el.dirtyStyle && el.dirtyStyle()
      }

      return this
    },
    getStyle: function (key) {
      if ('development' !== 'production') {
        assertNotReserved(key)
      }

      const style = tmpDuringScope.el.style

      if (style) {
        return style[key]
      }
    },
    setExtra: function (key, val) {
      if ('development' !== 'production') {
        assertNotReserved(key)
      }

      const extra = tmpDuringScope.el.extra || (tmpDuringScope.el.extra = {})
      extra[key] = val
      return this
    },
    getExtra: function (key) {
      if ('development' !== 'production') {
        assertNotReserved(key)
      }

      const extra = tmpDuringScope.el.extra

      if (extra) {
        return extra[key]
      }
    }
  }

  function assertNotReserved (key) {
    if ('development' !== 'production') {
      if (key === 'transition' || key === 'enterFrom' || key === 'leaveTo') {
        throw new Error('key must not be "' + key + '"')
      }
    }
  }

  function duringCall () {
    // Do not provide "percent" until some requirements come.
    // Because consider thies case:
    // enterFrom: {x: 100, y: 30}, transition: 'x'.
    // And enter duration is different from update duration.
    // Thus it might be confused about the meaning of "percent" in during callback.
    const scope = this
    const el = scope.el

    if (!el) {
      return
    } // If el is remove from zr by reason like legend, during still need to called,
    // becuase el will be added back to zr and the prop value should not be incorrect.

    const latestUserDuring = transitionInnerStore(el).userDuring
    const scopeUserDuring = scope.userDuring // Ensured a during is only called once in each animation frame.
    // If a during is called multiple times in one frame, maybe some users' calulation logic
    // might be wrong (not sure whether this usage exists).
    // The case of a during might be called twice can be: by default there is a animator for
    // 'x', 'y' when init. Before the init animation finished, call `setOption` to start
    // another animators for 'style'/'shape'/'extra'.

    if (latestUserDuring !== scopeUserDuring) {
      // release
      scope.el = scope.userDuring = null
      return
    }

    tmpDuringScope.el = el // Give no `this` to user in "during" calling.

    scopeUserDuring(transitionDuringAPI) // FIXME: if in future meet the case that some prop will be both modified in `during` and `state`,
    // consider the issue that the prop might be incorrect when return to "normal" state.
  }

  function prepareShapeOrExtraTransitionFrom (mainAttr, fromEl, elOption, transFromProps) {
    const attrOpt = elOption[mainAttr]

    if (!attrOpt) {
      return
    }

    const elPropsInAttr = fromEl[mainAttr]
    let transFromPropsInAttr

    if (elPropsInAttr) {
      const transition = elOption.transition
      const attrTransition = attrOpt.transition

      if (attrTransition) {
        !transFromPropsInAttr && (transFromPropsInAttr = transFromProps[mainAttr] = {})

        if (isTransitionAll(attrTransition)) {
          extend(transFromPropsInAttr, elPropsInAttr)
        } else {
          const transitionKeys = normalizeToArray(attrTransition)

          for (var i = 0; i < transitionKeys.length; i++) {
            var key = transitionKeys[i]
            var elVal = elPropsInAttr[key]
            transFromPropsInAttr[key] = elVal
          }
        }
      } else if (isTransitionAll(transition) || indexOf(transition, mainAttr) >= 0) {
        !transFromPropsInAttr && (transFromPropsInAttr = transFromProps[mainAttr] = {})
        const elPropsInAttrKeys = keys(elPropsInAttr)

        for (var i = 0; i < elPropsInAttrKeys.length; i++) {
          var key = elPropsInAttrKeys[i]
          var elVal = elPropsInAttr[key]

          if (isNonStyleTransitionEnabled(attrOpt[key], elVal)) {
            transFromPropsInAttr[key] = elVal
          }
        }
      }
    }
  }

  function prepareShapeOrExtraAllPropsFinal (mainAttr, elOption, allProps) {
    const attrOpt = elOption[mainAttr]

    if (!attrOpt) {
      return
    }

    const allPropsInAttr = allProps[mainAttr] = {}
    const keysInAttr = keys(attrOpt)

    for (let i = 0; i < keysInAttr.length; i++) {
      const key = keysInAttr[i] // To avoid share one object with different element, and
      // to avoid user modify the object inexpectedly, have to clone.

      allPropsInAttr[key] = cloneValue(attrOpt[key])
    }
  }

  function prepareTransformTransitionFrom (el, elOption, transFromProps) {
    const transition = elOption.transition
    const transitionKeys = isTransitionAll(transition) ? TRANSFORMABLE_PROPS : normalizeToArray(transition || [])

    for (let i = 0; i < transitionKeys.length; i++) {
      const key = transitionKeys[i]

      if (key === 'style' || key === 'shape' || key === 'extra') {
        continue
      }

      const elVal = el[key]

      if ('development' !== 'production') {
        checkTransformPropRefer(key, 'el.transition')
      } // Do not clone, animator will perform that clone.

      transFromProps[key] = elVal
    }
  }

  function prepareTransformAllPropsFinal (el, elOption, allProps) {
    for (var i = 0; i < LEGACY_TRANSFORM_PROPS.length; i++) {
      const legacyName = LEGACY_TRANSFORM_PROPS[i]
      const xyName = LEGACY_TRANSFORM_PROPS_MAP[legacyName]
      const legacyArr = elOption[legacyName]

      if (legacyArr) {
        allProps[xyName[0]] = legacyArr[0]
        allProps[xyName[1]] = legacyArr[1]
      }
    }

    for (var i = 0; i < TRANSFORMABLE_PROPS.length; i++) {
      const key = TRANSFORMABLE_PROPS[i]

      if (elOption[key] != null) {
        allProps[key] = elOption[key]
      }
    }
  }

  function prepareStyleTransitionFrom (fromEl, elOption, styleOpt, transFromProps) {
    if (!styleOpt) {
      return
    }

    const fromElStyle = fromEl.style
    let transFromStyleProps

    if (fromElStyle) {
      const styleTransition = styleOpt.transition
      const elTransition = elOption.transition

      if (styleTransition && !isTransitionAll(styleTransition)) {
        const transitionKeys = normalizeToArray(styleTransition)
        !transFromStyleProps && (transFromStyleProps = transFromProps.style = {})

        for (var i = 0; i < transitionKeys.length; i++) {
          var key = transitionKeys[i]
          var elVal = fromElStyle[key] // Do not clone, see `checkNonStyleTansitionRefer`.

          transFromStyleProps[key] = elVal
        }
      } else if (fromEl.getAnimationStyleProps && (isTransitionAll(elTransition) || isTransitionAll(styleTransition) || indexOf(elTransition, 'style') >= 0)) {
        const animationProps = fromEl.getAnimationStyleProps()
        const animationStyleProps = animationProps ? animationProps.style : null

        if (animationStyleProps) {
          !transFromStyleProps && (transFromStyleProps = transFromProps.style = {})
          const styleKeys = keys(styleOpt)

          for (var i = 0; i < styleKeys.length; i++) {
            var key = styleKeys[i]

            if (animationStyleProps[key]) {
              var elVal = fromElStyle[key]
              transFromStyleProps[key] = elVal
            }
          }
        }
      }
    }
  }

  function isNonStyleTransitionEnabled (optVal, elVal) {
    // The same as `checkNonStyleTansitionRefer`.
    return !isArrayLike(optVal) ? optVal != null && isFinite(optVal) : optVal !== elVal
  }

  let checkTransformPropRefer

  if ('development' !== 'production') {
    checkTransformPropRefer = function (key, usedIn) {
      if (!hasOwn(TRANSFORM_PROPS_MAP, key)) {
        warn('Prop `' + key + '` is not a permitted in `' + usedIn + '`. ' + 'Only `' + keys(TRANSFORM_PROPS_MAP).join('`, `') + '` are permitted.')
      }
    }
  }

  const getStateToRestore = makeInner()
  const KEYFRAME_EXCLUDE_KEYS = ['percent', 'easing', 'shape', 'style', 'extra']
  /**
     * Stop previous keyframe animation and restore the attributes.
     * Avoid new keyframe animation starts with wrong internal state when the percent: 0 is not set.
     */

  function stopPreviousKeyframeAnimationAndRestore (el) {
    // Stop previous keyframe animation.
    el.stopAnimation('keyframe') // Restore

    el.attr(getStateToRestore(el))
  }
  function applyKeyframeAnimation (el, animationOpts, animatableModel) {
    if (!animatableModel.isAnimationEnabled() || !animationOpts) {
      return
    }

    if (isArray(animationOpts)) {
      each(animationOpts, function (singleAnimationOpts) {
        applyKeyframeAnimation(el, singleAnimationOpts, animatableModel)
      })
      return
    }

    const keyframes = animationOpts.keyframes
    let duration = animationOpts.duration

    if (animatableModel && duration == null) {
      // Default to use duration of config.
      // NOTE: animation config from payload will be ignored because they are mainly for transitions.
      const config = getAnimationConfig('enter', animatableModel, 0)
      duration = config && config.duration
    }

    if (!keyframes || !duration) {
      return
    }

    const stateToRestore = getStateToRestore(el)
    each(ELEMENT_ANIMATABLE_PROPS, function (targetPropName) {
      if (targetPropName && !el[targetPropName]) {
        return
      }

      let animator
      let endFrameIsSet = false // Sort keyframes by percent.

      keyframes.sort(function (a, b) {
        return a.percent - b.percent
      })
      each(keyframes, function (kf) {
        // Stop current animation.
        const animators = el.animators
        const kfValues = targetPropName ? kf[targetPropName] : kf

        if ('development' !== 'production') {
          if (kf.percent >= 1) {
            endFrameIsSet = true
          }
        }

        if (!kfValues) {
          return
        }

        let propKeys = keys(kfValues)

        if (!targetPropName) {
          // PENDING performance?
          propKeys = filter(propKeys, function (key) {
            return indexOf(KEYFRAME_EXCLUDE_KEYS, key) < 0
          })
        }

        if (!propKeys.length) {
          return
        }

        if (!animator) {
          animator = el.animate(targetPropName, animationOpts.loop, true)
          animator.scope = 'keyframe'
        }

        for (let i = 0; i < animators.length; i++) {
          // Stop all other animation that is not keyframe.
          if (animators[i] !== animator && animators[i].targetName === animator.targetName) {
            animators[i].stopTracks(propKeys)
          }
        }

        targetPropName && (stateToRestore[targetPropName] = stateToRestore[targetPropName] || {})
        const savedTarget = targetPropName ? stateToRestore[targetPropName] : stateToRestore
        each(propKeys, function (key) {
          // Save original value.
          savedTarget[key] = ((targetPropName ? el[targetPropName] : el) || {})[key]
        })
        animator.whenWithKeys(duration * kf.percent, kfValues, propKeys, kf.easing)
      })

      if (!animator) {
        return
      }

      if ('development' !== 'production') {
        if (!endFrameIsSet) {
          warn('End frame with percent: 1 is missing in the keyframeAnimation.', true)
        }
      }

      animator.delay(animationOpts.delay || 0).duration(duration).start(animationOpts.easing)
    })
  }

  const EMPHASIS = 'emphasis'
  const NORMAL = 'normal'
  const BLUR = 'blur'
  const SELECT = 'select'
  const STATES = [NORMAL, EMPHASIS, BLUR, SELECT]
  const PATH_ITEM_STYLE = {
    normal: ['itemStyle'],
    emphasis: [EMPHASIS, 'itemStyle'],
    blur: [BLUR, 'itemStyle'],
    select: [SELECT, 'itemStyle']
  }
  const PATH_LABEL = {
    normal: ['label'],
    emphasis: [EMPHASIS, 'label'],
    blur: [BLUR, 'label'],
    select: [SELECT, 'label']
  }
  const DEFAULT_TRANSITION = ['x', 'y'] // Use prefix to avoid index to be the same as el.name,
  // which will cause weird update animation.

  const GROUP_DIFF_PREFIX = 'e\0\0'
  const attachedTxInfoTmp = {
    normal: {},
    emphasis: {},
    blur: {},
    select: {}
  }
  /**
     * To reduce total package size of each coordinate systems, the modules `prepareCustom`
     * of each coordinate systems are not required by each coordinate systems directly, but
     * required by the module `custom`.
     *
     * prepareInfoForCustomSeries {Function}: optional
     *     @return {Object} {coordSys: {...}, api: {
     *         coord: function (data, clamp) {}, // return point in global.
     *         size: function (dataSize, dataItem) {} // return size of each axis in coordSys.
     *     }}
     */

  const prepareCustoms = {
    cartesian2d: cartesianPrepareCustom,
    geo: geoPrepareCustom,
    single: singlePrepareCustom,
    polar: polarPrepareCustom,
    calendar: calendarPrepareCustom
  }

  function isPath$1 (el) {
    return el instanceof Path
  }

  function isDisplayable (el) {
    return el instanceof Displayable
  }

  function copyElement (sourceEl, targetEl) {
    targetEl.copyTransform(sourceEl)

    if (isDisplayable(targetEl) && isDisplayable(sourceEl)) {
      targetEl.setStyle(sourceEl.style)
      targetEl.z = sourceEl.z
      targetEl.z2 = sourceEl.z2
      targetEl.zlevel = sourceEl.zlevel
      targetEl.invisible = sourceEl.invisible
      targetEl.ignore = sourceEl.ignore

      if (isPath$1(targetEl) && isPath$1(sourceEl)) {
        targetEl.setShape(sourceEl.shape)
      }
    }
  }

  const CustomChartView =
    /** @class */
    (function (_super) {
      __extends(CustomChartView, _super)

      function CustomChartView () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = CustomChartView.type
        return _this
      }

      CustomChartView.prototype.render = function (customSeries, ecModel, api, payload) {
        // Clear previously rendered progressive elements.
        this._progressiveEls = null
        const oldData = this._data
        const data = customSeries.getData()
        const group = this.group
        const renderItem = makeRenderItem(customSeries, data, ecModel, api)

        if (!oldData) {
          // Previous render is incremental render or first render.
          // Needs remove the incremental rendered elements.
          group.removeAll()
        }

        data.diff(oldData).add(function (newIdx) {
          createOrUpdateItem(api, null, newIdx, renderItem(newIdx, payload), customSeries, group, data)
        }).remove(function (oldIdx) {
          const el = oldData.getItemGraphicEl(oldIdx)
          applyLeaveTransition(el, customInnerStore(el).option, customSeries)
        }).update(function (newIdx, oldIdx) {
          const oldEl = oldData.getItemGraphicEl(oldIdx)
          createOrUpdateItem(api, oldEl, newIdx, renderItem(newIdx, payload), customSeries, group, data)
        }).execute() // Do clipping

        const clipPath = customSeries.get('clip', true) ? createClipPath(customSeries.coordinateSystem, false, customSeries) : null

        if (clipPath) {
          group.setClipPath(clipPath)
        } else {
          group.removeClipPath()
        }

        this._data = data
      }

      CustomChartView.prototype.incrementalPrepareRender = function (customSeries, ecModel, api) {
        this.group.removeAll()
        this._data = null
      }

      CustomChartView.prototype.incrementalRender = function (params, customSeries, ecModel, api, payload) {
        const data = customSeries.getData()
        const renderItem = makeRenderItem(customSeries, data, ecModel, api)
        const progressiveEls = this._progressiveEls = []

        function setIncrementalAndHoverLayer (el) {
          if (!el.isGroup) {
            el.incremental = true
            el.ensureState('emphasis').hoverLayer = true
          }
        }

        for (let idx = params.start; idx < params.end; idx++) {
          const el = createOrUpdateItem(null, null, idx, renderItem(idx, payload), customSeries, this.group, data)

          if (el) {
            el.traverse(setIncrementalAndHoverLayer)
            progressiveEls.push(el)
          }
        }
      }

      CustomChartView.prototype.eachRendered = function (cb) {
        traverseElements(this._progressiveEls || this.group, cb)
      }

      CustomChartView.prototype.filterForExposedEvent = function (eventType, query, targetEl, packedEvent) {
        const elementName = query.element

        if (elementName == null || targetEl.name === elementName) {
          return true
        } // Enable to give a name on a group made by `renderItem`, and listen
        // events that triggerd by its descendents.

        while ((targetEl = targetEl.__hostTarget || targetEl.parent) && targetEl !== this.group) {
          if (targetEl.name === elementName) {
            return true
          }
        }

        return false
      }

      CustomChartView.type = 'custom'
      return CustomChartView
    }(ChartView))

  function createEl (elOption) {
    const graphicType = elOption.type
    let el // Those graphic elements are not shapes. They should not be
    // overwritten by users, so do them first.

    if (graphicType === 'path') {
      const shape = elOption.shape // Using pathRect brings convenience to users sacle svg path.

      const pathRect = shape.width != null && shape.height != null
        ? {
            x: shape.x || 0,
            y: shape.y || 0,
            width: shape.width,
            height: shape.height
          }
        : null
      const pathData = getPathData(shape) // Path is also used for icon, so layout 'center' by default.

      el = makePath(pathData, null, pathRect, shape.layout || 'center')
      customInnerStore(el).customPathData = pathData
    } else if (graphicType === 'image') {
      el = new ZRImage({})
      customInnerStore(el).customImagePath = elOption.style.image
    } else if (graphicType === 'text') {
      el = new ZRText({}) // customInnerStore(el).customText = (elOption.style as TextStyleProps).text;
    } else if (graphicType === 'group') {
      el = new Group()
    } else if (graphicType === 'compoundPath') {
      throw new Error('"compoundPath" is not supported yet.')
    } else {
      const Clz = getShapeClass(graphicType)

      if (!Clz) {
        let errMsg = ''

        if ('development' !== 'production') {
          errMsg = 'graphic type "' + graphicType + '" can not be found.'
        }

        throwError(errMsg)
      }

      el = new Clz()
    }

    customInnerStore(el).customGraphicType = graphicType
    el.name = elOption.name // Compat ec4: the default z2 lift is 1. If changing the number,
    // some cases probably be broken: hierarchy layout along z, like circle packing,
    // where emphasis only intending to modify color/border rather than lift z2.

    el.z2EmphasisLift = 1
    el.z2SelectLift = 1
    return el
  }

  function updateElNormal ( // Can be null/undefined
    api, el, dataIndex, elOption, attachedTxInfo, seriesModel, isInit) {
    // Stop and restore before update any other attributes.
    stopPreviousKeyframeAnimationAndRestore(el)
    const txCfgOpt = attachedTxInfo && attachedTxInfo.normal.cfg

    if (txCfgOpt) {
      // PENDING: whether use user object directly rather than clone?
      // TODO:5.0 textConfig transition animation?
      el.setTextConfig(txCfgOpt)
    } // Default transition ['x', 'y']

    if (elOption && elOption.transition == null) {
      elOption.transition = DEFAULT_TRANSITION
    } // Do some normalization on style.

    const styleOpt = elOption && elOption.style

    if (styleOpt) {
      if (el.type === 'text') {
        const textOptionStyle = styleOpt // Compatible with ec4: if `textFill` or `textStroke` exists use them.

        hasOwn(textOptionStyle, 'textFill') && (textOptionStyle.fill = textOptionStyle.textFill)
        hasOwn(textOptionStyle, 'textStroke') && (textOptionStyle.stroke = textOptionStyle.textStroke)
      }

      var decalPattern = void 0
      const decalObj = isPath$1(el) ? styleOpt.decal : null

      if (api && decalObj) {
        decalObj.dirty = true
        decalPattern = createOrUpdatePatternFromDecal(decalObj, api)
      } // Always overwrite in case user specify this prop.

      styleOpt.__decalPattern = decalPattern
    }

    if (isDisplayable(el)) {
      if (styleOpt) {
        var decalPattern = styleOpt.__decalPattern

        if (decalPattern) {
          styleOpt.decal = decalPattern
        }
      }
    }

    applyUpdateTransition(el, elOption, seriesModel, {
      dataIndex: dataIndex,
      isInit: isInit,
      clearStyle: true
    })
    applyKeyframeAnimation(el, elOption.keyframeAnimation, seriesModel)
  }

  function updateElOnState (state, el, elStateOpt, styleOpt, attachedTxInfo) {
    const elDisplayable = el.isGroup ? null : el
    const txCfgOpt = attachedTxInfo && attachedTxInfo[state].cfg // PENDING:5.0 support customize scale change and transition animation?

    if (elDisplayable) {
      // By default support auto lift color when hover whether `emphasis` specified.
      const stateObj = elDisplayable.ensureState(state)

      if (styleOpt === false) {
        const existingEmphasisState = elDisplayable.getState(state)

        if (existingEmphasisState) {
          existingEmphasisState.style = null
        }
      } else {
        // style is needed to enable defaut emphasis.
        stateObj.style = styleOpt || null
      } // If `elOption.styleEmphasis` or `elOption.emphasis.style` is `false`,
      // remove hover style.
      // If `elOption.textConfig` or `elOption.emphasis.textConfig` is null/undefined, it does not
      // make sense. So for simplicity, we do not ditinguish `hasOwnProperty` and null/undefined.

      if (txCfgOpt) {
        stateObj.textConfig = txCfgOpt
      }

      setDefaultStateProxy(elDisplayable)
    }
  }

  function updateZ$1 (el, elOption, seriesModel) {
    // Group not support textContent and not support z yet.
    if (el.isGroup) {
      return
    }

    const elDisplayable = el
    const currentZ = seriesModel.currentZ
    const currentZLevel = seriesModel.currentZLevel // Always erase.

    elDisplayable.z = currentZ
    elDisplayable.zlevel = currentZLevel // z2 must not be null/undefined, otherwise sort error may occur.

    const optZ2 = elOption.z2
    optZ2 != null && (elDisplayable.z2 = optZ2 || 0)

    for (let i = 0; i < STATES.length; i++) {
      updateZForEachState(elDisplayable, elOption, STATES[i])
    }
  }

  function updateZForEachState (elDisplayable, elOption, state) {
    const isNormal = state === NORMAL
    const elStateOpt = isNormal ? elOption : retrieveStateOption(elOption, state)
    const optZ2 = elStateOpt ? elStateOpt.z2 : null
    let stateObj

    if (optZ2 != null) {
      // Do not `ensureState` until required.
      stateObj = isNormal ? elDisplayable : elDisplayable.ensureState(state)
      stateObj.z2 = optZ2 || 0
    }
  }

  function makeRenderItem (customSeries, data, ecModel, api) {
    const renderItem = customSeries.get('renderItem')
    const coordSys = customSeries.coordinateSystem
    let prepareResult = {}

    if (coordSys) {
      if ('development' !== 'production') {
        assert(renderItem, 'series.render is required.')
        assert(coordSys.prepareCustoms || prepareCustoms[coordSys.type], 'This coordSys does not support custom series.')
      } // `coordSys.prepareCustoms` is used for external coord sys like bmap.

      prepareResult = coordSys.prepareCustoms ? coordSys.prepareCustoms(coordSys) : prepareCustoms[coordSys.type](coordSys)
    }

    const userAPI = defaults({
      getWidth: api.getWidth,
      getHeight: api.getHeight,
      getZr: api.getZr,
      getDevicePixelRatio: api.getDevicePixelRatio,
      value: value,
      style: style,
      ordinalRawValue: ordinalRawValue,
      styleEmphasis: styleEmphasis,
      visual: visual,
      barLayout: barLayout,
      currentSeriesIndices: currentSeriesIndices,
      font: font
    }, prepareResult.api || {})
    const userParams = {
      // The life cycle of context: current round of rendering.
      // The global life cycle is probably not necessary, because
      // user can store global status by themselves.
      context: {},
      seriesId: customSeries.id,
      seriesName: customSeries.name,
      seriesIndex: customSeries.seriesIndex,
      coordSys: prepareResult.coordSys,
      dataInsideLength: data.count(),
      encode: wrapEncodeDef(customSeries.getData())
    } // If someday intending to refactor them to a class, should consider do not
    // break change: currently these attribute member are encapsulated in a closure
    // so that do not need to force user to call these method with a scope.
    // Do not support call `api` asynchronously without dataIndexInside input.

    let currDataIndexInside
    let currItemModel
    let currItemStyleModels = {}
    let currLabelModels = {}
    const seriesItemStyleModels = {}
    const seriesLabelModels = {}

    for (let i = 0; i < STATES.length; i++) {
      const stateName = STATES[i]
      seriesItemStyleModels[stateName] = customSeries.getModel(PATH_ITEM_STYLE[stateName])
      seriesLabelModels[stateName] = customSeries.getModel(PATH_LABEL[stateName])
    }

    function getItemModel (dataIndexInside) {
      return dataIndexInside === currDataIndexInside ? currItemModel || (currItemModel = data.getItemModel(dataIndexInside)) : data.getItemModel(dataIndexInside)
    }

    function getItemStyleModel (dataIndexInside, state) {
      return !data.hasItemOption ? seriesItemStyleModels[state] : dataIndexInside === currDataIndexInside ? currItemStyleModels[state] || (currItemStyleModels[state] = getItemModel(dataIndexInside).getModel(PATH_ITEM_STYLE[state])) : getItemModel(dataIndexInside).getModel(PATH_ITEM_STYLE[state])
    }

    function getLabelModel (dataIndexInside, state) {
      return !data.hasItemOption ? seriesLabelModels[state] : dataIndexInside === currDataIndexInside ? currLabelModels[state] || (currLabelModels[state] = getItemModel(dataIndexInside).getModel(PATH_LABEL[state])) : getItemModel(dataIndexInside).getModel(PATH_LABEL[state])
    }

    return function (dataIndexInside, payload) {
      currDataIndexInside = dataIndexInside
      currItemModel = null
      currItemStyleModels = {}
      currLabelModels = {}
      return renderItem && renderItem(defaults({
        dataIndexInside: dataIndexInside,
        dataIndex: data.getRawIndex(dataIndexInside),
        // Can be used for optimization when zoom or roam.
        actionType: payload ? payload.type : null
      }, userParams), userAPI)
    }
    /**
       * @public
       * @param dim by default 0.
       * @param dataIndexInside by default `currDataIndexInside`.
       */

    function value (dim, dataIndexInside) {
      dataIndexInside == null && (dataIndexInside = currDataIndexInside)
      return data.getStore().get(data.getDimensionIndex(dim || 0), dataIndexInside)
    }
    /**
       * @public
       * @param dim by default 0.
       * @param dataIndexInside by default `currDataIndexInside`.
       */

    function ordinalRawValue (dim, dataIndexInside) {
      dataIndexInside == null && (dataIndexInside = currDataIndexInside)
      dim = dim || 0
      const dimInfo = data.getDimensionInfo(dim)

      if (!dimInfo) {
        const dimIndex = data.getDimensionIndex(dim)
        return dimIndex >= 0 ? data.getStore().get(dimIndex, dataIndexInside) : undefined
      }

      const val = data.get(dimInfo.name, dataIndexInside)
      const ordinalMeta = dimInfo && dimInfo.ordinalMeta
      return ordinalMeta ? ordinalMeta.categories[val] : val
    }
    /**
       * @deprecated The orgininal intention of `api.style` is enable to set itemStyle
       * like other series. But it not necessary and not easy to give a strict definition
       * of what it return. And since echarts5 it needs to be make compat work. So
       * deprecates it since echarts5.
       *
       * By default, `visual` is applied to style (to support visualMap).
       * `visual.color` is applied at `fill`. If user want apply visual.color on `stroke`,
       * it can be implemented as:
       * `api.style({stroke: api.visual('color'), fill: null})`;
       *
       * [Compat]: since ec5, RectText has been separated from its hosts el.
       * so `api.style()` will only return the style from `itemStyle` but not handle `label`
       * any more. But `series.label` config is never published in doc.
       * We still compat it in `api.style()`. But not encourage to use it and will still not
       * to pulish it to doc.
       * @public
       * @param dataIndexInside by default `currDataIndexInside`.
       */

    function style (userProps, dataIndexInside) {
      if ('development' !== 'production') {
        warnDeprecated('api.style', 'Please write literal style directly instead.')
      }

      dataIndexInside == null && (dataIndexInside = currDataIndexInside)
      const style = data.getItemVisual(dataIndexInside, 'style')
      const visualColor = style && style.fill
      const opacity = style && style.opacity
      let itemStyle = getItemStyleModel(dataIndexInside, NORMAL).getItemStyle()
      visualColor != null && (itemStyle.fill = visualColor)
      opacity != null && (itemStyle.opacity = opacity)
      const opt = {
        inheritColor: isString(visualColor) ? visualColor : '#000'
      }
      const labelModel = getLabelModel(dataIndexInside, NORMAL) // Now that the feture of "auto adjust text fill/stroke" has been migrated to zrender
      // since ec5, we should set `isAttached` as `false` here and make compat in
      // `convertToEC4StyleForCustomSerise`.

      const textStyle = createTextStyle(labelModel, null, opt, false, true)
      textStyle.text = labelModel.getShallow('show') ? retrieve2(customSeries.getFormattedLabel(dataIndexInside, NORMAL), getDefaultLabel(data, dataIndexInside)) : null
      const textConfig = createTextConfig(labelModel, opt, false)
      preFetchFromExtra(userProps, itemStyle)
      itemStyle = convertToEC4StyleForCustomSerise(itemStyle, textStyle, textConfig)
      userProps && applyUserPropsAfter(itemStyle, userProps)
      itemStyle.legacy = true
      return itemStyle
    }
    /**
       * @deprecated The reason see `api.style()`
       * @public
       * @param dataIndexInside by default `currDataIndexInside`.
       */

    function styleEmphasis (userProps, dataIndexInside) {
      if ('development' !== 'production') {
        warnDeprecated('api.styleEmphasis', 'Please write literal style directly instead.')
      }

      dataIndexInside == null && (dataIndexInside = currDataIndexInside)
      let itemStyle = getItemStyleModel(dataIndexInside, EMPHASIS).getItemStyle()
      const labelModel = getLabelModel(dataIndexInside, EMPHASIS)
      const textStyle = createTextStyle(labelModel, null, null, true, true)
      textStyle.text = labelModel.getShallow('show') ? retrieve3(customSeries.getFormattedLabel(dataIndexInside, EMPHASIS), customSeries.getFormattedLabel(dataIndexInside, NORMAL), getDefaultLabel(data, dataIndexInside)) : null
      const textConfig = createTextConfig(labelModel, null, true)
      preFetchFromExtra(userProps, itemStyle)
      itemStyle = convertToEC4StyleForCustomSerise(itemStyle, textStyle, textConfig)
      userProps && applyUserPropsAfter(itemStyle, userProps)
      itemStyle.legacy = true
      return itemStyle
    }

    function applyUserPropsAfter (itemStyle, extra) {
      for (const key in extra) {
        if (hasOwn(extra, key)) {
          itemStyle[key] = extra[key]
        }
      }
    }

    function preFetchFromExtra (extra, itemStyle) {
      // A trick to retrieve those props firstly, which are used to
      // apply auto inside fill/stroke in `convertToEC4StyleForCustomSerise`.
      // (It's not reasonable but only for a degree of compat)
      if (extra) {
        extra.textFill && (itemStyle.textFill = extra.textFill)
        extra.textPosition && (itemStyle.textPosition = extra.textPosition)
      }
    }
    /**
       * @public
       * @param dataIndexInside by default `currDataIndexInside`.
       */

    function visual (visualType, dataIndexInside) {
      dataIndexInside == null && (dataIndexInside = currDataIndexInside)

      if (hasOwn(STYLE_VISUAL_TYPE, visualType)) {
        const style_1 = data.getItemVisual(dataIndexInside, 'style')
        return style_1 ? style_1[STYLE_VISUAL_TYPE[visualType]] : null
      } // Only support these visuals. Other visual might be inner tricky
      // for performance (like `style`), do not expose to users.

      if (hasOwn(NON_STYLE_VISUAL_PROPS, visualType)) {
        return data.getItemVisual(dataIndexInside, visualType)
      }
    }
    /**
       * @public
       * @return If not support, return undefined.
       */

    function barLayout (opt) {
      if (coordSys.type === 'cartesian2d') {
        const baseAxis = coordSys.getBaseAxis()
        return getLayoutOnAxis(defaults({
          axis: baseAxis
        }, opt))
      }
    }
    /**
       * @public
       */

    function currentSeriesIndices () {
      return ecModel.getCurrentSeriesIndices()
    }
    /**
       * @public
       * @return font string
       */

    function font (opt) {
      return getFont(opt, ecModel)
    }
  }

  function wrapEncodeDef (data) {
    const encodeDef = {}
    each(data.dimensions, function (dimName) {
      const dimInfo = data.getDimensionInfo(dimName)

      if (!dimInfo.isExtraCoord) {
        const coordDim = dimInfo.coordDim
        const dataDims = encodeDef[coordDim] = encodeDef[coordDim] || []
        dataDims[dimInfo.coordDimIndex] = data.getDimensionIndex(dimName)
      }
    })
    return encodeDef
  }

  function createOrUpdateItem (api, existsEl, dataIndex, elOption, seriesModel, group, data) {
    // [Rule]
    // If `renderItem` returns `null`/`undefined`/`false`, remove the previous el if existing.
    //     (It seems that violate the "merge" principle, but most of users probably intuitively
    //     regard "return;" as "show nothing element whatever", so make a exception to meet the
    //     most cases.)
    // The rule or "merge" see [STRATEGY_MERGE].
    // If `elOption` is `null`/`undefined`/`false` (when `renderItem` returns nothing).
    if (!elOption) {
      group.remove(existsEl)
      return
    }

    const el = doCreateOrUpdateEl(api, existsEl, dataIndex, elOption, seriesModel, group)
    el && data.setItemGraphicEl(dataIndex, el)
    el && toggleHoverEmphasis(el, elOption.focus, elOption.blurScope, elOption.emphasisDisabled)
    return el
  }

  function doCreateOrUpdateEl (api, existsEl, dataIndex, elOption, seriesModel, group) {
    if ('development' !== 'production') {
      assert(elOption, 'should not have an null/undefined element setting')
    }

    let toBeReplacedIdx = -1
    const oldEl = existsEl

    if (existsEl && doesElNeedRecreate(existsEl, elOption, seriesModel) // || (
    //     // PENDING: even in one-to-one mapping case, if el is marked as morph,
    //     // do not sure whether the el will be mapped to another el with different
    //     // hierarchy in Group tree. So always recreate el rather than reuse the el.
    //     morphHelper && morphHelper.isOneToOneFrom(el)
    // )
    ) {
      // Should keep at the original index, otherwise "merge by index" will be incorrect.
      toBeReplacedIdx = indexOf(group.childrenRef(), existsEl)
      existsEl = null
    }

    const isInit = !existsEl
    let el = existsEl

    if (!el) {
      el = createEl(elOption)

      if (oldEl) {
        copyElement(oldEl, el)
      }
    } else {
      // FIMXE:NEXT unified clearState?
      // If in some case the performance issue arised, consider
      // do not clearState but update cached normal state directly.
      el.clearStates()
    } // Need to set morph: false explictly to disable automatically morphing.

    if (elOption.morph === false) {
      el.disableMorphing = true
    } else if (el.disableMorphing) {
      el.disableMorphing = false
    }

    attachedTxInfoTmp.normal.cfg = attachedTxInfoTmp.normal.conOpt = attachedTxInfoTmp.emphasis.cfg = attachedTxInfoTmp.emphasis.conOpt = attachedTxInfoTmp.blur.cfg = attachedTxInfoTmp.blur.conOpt = attachedTxInfoTmp.select.cfg = attachedTxInfoTmp.select.conOpt = null
    attachedTxInfoTmp.isLegacy = false
    doCreateOrUpdateAttachedTx(el, dataIndex, elOption, seriesModel, isInit, attachedTxInfoTmp)
    doCreateOrUpdateClipPath(el, dataIndex, elOption, seriesModel, isInit)
    updateElNormal(api, el, dataIndex, elOption, attachedTxInfoTmp, seriesModel, isInit) // `elOption.info` enables user to mount some info on
    // elements and use them in event handlers.
    // Update them only when user specified, otherwise, remain.

    hasOwn(elOption, 'info') && (customInnerStore(el).info = elOption.info)

    for (let i = 0; i < STATES.length; i++) {
      const stateName = STATES[i]

      if (stateName !== NORMAL) {
        const otherStateOpt = retrieveStateOption(elOption, stateName)
        const otherStyleOpt = retrieveStyleOptionOnState(elOption, otherStateOpt, stateName)
        updateElOnState(stateName, el, otherStateOpt, otherStyleOpt, attachedTxInfoTmp)
      }
    }

    updateZ$1(el, elOption, seriesModel)

    if (elOption.type === 'group') {
      mergeChildren(api, el, dataIndex, elOption, seriesModel)
    }

    if (toBeReplacedIdx >= 0) {
      group.replaceAt(el, toBeReplacedIdx)
    } else {
      group.add(el)
    }

    return el
  } // `el` must not be null/undefined.

  function doesElNeedRecreate (el, elOption, seriesModel) {
    const elInner = customInnerStore(el)
    const elOptionType = elOption.type
    const elOptionShape = elOption.shape
    const elOptionStyle = elOption.style
    return (// Always create new if universal transition is enabled.
    // Because we do transition after render. It needs to know what old element is. Replacement will loose it.
      seriesModel.isUniversalTransitionEnabled() || // If `elOptionType` is `null`, follow the merge principle.
        elOptionType != null && elOptionType !== elInner.customGraphicType || elOptionType === 'path' && hasOwnPathData(elOptionShape) && getPathData(elOptionShape) !== elInner.customPathData || elOptionType === 'image' && hasOwn(elOptionStyle, 'image') && elOptionStyle.image !== elInner.customImagePath // // FIXME test and remove this restriction?
    // || (elOptionType === 'text'
    //     && hasOwn(elOptionStyle, 'text')
    //     && (elOptionStyle as TextStyleProps).text !== elInner.customText
    // )

    )
  }

  function doCreateOrUpdateClipPath (el, dataIndex, elOption, seriesModel, isInit) {
    // Based on the "merge" principle, if no clipPath provided,
    // do nothing. The exists clip will be totally removed only if
    // `el.clipPath` is `false`. Otherwise it will be merged/replaced.
    const clipPathOpt = elOption.clipPath

    if (clipPathOpt === false) {
      if (el && el.getClipPath()) {
        el.removeClipPath()
      }
    } else if (clipPathOpt) {
      let clipPath = el.getClipPath()

      if (clipPath && doesElNeedRecreate(clipPath, clipPathOpt, seriesModel)) {
        clipPath = null
      }

      if (!clipPath) {
        clipPath = createEl(clipPathOpt)

        if ('development' !== 'production') {
          assert(isPath$1(clipPath), 'Only any type of `path` can be used in `clipPath`, rather than ' + clipPath.type + '.')
        }

        el.setClipPath(clipPath)
      }

      updateElNormal(null, clipPath, dataIndex, clipPathOpt, null, seriesModel, isInit)
    } // If not define `clipPath` in option, do nothing unnecessary.
  }

  function doCreateOrUpdateAttachedTx (el, dataIndex, elOption, seriesModel, isInit, attachedTxInfo) {
    // group do not support textContent temporarily untill necessary.
    if (el.isGroup) {
      return
    } // Normal must be called before emphasis, for `isLegacy` detection.

    processTxInfo(elOption, null, attachedTxInfo)
    processTxInfo(elOption, EMPHASIS, attachedTxInfo) // If `elOption.textConfig` or `elOption.textContent` is null/undefined, it does not make sence.
    // So for simplicity, if "elOption hasOwnProperty of them but be null/undefined", we do not
    // trade them as set to null to el.
    // Especially:
    // `elOption.textContent: false` means remove textContent.
    // `elOption.textContent.emphasis.style: false` means remove the style from emphasis state.

    let txConOptNormal = attachedTxInfo.normal.conOpt
    const txConOptEmphasis = attachedTxInfo.emphasis.conOpt
    const txConOptBlur = attachedTxInfo.blur.conOpt
    const txConOptSelect = attachedTxInfo.select.conOpt

    if (txConOptNormal != null || txConOptEmphasis != null || txConOptSelect != null || txConOptBlur != null) {
      let textContent = el.getTextContent()

      if (txConOptNormal === false) {
        textContent && el.removeTextContent()
      } else {
        txConOptNormal = attachedTxInfo.normal.conOpt = txConOptNormal || {
          type: 'text'
        }

        if (!textContent) {
          textContent = createEl(txConOptNormal)
          el.setTextContent(textContent)
        } else {
          // If in some case the performance issue arised, consider
          // do not clearState but update cached normal state directly.
          textContent.clearStates()
        }

        updateElNormal(null, textContent, dataIndex, txConOptNormal, null, seriesModel, isInit)
        const txConStlOptNormal = txConOptNormal && txConOptNormal.style

        for (let i = 0; i < STATES.length; i++) {
          const stateName = STATES[i]

          if (stateName !== NORMAL) {
            const txConOptOtherState = attachedTxInfo[stateName].conOpt
            updateElOnState(stateName, textContent, txConOptOtherState, retrieveStyleOptionOnState(txConOptNormal, txConOptOtherState, stateName), null)
          }
        }

        txConStlOptNormal ? textContent.dirty() : textContent.markRedraw()
      }
    }
  }

  function processTxInfo (elOption, state, attachedTxInfo) {
    const stateOpt = !state ? elOption : retrieveStateOption(elOption, state)
    const styleOpt = !state ? elOption.style : retrieveStyleOptionOnState(elOption, stateOpt, EMPHASIS)
    const elType = elOption.type
    let txCfg = stateOpt ? stateOpt.textConfig : null
    const txConOptNormal = elOption.textContent
    let txConOpt = !txConOptNormal ? null : !state ? txConOptNormal : retrieveStateOption(txConOptNormal, state)

    if (styleOpt && ( // Because emphasis style has little info to detect legacy,
      // if normal is legacy, emphasis is trade as legacy.
      attachedTxInfo.isLegacy || isEC4CompatibleStyle(styleOpt, elType, !!txCfg, !!txConOpt))) {
      attachedTxInfo.isLegacy = true
      const convertResult = convertFromEC4CompatibleStyle(styleOpt, elType, !state) // Explicitly specified `textConfig` and `textContent` has higher priority than
      // the ones generated by legacy style. Otherwise if users use them and `api.style`
      // at the same time, they not both work and hardly to known why.

      if (!txCfg && convertResult.textConfig) {
        txCfg = convertResult.textConfig
      }

      if (!txConOpt && convertResult.textContent) {
        txConOpt = convertResult.textContent
      }
    }

    if (!state && txConOpt) {
      const txConOptNormal_1 = txConOpt // `textContent: {type: 'text'}`, the "type" is easy to be missing. So we tolerate it.

      !txConOptNormal_1.type && (txConOptNormal_1.type = 'text')

      if ('development' !== 'production') {
        // Do not tolerate incorret type for forward compat.
        assert(txConOptNormal_1.type === 'text', 'textContent.type must be "text"')
      }
    }

    const info = !state ? attachedTxInfo.normal : attachedTxInfo[state]
    info.cfg = txCfg
    info.conOpt = txConOpt
  }

  function retrieveStateOption (elOption, state) {
    return !state ? elOption : elOption ? elOption[state] : null
  }

  function retrieveStyleOptionOnState (stateOptionNormal, stateOption, state) {
    let style = stateOption && stateOption.style

    if (style == null && state === EMPHASIS && stateOptionNormal) {
      style = stateOptionNormal.styleEmphasis
    }

    return style
  } // Usage:
  // (1) By default, `elOption.$mergeChildren` is `'byIndex'`, which indicates that
  //     the existing children will not be removed, and enables the feature that
  //     update some of the props of some of the children simply by construct
  //     the returned children of `renderItem` like:
  //     `var children = group.children = []; children[3] = {opacity: 0.5};`
  // (2) If `elOption.$mergeChildren` is `'byName'`, add/update/remove children
  //     by child.name. But that might be lower performance.
  // (3) If `elOption.$mergeChildren` is `false`, the existing children will be
  //     replaced totally.
  // (4) If `!elOption.children`, following the "merge" principle, nothing will happen.
  //
  // For implementation simpleness, do not provide a direct way to remove sinlge
  // child (otherwise the total indicies of the children array have to be modified).
  // User can remove a single child by set its `ignore` as `true`.

  function mergeChildren (api, el, dataIndex, elOption, seriesModel) {
    const newChildren = elOption.children
    const newLen = newChildren ? newChildren.length : 0
    const mergeChildren = elOption.$mergeChildren // `diffChildrenByName` has been deprecated.

    const byName = mergeChildren === 'byName' || elOption.diffChildrenByName
    const notMerge = mergeChildren === false // For better performance on roam update, only enter if necessary.

    if (!newLen && !byName && !notMerge) {
      return
    }

    if (byName) {
      diffGroupChildren({
        api: api,
        oldChildren: el.children() || [],
        newChildren: newChildren || [],
        dataIndex: dataIndex,
        seriesModel: seriesModel,
        group: el
      })
      return
    }

    notMerge && el.removeAll() // Mapping children of a group simply by index, which
    // might be better performance.

    let index = 0

    for (; index < newLen; index++) {
      newChildren[index] && doCreateOrUpdateEl(api, el.childAt(index), dataIndex, newChildren[index], seriesModel, el)
    }

    for (let i = el.childCount() - 1; i >= index; i--) {
      // Do not supprot leave elements that are not mentioned in the latest
      // `renderItem` return. Otherwise users may not have a clear and simple
      // concept that how to contorl all of the elements.
      const child = el.childAt(i)
      applyLeaveTransition(child, customInnerStore(el).option, seriesModel)
    }
  }

  function diffGroupChildren (context) {
    new DataDiffer(context.oldChildren, context.newChildren, getKey, getKey, context).add(processAddUpdate).update(processAddUpdate).remove(processRemove).execute()
  }

  function getKey (item, idx) {
    const name = item && item.name
    return name != null ? name : GROUP_DIFF_PREFIX + idx
  }

  function processAddUpdate (newIndex, oldIndex) {
    const context = this.context
    const childOption = newIndex != null ? context.newChildren[newIndex] : null
    const child = oldIndex != null ? context.oldChildren[oldIndex] : null
    doCreateOrUpdateEl(context.api, child, context.dataIndex, childOption, context.seriesModel, context.group)
  }

  function processRemove (oldIndex) {
    const context = this.context
    const child = context.oldChildren[oldIndex]
    applyLeaveTransition(child, customInnerStore(child).option, context.seriesModel)
  }
  /**
     * @return SVG Path data.
     */

  function getPathData (shape) {
    // "d" follows the SVG convention.
    return shape && (shape.pathData || shape.d)
  }

  function hasOwnPathData (shape) {
    return shape && (hasOwn(shape, 'pathData') || hasOwn(shape, 'd'))
  }

  function install$r (registers) {
    registers.registerChartView(CustomChartView)
    registers.registerSeriesModel(CustomSeriesModel)
  }

  const inner$a = makeInner()
  const clone$3 = clone
  const bind$1 = bind
  /**
     * Base axis pointer class in 2D.
     */

  const BaseAxisPointer =
    /** @class */
    (function () {
      function BaseAxisPointer () {
        this._dragging = false
        /**
         * In px, arbitrary value. Do not set too small,
         * no animation is ok for most cases.
         */

        this.animationThreshold = 15
      }
      /**
       * @implement
       */

      BaseAxisPointer.prototype.render = function (axisModel, axisPointerModel, api, forceRender) {
        const value = axisPointerModel.get('value')
        const status = axisPointerModel.get('status') // Bind them to `this`, not in closure, otherwise they will not
        // be replaced when user calling setOption in not merge mode.

        this._axisModel = axisModel
        this._axisPointerModel = axisPointerModel
        this._api = api // Optimize: `render` will be called repeatly during mouse move.
        // So it is power consuming if performing `render` each time,
        // especially on mobile device.

        if (!forceRender && this._lastValue === value && this._lastStatus === status) {
          return
        }

        this._lastValue = value
        this._lastStatus = status
        let group = this._group
        const handle = this._handle

        if (!status || status === 'hide') {
          // Do not clear here, for animation better.
          group && group.hide()
          handle && handle.hide()
          return
        }

        group && group.show()
        handle && handle.show() // Otherwise status is 'show'

        const elOption = {}
        this.makeElOption(elOption, value, axisModel, axisPointerModel, api) // Enable change axis pointer type.

        const graphicKey = elOption.graphicKey

        if (graphicKey !== this._lastGraphicKey) {
          this.clear(api)
        }

        this._lastGraphicKey = graphicKey
        const moveAnimation = this._moveAnimation = this.determineAnimation(axisModel, axisPointerModel)

        if (!group) {
          group = this._group = new Group()
          this.createPointerEl(group, elOption, axisModel, axisPointerModel)
          this.createLabelEl(group, elOption, axisModel, axisPointerModel)
          api.getZr().add(group)
        } else {
          const doUpdateProps = curry(updateProps$1, axisPointerModel, moveAnimation)
          this.updatePointerEl(group, elOption, doUpdateProps)
          this.updateLabelEl(group, elOption, doUpdateProps, axisPointerModel)
        }

        updateMandatoryProps(group, axisPointerModel, true)

        this._renderHandle(value)
      }
      /**
       * @implement
       */

      BaseAxisPointer.prototype.remove = function (api) {
        this.clear(api)
      }
      /**
       * @implement
       */

      BaseAxisPointer.prototype.dispose = function (api) {
        this.clear(api)
      }
      /**
       * @protected
       */

      BaseAxisPointer.prototype.determineAnimation = function (axisModel, axisPointerModel) {
        const animation = axisPointerModel.get('animation')
        const axis = axisModel.axis
        const isCategoryAxis = axis.type === 'category'
        const useSnap = axisPointerModel.get('snap') // Value axis without snap always do not snap.

        if (!useSnap && !isCategoryAxis) {
          return false
        }

        if (animation === 'auto' || animation == null) {
          const animationThreshold = this.animationThreshold

          if (isCategoryAxis && axis.getBandWidth() > animationThreshold) {
            return true
          } // It is important to auto animation when snap used. Consider if there is
          // a dataZoom, animation will be disabled when too many points exist, while
          // it will be enabled for better visual effect when little points exist.

          if (useSnap) {
            const seriesDataCount = getAxisInfo(axisModel).seriesDataCount
            const axisExtent = axis.getExtent() // Approximate band width

            return Math.abs(axisExtent[0] - axisExtent[1]) / seriesDataCount > animationThreshold
          }

          return false
        }

        return animation === true
      }
      /**
       * add {pointer, label, graphicKey} to elOption
       * @protected
       */

      BaseAxisPointer.prototype.makeElOption = function (elOption, value, axisModel, axisPointerModel, api) { // Shoule be implemenented by sub-class.
      }
      /**
       * @protected
       */

      BaseAxisPointer.prototype.createPointerEl = function (group, elOption, axisModel, axisPointerModel) {
        const pointerOption = elOption.pointer

        if (pointerOption) {
          const pointerEl = inner$a(group).pointerEl = new graphic[pointerOption.type](clone$3(elOption.pointer))
          group.add(pointerEl)
        }
      }
      /**
       * @protected
       */

      BaseAxisPointer.prototype.createLabelEl = function (group, elOption, axisModel, axisPointerModel) {
        if (elOption.label) {
          const labelEl = inner$a(group).labelEl = new ZRText(clone$3(elOption.label))
          group.add(labelEl)
          updateLabelShowHide(labelEl, axisPointerModel)
        }
      }
      /**
       * @protected
       */

      BaseAxisPointer.prototype.updatePointerEl = function (group, elOption, updateProps) {
        const pointerEl = inner$a(group).pointerEl

        if (pointerEl && elOption.pointer) {
          pointerEl.setStyle(elOption.pointer.style)
          updateProps(pointerEl, {
            shape: elOption.pointer.shape
          })
        }
      }
      /**
       * @protected
       */

      BaseAxisPointer.prototype.updateLabelEl = function (group, elOption, updateProps, axisPointerModel) {
        const labelEl = inner$a(group).labelEl

        if (labelEl) {
          labelEl.setStyle(elOption.label.style)
          updateProps(labelEl, {
            // Consider text length change in vertical axis, animation should
            // be used on shape, otherwise the effect will be weird.
            // TODOTODO
            // shape: elOption.label.shape,
            x: elOption.label.x,
            y: elOption.label.y
          })
          updateLabelShowHide(labelEl, axisPointerModel)
        }
      }
      /**
       * @private
       */

      BaseAxisPointer.prototype._renderHandle = function (value) {
        if (this._dragging || !this.updateHandleTransform) {
          return
        }

        const axisPointerModel = this._axisPointerModel

        const zr = this._api.getZr()

        let handle = this._handle
        const handleModel = axisPointerModel.getModel('handle')
        const status = axisPointerModel.get('status')

        if (!handleModel.get('show') || !status || status === 'hide') {
          handle && zr.remove(handle)
          this._handle = null
          return
        }

        let isInit

        if (!this._handle) {
          isInit = true
          handle = this._handle = createIcon(handleModel.get('icon'), {
            cursor: 'move',
            draggable: true,
            onmousemove: function (e) {
              // Fot mobile devicem, prevent screen slider on the button.
              stop(e.event)
            },
            onmousedown: bind$1(this._onHandleDragMove, this, 0, 0),
            drift: bind$1(this._onHandleDragMove, this),
            ondragend: bind$1(this._onHandleDragEnd, this)
          })
          zr.add(handle)
        }

        updateMandatoryProps(handle, axisPointerModel, false) // update style

        handle.setStyle(handleModel.getItemStyle(null, ['color', 'borderColor', 'borderWidth', 'opacity', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY'])) // update position

        let handleSize = handleModel.get('size')

        if (!isArray(handleSize)) {
          handleSize = [handleSize, handleSize]
        }

        handle.scaleX = handleSize[0] / 2
        handle.scaleY = handleSize[1] / 2
        createOrUpdate(this, '_doDispatchAxisPointer', handleModel.get('throttle') || 0, 'fixRate')

        this._moveHandleToValue(value, isInit)
      }

      BaseAxisPointer.prototype._moveHandleToValue = function (value, isInit) {
        updateProps$1(this._axisPointerModel, !isInit && this._moveAnimation, this._handle, getHandleTransProps(this.getHandleTransform(value, this._axisModel, this._axisPointerModel)))
      }

      BaseAxisPointer.prototype._onHandleDragMove = function (dx, dy) {
        const handle = this._handle

        if (!handle) {
          return
        }

        this._dragging = true // Persistent for throttle.

        const trans = this.updateHandleTransform(getHandleTransProps(handle), [dx, dy], this._axisModel, this._axisPointerModel)
        this._payloadInfo = trans
        handle.stopAnimation()
        handle.attr(getHandleTransProps(trans))
        inner$a(handle).lastProp = null

        this._doDispatchAxisPointer()
      }
      /**
       * Throttled method.
       */

      BaseAxisPointer.prototype._doDispatchAxisPointer = function () {
        const handle = this._handle

        if (!handle) {
          return
        }

        const payloadInfo = this._payloadInfo
        const axisModel = this._axisModel

        this._api.dispatchAction({
          type: 'updateAxisPointer',
          x: payloadInfo.cursorPoint[0],
          y: payloadInfo.cursorPoint[1],
          tooltipOption: payloadInfo.tooltipOption,
          axesInfo: [{
            axisDim: axisModel.axis.dim,
            axisIndex: axisModel.componentIndex
          }]
        })
      }

      BaseAxisPointer.prototype._onHandleDragEnd = function () {
        this._dragging = false
        const handle = this._handle

        if (!handle) {
          return
        }

        const value = this._axisPointerModel.get('value') // Consider snap or categroy axis, handle may be not consistent with
        // axisPointer. So move handle to align the exact value position when
        // drag ended.

        this._moveHandleToValue(value) // For the effect: tooltip will be shown when finger holding on handle
        // button, and will be hidden after finger left handle button.

        this._api.dispatchAction({
          type: 'hideTip'
        })
      }
      /**
       * @private
       */

      BaseAxisPointer.prototype.clear = function (api) {
        this._lastValue = null
        this._lastStatus = null
        const zr = api.getZr()
        const group = this._group
        const handle = this._handle

        if (zr && group) {
          this._lastGraphicKey = null
          group && zr.remove(group)
          handle && zr.remove(handle)
          this._group = null
          this._handle = null
          this._payloadInfo = null
        }

        clear(this, '_doDispatchAxisPointer')
      }
      /**
       * @protected
       */

      BaseAxisPointer.prototype.doClear = function () { // Implemented by sub-class if necessary.
      }

      BaseAxisPointer.prototype.buildLabel = function (xy, wh, xDimIndex) {
        xDimIndex = xDimIndex || 0
        return {
          x: xy[xDimIndex],
          y: xy[1 - xDimIndex],
          width: wh[xDimIndex],
          height: wh[1 - xDimIndex]
        }
      }

      return BaseAxisPointer
    }())

  function updateProps$1 (animationModel, moveAnimation, el, props) {
    // Animation optimize.
    if (!propsEqual(inner$a(el).lastProp, props)) {
      inner$a(el).lastProp = props
      moveAnimation ? updateProps(el, props, animationModel) : (el.stopAnimation(), el.attr(props))
    }
  }

  function propsEqual (lastProps, newProps) {
    if (isObject(lastProps) && isObject(newProps)) {
      let equals_1 = true
      each(newProps, function (item, key) {
        equals_1 = equals_1 && propsEqual(lastProps[key], item)
      })
      return !!equals_1
    } else {
      return lastProps === newProps
    }
  }

  function updateLabelShowHide (labelEl, axisPointerModel) {
    labelEl[axisPointerModel.get(['label', 'show']) ? 'show' : 'hide']()
  }

  function getHandleTransProps (trans) {
    return {
      x: trans.x || 0,
      y: trans.y || 0,
      rotation: trans.rotation || 0
    }
  }

  function updateMandatoryProps (group, axisPointerModel, silent) {
    const z = axisPointerModel.get('z')
    const zlevel = axisPointerModel.get('zlevel')
    group && group.traverse(function (el) {
      if (el.type !== 'group') {
        z != null && (el.z = z)
        zlevel != null && (el.zlevel = zlevel)
        el.silent = silent
      }
    })
  }

  function buildElStyle (axisPointerModel) {
    const axisPointerType = axisPointerModel.get('type')
    const styleModel = axisPointerModel.getModel(axisPointerType + 'Style')
    let style

    if (axisPointerType === 'line') {
      style = styleModel.getLineStyle()
      style.fill = null
    } else if (axisPointerType === 'shadow') {
      style = styleModel.getAreaStyle()
      style.stroke = null
    }

    return style
  }
  /**
     * @param {Function} labelPos {align, verticalAlign, position}
     */

  function buildLabelElOption (elOption, axisModel, axisPointerModel, api, labelPos) {
    const value = axisPointerModel.get('value')
    const text = getValueLabel(value, axisModel.axis, axisModel.ecModel, axisPointerModel.get('seriesDataIndices'), {
      precision: axisPointerModel.get(['label', 'precision']),
      formatter: axisPointerModel.get(['label', 'formatter'])
    })
    const labelModel = axisPointerModel.getModel('label')
    const paddings = normalizeCssArray$1(labelModel.get('padding') || 0)
    const font = labelModel.getFont()
    const textRect = getBoundingRect(text, font)
    const position = labelPos.position
    const width = textRect.width + paddings[1] + paddings[3]
    const height = textRect.height + paddings[0] + paddings[2] // Adjust by align.

    const align = labelPos.align
    align === 'right' && (position[0] -= width)
    align === 'center' && (position[0] -= width / 2)
    const verticalAlign = labelPos.verticalAlign
    verticalAlign === 'bottom' && (position[1] -= height)
    verticalAlign === 'middle' && (position[1] -= height / 2) // Not overflow ec container

    confineInContainer(position, width, height, api)
    let bgColor = labelModel.get('backgroundColor')

    if (!bgColor || bgColor === 'auto') {
      bgColor = axisModel.get(['axisLine', 'lineStyle', 'color'])
    }

    elOption.label = {
      // shape: {x: 0, y: 0, width: width, height: height, r: labelModel.get('borderRadius')},
      x: position[0],
      y: position[1],
      style: createTextStyle(labelModel, {
        text: text,
        font: font,
        fill: labelModel.getTextColor(),
        padding: paddings,
        backgroundColor: bgColor
      }),
      // Lable should be over axisPointer.
      z2: 10
    }
  } // Do not overflow ec container

  function confineInContainer (position, width, height, api) {
    const viewWidth = api.getWidth()
    const viewHeight = api.getHeight()
    position[0] = Math.min(position[0] + width, viewWidth) - width
    position[1] = Math.min(position[1] + height, viewHeight) - height
    position[0] = Math.max(position[0], 0)
    position[1] = Math.max(position[1], 0)
  }

  function getValueLabel (value, axis, ecModel, seriesDataIndices, opt) {
    value = axis.scale.parse(value)
    let text = axis.scale.getLabel({
      value: value
    }, {
      // If `precision` is set, width can be fixed (like '12.00500'), which
      // helps to debounce when when moving label.
      precision: opt.precision
    })
    const formatter = opt.formatter

    if (formatter) {
      const params_1 = {
        value: getAxisRawValue(axis, {
          value: value
        }),
        axisDimension: axis.dim,
        axisIndex: axis.index,
        seriesData: []
      }
      each(seriesDataIndices, function (idxItem) {
        const series = ecModel.getSeriesByIndex(idxItem.seriesIndex)
        const dataIndex = idxItem.dataIndexInside
        const dataParams = series && series.getDataParams(dataIndex)
        dataParams && params_1.seriesData.push(dataParams)
      })

      if (isString(formatter)) {
        text = formatter.replace('{value}', text)
      } else if (isFunction(formatter)) {
        text = formatter(params_1)
      }
    }

    return text
  }
  function getTransformedPosition (axis, value, layoutInfo) {
    const transform = create$1()
    rotate(transform, transform, layoutInfo.rotation)
    translate(transform, transform, layoutInfo.position)
    return applyTransform$1([axis.dataToCoord(value), (layoutInfo.labelOffset || 0) + (layoutInfo.labelDirection || 1) * (layoutInfo.labelMargin || 0)], transform)
  }
  function buildCartesianSingleLabelElOption (value, elOption, layoutInfo, axisModel, axisPointerModel, api) {
    // @ts-ignore
    const textLayout = AxisBuilder.innerTextLayout(layoutInfo.rotation, 0, layoutInfo.labelDirection)
    layoutInfo.labelMargin = axisPointerModel.get(['label', 'margin'])
    buildLabelElOption(elOption, axisModel, axisPointerModel, api, {
      position: getTransformedPosition(axisModel.axis, value, layoutInfo),
      align: textLayout.textAlign,
      verticalAlign: textLayout.textVerticalAlign
    })
  }
  function makeLineShape (p1, p2, xDimIndex) {
    xDimIndex = xDimIndex || 0
    return {
      x1: p1[xDimIndex],
      y1: p1[1 - xDimIndex],
      x2: p2[xDimIndex],
      y2: p2[1 - xDimIndex]
    }
  }
  function makeRectShape (xy, wh, xDimIndex) {
    xDimIndex = xDimIndex || 0
    return {
      x: xy[xDimIndex],
      y: xy[1 - xDimIndex],
      width: wh[xDimIndex],
      height: wh[1 - xDimIndex]
    }
  }
  function makeSectorShape (cx, cy, r0, r, startAngle, endAngle) {
    return {
      cx: cx,
      cy: cy,
      r0: r0,
      r: r,
      startAngle: startAngle,
      endAngle: endAngle,
      clockwise: true
    }
  }

  const CartesianAxisPointer =
    /** @class */
    (function (_super) {
      __extends(CartesianAxisPointer, _super)

      function CartesianAxisPointer () {
        return _super !== null && _super.apply(this, arguments) || this
      }
      /**
       * @override
       */

      CartesianAxisPointer.prototype.makeElOption = function (elOption, value, axisModel, axisPointerModel, api) {
        const axis = axisModel.axis
        const grid = axis.grid
        const axisPointerType = axisPointerModel.get('type')
        const otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent()
        const pixelValue = axis.toGlobalCoord(axis.dataToCoord(value, true))

        if (axisPointerType && axisPointerType !== 'none') {
          const elStyle = buildElStyle(axisPointerModel)
          const pointerOption = pointerShapeBuilder[axisPointerType](axis, pixelValue, otherExtent)
          pointerOption.style = elStyle
          elOption.graphicKey = pointerOption.type
          elOption.pointer = pointerOption
        }

        const layoutInfo = layout$1(grid.model, axisModel)
        buildCartesianSingleLabelElOption( // @ts-ignore
          value, elOption, layoutInfo, axisModel, axisPointerModel, api)
      }
      /**
       * @override
       */

      CartesianAxisPointer.prototype.getHandleTransform = function (value, axisModel, axisPointerModel) {
        const layoutInfo = layout$1(axisModel.axis.grid.model, axisModel, {
          labelInside: false
        }) // @ts-ignore

        layoutInfo.labelMargin = axisPointerModel.get(['handle', 'margin'])
        const pos = getTransformedPosition(axisModel.axis, value, layoutInfo)
        return {
          x: pos[0],
          y: pos[1],
          rotation: layoutInfo.rotation + (layoutInfo.labelDirection < 0 ? Math.PI : 0)
        }
      }
      /**
       * @override
       */

      CartesianAxisPointer.prototype.updateHandleTransform = function (transform, delta, axisModel, axisPointerModel) {
        const axis = axisModel.axis
        const grid = axis.grid
        const axisExtent = axis.getGlobalExtent(true)
        const otherExtent = getCartesian(grid, axis).getOtherAxis(axis).getGlobalExtent()
        const dimIndex = axis.dim === 'x' ? 0 : 1
        const currPosition = [transform.x, transform.y]
        currPosition[dimIndex] += delta[dimIndex]
        currPosition[dimIndex] = Math.min(axisExtent[1], currPosition[dimIndex])
        currPosition[dimIndex] = Math.max(axisExtent[0], currPosition[dimIndex])
        const cursorOtherValue = (otherExtent[1] + otherExtent[0]) / 2
        const cursorPoint = [cursorOtherValue, cursorOtherValue]
        cursorPoint[dimIndex] = currPosition[dimIndex] // Make tooltip do not overlap axisPointer and in the middle of the grid.

        const tooltipOptions = [{
          verticalAlign: 'middle'
        }, {
          align: 'center'
        }]
        return {
          x: currPosition[0],
          y: currPosition[1],
          rotation: transform.rotation,
          cursorPoint: cursorPoint,
          tooltipOption: tooltipOptions[dimIndex]
        }
      }

      return CartesianAxisPointer
    }(BaseAxisPointer))

  function getCartesian (grid, axis) {
    const opt = {}
    opt[axis.dim + 'AxisIndex'] = axis.index
    return grid.getCartesian(opt)
  }

  var pointerShapeBuilder = {
    line: function (axis, pixelValue, otherExtent) {
      const targetShape = makeLineShape([pixelValue, otherExtent[0]], [pixelValue, otherExtent[1]], getAxisDimIndex(axis))
      return {
        type: 'Line',
        subPixelOptimize: true,
        shape: targetShape
      }
    },
    shadow: function (axis, pixelValue, otherExtent) {
      const bandWidth = Math.max(1, axis.getBandWidth())
      const span = otherExtent[1] - otherExtent[0]
      return {
        type: 'Rect',
        shape: makeRectShape([pixelValue - bandWidth / 2, otherExtent[0]], [bandWidth, span], getAxisDimIndex(axis))
      }
    }
  }

  function getAxisDimIndex (axis) {
    return axis.dim === 'x' ? 0 : 1
  }

  const AxisPointerModel =
    /** @class */
    (function (_super) {
      __extends(AxisPointerModel, _super)

      function AxisPointerModel () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = AxisPointerModel.type
        return _this
      }

      AxisPointerModel.type = 'axisPointer'
      AxisPointerModel.defaultOption = {
        // 'auto' means that show when triggered by tooltip or handle.
        show: 'auto',
        // zlevel: 0,
        z: 50,
        type: 'line',
        // axispointer triggered by tootip determine snap automatically,
        // see `modelHelper`.
        snap: false,
        triggerTooltip: true,
        value: null,
        status: null,
        link: [],
        // Do not set 'auto' here, otherwise global animation: false
        // will not effect at this axispointer.
        animation: null,
        animationDurationUpdate: 200,
        lineStyle: {
          color: '#B9BEC9',
          width: 1,
          type: 'dashed'
        },
        shadowStyle: {
          color: 'rgba(210,219,238,0.2)'
        },
        label: {
          show: true,
          formatter: null,
          precision: 'auto',
          margin: 3,
          color: '#fff',
          padding: [5, 7, 5, 7],
          backgroundColor: 'auto',
          borderColor: null,
          borderWidth: 0,
          borderRadius: 3
        },
        handle: {
          show: false,
          // eslint-disable-next-line
          icon: 'M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z',
          size: 45,
          // handle margin is from symbol center to axis, which is stable when circular move.
          margin: 50,
          // color: '#1b8bbd'
          // color: '#2f4554'
          color: '#333',
          shadowBlur: 3,
          shadowColor: '#aaa',
          shadowOffsetX: 0,
          shadowOffsetY: 2,
          // For mobile performance
          throttle: 40
        }
      }
      return AxisPointerModel
    }(ComponentModel))

  const inner$b = makeInner()
  const each$7 = each
  /**
     * @param {string} key
     * @param {module:echarts/ExtensionAPI} api
     * @param {Function} handler
     *      param: {string} currTrigger
     *      param: {Array.<number>} point
     */

  function register (key, api, handler) {
    if (env.node) {
      return
    }

    const zr = api.getZr()
    inner$b(zr).records || (inner$b(zr).records = {})
    initGlobalListeners(zr, api)
    const record = inner$b(zr).records[key] || (inner$b(zr).records[key] = {})
    record.handler = handler
  }

  function initGlobalListeners (zr, api) {
    if (inner$b(zr).initialized) {
      return
    }

    inner$b(zr).initialized = true
    useHandler('click', curry(doEnter, 'click'))
    useHandler('mousemove', curry(doEnter, 'mousemove')) // useHandler('mouseout', onLeave);

    useHandler('globalout', onLeave)

    function useHandler (eventType, cb) {
      zr.on(eventType, function (e) {
        const dis = makeDispatchAction(api)
        each$7(inner$b(zr).records, function (record) {
          record && cb(record, e, dis.dispatchAction)
        })
        dispatchTooltipFinally(dis.pendings, api)
      })
    }
  }

  function dispatchTooltipFinally (pendings, api) {
    const showLen = pendings.showTip.length
    const hideLen = pendings.hideTip.length
    let actuallyPayload

    if (showLen) {
      actuallyPayload = pendings.showTip[showLen - 1]
    } else if (hideLen) {
      actuallyPayload = pendings.hideTip[hideLen - 1]
    }

    if (actuallyPayload) {
      actuallyPayload.dispatchAction = null
      api.dispatchAction(actuallyPayload)
    }
  }

  function onLeave (record, e, dispatchAction) {
    record.handler('leave', null, dispatchAction)
  }

  function doEnter (currTrigger, record, e, dispatchAction) {
    record.handler(currTrigger, e, dispatchAction)
  }

  function makeDispatchAction (api) {
    const pendings = {
      showTip: [],
      hideTip: []
    } // FIXME
    // better approach?
    // 'showTip' and 'hideTip' can be triggered by axisPointer and tooltip,
    // which may be conflict, (axisPointer call showTip but tooltip call hideTip);
    // So we have to add "final stage" to merge those dispatched actions.

    var dispatchAction = function (payload) {
      const pendingList = pendings[payload.type]

      if (pendingList) {
        pendingList.push(payload)
      } else {
        payload.dispatchAction = dispatchAction
        api.dispatchAction(payload)
      }
    }

    return {
      dispatchAction: dispatchAction,
      pendings: pendings
    }
  }

  function unregister (key, api) {
    if (env.node) {
      return
    }

    const zr = api.getZr()
    const record = (inner$b(zr).records || {})[key]

    if (record) {
      inner$b(zr).records[key] = null
    }
  }

  const AxisPointerView =
    /** @class */
    (function (_super) {
      __extends(AxisPointerView, _super)

      function AxisPointerView () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = AxisPointerView.type
        return _this
      }

      AxisPointerView.prototype.render = function (globalAxisPointerModel, ecModel, api) {
        const globalTooltipModel = ecModel.getComponent('tooltip')
        const triggerOn = globalAxisPointerModel.get('triggerOn') || globalTooltipModel && globalTooltipModel.get('triggerOn') || 'mousemove|click' // Register global listener in AxisPointerView to enable
        // AxisPointerView to be independent to Tooltip.

        register('axisPointer', api, function (currTrigger, e, dispatchAction) {
          // If 'none', it is not controlled by mouse totally.
          if (triggerOn !== 'none' && (currTrigger === 'leave' || triggerOn.indexOf(currTrigger) >= 0)) {
            dispatchAction({
              type: 'updateAxisPointer',
              currTrigger: currTrigger,
              x: e && e.offsetX,
              y: e && e.offsetY
            })
          }
        })
      }

      AxisPointerView.prototype.remove = function (ecModel, api) {
        unregister('axisPointer', api)
      }

      AxisPointerView.prototype.dispose = function (ecModel, api) {
        unregister('axisPointer', api)
      }

      AxisPointerView.type = 'axisPointer'
      return AxisPointerView
    }(ComponentView))

  /**
     * @param finder contains {seriesIndex, dataIndex, dataIndexInside}
     * @param ecModel
     * @return  {point: [x, y], el: ...} point Will not be null.
     */

  function findPointFromSeries (finder, ecModel) {
    let point = []
    const seriesIndex = finder.seriesIndex
    let seriesModel

    if (seriesIndex == null || !(seriesModel = ecModel.getSeriesByIndex(seriesIndex))) {
      return {
        point: []
      }
    }

    const data = seriesModel.getData()
    const dataIndex = queryDataIndex(data, finder)

    if (dataIndex == null || dataIndex < 0 || isArray(dataIndex)) {
      return {
        point: []
      }
    }

    const el = data.getItemGraphicEl(dataIndex)
    const coordSys = seriesModel.coordinateSystem

    if (seriesModel.getTooltipPosition) {
      point = seriesModel.getTooltipPosition(dataIndex) || []
    } else if (coordSys && coordSys.dataToPoint) {
      if (finder.isStacked) {
        const baseAxis = coordSys.getBaseAxis()
        const valueAxis = coordSys.getOtherAxis(baseAxis)
        const valueAxisDim = valueAxis.dim
        const baseAxisDim = baseAxis.dim
        const baseDataOffset = valueAxisDim === 'x' || valueAxisDim === 'radius' ? 1 : 0
        const baseDim = data.mapDimension(baseAxisDim)
        const stackedData = []
        stackedData[baseDataOffset] = data.get(baseDim, dataIndex)
        stackedData[1 - baseDataOffset] = data.get(data.getCalculationInfo('stackResultDimension'), dataIndex)
        point = coordSys.dataToPoint(stackedData) || []
      } else {
        point = coordSys.dataToPoint(data.getValues(map(coordSys.dimensions, function (dim) {
          return data.mapDimension(dim)
        }), dataIndex)) || []
      }
    } else if (el) {
      // Use graphic bounding rect
      const rect = el.getBoundingRect().clone()
      rect.applyTransform(el.transform)
      point = [rect.x + rect.width / 2, rect.y + rect.height / 2]
    }

    return {
      point: point,
      el: el
    }
  }

  const inner$c = makeInner()
  /**
     * Basic logic: check all axis, if they do not demand show/highlight,
     * then hide/downplay them.
     *
     * @return content of event obj for echarts.connect.
     */

  function axisTrigger (payload, ecModel, api) {
    const currTrigger = payload.currTrigger
    let point = [payload.x, payload.y]
    const finder = payload
    const dispatchAction = payload.dispatchAction || bind(api.dispatchAction, api)
    const coordSysAxesInfo = ecModel.getComponent('axisPointer').coordSysAxesInfo // Pending
    // See #6121. But we are not able to reproduce it yet.

    if (!coordSysAxesInfo) {
      return
    }

    if (illegalPoint(point)) {
      // Used in the default behavior of `connection`: use the sample seriesIndex
      // and dataIndex. And also used in the tooltipView trigger.
      point = findPointFromSeries({
        seriesIndex: finder.seriesIndex,
        // Do not use dataIndexInside from other ec instance.
        // FIXME: auto detect it?
        dataIndex: finder.dataIndex
      }, ecModel).point
    }

    const isIllegalPoint = illegalPoint(point) // Axis and value can be specified when calling dispatchAction({type: 'updateAxisPointer'}).
    // Notice: In this case, it is difficult to get the `point` (which is necessary to show
    // tooltip, so if point is not given, we just use the point found by sample seriesIndex
    // and dataIndex.

    const inputAxesInfo = finder.axesInfo
    const axesInfo = coordSysAxesInfo.axesInfo
    const shouldHide = currTrigger === 'leave' || illegalPoint(point)
    const outputPayload = {}
    const showValueMap = {}
    const dataByCoordSys = {
      list: [],
      map: {}
    }
    const updaters = {
      showPointer: curry(showPointer, showValueMap),
      showTooltip: curry(showTooltip, dataByCoordSys)
    } // Process for triggered axes.

    each(coordSysAxesInfo.coordSysMap, function (coordSys, coordSysKey) {
      // If a point given, it must be contained by the coordinate system.
      const coordSysContainsPoint = isIllegalPoint || coordSys.containPoint(point)
      each(coordSysAxesInfo.coordSysAxesInfo[coordSysKey], function (axisInfo, key) {
        const axis = axisInfo.axis
        const inputAxisInfo = findInputAxisInfo(inputAxesInfo, axisInfo) // If no inputAxesInfo, no axis is restricted.

        if (!shouldHide && coordSysContainsPoint && (!inputAxesInfo || inputAxisInfo)) {
          let val = inputAxisInfo && inputAxisInfo.value

          if (val == null && !isIllegalPoint) {
            val = axis.pointToData(point)
          }

          val != null && processOnAxis(axisInfo, val, updaters, false, outputPayload)
        }
      })
    }) // Process for linked axes.

    const linkTriggers = {}
    each(axesInfo, function (tarAxisInfo, tarKey) {
      const linkGroup = tarAxisInfo.linkGroup // If axis has been triggered in the previous stage, it should not be triggered by link.

      if (linkGroup && !showValueMap[tarKey]) {
        each(linkGroup.axesInfo, function (srcAxisInfo, srcKey) {
          const srcValItem = showValueMap[srcKey] // If srcValItem exist, source axis is triggered, so link to target axis.

          if (srcAxisInfo !== tarAxisInfo && srcValItem) {
            let val = srcValItem.value
            linkGroup.mapper && (val = tarAxisInfo.axis.scale.parse(linkGroup.mapper(val, makeMapperParam(srcAxisInfo), makeMapperParam(tarAxisInfo))))
            linkTriggers[tarAxisInfo.key] = val
          }
        })
      }
    })
    each(linkTriggers, function (val, tarKey) {
      processOnAxis(axesInfo[tarKey], val, updaters, true, outputPayload)
    })
    updateModelActually(showValueMap, axesInfo, outputPayload)
    dispatchTooltipActually(dataByCoordSys, point, payload, dispatchAction)
    dispatchHighDownActually(axesInfo, dispatchAction, api)
    return outputPayload
  }

  function processOnAxis (axisInfo, newValue, updaters, noSnap, outputFinder) {
    const axis = axisInfo.axis

    if (axis.scale.isBlank() || !axis.containData(newValue)) {
      return
    }

    if (!axisInfo.involveSeries) {
      updaters.showPointer(axisInfo, newValue)
      return
    } // Heavy calculation. So put it after axis.containData checking.

    const payloadInfo = buildPayloadsBySeries(newValue, axisInfo)
    const payloadBatch = payloadInfo.payloadBatch
    const snapToValue = payloadInfo.snapToValue // Fill content of event obj for echarts.connect.
    // By default use the first involved series data as a sample to connect.

    if (payloadBatch[0] && outputFinder.seriesIndex == null) {
      extend(outputFinder, payloadBatch[0])
    } // If no linkSource input, this process is for collecting link
    // target, where snap should not be accepted.

    if (!noSnap && axisInfo.snap) {
      if (axis.containData(snapToValue) && snapToValue != null) {
        newValue = snapToValue
      }
    }

    updaters.showPointer(axisInfo, newValue, payloadBatch) // Tooltip should always be snapToValue, otherwise there will be
    // incorrect "axis value ~ series value" mapping displayed in tooltip.

    updaters.showTooltip(axisInfo, payloadInfo, snapToValue)
  }

  function buildPayloadsBySeries (value, axisInfo) {
    const axis = axisInfo.axis
    const dim = axis.dim
    let snapToValue = value
    const payloadBatch = []
    let minDist = Number.MAX_VALUE
    let minDiff = -1
    each(axisInfo.seriesModels, function (series, idx) {
      const dataDim = series.getData().mapDimensionsAll(dim)
      let seriesNestestValue
      let dataIndices

      if (series.getAxisTooltipData) {
        const result = series.getAxisTooltipData(dataDim, value, axis)
        dataIndices = result.dataIndices
        seriesNestestValue = result.nestestValue
      } else {
        dataIndices = series.getData().indicesOfNearest(dataDim[0], value, // Add a threshold to avoid find the wrong dataIndex
          // when data length is not same.
          // false,
          axis.type === 'category' ? 0.5 : null)

        if (!dataIndices.length) {
          return
        }

        seriesNestestValue = series.getData().get(dataDim[0], dataIndices[0])
      }

      if (seriesNestestValue == null || !isFinite(seriesNestestValue)) {
        return
      }

      const diff = value - seriesNestestValue
      const dist = Math.abs(diff) // Consider category case

      if (dist <= minDist) {
        if (dist < minDist || diff >= 0 && minDiff < 0) {
          minDist = dist
          minDiff = diff
          snapToValue = seriesNestestValue
          payloadBatch.length = 0
        }

        each(dataIndices, function (dataIndex) {
          payloadBatch.push({
            seriesIndex: series.seriesIndex,
            dataIndexInside: dataIndex,
            dataIndex: series.getData().getRawIndex(dataIndex)
          })
        })
      }
    })
    return {
      payloadBatch: payloadBatch,
      snapToValue: snapToValue
    }
  }

  function showPointer (showValueMap, axisInfo, value, payloadBatch) {
    showValueMap[axisInfo.key] = {
      value: value,
      payloadBatch: payloadBatch
    }
  }

  function showTooltip (dataByCoordSys, axisInfo, payloadInfo, value) {
    const payloadBatch = payloadInfo.payloadBatch
    const axis = axisInfo.axis
    const axisModel = axis.model
    const axisPointerModel = axisInfo.axisPointerModel // If no data, do not create anything in dataByCoordSys,
    // whose length will be used to judge whether dispatch action.

    if (!axisInfo.triggerTooltip || !payloadBatch.length) {
      return
    }

    const coordSysModel = axisInfo.coordSys.model
    const coordSysKey = makeKey(coordSysModel)
    let coordSysItem = dataByCoordSys.map[coordSysKey]

    if (!coordSysItem) {
      coordSysItem = dataByCoordSys.map[coordSysKey] = {
        coordSysId: coordSysModel.id,
        coordSysIndex: coordSysModel.componentIndex,
        coordSysType: coordSysModel.type,
        coordSysMainType: coordSysModel.mainType,
        dataByAxis: []
      }
      dataByCoordSys.list.push(coordSysItem)
    }

    coordSysItem.dataByAxis.push({
      axisDim: axis.dim,
      axisIndex: axisModel.componentIndex,
      axisType: axisModel.type,
      axisId: axisModel.id,
      value: value,
      // Caustion: viewHelper.getValueLabel is actually on "view stage", which
      // depends that all models have been updated. So it should not be performed
      // here. Considering axisPointerModel used here is volatile, which is hard
      // to be retrieve in TooltipView, we prepare parameters here.
      valueLabelOpt: {
        precision: axisPointerModel.get(['label', 'precision']),
        formatter: axisPointerModel.get(['label', 'formatter'])
      },
      seriesDataIndices: payloadBatch.slice()
    })
  }

  function updateModelActually (showValueMap, axesInfo, outputPayload) {
    const outputAxesInfo = outputPayload.axesInfo = [] // Basic logic: If no 'show' required, 'hide' this axisPointer.

    each(axesInfo, function (axisInfo, key) {
      const option = axisInfo.axisPointerModel.option
      const valItem = showValueMap[key]

      if (valItem) {
        !axisInfo.useHandle && (option.status = 'show')
        option.value = valItem.value // For label formatter param and highlight.

        option.seriesDataIndices = (valItem.payloadBatch || []).slice()
      } // When always show (e.g., handle used), remain
      // original value and status.
      else {
        // If hide, value still need to be set, consider
        // click legend to toggle axis blank.
        !axisInfo.useHandle && (option.status = 'hide')
      } // If status is 'hide', should be no info in payload.

      option.status === 'show' && outputAxesInfo.push({
        axisDim: axisInfo.axis.dim,
        axisIndex: axisInfo.axis.model.componentIndex,
        value: option.value
      })
    })
  }

  function dispatchTooltipActually (dataByCoordSys, point, payload, dispatchAction) {
    // Basic logic: If no showTip required, hideTip will be dispatched.
    if (illegalPoint(point) || !dataByCoordSys.list.length) {
      dispatchAction({
        type: 'hideTip'
      })
      return
    } // In most case only one axis (or event one series is used). It is
    // convinient to fetch payload.seriesIndex and payload.dataIndex
    // dirtectly. So put the first seriesIndex and dataIndex of the first
    // axis on the payload.

    const sampleItem = ((dataByCoordSys.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {}
    dispatchAction({
      type: 'showTip',
      escapeConnect: true,
      x: point[0],
      y: point[1],
      tooltipOption: payload.tooltipOption,
      position: payload.position,
      dataIndexInside: sampleItem.dataIndexInside,
      dataIndex: sampleItem.dataIndex,
      seriesIndex: sampleItem.seriesIndex,
      dataByCoordSys: dataByCoordSys.list
    })
  }

  function dispatchHighDownActually (axesInfo, dispatchAction, api) {
    // FIXME
    // highlight status modification shoule be a stage of main process?
    // (Consider confilct (e.g., legend and axisPointer) and setOption)
    const zr = api.getZr()
    const highDownKey = 'axisPointerLastHighlights'
    const lastHighlights = inner$c(zr)[highDownKey] || {}
    const newHighlights = inner$c(zr)[highDownKey] = {} // Update highlight/downplay status according to axisPointer model.
    // Build hash map and remove duplicate incidentally.

    each(axesInfo, function (axisInfo, key) {
      const option = axisInfo.axisPointerModel.option
      option.status === 'show' && each(option.seriesDataIndices, function (batchItem) {
        const key = batchItem.seriesIndex + ' | ' + batchItem.dataIndex
        newHighlights[key] = batchItem
      })
    }) // Diff.

    const toHighlight = []
    const toDownplay = []
    each(lastHighlights, function (batchItem, key) {
      !newHighlights[key] && toDownplay.push(batchItem)
    })
    each(newHighlights, function (batchItem, key) {
      !lastHighlights[key] && toHighlight.push(batchItem)
    })
    toDownplay.length && api.dispatchAction({
      type: 'downplay',
      escapeConnect: true,
      // Not blur others when highlight in axisPointer.
      notBlur: true,
      batch: toDownplay
    })
    toHighlight.length && api.dispatchAction({
      type: 'highlight',
      escapeConnect: true,
      // Not blur others when highlight in axisPointer.
      notBlur: true,
      batch: toHighlight
    })
  }

  function findInputAxisInfo (inputAxesInfo, axisInfo) {
    for (let i = 0; i < (inputAxesInfo || []).length; i++) {
      const inputAxisInfo = inputAxesInfo[i]

      if (axisInfo.axis.dim === inputAxisInfo.axisDim && axisInfo.axis.model.componentIndex === inputAxisInfo.axisIndex) {
        return inputAxisInfo
      }
    }
  }

  function makeMapperParam (axisInfo) {
    const axisModel = axisInfo.axis.model
    const item = {}
    const dim = item.axisDim = axisInfo.axis.dim
    item.axisIndex = item[dim + 'AxisIndex'] = axisModel.componentIndex
    item.axisName = item[dim + 'AxisName'] = axisModel.name
    item.axisId = item[dim + 'AxisId'] = axisModel.id
    return item
  }

  function illegalPoint (point) {
    return !point || point[0] == null || isNaN(point[0]) || point[1] == null || isNaN(point[1])
  }

  function install$s (registers) {
    // CartesianAxisPointer is not supposed to be required here. But consider
    // echarts.simple.js and online build tooltip, which only require gridSimple,
    // CartesianAxisPointer should be able to required somewhere.
    AxisView.registerAxisPointerClass('CartesianAxisPointer', CartesianAxisPointer)
    registers.registerComponentModel(AxisPointerModel)
    registers.registerComponentView(AxisPointerView)
    registers.registerPreprocessor(function (option) {
      // Always has a global axisPointerModel for default setting.
      if (option) {
        (!option.axisPointer || option.axisPointer.length === 0) && (option.axisPointer = {})
        const link = option.axisPointer.link // Normalize to array to avoid object mergin. But if link
        // is not set, remain null/undefined, otherwise it will
        // override existent link setting.

        if (link && !isArray(link)) {
          option.axisPointer.link = [link]
        }
      }
    }) // This process should proformed after coordinate systems created
    // and series data processed. So put it on statistic processing stage.

    registers.registerProcessor(registers.PRIORITY.PROCESSOR.STATISTIC, function (ecModel, api) {
      // Build axisPointerModel, mergin tooltip.axisPointer model for each axis.
      // allAxesInfo should be updated when setOption performed.
      ecModel.getComponent('axisPointer').coordSysAxesInfo = collect(ecModel, api)
    }) // Broadcast to all views.

    registers.registerAction({
      type: 'updateAxisPointer',
      event: 'updateAxisPointer',
      update: ':updateAxisPointer'
    }, axisTrigger)
  }

  function install$t (registers) {
    use(install$5)
    use(install$s)
  }

  const PolarAxisPointer =
    /** @class */
    (function (_super) {
      __extends(PolarAxisPointer, _super)

      function PolarAxisPointer () {
        return _super !== null && _super.apply(this, arguments) || this
      }
      /**
       * @override
       */

      PolarAxisPointer.prototype.makeElOption = function (elOption, value, axisModel, axisPointerModel, api) {
        const axis = axisModel.axis

        if (axis.dim === 'angle') {
          this.animationThreshold = Math.PI / 18
        }

        const polar = axis.polar
        const otherAxis = polar.getOtherAxis(axis)
        const otherExtent = otherAxis.getExtent()
        const coordValue = axis.dataToCoord(value)
        const axisPointerType = axisPointerModel.get('type')

        if (axisPointerType && axisPointerType !== 'none') {
          const elStyle = buildElStyle(axisPointerModel)
          const pointerOption = pointerShapeBuilder$1[axisPointerType](axis, polar, coordValue, otherExtent)
          pointerOption.style = elStyle
          elOption.graphicKey = pointerOption.type
          elOption.pointer = pointerOption
        }

        const labelMargin = axisPointerModel.get(['label', 'margin'])
        const labelPos = getLabelPosition(value, axisModel, axisPointerModel, polar, labelMargin)
        buildLabelElOption(elOption, axisModel, axisPointerModel, api, labelPos)
      }

      return PolarAxisPointer
    }(BaseAxisPointer))

  function getLabelPosition (value, axisModel, axisPointerModel, polar, labelMargin) {
    const axis = axisModel.axis
    const coord = axis.dataToCoord(value)
    let axisAngle = polar.getAngleAxis().getExtent()[0]
    axisAngle = axisAngle / 180 * Math.PI
    const radiusExtent = polar.getRadiusAxis().getExtent()
    let position
    let align
    let verticalAlign

    if (axis.dim === 'radius') {
      const transform = create$1()
      rotate(transform, transform, axisAngle)
      translate(transform, transform, [polar.cx, polar.cy])
      position = applyTransform$1([coord, -labelMargin], transform)
      const labelRotation = axisModel.getModel('axisLabel').get('rotate') || 0 // @ts-ignore

      const labelLayout = AxisBuilder.innerTextLayout(axisAngle, labelRotation * Math.PI / 180, -1)
      align = labelLayout.textAlign
      verticalAlign = labelLayout.textVerticalAlign
    } else {
      // angle axis
      const r = radiusExtent[1]
      position = polar.coordToPoint([r + labelMargin, coord])
      const cx = polar.cx
      const cy = polar.cy
      align = Math.abs(position[0] - cx) / r < 0.3 ? 'center' : position[0] > cx ? 'left' : 'right'
      verticalAlign = Math.abs(position[1] - cy) / r < 0.3 ? 'middle' : position[1] > cy ? 'top' : 'bottom'
    }

    return {
      position: position,
      align: align,
      verticalAlign: verticalAlign
    }
  }

  var pointerShapeBuilder$1 = {
    line: function (axis, polar, coordValue, otherExtent) {
      return axis.dim === 'angle'
        ? {
            type: 'Line',
            shape: makeLineShape(polar.coordToPoint([otherExtent[0], coordValue]), polar.coordToPoint([otherExtent[1], coordValue]))
          }
        : {
            type: 'Circle',
            shape: {
              cx: polar.cx,
              cy: polar.cy,
              r: coordValue
            }
          }
    },
    shadow: function (axis, polar, coordValue, otherExtent) {
      const bandWidth = Math.max(1, axis.getBandWidth())
      const radian = Math.PI / 180
      return axis.dim === 'angle' ? {
        type: 'Sector',
        shape: makeSectorShape(polar.cx, polar.cy, otherExtent[0], otherExtent[1], // In ECharts y is negative if angle is positive
          (-coordValue - bandWidth / 2) * radian, (-coordValue + bandWidth / 2) * radian)
      } : {
        type: 'Sector',
        shape: makeSectorShape(polar.cx, polar.cy, coordValue - bandWidth / 2, coordValue + bandWidth / 2, 0, Math.PI * 2)
      }
    }
  }

  const PolarModel =
    /** @class */
    (function (_super) {
      __extends(PolarModel, _super)

      function PolarModel () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = PolarModel.type
        return _this
      }

      PolarModel.prototype.findAxisModel = function (axisType) {
        let foundAxisModel
        const ecModel = this.ecModel
        ecModel.eachComponent(axisType, function (axisModel) {
          if (axisModel.getCoordSysModel() === this) {
            foundAxisModel = axisModel
          }
        }, this)
        return foundAxisModel
      }

      PolarModel.type = 'polar'
      PolarModel.dependencies = ['radiusAxis', 'angleAxis']
      PolarModel.defaultOption = {
        // zlevel: 0,
        z: 0,
        center: ['50%', '50%'],
        radius: '80%'
      }
      return PolarModel
    }(ComponentModel))

  const PolarAxisModel =
    /** @class */
    (function (_super) {
      __extends(PolarAxisModel, _super)

      function PolarAxisModel () {
        return _super !== null && _super.apply(this, arguments) || this
      }

      PolarAxisModel.prototype.getCoordSysModel = function () {
        return this.getReferringComponents('polar', SINGLE_REFERRING).models[0]
      }

      PolarAxisModel.type = 'polarAxis'
      return PolarAxisModel
    }(ComponentModel))

  mixin(PolarAxisModel, AxisModelCommonMixin)

  const AngleAxisModel =
    /** @class */
    (function (_super) {
      __extends(AngleAxisModel, _super)

      function AngleAxisModel () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = AngleAxisModel.type
        return _this
      }

      AngleAxisModel.type = 'angleAxis'
      return AngleAxisModel
    }(PolarAxisModel))

  const RadiusAxisModel =
    /** @class */
    (function (_super) {
      __extends(RadiusAxisModel, _super)

      function RadiusAxisModel () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = RadiusAxisModel.type
        return _this
      }

      RadiusAxisModel.type = 'radiusAxis'
      return RadiusAxisModel
    }(PolarAxisModel))

  const RadiusAxis =
    /** @class */
    (function (_super) {
      __extends(RadiusAxis, _super)

      function RadiusAxis (scale, radiusExtent) {
        return _super.call(this, 'radius', scale, radiusExtent) || this
      }

      RadiusAxis.prototype.pointToData = function (point, clamp) {
        return this.polar.pointToData(point, clamp)[this.dim === 'radius' ? 0 : 1]
      }

      return RadiusAxis
    }(Axis))

  RadiusAxis.prototype.dataToRadius = Axis.prototype.dataToCoord
  RadiusAxis.prototype.radiusToData = Axis.prototype.coordToData

  const inner$d = makeInner()

  const AngleAxis =
    /** @class */
    (function (_super) {
      __extends(AngleAxis, _super)

      function AngleAxis (scale, angleExtent) {
        return _super.call(this, 'angle', scale, angleExtent || [0, 360]) || this
      }

      AngleAxis.prototype.pointToData = function (point, clamp) {
        return this.polar.pointToData(point, clamp)[this.dim === 'radius' ? 0 : 1]
      }
      /**
       * Only be called in category axis.
       * Angle axis uses text height to decide interval
       *
       * @override
       * @return {number} Auto interval for cateogry axis tick and label
       */

      AngleAxis.prototype.calculateCategoryInterval = function () {
        const axis = this
        const labelModel = axis.getLabelModel()
        const ordinalScale = axis.scale
        const ordinalExtent = ordinalScale.getExtent() // Providing this method is for optimization:
        // avoid generating a long array by `getTicks`
        // in large category data case.

        const tickCount = ordinalScale.count()

        if (ordinalExtent[1] - ordinalExtent[0] < 1) {
          return 0
        }

        const tickValue = ordinalExtent[0]
        const unitSpan = axis.dataToCoord(tickValue + 1) - axis.dataToCoord(tickValue)
        const unitH = Math.abs(unitSpan) // Not precise, just use height as text width
        // and each distance from axis line yet.

        const rect = getBoundingRect(tickValue == null ? '' : tickValue + '', labelModel.getFont(), 'center', 'top')
        const maxH = Math.max(rect.height, 7)
        let dh = maxH / unitH // 0/0 is NaN, 1/0 is Infinity.

        isNaN(dh) && (dh = Infinity)
        let interval = Math.max(0, Math.floor(dh))
        const cache = inner$d(axis.model)
        const lastAutoInterval = cache.lastAutoInterval
        const lastTickCount = cache.lastTickCount // Use cache to keep interval stable while moving zoom window,
        // otherwise the calculated interval might jitter when the zoom
        // window size is close to the interval-changing size.

        if (lastAutoInterval != null && lastTickCount != null && Math.abs(lastAutoInterval - interval) <= 1 && Math.abs(lastTickCount - tickCount) <= 1 && // Always choose the bigger one, otherwise the critical
        // point is not the same when zooming in or zooming out.
        lastAutoInterval > interval) {
          interval = lastAutoInterval
        } // Only update cache if cache not used, otherwise the
        // changing of interval is too insensitive.
        else {
          cache.lastTickCount = tickCount
          cache.lastAutoInterval = interval
        }

        return interval
      }

      return AngleAxis
    }(Axis))

  AngleAxis.prototype.dataToAngle = Axis.prototype.dataToCoord
  AngleAxis.prototype.angleToData = Axis.prototype.coordToData

  const polarDimensions = ['radius', 'angle']

  const Polar =
    /** @class */
    (function () {
      function Polar (name) {
        this.dimensions = polarDimensions
        this.type = 'polar'
        /**
         * x of polar center
         */

        this.cx = 0
        /**
         * y of polar center
         */

        this.cy = 0
        this._radiusAxis = new RadiusAxis()
        this._angleAxis = new AngleAxis()
        this.axisPointerEnabled = true
        this.name = name || ''
        this._radiusAxis.polar = this._angleAxis.polar = this
      }
      /**
       * If contain coord
       */

      Polar.prototype.containPoint = function (point) {
        const coord = this.pointToCoord(point)
        return this._radiusAxis.contain(coord[0]) && this._angleAxis.contain(coord[1])
      }
      /**
       * If contain data
       */

      Polar.prototype.containData = function (data) {
        return this._radiusAxis.containData(data[0]) && this._angleAxis.containData(data[1])
      }

      Polar.prototype.getAxis = function (dim) {
        const key = '_' + dim + 'Axis'
        return this[key]
      }

      Polar.prototype.getAxes = function () {
        return [this._radiusAxis, this._angleAxis]
      }
      /**
       * Get axes by type of scale
       */

      Polar.prototype.getAxesByScale = function (scaleType) {
        const axes = []
        const angleAxis = this._angleAxis
        const radiusAxis = this._radiusAxis
        angleAxis.scale.type === scaleType && axes.push(angleAxis)
        radiusAxis.scale.type === scaleType && axes.push(radiusAxis)
        return axes
      }

      Polar.prototype.getAngleAxis = function () {
        return this._angleAxis
      }

      Polar.prototype.getRadiusAxis = function () {
        return this._radiusAxis
      }

      Polar.prototype.getOtherAxis = function (axis) {
        const angleAxis = this._angleAxis
        return axis === angleAxis ? this._radiusAxis : angleAxis
      }
      /**
       * Base axis will be used on stacking.
       *
       */

      Polar.prototype.getBaseAxis = function () {
        return this.getAxesByScale('ordinal')[0] || this.getAxesByScale('time')[0] || this.getAngleAxis()
      }

      Polar.prototype.getTooltipAxes = function (dim) {
        const baseAxis = dim != null && dim !== 'auto' ? this.getAxis(dim) : this.getBaseAxis()
        return {
          baseAxes: [baseAxis],
          otherAxes: [this.getOtherAxis(baseAxis)]
        }
      }
      /**
       * Convert a single data item to (x, y) point.
       * Parameter data is an array which the first element is radius and the second is angle
       */

      Polar.prototype.dataToPoint = function (data, clamp) {
        return this.coordToPoint([this._radiusAxis.dataToRadius(data[0], clamp), this._angleAxis.dataToAngle(data[1], clamp)])
      }
      /**
       * Convert a (x, y) point to data
       */

      Polar.prototype.pointToData = function (point, clamp) {
        const coord = this.pointToCoord(point)
        return [this._radiusAxis.radiusToData(coord[0], clamp), this._angleAxis.angleToData(coord[1], clamp)]
      }
      /**
       * Convert a (x, y) point to (radius, angle) coord
       */

      Polar.prototype.pointToCoord = function (point) {
        let dx = point[0] - this.cx
        let dy = point[1] - this.cy
        const angleAxis = this.getAngleAxis()
        const extent = angleAxis.getExtent()
        let minAngle = Math.min(extent[0], extent[1])
        let maxAngle = Math.max(extent[0], extent[1]) // Fix fixed extent in polarCreator
        // FIXME

        angleAxis.inverse ? minAngle = maxAngle - 360 : maxAngle = minAngle + 360
        const radius = Math.sqrt(dx * dx + dy * dy)
        dx /= radius
        dy /= radius
        let radian = Math.atan2(-dy, dx) / Math.PI * 180 // move to angleExtent

        const dir = radian < minAngle ? 1 : -1

        while (radian < minAngle || radian > maxAngle) {
          radian += dir * 360
        }

        return [radius, radian]
      }
      /**
       * Convert a (radius, angle) coord to (x, y) point
       */

      Polar.prototype.coordToPoint = function (coord) {
        const radius = coord[0]
        const radian = coord[1] / 180 * Math.PI
        const x = Math.cos(radian) * radius + this.cx // Inverse the y

        const y = -Math.sin(radian) * radius + this.cy
        return [x, y]
      }
      /**
       * Get ring area of cartesian.
       * Area will have a contain function to determine if a point is in the coordinate system.
       */

      Polar.prototype.getArea = function () {
        const angleAxis = this.getAngleAxis()
        const radiusAxis = this.getRadiusAxis()
        const radiusExtent = radiusAxis.getExtent().slice()
        radiusExtent[0] > radiusExtent[1] && radiusExtent.reverse()
        const angleExtent = angleAxis.getExtent()
        const RADIAN = Math.PI / 180
        return {
          cx: this.cx,
          cy: this.cy,
          r0: radiusExtent[0],
          r: radiusExtent[1],
          startAngle: -angleExtent[0] * RADIAN,
          endAngle: -angleExtent[1] * RADIAN,
          clockwise: angleAxis.inverse,
          contain: function (x, y) {
            // It's a ring shape.
            // Start angle and end angle don't matter
            const dx = x - this.cx
            const dy = y - this.cy // minus a tiny value 1e-4 to avoid being clipped unexpectedly

            const d2 = dx * dx + dy * dy - 1e-4
            const r = this.r
            const r0 = this.r0
            return d2 <= r * r && d2 >= r0 * r0
          }
        }
      }

      Polar.prototype.convertToPixel = function (ecModel, finder, value) {
        const coordSys = getCoordSys$2(finder)
        return coordSys === this ? this.dataToPoint(value) : null
      }

      Polar.prototype.convertFromPixel = function (ecModel, finder, pixel) {
        const coordSys = getCoordSys$2(finder)
        return coordSys === this ? this.pointToData(pixel) : null
      }

      return Polar
    }())

  function getCoordSys$2 (finder) {
    const seriesModel = finder.seriesModel
    const polarModel = finder.polarModel
    return polarModel && polarModel.coordinateSystem || seriesModel && seriesModel.coordinateSystem
  }

  /**
     * Resize method bound to the polar
     */

  function resizePolar (polar, polarModel, api) {
    const center = polarModel.get('center')
    const width = api.getWidth()
    const height = api.getHeight()
    polar.cx = parsePercent$1(center[0], width)
    polar.cy = parsePercent$1(center[1], height)
    const radiusAxis = polar.getRadiusAxis()
    const size = Math.min(width, height) / 2
    let radius = polarModel.get('radius')

    if (radius == null) {
      radius = [0, '100%']
    } else if (!isArray(radius)) {
      // r0 = 0
      radius = [0, radius]
    }

    const parsedRadius = [parsePercent$1(radius[0], size), parsePercent$1(radius[1], size)]
    radiusAxis.inverse ? radiusAxis.setExtent(parsedRadius[1], parsedRadius[0]) : radiusAxis.setExtent(parsedRadius[0], parsedRadius[1])
  }
  /**
     * Update polar
     */

  function updatePolarScale (ecModel, api) {
    const polar = this
    const angleAxis = polar.getAngleAxis()
    const radiusAxis = polar.getRadiusAxis() // Reset scale

    angleAxis.scale.setExtent(Infinity, -Infinity)
    radiusAxis.scale.setExtent(Infinity, -Infinity)
    ecModel.eachSeries(function (seriesModel) {
      if (seriesModel.coordinateSystem === polar) {
        const data_1 = seriesModel.getData()
        each(getDataDimensionsOnAxis(data_1, 'radius'), function (dim) {
          radiusAxis.scale.unionExtentFromData(data_1, dim)
        })
        each(getDataDimensionsOnAxis(data_1, 'angle'), function (dim) {
          angleAxis.scale.unionExtentFromData(data_1, dim)
        })
      }
    })
    niceScaleExtent(angleAxis.scale, angleAxis.model)
    niceScaleExtent(radiusAxis.scale, radiusAxis.model) // Fix extent of category angle axis

    if (angleAxis.type === 'category' && !angleAxis.onBand) {
      const extent = angleAxis.getExtent()
      const diff = 360 / angleAxis.scale.count()
      angleAxis.inverse ? extent[1] += diff : extent[1] -= diff
      angleAxis.setExtent(extent[0], extent[1])
    }
  }

  function isAngleAxisModel (axisModel) {
    return axisModel.mainType === 'angleAxis'
  }
  /**
     * Set common axis properties
     */

  function setAxis (axis, axisModel) {
    axis.type = axisModel.get('type')
    axis.scale = createScaleByModel(axisModel)
    axis.onBand = axisModel.get('boundaryGap') && axis.type === 'category'
    axis.inverse = axisModel.get('inverse')

    if (isAngleAxisModel(axisModel)) {
      axis.inverse = axis.inverse !== axisModel.get('clockwise')
      const startAngle = axisModel.get('startAngle')
      axis.setExtent(startAngle, startAngle + (axis.inverse ? -360 : 360))
    } // Inject axis instance

    axisModel.axis = axis
    axis.model = axisModel
  }

  const polarCreator = {
    dimensions: polarDimensions,
    create: function (ecModel, api) {
      const polarList = []
      ecModel.eachComponent('polar', function (polarModel, idx) {
        const polar = new Polar(idx + '') // Inject resize and update method

        polar.update = updatePolarScale
        const radiusAxis = polar.getRadiusAxis()
        const angleAxis = polar.getAngleAxis()
        const radiusAxisModel = polarModel.findAxisModel('radiusAxis')
        const angleAxisModel = polarModel.findAxisModel('angleAxis')
        setAxis(radiusAxis, radiusAxisModel)
        setAxis(angleAxis, angleAxisModel)
        resizePolar(polar, polarModel, api)
        polarList.push(polar)
        polarModel.coordinateSystem = polar
        polar.model = polarModel
      }) // Inject coordinateSystem to series

      ecModel.eachSeries(function (seriesModel) {
        if (seriesModel.get('coordinateSystem') === 'polar') {
          const polarModel = seriesModel.getReferringComponents('polar', SINGLE_REFERRING).models[0]

          if ('development' !== 'production') {
            if (!polarModel) {
              throw new Error('Polar "' + retrieve(seriesModel.get('polarIndex'), seriesModel.get('polarId'), 0) + '" not found')
            }
          }

          seriesModel.coordinateSystem = polarModel.coordinateSystem
        }
      })
      return polarList
    }
  }

  const elementList$1 = ['axisLine', 'axisLabel', 'axisTick', 'minorTick', 'splitLine', 'minorSplitLine', 'splitArea']

  function getAxisLineShape (polar, rExtent, angle) {
    rExtent[1] > rExtent[0] && (rExtent = rExtent.slice().reverse())
    const start = polar.coordToPoint([rExtent[0], angle])
    const end = polar.coordToPoint([rExtent[1], angle])
    return {
      x1: start[0],
      y1: start[1],
      x2: end[0],
      y2: end[1]
    }
  }

  function getRadiusIdx (polar) {
    const radiusAxis = polar.getRadiusAxis()
    return radiusAxis.inverse ? 0 : 1
  } // Remove the last tick which will overlap the first tick

  function fixAngleOverlap (list) {
    const firstItem = list[0]
    const lastItem = list[list.length - 1]

    if (firstItem && lastItem && Math.abs(Math.abs(firstItem.coord - lastItem.coord) - 360) < 1e-4) {
      list.pop()
    }
  }

  const AngleAxisView =
    /** @class */
    (function (_super) {
      __extends(AngleAxisView, _super)

      function AngleAxisView () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = AngleAxisView.type
        _this.axisPointerClass = 'PolarAxisPointer'
        return _this
      }

      AngleAxisView.prototype.render = function (angleAxisModel, ecModel) {
        this.group.removeAll()

        if (!angleAxisModel.get('show')) {
          return
        }

        const angleAxis = angleAxisModel.axis
        const polar = angleAxis.polar
        const radiusExtent = polar.getRadiusAxis().getExtent()
        const ticksAngles = angleAxis.getTicksCoords()
        const minorTickAngles = angleAxis.getMinorTicksCoords()
        const labels = map(angleAxis.getViewLabels(), function (labelItem) {
          labelItem = clone(labelItem)
          const scale = angleAxis.scale
          const tickValue = scale.type === 'ordinal' ? scale.getRawOrdinalNumber(labelItem.tickValue) : labelItem.tickValue
          labelItem.coord = angleAxis.dataToCoord(tickValue)
          return labelItem
        })
        fixAngleOverlap(labels)
        fixAngleOverlap(ticksAngles)
        each(elementList$1, function (name) {
          if (angleAxisModel.get([name, 'show']) && (!angleAxis.scale.isBlank() || name === 'axisLine')) {
            angelAxisElementsBuilders[name](this.group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent, labels)
          }
        }, this)
      }

      AngleAxisView.type = 'angleAxis'
      return AngleAxisView
    }(AxisView))

  var angelAxisElementsBuilders = {
    axisLine: function (group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {
      const lineStyleModel = angleAxisModel.getModel(['axisLine', 'lineStyle']) // extent id of the axis radius (r0 and r)

      const rId = getRadiusIdx(polar)
      const r0Id = rId ? 0 : 1
      let shape

      if (radiusExtent[r0Id] === 0) {
        shape = new Circle({
          shape: {
            cx: polar.cx,
            cy: polar.cy,
            r: radiusExtent[rId]
          },
          style: lineStyleModel.getLineStyle(),
          z2: 1,
          silent: true
        })
      } else {
        shape = new Ring({
          shape: {
            cx: polar.cx,
            cy: polar.cy,
            r: radiusExtent[rId],
            r0: radiusExtent[r0Id]
          },
          style: lineStyleModel.getLineStyle(),
          z2: 1,
          silent: true
        })
      }

      shape.style.fill = null
      group.add(shape)
    },
    axisTick: function (group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {
      const tickModel = angleAxisModel.getModel('axisTick')
      const tickLen = (tickModel.get('inside') ? -1 : 1) * tickModel.get('length')
      const radius = radiusExtent[getRadiusIdx(polar)]
      const lines = map(ticksAngles, function (tickAngleItem) {
        return new Line({
          shape: getAxisLineShape(polar, [radius, radius + tickLen], tickAngleItem.coord)
        })
      })
      group.add(mergePath$1(lines, {
        style: defaults(tickModel.getModel('lineStyle').getLineStyle(), {
          stroke: angleAxisModel.get(['axisLine', 'lineStyle', 'color'])
        })
      }))
    },
    minorTick: function (group, angleAxisModel, polar, tickAngles, minorTickAngles, radiusExtent) {
      if (!minorTickAngles.length) {
        return
      }

      const tickModel = angleAxisModel.getModel('axisTick')
      const minorTickModel = angleAxisModel.getModel('minorTick')
      const tickLen = (tickModel.get('inside') ? -1 : 1) * minorTickModel.get('length')
      const radius = radiusExtent[getRadiusIdx(polar)]
      const lines = []

      for (let i = 0; i < minorTickAngles.length; i++) {
        for (let k = 0; k < minorTickAngles[i].length; k++) {
          lines.push(new Line({
            shape: getAxisLineShape(polar, [radius, radius + tickLen], minorTickAngles[i][k].coord)
          }))
        }
      }

      group.add(mergePath$1(lines, {
        style: defaults(minorTickModel.getModel('lineStyle').getLineStyle(), defaults(tickModel.getLineStyle(), {
          stroke: angleAxisModel.get(['axisLine', 'lineStyle', 'color'])
        }))
      }))
    },
    axisLabel: function (group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent, labels) {
      const rawCategoryData = angleAxisModel.getCategories(true)
      const commonLabelModel = angleAxisModel.getModel('axisLabel')
      const labelMargin = commonLabelModel.get('margin')
      const triggerEvent = angleAxisModel.get('triggerEvent') // Use length of ticksAngles because it may remove the last tick to avoid overlapping

      each(labels, function (labelItem, idx) {
        let labelModel = commonLabelModel
        const tickValue = labelItem.tickValue
        const r = radiusExtent[getRadiusIdx(polar)]
        const p = polar.coordToPoint([r + labelMargin, labelItem.coord])
        const cx = polar.cx
        const cy = polar.cy
        const labelTextAlign = Math.abs(p[0] - cx) / r < 0.3 ? 'center' : p[0] > cx ? 'left' : 'right'
        const labelTextVerticalAlign = Math.abs(p[1] - cy) / r < 0.3 ? 'middle' : p[1] > cy ? 'top' : 'bottom'

        if (rawCategoryData && rawCategoryData[tickValue]) {
          const rawCategoryItem = rawCategoryData[tickValue]

          if (isObject(rawCategoryItem) && rawCategoryItem.textStyle) {
            labelModel = new Model(rawCategoryItem.textStyle, commonLabelModel, commonLabelModel.ecModel)
          }
        }

        const textEl = new ZRText({
          silent: AxisBuilder.isLabelSilent(angleAxisModel),
          style: createTextStyle(labelModel, {
            x: p[0],
            y: p[1],
            fill: labelModel.getTextColor() || angleAxisModel.get(['axisLine', 'lineStyle', 'color']),
            text: labelItem.formattedLabel,
            align: labelTextAlign,
            verticalAlign: labelTextVerticalAlign
          })
        })
        group.add(textEl) // Pack data for mouse event

        if (triggerEvent) {
          const eventData = AxisBuilder.makeAxisEventDataBase(angleAxisModel)
          eventData.targetType = 'axisLabel'
          eventData.value = labelItem.rawLabel
          getECData(textEl).eventData = eventData
        }
      }, this)
    },
    splitLine: function (group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {
      const splitLineModel = angleAxisModel.getModel('splitLine')
      const lineStyleModel = splitLineModel.getModel('lineStyle')
      let lineColors = lineStyleModel.get('color')
      let lineCount = 0
      lineColors = lineColors instanceof Array ? lineColors : [lineColors]
      const splitLines = []

      for (var i = 0; i < ticksAngles.length; i++) {
        const colorIndex = lineCount++ % lineColors.length
        splitLines[colorIndex] = splitLines[colorIndex] || []
        splitLines[colorIndex].push(new Line({
          shape: getAxisLineShape(polar, radiusExtent, ticksAngles[i].coord)
        }))
      } // Simple optimization
      // Batching the lines if color are the same

      for (var i = 0; i < splitLines.length; i++) {
        group.add(mergePath$1(splitLines[i], {
          style: defaults({
            stroke: lineColors[i % lineColors.length]
          }, lineStyleModel.getLineStyle()),
          silent: true,
          z: angleAxisModel.get('z')
        }))
      }
    },
    minorSplitLine: function (group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {
      if (!minorTickAngles.length) {
        return
      }

      const minorSplitLineModel = angleAxisModel.getModel('minorSplitLine')
      const lineStyleModel = minorSplitLineModel.getModel('lineStyle')
      const lines = []

      for (let i = 0; i < minorTickAngles.length; i++) {
        for (let k = 0; k < minorTickAngles[i].length; k++) {
          lines.push(new Line({
            shape: getAxisLineShape(polar, radiusExtent, minorTickAngles[i][k].coord)
          }))
        }
      }

      group.add(mergePath$1(lines, {
        style: lineStyleModel.getLineStyle(),
        silent: true,
        z: angleAxisModel.get('z')
      }))
    },
    splitArea: function (group, angleAxisModel, polar, ticksAngles, minorTickAngles, radiusExtent) {
      if (!ticksAngles.length) {
        return
      }

      const splitAreaModel = angleAxisModel.getModel('splitArea')
      const areaStyleModel = splitAreaModel.getModel('areaStyle')
      let areaColors = areaStyleModel.get('color')
      let lineCount = 0
      areaColors = areaColors instanceof Array ? areaColors : [areaColors]
      const splitAreas = []
      const RADIAN = Math.PI / 180
      let prevAngle = -ticksAngles[0].coord * RADIAN
      const r0 = Math.min(radiusExtent[0], radiusExtent[1])
      const r1 = Math.max(radiusExtent[0], radiusExtent[1])
      const clockwise = angleAxisModel.get('clockwise')

      for (var i = 1, len = ticksAngles.length; i <= len; i++) {
        const coord = i === len ? ticksAngles[0].coord : ticksAngles[i].coord
        const colorIndex = lineCount++ % areaColors.length
        splitAreas[colorIndex] = splitAreas[colorIndex] || []
        splitAreas[colorIndex].push(new Sector({
          shape: {
            cx: polar.cx,
            cy: polar.cy,
            r0: r0,
            r: r1,
            startAngle: prevAngle,
            endAngle: -coord * RADIAN,
            clockwise: clockwise
          },
          silent: true
        }))
        prevAngle = -coord * RADIAN
      } // Simple optimization
      // Batching the lines if color are the same

      for (var i = 0; i < splitAreas.length; i++) {
        group.add(mergePath$1(splitAreas[i], {
          style: defaults({
            fill: areaColors[i % areaColors.length]
          }, areaStyleModel.getAreaStyle()),
          silent: true
        }))
      }
    }
  }

  const axisBuilderAttrs$2 = ['axisLine', 'axisTickLabel', 'axisName']
  const selfBuilderAttrs$1 = ['splitLine', 'splitArea', 'minorSplitLine']

  const RadiusAxisView =
    /** @class */
    (function (_super) {
      __extends(RadiusAxisView, _super)

      function RadiusAxisView () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = RadiusAxisView.type
        _this.axisPointerClass = 'PolarAxisPointer'
        return _this
      }

      RadiusAxisView.prototype.render = function (radiusAxisModel, ecModel) {
        this.group.removeAll()

        if (!radiusAxisModel.get('show')) {
          return
        }

        const oldAxisGroup = this._axisGroup
        const newAxisGroup = this._axisGroup = new Group()
        this.group.add(newAxisGroup)
        const radiusAxis = radiusAxisModel.axis
        const polar = radiusAxis.polar
        const angleAxis = polar.getAngleAxis()
        const ticksCoords = radiusAxis.getTicksCoords()
        const minorTicksCoords = radiusAxis.getMinorTicksCoords()
        const axisAngle = angleAxis.getExtent()[0]
        const radiusExtent = radiusAxis.getExtent()
        const layout = layoutAxis(polar, radiusAxisModel, axisAngle)
        const axisBuilder = new AxisBuilder(radiusAxisModel, layout)
        each(axisBuilderAttrs$2, axisBuilder.add, axisBuilder)
        newAxisGroup.add(axisBuilder.getGroup())
        groupTransition(oldAxisGroup, newAxisGroup, radiusAxisModel)
        each(selfBuilderAttrs$1, function (name) {
          if (radiusAxisModel.get([name, 'show']) && !radiusAxis.scale.isBlank()) {
            axisElementBuilders$1[name](this.group, radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords, minorTicksCoords)
          }
        }, this)
      }

      RadiusAxisView.type = 'radiusAxis'
      return RadiusAxisView
    }(AxisView))

  var axisElementBuilders$1 = {
    splitLine: function (group, radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords) {
      const splitLineModel = radiusAxisModel.getModel('splitLine')
      const lineStyleModel = splitLineModel.getModel('lineStyle')
      let lineColors = lineStyleModel.get('color')
      let lineCount = 0
      lineColors = lineColors instanceof Array ? lineColors : [lineColors]
      const splitLines = []

      for (var i = 0; i < ticksCoords.length; i++) {
        const colorIndex = lineCount++ % lineColors.length
        splitLines[colorIndex] = splitLines[colorIndex] || []
        splitLines[colorIndex].push(new Circle({
          shape: {
            cx: polar.cx,
            cy: polar.cy,
            // ensure circle radius >= 0
            r: Math.max(ticksCoords[i].coord, 0)
          }
        }))
      } // Simple optimization
      // Batching the lines if color are the same

      for (var i = 0; i < splitLines.length; i++) {
        group.add(mergePath$1(splitLines[i], {
          style: defaults({
            stroke: lineColors[i % lineColors.length],
            fill: null
          }, lineStyleModel.getLineStyle()),
          silent: true
        }))
      }
    },
    minorSplitLine: function (group, radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords, minorTicksCoords) {
      if (!minorTicksCoords.length) {
        return
      }

      const minorSplitLineModel = radiusAxisModel.getModel('minorSplitLine')
      const lineStyleModel = minorSplitLineModel.getModel('lineStyle')
      const lines = []

      for (let i = 0; i < minorTicksCoords.length; i++) {
        for (let k = 0; k < minorTicksCoords[i].length; k++) {
          lines.push(new Circle({
            shape: {
              cx: polar.cx,
              cy: polar.cy,
              r: minorTicksCoords[i][k].coord
            }
          }))
        }
      }

      group.add(mergePath$1(lines, {
        style: defaults({
          fill: null
        }, lineStyleModel.getLineStyle()),
        silent: true
      }))
    },
    splitArea: function (group, radiusAxisModel, polar, axisAngle, radiusExtent, ticksCoords) {
      if (!ticksCoords.length) {
        return
      }

      const splitAreaModel = radiusAxisModel.getModel('splitArea')
      const areaStyleModel = splitAreaModel.getModel('areaStyle')
      let areaColors = areaStyleModel.get('color')
      let lineCount = 0
      areaColors = areaColors instanceof Array ? areaColors : [areaColors]
      const splitAreas = []
      let prevRadius = ticksCoords[0].coord

      for (var i = 1; i < ticksCoords.length; i++) {
        const colorIndex = lineCount++ % areaColors.length
        splitAreas[colorIndex] = splitAreas[colorIndex] || []
        splitAreas[colorIndex].push(new Sector({
          shape: {
            cx: polar.cx,
            cy: polar.cy,
            r0: prevRadius,
            r: ticksCoords[i].coord,
            startAngle: 0,
            endAngle: Math.PI * 2
          },
          silent: true
        }))
        prevRadius = ticksCoords[i].coord
      } // Simple optimization
      // Batching the lines if color are the same

      for (var i = 0; i < splitAreas.length; i++) {
        group.add(mergePath$1(splitAreas[i], {
          style: defaults({
            fill: areaColors[i % areaColors.length]
          }, areaStyleModel.getAreaStyle()),
          silent: true
        }))
      }
    }
  }
  /**
     * @inner
     */

  function layoutAxis (polar, radiusAxisModel, axisAngle) {
    return {
      position: [polar.cx, polar.cy],
      rotation: axisAngle / 180 * Math.PI,
      labelDirection: -1,
      tickDirection: -1,
      nameDirection: 1,
      labelRotate: radiusAxisModel.getModel('axisLabel').get('rotate'),
      // Over splitLine and splitArea
      z2: 1
    }
  }

  function getSeriesStackId$1 (seriesModel) {
    return seriesModel.get('stack') || '__ec_stack_' + seriesModel.seriesIndex
  }

  function getAxisKey$1 (polar, axis) {
    return axis.dim + polar.model.componentIndex
  }

  function barLayoutPolar (seriesType, ecModel, api) {
    const lastStackCoords = {}
    const barWidthAndOffset = calRadialBar(filter(ecModel.getSeriesByType(seriesType), function (seriesModel) {
      return !ecModel.isSeriesFiltered(seriesModel) && seriesModel.coordinateSystem && seriesModel.coordinateSystem.type === 'polar'
    }))
    ecModel.eachSeriesByType(seriesType, function (seriesModel) {
      // Check series coordinate, do layout for polar only
      if (seriesModel.coordinateSystem.type !== 'polar') {
        return
      }

      const data = seriesModel.getData()
      const polar = seriesModel.coordinateSystem
      const baseAxis = polar.getBaseAxis()
      const axisKey = getAxisKey$1(polar, baseAxis)
      const stackId = getSeriesStackId$1(seriesModel)
      const columnLayoutInfo = barWidthAndOffset[axisKey][stackId]
      const columnOffset = columnLayoutInfo.offset
      const columnWidth = columnLayoutInfo.width
      const valueAxis = polar.getOtherAxis(baseAxis)
      const cx = seriesModel.coordinateSystem.cx
      const cy = seriesModel.coordinateSystem.cy
      const barMinHeight = seriesModel.get('barMinHeight') || 0
      const barMinAngle = seriesModel.get('barMinAngle') || 0
      lastStackCoords[stackId] = lastStackCoords[stackId] || []
      const valueDim = data.mapDimension(valueAxis.dim)
      const baseDim = data.mapDimension(baseAxis.dim)
      const stacked = isDimensionStacked(data, valueDim
        /*, baseDim */
      )
      const clampLayout = baseAxis.dim !== 'radius' || !seriesModel.get('roundCap', true)
      const valueAxisStart = valueAxis.dataToCoord(0)

      for (let idx = 0, len = data.count(); idx < len; idx++) {
        const value = data.get(valueDim, idx)
        const baseValue = data.get(baseDim, idx)
        const sign = value >= 0 ? 'p' : 'n'
        let baseCoord = valueAxisStart // Because of the barMinHeight, we can not use the value in
        // stackResultDimension directly.
        // Only ordinal axis can be stacked.

        if (stacked) {
          if (!lastStackCoords[stackId][baseValue]) {
            lastStackCoords[stackId][baseValue] = {
              p: valueAxisStart,
              n: valueAxisStart // Negative stack

            }
          } // Should also consider #4243

          baseCoord = lastStackCoords[stackId][baseValue][sign]
        }

        let r0 = void 0
        let r = void 0
        let startAngle = void 0
        let endAngle = void 0 // radial sector

        if (valueAxis.dim === 'radius') {
          let radiusSpan = valueAxis.dataToCoord(value) - valueAxisStart
          const angle = baseAxis.dataToCoord(baseValue)

          if (Math.abs(radiusSpan) < barMinHeight) {
            radiusSpan = (radiusSpan < 0 ? -1 : 1) * barMinHeight
          }

          r0 = baseCoord
          r = baseCoord + radiusSpan
          startAngle = angle - columnOffset
          endAngle = startAngle - columnWidth
          stacked && (lastStackCoords[stackId][baseValue][sign] = r)
        } // tangential sector
        else {
          let angleSpan = valueAxis.dataToCoord(value, clampLayout) - valueAxisStart
          const radius = baseAxis.dataToCoord(baseValue)

          if (Math.abs(angleSpan) < barMinAngle) {
            angleSpan = (angleSpan < 0 ? -1 : 1) * barMinAngle
          }

          r0 = radius + columnOffset
          r = r0 + columnWidth
          startAngle = baseCoord
          endAngle = baseCoord + angleSpan // if the previous stack is at the end of the ring,
          // add a round to differentiate it from origin
          // let extent = angleAxis.getExtent();
          // let stackCoord = angle;
          // if (stackCoord === extent[0] && value > 0) {
          //     stackCoord = extent[1];
          // }
          // else if (stackCoord === extent[1] && value < 0) {
          //     stackCoord = extent[0];
          // }

          stacked && (lastStackCoords[stackId][baseValue][sign] = endAngle)
        }

        data.setItemLayout(idx, {
          cx: cx,
          cy: cy,
          r0: r0,
          r: r,
          // Consider that positive angle is anti-clockwise,
          // while positive radian of sector is clockwise
          startAngle: -startAngle * Math.PI / 180,
          endAngle: -endAngle * Math.PI / 180,

          /**
             * Keep the same logic with bar in catesion: use end value to
             * control direction. Notice that if clockwise is true (by
             * default), the sector will always draw clockwisely, no matter
             * whether endAngle is greater or less than startAngle.
             */
          clockwise: startAngle >= endAngle
        })
      }
    })
  }
  /**
     * Calculate bar width and offset for radial bar charts
     */

  function calRadialBar (barSeries) {
    // Columns info on each category axis. Key is polar name
    const columnsMap = {}
    each(barSeries, function (seriesModel, idx) {
      const data = seriesModel.getData()
      const polar = seriesModel.coordinateSystem
      const baseAxis = polar.getBaseAxis()
      const axisKey = getAxisKey$1(polar, baseAxis)
      const axisExtent = baseAxis.getExtent()
      const bandWidth = baseAxis.type === 'category' ? baseAxis.getBandWidth() : Math.abs(axisExtent[1] - axisExtent[0]) / data.count()
      const columnsOnAxis = columnsMap[axisKey] || {
        bandWidth: bandWidth,
        remainedWidth: bandWidth,
        autoWidthCount: 0,
        categoryGap: '20%',
        gap: '30%',
        stacks: {}
      }
      const stacks = columnsOnAxis.stacks
      columnsMap[axisKey] = columnsOnAxis
      const stackId = getSeriesStackId$1(seriesModel)

      if (!stacks[stackId]) {
        columnsOnAxis.autoWidthCount++
      }

      stacks[stackId] = stacks[stackId] || {
        width: 0,
        maxWidth: 0
      }
      let barWidth = parsePercent$1(seriesModel.get('barWidth'), bandWidth)
      const barMaxWidth = parsePercent$1(seriesModel.get('barMaxWidth'), bandWidth)
      const barGap = seriesModel.get('barGap')
      const barCategoryGap = seriesModel.get('barCategoryGap')

      if (barWidth && !stacks[stackId].width) {
        barWidth = Math.min(columnsOnAxis.remainedWidth, barWidth)
        stacks[stackId].width = barWidth
        columnsOnAxis.remainedWidth -= barWidth
      }

      barMaxWidth && (stacks[stackId].maxWidth = barMaxWidth)
      barGap != null && (columnsOnAxis.gap = barGap)
      barCategoryGap != null && (columnsOnAxis.categoryGap = barCategoryGap)
    })
    const result = {}
    each(columnsMap, function (columnsOnAxis, coordSysName) {
      result[coordSysName] = {}
      const stacks = columnsOnAxis.stacks
      const bandWidth = columnsOnAxis.bandWidth
      const categoryGap = parsePercent$1(columnsOnAxis.categoryGap, bandWidth)
      const barGapPercent = parsePercent$1(columnsOnAxis.gap, 1)
      let remainedWidth = columnsOnAxis.remainedWidth
      let autoWidthCount = columnsOnAxis.autoWidthCount
      let autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent)
      autoWidth = Math.max(autoWidth, 0) // Find if any auto calculated bar exceeded maxBarWidth

      each(stacks, function (column, stack) {
        let maxWidth = column.maxWidth

        if (maxWidth && maxWidth < autoWidth) {
          maxWidth = Math.min(maxWidth, remainedWidth)

          if (column.width) {
            maxWidth = Math.min(maxWidth, column.width)
          }

          remainedWidth -= maxWidth
          column.width = maxWidth
          autoWidthCount--
        }
      }) // Recalculate width again

      autoWidth = (remainedWidth - categoryGap) / (autoWidthCount + (autoWidthCount - 1) * barGapPercent)
      autoWidth = Math.max(autoWidth, 0)
      let widthSum = 0
      let lastColumn
      each(stacks, function (column, idx) {
        if (!column.width) {
          column.width = autoWidth
        }

        lastColumn = column
        widthSum += column.width * (1 + barGapPercent)
      })

      if (lastColumn) {
        widthSum -= lastColumn.width * barGapPercent
      }

      let offset = -widthSum / 2
      each(stacks, function (column, stackId) {
        result[coordSysName][stackId] = result[coordSysName][stackId] || {
          offset: offset,
          width: column.width
        }
        offset += column.width * (1 + barGapPercent)
      })
    })
    return result
  }

  const angleAxisExtraOption = {
    startAngle: 90,
    clockwise: true,
    splitNumber: 12,
    axisLabel: {
      rotate: 0
    }
  }
  const radiusAxisExtraOption = {
    splitNumber: 5
  }

  const PolarView =
    /** @class */
    (function (_super) {
      __extends(PolarView, _super)

      function PolarView () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = PolarView.type
        return _this
      }

      PolarView.type = 'polar'
      return PolarView
    }(ComponentView))

  function install$u (registers) {
    use(install$s)
    AxisView.registerAxisPointerClass('PolarAxisPointer', PolarAxisPointer)
    registers.registerCoordinateSystem('polar', polarCreator)
    registers.registerComponentModel(PolarModel)
    registers.registerComponentView(PolarView) // Model and view for angleAxis and radiusAxis

    axisModelCreator(registers, 'angle', AngleAxisModel, angleAxisExtraOption)
    axisModelCreator(registers, 'radius', RadiusAxisModel, radiusAxisExtraOption)
    registers.registerComponentView(AngleAxisView)
    registers.registerComponentView(RadiusAxisView)
    registers.registerLayout(curry(barLayoutPolar, 'bar'))
  }

  function layout$2 (axisModel, opt) {
    opt = opt || {}
    const single = axisModel.coordinateSystem
    const axis = axisModel.axis
    const layout = {}
    const axisPosition = axis.position
    const orient = axis.orient
    const rect = single.getRect()
    const rectBound = [rect.x, rect.x + rect.width, rect.y, rect.y + rect.height]
    const positionMap = {
      horizontal: {
        top: rectBound[2],
        bottom: rectBound[3]
      },
      vertical: {
        left: rectBound[0],
        right: rectBound[1]
      }
    }
    layout.position = [orient === 'vertical' ? positionMap.vertical[axisPosition] : rectBound[0], orient === 'horizontal' ? positionMap.horizontal[axisPosition] : rectBound[3]]
    const r = {
      horizontal: 0,
      vertical: 1
    }
    layout.rotation = Math.PI / 2 * r[orient]
    const directionMap = {
      top: -1,
      bottom: 1,
      right: 1,
      left: -1
    }
    layout.labelDirection = layout.tickDirection = layout.nameDirection = directionMap[axisPosition]

    if (axisModel.get(['axisTick', 'inside'])) {
      layout.tickDirection = -layout.tickDirection
    }

    if (retrieve(opt.labelInside, axisModel.get(['axisLabel', 'inside']))) {
      layout.labelDirection = -layout.labelDirection
    }

    let labelRotation = opt.rotate
    labelRotation == null && (labelRotation = axisModel.get(['axisLabel', 'rotate']))
    layout.labelRotation = axisPosition === 'top' ? -labelRotation : labelRotation
    layout.z2 = 1
    return layout
  }

  const axisBuilderAttrs$3 = ['axisLine', 'axisTickLabel', 'axisName']
  const selfBuilderAttrs$2 = ['splitArea', 'splitLine']

  const SingleAxisView =
    /** @class */
    (function (_super) {
      __extends(SingleAxisView, _super)

      function SingleAxisView () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = SingleAxisView.type
        _this.axisPointerClass = 'SingleAxisPointer'
        return _this
      }

      SingleAxisView.prototype.render = function (axisModel, ecModel, api, payload) {
        const group = this.group
        group.removeAll()
        const oldAxisGroup = this._axisGroup
        this._axisGroup = new Group()
        const layout = layout$2(axisModel)
        const axisBuilder = new AxisBuilder(axisModel, layout)
        each(axisBuilderAttrs$3, axisBuilder.add, axisBuilder)
        group.add(this._axisGroup)
        group.add(axisBuilder.getGroup())
        each(selfBuilderAttrs$2, function (name) {
          if (axisModel.get([name, 'show'])) {
            axisElementBuilders$2[name](this, this.group, this._axisGroup, axisModel)
          }
        }, this)
        groupTransition(oldAxisGroup, this._axisGroup, axisModel)

        _super.prototype.render.call(this, axisModel, ecModel, api, payload)
      }

      SingleAxisView.prototype.remove = function () {
        rectCoordAxisHandleRemove(this)
      }

      SingleAxisView.type = 'singleAxis'
      return SingleAxisView
    }(AxisView))

  var axisElementBuilders$2 = {
    splitLine: function (axisView, group, axisGroup, axisModel) {
      const axis = axisModel.axis

      if (axis.scale.isBlank()) {
        return
      }

      const splitLineModel = axisModel.getModel('splitLine')
      const lineStyleModel = splitLineModel.getModel('lineStyle')
      let lineColors = lineStyleModel.get('color')
      lineColors = lineColors instanceof Array ? lineColors : [lineColors]
      const gridRect = axisModel.coordinateSystem.getRect()
      const isHorizontal = axis.isHorizontal()
      const splitLines = []
      let lineCount = 0
      const ticksCoords = axis.getTicksCoords({
        tickModel: splitLineModel
      })
      const p1 = []
      const p2 = []

      for (var i = 0; i < ticksCoords.length; ++i) {
        const tickCoord = axis.toGlobalCoord(ticksCoords[i].coord)

        if (isHorizontal) {
          p1[0] = tickCoord
          p1[1] = gridRect.y
          p2[0] = tickCoord
          p2[1] = gridRect.y + gridRect.height
        } else {
          p1[0] = gridRect.x
          p1[1] = tickCoord
          p2[0] = gridRect.x + gridRect.width
          p2[1] = tickCoord
        }

        const colorIndex = lineCount++ % lineColors.length
        splitLines[colorIndex] = splitLines[colorIndex] || []
        splitLines[colorIndex].push(new Line({
          subPixelOptimize: true,
          shape: {
            x1: p1[0],
            y1: p1[1],
            x2: p2[0],
            y2: p2[1]
          },
          silent: true
        }))
      }

      const lineStyle = lineStyleModel.getLineStyle(['color'])

      for (var i = 0; i < splitLines.length; ++i) {
        group.add(mergePath$1(splitLines[i], {
          style: defaults({
            stroke: lineColors[i % lineColors.length]
          }, lineStyle),
          silent: true
        }))
      }
    },
    splitArea: function (axisView, group, axisGroup, axisModel) {
      rectCoordAxisBuildSplitArea(axisView, axisGroup, axisModel, axisModel)
    }
  }

  const SingleAxisModel =
    /** @class */
    (function (_super) {
      __extends(SingleAxisModel, _super)

      function SingleAxisModel () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = SingleAxisModel.type
        return _this
      }

      SingleAxisModel.prototype.getCoordSysModel = function () {
        return this
      }

      SingleAxisModel.type = 'singleAxis'
      SingleAxisModel.layoutMode = 'box'
      SingleAxisModel.defaultOption = {
        left: '5%',
        top: '5%',
        right: '5%',
        bottom: '5%',
        type: 'value',
        position: 'bottom',
        orient: 'horizontal',
        axisLine: {
          show: true,
          lineStyle: {
            width: 1,
            type: 'solid'
          }
        },
        // Single coordinate system and single axis is the,
        // which is used as the parent tooltip model.
        // same model, so we set default tooltip show as true.
        tooltip: {
          show: true
        },
        axisTick: {
          show: true,
          length: 6,
          lineStyle: {
            width: 1
          }
        },
        axisLabel: {
          show: true,
          interval: 'auto'
        },
        splitLine: {
          show: true,
          lineStyle: {
            type: 'dashed',
            opacity: 0.2
          }
        }
      }
      return SingleAxisModel
    }(ComponentModel))

  mixin(SingleAxisModel, AxisModelCommonMixin.prototype)

  const SingleAxis =
    /** @class */
    (function (_super) {
      __extends(SingleAxis, _super)

      function SingleAxis (dim, scale, coordExtent, axisType, position) {
        const _this = _super.call(this, dim, scale, coordExtent) || this

        _this.type = axisType || 'value'
        _this.position = position || 'bottom'
        return _this
      }
      /**
       * Judge the orient of the axis.
       */

      SingleAxis.prototype.isHorizontal = function () {
        const position = this.position
        return position === 'top' || position === 'bottom'
      }

      SingleAxis.prototype.pointToData = function (point, clamp) {
        return this.coordinateSystem.pointToData(point)[0]
      }

      return SingleAxis
    }(Axis))

  const singleDimensions = ['single']
  /**
     * Create a single coordinates system.
     */

  const Single =
    /** @class */
    (function () {
      function Single (axisModel, ecModel, api) {
        this.type = 'single'
        this.dimension = 'single'
        /**
         * Add it just for draw tooltip.
         */

        this.dimensions = singleDimensions
        this.axisPointerEnabled = true
        this.model = axisModel

        this._init(axisModel, ecModel, api)
      }
      /**
       * Initialize single coordinate system.
       */

      Single.prototype._init = function (axisModel, ecModel, api) {
        const dim = this.dimension
        const axis = new SingleAxis(dim, createScaleByModel(axisModel), [0, 0], axisModel.get('type'), axisModel.get('position'))
        const isCategory = axis.type === 'category'
        axis.onBand = isCategory && axisModel.get('boundaryGap')
        axis.inverse = axisModel.get('inverse')
        axis.orient = axisModel.get('orient')
        axisModel.axis = axis
        axis.model = axisModel
        axis.coordinateSystem = this
        this._axis = axis
      }
      /**
       * Update axis scale after data processed
       */

      Single.prototype.update = function (ecModel, api) {
        ecModel.eachSeries(function (seriesModel) {
          if (seriesModel.coordinateSystem === this) {
            const data_1 = seriesModel.getData()
            each(data_1.mapDimensionsAll(this.dimension), function (dim) {
              this._axis.scale.unionExtentFromData(data_1, dim)
            }, this)
            niceScaleExtent(this._axis.scale, this._axis.model)
          }
        }, this)
      }
      /**
       * Resize the single coordinate system.
       */

      Single.prototype.resize = function (axisModel, api) {
        this._rect = getLayoutRect({
          left: axisModel.get('left'),
          top: axisModel.get('top'),
          right: axisModel.get('right'),
          bottom: axisModel.get('bottom'),
          width: axisModel.get('width'),
          height: axisModel.get('height')
        }, {
          width: api.getWidth(),
          height: api.getHeight()
        })

        this._adjustAxis()
      }

      Single.prototype.getRect = function () {
        return this._rect
      }

      Single.prototype._adjustAxis = function () {
        const rect = this._rect
        const axis = this._axis
        const isHorizontal = axis.isHorizontal()
        const extent = isHorizontal ? [0, rect.width] : [0, rect.height]
        const idx = axis.reverse ? 1 : 0
        axis.setExtent(extent[idx], extent[1 - idx])

        this._updateAxisTransform(axis, isHorizontal ? rect.x : rect.y)
      }

      Single.prototype._updateAxisTransform = function (axis, coordBase) {
        const axisExtent = axis.getExtent()
        const extentSum = axisExtent[0] + axisExtent[1]
        const isHorizontal = axis.isHorizontal()
        axis.toGlobalCoord = isHorizontal
          ? function (coord) {
            return coord + coordBase
          }
          : function (coord) {
            return extentSum - coord + coordBase
          }
        axis.toLocalCoord = isHorizontal
          ? function (coord) {
            return coord - coordBase
          }
          : function (coord) {
            return extentSum - coord + coordBase
          }
      }
      /**
       * Get axis.
       */

      Single.prototype.getAxis = function () {
        return this._axis
      }
      /**
       * Get axis, add it just for draw tooltip.
       */

      Single.prototype.getBaseAxis = function () {
        return this._axis
      }

      Single.prototype.getAxes = function () {
        return [this._axis]
      }

      Single.prototype.getTooltipAxes = function () {
        return {
          baseAxes: [this.getAxis()],
          // Empty otherAxes
          otherAxes: []
        }
      }
      /**
       * If contain point.
       */

      Single.prototype.containPoint = function (point) {
        const rect = this.getRect()
        const axis = this.getAxis()
        const orient = axis.orient

        if (orient === 'horizontal') {
          return axis.contain(axis.toLocalCoord(point[0])) && point[1] >= rect.y && point[1] <= rect.y + rect.height
        } else {
          return axis.contain(axis.toLocalCoord(point[1])) && point[0] >= rect.y && point[0] <= rect.y + rect.height
        }
      }

      Single.prototype.pointToData = function (point) {
        const axis = this.getAxis()
        return [axis.coordToData(axis.toLocalCoord(point[axis.orient === 'horizontal' ? 0 : 1]))]
      }
      /**
       * Convert the series data to concrete point.
       * Can be [val] | val
       */

      Single.prototype.dataToPoint = function (val) {
        const axis = this.getAxis()
        const rect = this.getRect()
        const pt = []
        const idx = axis.orient === 'horizontal' ? 0 : 1

        if (val instanceof Array) {
          val = val[0]
        }

        pt[idx] = axis.toGlobalCoord(axis.dataToCoord(+val))
        pt[1 - idx] = idx === 0 ? rect.y + rect.height / 2 : rect.x + rect.width / 2
        return pt
      }

      Single.prototype.convertToPixel = function (ecModel, finder, value) {
        const coordSys = getCoordSys$3(finder)
        return coordSys === this ? this.dataToPoint(value) : null
      }

      Single.prototype.convertFromPixel = function (ecModel, finder, pixel) {
        const coordSys = getCoordSys$3(finder)
        return coordSys === this ? this.pointToData(pixel) : null
      }

      return Single
    }())

  function getCoordSys$3 (finder) {
    const seriesModel = finder.seriesModel
    const singleModel = finder.singleAxisModel
    return singleModel && singleModel.coordinateSystem || seriesModel && seriesModel.coordinateSystem
  }

  /**
     * Create single coordinate system and inject it into seriesModel.
     */

  function create$2 (ecModel, api) {
    const singles = []
    ecModel.eachComponent('singleAxis', function (axisModel, idx) {
      const single = new Single(axisModel, ecModel, api)
      single.name = 'single_' + idx
      single.resize(axisModel, api)
      axisModel.coordinateSystem = single
      singles.push(single)
    })
    ecModel.eachSeries(function (seriesModel) {
      if (seriesModel.get('coordinateSystem') === 'singleAxis') {
        const singleAxisModel = seriesModel.getReferringComponents('singleAxis', SINGLE_REFERRING).models[0]
        seriesModel.coordinateSystem = singleAxisModel && singleAxisModel.coordinateSystem
      }
    })
    return singles
  }

  const singleCreator = {
    create: create$2,
    dimensions: singleDimensions
  }

  const XY = ['x', 'y']
  const WH = ['width', 'height']

  const SingleAxisPointer =
    /** @class */
    (function (_super) {
      __extends(SingleAxisPointer, _super)

      function SingleAxisPointer () {
        return _super !== null && _super.apply(this, arguments) || this
      }
      /**
       * @override
       */

      SingleAxisPointer.prototype.makeElOption = function (elOption, value, axisModel, axisPointerModel, api) {
        const axis = axisModel.axis
        const coordSys = axis.coordinateSystem
        const otherExtent = getGlobalExtent(coordSys, 1 - getPointDimIndex(axis))
        const pixelValue = coordSys.dataToPoint(value)[0]
        const axisPointerType = axisPointerModel.get('type')

        if (axisPointerType && axisPointerType !== 'none') {
          const elStyle = buildElStyle(axisPointerModel)
          const pointerOption = pointerShapeBuilder$2[axisPointerType](axis, pixelValue, otherExtent)
          pointerOption.style = elStyle
          elOption.graphicKey = pointerOption.type
          elOption.pointer = pointerOption
        }

        const layoutInfo = layout$2(axisModel)
        buildCartesianSingleLabelElOption( // @ts-ignore
          value, elOption, layoutInfo, axisModel, axisPointerModel, api)
      }
      /**
       * @override
       */

      SingleAxisPointer.prototype.getHandleTransform = function (value, axisModel, axisPointerModel) {
        const layoutInfo = layout$2(axisModel, {
          labelInside: false
        }) // @ts-ignore

        layoutInfo.labelMargin = axisPointerModel.get(['handle', 'margin'])
        const position = getTransformedPosition(axisModel.axis, value, layoutInfo)
        return {
          x: position[0],
          y: position[1],
          rotation: layoutInfo.rotation + (layoutInfo.labelDirection < 0 ? Math.PI : 0)
        }
      }
      /**
       * @override
       */

      SingleAxisPointer.prototype.updateHandleTransform = function (transform, delta, axisModel, axisPointerModel) {
        const axis = axisModel.axis
        const coordSys = axis.coordinateSystem
        const dimIndex = getPointDimIndex(axis)
        const axisExtent = getGlobalExtent(coordSys, dimIndex)
        const currPosition = [transform.x, transform.y]
        currPosition[dimIndex] += delta[dimIndex]
        currPosition[dimIndex] = Math.min(axisExtent[1], currPosition[dimIndex])
        currPosition[dimIndex] = Math.max(axisExtent[0], currPosition[dimIndex])
        const otherExtent = getGlobalExtent(coordSys, 1 - dimIndex)
        const cursorOtherValue = (otherExtent[1] + otherExtent[0]) / 2
        const cursorPoint = [cursorOtherValue, cursorOtherValue]
        cursorPoint[dimIndex] = currPosition[dimIndex]
        return {
          x: currPosition[0],
          y: currPosition[1],
          rotation: transform.rotation,
          cursorPoint: cursorPoint,
          tooltipOption: {
            verticalAlign: 'middle'
          }
        }
      }

      return SingleAxisPointer
    }(BaseAxisPointer))

  var pointerShapeBuilder$2 = {
    line: function (axis, pixelValue, otherExtent) {
      const targetShape = makeLineShape([pixelValue, otherExtent[0]], [pixelValue, otherExtent[1]], getPointDimIndex(axis))
      return {
        type: 'Line',
        subPixelOptimize: true,
        shape: targetShape
      }
    },
    shadow: function (axis, pixelValue, otherExtent) {
      const bandWidth = axis.getBandWidth()
      const span = otherExtent[1] - otherExtent[0]
      return {
        type: 'Rect',
        shape: makeRectShape([pixelValue - bandWidth / 2, otherExtent[0]], [bandWidth, span], getPointDimIndex(axis))
      }
    }
  }

  function getPointDimIndex (axis) {
    return axis.isHorizontal() ? 0 : 1
  }

  function getGlobalExtent (coordSys, dimIndex) {
    const rect = coordSys.getRect()
    return [rect[XY[dimIndex]], rect[XY[dimIndex]] + rect[WH[dimIndex]]]
  }

  const SingleView =
    /** @class */
    (function (_super) {
      __extends(SingleView, _super)

      function SingleView () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = SingleView.type
        return _this
      }

      SingleView.type = 'single'
      return SingleView
    }(ComponentView))

  function install$v (registers) {
    use(install$s)
    AxisView.registerAxisPointerClass('SingleAxisPointer', SingleAxisPointer)
    registers.registerComponentView(SingleView) // Axis

    registers.registerComponentView(SingleAxisView)
    registers.registerComponentModel(SingleAxisModel)
    axisModelCreator(registers, 'single', SingleAxisModel, SingleAxisModel.defaultOption)
    registers.registerCoordinateSystem('single', singleCreator)
  }

  const CalendarModel =
    /** @class */
    (function (_super) {
      __extends(CalendarModel, _super)

      function CalendarModel () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = CalendarModel.type
        return _this
      }
      /**
       * @override
       */

      CalendarModel.prototype.init = function (option, parentModel, ecModel) {
        const inputPositionParams = getLayoutParams(option)

        _super.prototype.init.apply(this, arguments)

        mergeAndNormalizeLayoutParams(option, inputPositionParams)
      }
      /**
       * @override
       */

      CalendarModel.prototype.mergeOption = function (option) {
        _super.prototype.mergeOption.apply(this, arguments)

        mergeAndNormalizeLayoutParams(this.option, option)
      }

      CalendarModel.prototype.getCellSize = function () {
        // Has been normalized
        return this.option.cellSize
      }

      CalendarModel.type = 'calendar'
      CalendarModel.defaultOption = {
        // zlevel: 0,
        z: 2,
        left: 80,
        top: 60,
        cellSize: 20,
        // horizontal vertical
        orient: 'horizontal',
        // month separate line style
        splitLine: {
          show: true,
          lineStyle: {
            color: '#000',
            width: 1,
            type: 'solid'
          }
        },
        // rect style  temporarily unused emphasis
        itemStyle: {
          color: '#fff',
          borderWidth: 1,
          borderColor: '#ccc'
        },
        // week text style
        dayLabel: {
          show: true,
          firstDay: 0,
          // start end
          position: 'start',
          margin: '50%',
          color: '#000'
        },
        // month text style
        monthLabel: {
          show: true,
          // start end
          position: 'start',
          margin: 5,
          // center or left
          align: 'center',
          formatter: null,
          color: '#000'
        },
        // year text style
        yearLabel: {
          show: true,
          // top bottom left right
          position: null,
          margin: 30,
          formatter: null,
          color: '#ccc',
          fontFamily: 'sans-serif',
          fontWeight: 'bolder',
          fontSize: 20
        }
      }
      return CalendarModel
    }(ComponentModel))

  function mergeAndNormalizeLayoutParams (target, raw) {
    // Normalize cellSize
    const cellSize = target.cellSize
    let cellSizeArr

    if (!isArray(cellSize)) {
      cellSizeArr = target.cellSize = [cellSize, cellSize]
    } else {
      cellSizeArr = cellSize
    }

    if (cellSizeArr.length === 1) {
      cellSizeArr[1] = cellSizeArr[0]
    }

    const ignoreSize = map([0, 1], function (hvIdx) {
      // If user have set `width` or both `left` and `right`, cellSizeArr
      // will be automatically set to 'auto', otherwise the default
      // setting of cellSizeArr will make `width` setting not work.
      if (sizeCalculable(raw, hvIdx)) {
        cellSizeArr[hvIdx] = 'auto'
      }

      return cellSizeArr[hvIdx] != null && cellSizeArr[hvIdx] !== 'auto'
    })
    mergeLayoutParam(target, raw, {
      type: 'box',
      ignoreSize: ignoreSize
    })
  }

  const CalendarView =
    /** @class */
    (function (_super) {
      __extends(CalendarView, _super)

      function CalendarView () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = CalendarView.type
        return _this
      }

      CalendarView.prototype.render = function (calendarModel, ecModel, api) {
        const group = this.group
        group.removeAll()
        const coordSys = calendarModel.coordinateSystem // range info

        const rangeData = coordSys.getRangeInfo()
        const orient = coordSys.getOrient() // locale

        const localeModel = ecModel.getLocaleModel()

        this._renderDayRect(calendarModel, rangeData, group) // _renderLines must be called prior to following function

        this._renderLines(calendarModel, rangeData, orient, group)

        this._renderYearText(calendarModel, rangeData, orient, group)

        this._renderMonthText(calendarModel, localeModel, orient, group)

        this._renderWeekText(calendarModel, localeModel, rangeData, orient, group)
      } // render day rect

      CalendarView.prototype._renderDayRect = function (calendarModel, rangeData, group) {
        const coordSys = calendarModel.coordinateSystem
        const itemRectStyleModel = calendarModel.getModel('itemStyle').getItemStyle()
        const sw = coordSys.getCellWidth()
        const sh = coordSys.getCellHeight()

        for (let i = rangeData.start.time; i <= rangeData.end.time; i = coordSys.getNextNDay(i, 1).time) {
          const point = coordSys.dataToRect([i], false).tl // every rect

          const rect = new Rect({
            shape: {
              x: point[0],
              y: point[1],
              width: sw,
              height: sh
            },
            cursor: 'default',
            style: itemRectStyleModel
          })
          group.add(rect)
        }
      } // render separate line

      CalendarView.prototype._renderLines = function (calendarModel, rangeData, orient, group) {
        const self = this
        const coordSys = calendarModel.coordinateSystem
        const lineStyleModel = calendarModel.getModel(['splitLine', 'lineStyle']).getLineStyle()
        const show = calendarModel.get(['splitLine', 'show'])
        const lineWidth = lineStyleModel.lineWidth
        this._tlpoints = []
        this._blpoints = []
        this._firstDayOfMonth = []
        this._firstDayPoints = []
        let firstDay = rangeData.start

        for (let i = 0; firstDay.time <= rangeData.end.time; i++) {
          addPoints(firstDay.formatedDate)

          if (i === 0) {
            firstDay = coordSys.getDateInfo(rangeData.start.y + '-' + rangeData.start.m)
          }

          const date = firstDay.date
          date.setMonth(date.getMonth() + 1)
          firstDay = coordSys.getDateInfo(date)
        }

        addPoints(coordSys.getNextNDay(rangeData.end.time, 1).formatedDate)

        function addPoints (date) {
          self._firstDayOfMonth.push(coordSys.getDateInfo(date))

          self._firstDayPoints.push(coordSys.dataToRect([date], false).tl)

          const points = self._getLinePointsOfOneWeek(calendarModel, date, orient)

          self._tlpoints.push(points[0])

          self._blpoints.push(points[points.length - 1])

          show && self._drawSplitline(points, lineStyleModel, group)
        } // render top/left line

        show && this._drawSplitline(self._getEdgesPoints(self._tlpoints, lineWidth, orient), lineStyleModel, group) // render bottom/right line

        show && this._drawSplitline(self._getEdgesPoints(self._blpoints, lineWidth, orient), lineStyleModel, group)
      } // get points at both ends

      CalendarView.prototype._getEdgesPoints = function (points, lineWidth, orient) {
        const rs = [points[0].slice(), points[points.length - 1].slice()]
        const idx = orient === 'horizontal' ? 0 : 1 // both ends of the line are extend half lineWidth

        rs[0][idx] = rs[0][idx] - lineWidth / 2
        rs[1][idx] = rs[1][idx] + lineWidth / 2
        return rs
      } // render split line

      CalendarView.prototype._drawSplitline = function (points, lineStyle, group) {
        const poyline = new Polyline({
          z2: 20,
          shape: {
            points: points
          },
          style: lineStyle
        })
        group.add(poyline)
      } // render month line of one week points

      CalendarView.prototype._getLinePointsOfOneWeek = function (calendarModel, date, orient) {
        const coordSys = calendarModel.coordinateSystem
        const parsedDate = coordSys.getDateInfo(date)
        const points = []

        for (let i = 0; i < 7; i++) {
          const tmpD = coordSys.getNextNDay(parsedDate.time, i)
          const point = coordSys.dataToRect([tmpD.time], false)
          points[2 * tmpD.day] = point.tl
          points[2 * tmpD.day + 1] = point[orient === 'horizontal' ? 'bl' : 'tr']
        }

        return points
      }

      CalendarView.prototype._formatterLabel = function (formatter, params) {
        if (isString(formatter) && formatter) {
          return formatTplSimple(formatter, params)
        }

        if (isFunction(formatter)) {
          return formatter(params)
        }

        return params.nameMap
      }

      CalendarView.prototype._yearTextPositionControl = function (textEl, point, orient, position, margin) {
        let x = point[0]
        let y = point[1]
        let aligns = ['center', 'bottom']

        if (position === 'bottom') {
          y += margin
          aligns = ['center', 'top']
        } else if (position === 'left') {
          x -= margin
        } else if (position === 'right') {
          x += margin
          aligns = ['center', 'top']
        } else {
          // top
          y -= margin
        }

        let rotate = 0

        if (position === 'left' || position === 'right') {
          rotate = Math.PI / 2
        }

        return {
          rotation: rotate,
          x: x,
          y: y,
          style: {
            align: aligns[0],
            verticalAlign: aligns[1]
          }
        }
      } // render year

      CalendarView.prototype._renderYearText = function (calendarModel, rangeData, orient, group) {
        const yearLabel = calendarModel.getModel('yearLabel')

        if (!yearLabel.get('show')) {
          return
        }

        const margin = yearLabel.get('margin')
        let pos = yearLabel.get('position')

        if (!pos) {
          pos = orient !== 'horizontal' ? 'top' : 'left'
        }

        const points = [this._tlpoints[this._tlpoints.length - 1], this._blpoints[0]]
        const xc = (points[0][0] + points[1][0]) / 2
        const yc = (points[0][1] + points[1][1]) / 2
        const idx = orient === 'horizontal' ? 0 : 1
        const posPoints = {
          top: [xc, points[idx][1]],
          bottom: [xc, points[1 - idx][1]],
          left: [points[1 - idx][0], yc],
          right: [points[idx][0], yc]
        }
        let name = rangeData.start.y

        if (+rangeData.end.y > +rangeData.start.y) {
          name = name + '-' + rangeData.end.y
        }

        const formatter = yearLabel.get('formatter')
        const params = {
          start: rangeData.start.y,
          end: rangeData.end.y,
          nameMap: name
        }

        const content = this._formatterLabel(formatter, params)

        const yearText = new ZRText({
          z2: 30,
          style: createTextStyle(yearLabel, {
            text: content
          })
        })
        yearText.attr(this._yearTextPositionControl(yearText, posPoints[pos], orient, pos, margin))
        group.add(yearText)
      }

      CalendarView.prototype._monthTextPositionControl = function (point, isCenter, orient, position, margin) {
        let align = 'left'
        let vAlign = 'top'
        let x = point[0]
        let y = point[1]

        if (orient === 'horizontal') {
          y = y + margin

          if (isCenter) {
            align = 'center'
          }

          if (position === 'start') {
            vAlign = 'bottom'
          }
        } else {
          x = x + margin

          if (isCenter) {
            vAlign = 'middle'
          }

          if (position === 'start') {
            align = 'right'
          }
        }

        return {
          x: x,
          y: y,
          align: align,
          verticalAlign: vAlign
        }
      } // render month and year text

      CalendarView.prototype._renderMonthText = function (calendarModel, localeModel, orient, group) {
        const monthLabel = calendarModel.getModel('monthLabel')

        if (!monthLabel.get('show')) {
          return
        }

        let nameMap = monthLabel.get('nameMap')
        let margin = monthLabel.get('margin')
        const pos = monthLabel.get('position')
        const align = monthLabel.get('align')
        const termPoints = [this._tlpoints, this._blpoints]

        if (!nameMap || isString(nameMap)) {
          if (nameMap) {
            // case-sensitive
            localeModel = getLocaleModel(nameMap) || localeModel
          } // PENDING
          // for ZH locale, original form is `一月` but current form is `1月`

          nameMap = localeModel.get(['time', 'monthAbbr']) || []
        }

        const idx = pos === 'start' ? 0 : 1
        const axis = orient === 'horizontal' ? 0 : 1
        margin = pos === 'start' ? -margin : margin
        const isCenter = align === 'center'

        for (let i = 0; i < termPoints[idx].length - 1; i++) {
          const tmp = termPoints[idx][i].slice()
          const firstDay = this._firstDayOfMonth[i]

          if (isCenter) {
            const firstDayPoints = this._firstDayPoints[i]
            tmp[axis] = (firstDayPoints[axis] + termPoints[0][i + 1][axis]) / 2
          }

          const formatter = monthLabel.get('formatter')
          const name_1 = nameMap[+firstDay.m - 1]
          const params = {
            yyyy: firstDay.y,
            yy: (firstDay.y + '').slice(2),
            MM: firstDay.m,
            M: +firstDay.m,
            nameMap: name_1
          }

          const content = this._formatterLabel(formatter, params)

          const monthText = new ZRText({
            z2: 30,
            style: extend(createTextStyle(monthLabel, {
              text: content
            }), this._monthTextPositionControl(tmp, isCenter, orient, pos, margin))
          })
          group.add(monthText)
        }
      }

      CalendarView.prototype._weekTextPositionControl = function (point, orient, position, margin, cellSize) {
        let align = 'center'
        let vAlign = 'middle'
        let x = point[0]
        let y = point[1]
        const isStart = position === 'start'

        if (orient === 'horizontal') {
          x = x + margin + (isStart ? 1 : -1) * cellSize[0] / 2
          align = isStart ? 'right' : 'left'
        } else {
          y = y + margin + (isStart ? 1 : -1) * cellSize[1] / 2
          vAlign = isStart ? 'bottom' : 'top'
        }

        return {
          x: x,
          y: y,
          align: align,
          verticalAlign: vAlign
        }
      } // render weeks

      CalendarView.prototype._renderWeekText = function (calendarModel, localeModel, rangeData, orient, group) {
        const dayLabel = calendarModel.getModel('dayLabel')

        if (!dayLabel.get('show')) {
          return
        }

        const coordSys = calendarModel.coordinateSystem
        const pos = dayLabel.get('position')
        let nameMap = dayLabel.get('nameMap')
        let margin = dayLabel.get('margin')
        const firstDayOfWeek = coordSys.getFirstDayOfWeek()

        if (!nameMap || isString(nameMap)) {
          if (nameMap) {
            // case-sensitive
            localeModel = getLocaleModel(nameMap) || localeModel
          } // Use the first letter of `dayOfWeekAbbr` if `dayOfWeekShort` doesn't exist in the locale file

          const dayOfWeekShort = localeModel.get(['time', 'dayOfWeekShort'])
          nameMap = dayOfWeekShort || map(localeModel.get(['time', 'dayOfWeekAbbr']), function (val) {
            return val[0]
          })
        }

        let start = coordSys.getNextNDay(rangeData.end.time, 7 - rangeData.lweek).time
        const cellSize = [coordSys.getCellWidth(), coordSys.getCellHeight()]
        margin = parsePercent$1(margin, Math.min(cellSize[1], cellSize[0]))

        if (pos === 'start') {
          start = coordSys.getNextNDay(rangeData.start.time, -(7 + rangeData.fweek)).time
          margin = -margin
        }

        for (let i = 0; i < 7; i++) {
          const tmpD = coordSys.getNextNDay(start, i)
          const point = coordSys.dataToRect([tmpD.time], false).center
          let day = i
          day = Math.abs((i + firstDayOfWeek) % 7)
          const weekText = new ZRText({
            z2: 30,
            style: extend(createTextStyle(dayLabel, {
              text: nameMap[day]
            }), this._weekTextPositionControl(point, orient, pos, margin, cellSize))
          })
          group.add(weekText)
        }
      }

      CalendarView.type = 'calendar'
      return CalendarView
    }(ComponentView))

  const PROXIMATE_ONE_DAY = 86400000

  const Calendar =
    /** @class */
    (function () {
      function Calendar (calendarModel, ecModel, api) {
        this.type = 'calendar'
        this.dimensions = Calendar.dimensions // Required in createListFromData

        this.getDimensionsInfo = Calendar.getDimensionsInfo
        this._model = calendarModel
      }

      Calendar.getDimensionsInfo = function () {
        return [{
          name: 'time',
          type: 'time'
        }, 'value']
      }

      Calendar.prototype.getRangeInfo = function () {
        return this._rangeInfo
      }

      Calendar.prototype.getModel = function () {
        return this._model
      }

      Calendar.prototype.getRect = function () {
        return this._rect
      }

      Calendar.prototype.getCellWidth = function () {
        return this._sw
      }

      Calendar.prototype.getCellHeight = function () {
        return this._sh
      }

      Calendar.prototype.getOrient = function () {
        return this._orient
      }
      /**
       * getFirstDayOfWeek
       *
       * @example
       *     0 : start at Sunday
       *     1 : start at Monday
       *
       * @return {number}
       */

      Calendar.prototype.getFirstDayOfWeek = function () {
        return this._firstDayOfWeek
      }
      /**
       * get date info
       * }
       */

      Calendar.prototype.getDateInfo = function (date) {
        date = parseDate(date)
        const y = date.getFullYear()
        const m = date.getMonth() + 1
        const mStr = m < 10 ? '0' + m : '' + m
        const d = date.getDate()
        const dStr = d < 10 ? '0' + d : '' + d
        let day = date.getDay()
        day = Math.abs((day + 7 - this.getFirstDayOfWeek()) % 7)
        return {
          y: y + '',
          m: mStr,
          d: dStr,
          day: day,
          time: date.getTime(),
          formatedDate: y + '-' + mStr + '-' + dStr,
          date: date
        }
      }

      Calendar.prototype.getNextNDay = function (date, n) {
        n = n || 0

        if (n === 0) {
          return this.getDateInfo(date)
        }

        date = new Date(this.getDateInfo(date).time)
        date.setDate(date.getDate() + n)
        return this.getDateInfo(date)
      }

      Calendar.prototype.update = function (ecModel, api) {
        this._firstDayOfWeek = +this._model.getModel('dayLabel').get('firstDay')
        this._orient = this._model.get('orient')
        this._lineWidth = this._model.getModel('itemStyle').getItemStyle().lineWidth || 0
        this._rangeInfo = this._getRangeInfo(this._initRangeOption())
        const weeks = this._rangeInfo.weeks || 1
        const whNames = ['width', 'height']

        const cellSize = this._model.getCellSize().slice()

        const layoutParams = this._model.getBoxLayoutParams()

        const cellNumbers = this._orient === 'horizontal' ? [weeks, 7] : [7, weeks]
        each([0, 1], function (idx) {
          if (cellSizeSpecified(cellSize, idx)) {
            layoutParams[whNames[idx]] = cellSize[idx] * cellNumbers[idx]
          }
        })
        const whGlobal = {
          width: api.getWidth(),
          height: api.getHeight()
        }
        const calendarRect = this._rect = getLayoutRect(layoutParams, whGlobal)
        each([0, 1], function (idx) {
          if (!cellSizeSpecified(cellSize, idx)) {
            cellSize[idx] = calendarRect[whNames[idx]] / cellNumbers[idx]
          }
        })

        function cellSizeSpecified (cellSize, idx) {
          return cellSize[idx] != null && cellSize[idx] !== 'auto'
        } // Has been calculated out number.

        this._sw = cellSize[0]
        this._sh = cellSize[1]
      }
      /**
       * Convert a time data(time, value) item to (x, y) point.
       */
      // TODO Clamp of calendar is not same with cartesian coordinate systems.
      // It will return NaN if data exceeds.

      Calendar.prototype.dataToPoint = function (data, clamp) {
        isArray(data) && (data = data[0])
        clamp == null && (clamp = true)
        const dayInfo = this.getDateInfo(data)
        const range = this._rangeInfo
        const date = dayInfo.formatedDate // if not in range return [NaN, NaN]

        if (clamp && !(dayInfo.time >= range.start.time && dayInfo.time < range.end.time + PROXIMATE_ONE_DAY)) {
          return [NaN, NaN]
        }

        const week = dayInfo.day

        const nthWeek = this._getRangeInfo([range.start.time, date]).nthWeek

        if (this._orient === 'vertical') {
          return [this._rect.x + week * this._sw + this._sw / 2, this._rect.y + nthWeek * this._sh + this._sh / 2]
        }

        return [this._rect.x + nthWeek * this._sw + this._sw / 2, this._rect.y + week * this._sh + this._sh / 2]
      }
      /**
       * Convert a (x, y) point to time data
       */

      Calendar.prototype.pointToData = function (point) {
        const date = this.pointToDate(point)
        return date && date.time
      }
      /**
       * Convert a time date item to (x, y) four point.
       */

      Calendar.prototype.dataToRect = function (data, clamp) {
        const point = this.dataToPoint(data, clamp)
        return {
          contentShape: {
            x: point[0] - (this._sw - this._lineWidth) / 2,
            y: point[1] - (this._sh - this._lineWidth) / 2,
            width: this._sw - this._lineWidth,
            height: this._sh - this._lineWidth
          },
          center: point,
          tl: [point[0] - this._sw / 2, point[1] - this._sh / 2],
          tr: [point[0] + this._sw / 2, point[1] - this._sh / 2],
          br: [point[0] + this._sw / 2, point[1] + this._sh / 2],
          bl: [point[0] - this._sw / 2, point[1] + this._sh / 2]
        }
      }
      /**
       * Convert a (x, y) point to time date
       *
       * @param  {Array} point point
       * @return {Object}       date
       */

      Calendar.prototype.pointToDate = function (point) {
        const nthX = Math.floor((point[0] - this._rect.x) / this._sw) + 1
        const nthY = Math.floor((point[1] - this._rect.y) / this._sh) + 1
        const range = this._rangeInfo.range

        if (this._orient === 'vertical') {
          return this._getDateByWeeksAndDay(nthY, nthX - 1, range)
        }

        return this._getDateByWeeksAndDay(nthX, nthY - 1, range)
      }

      Calendar.prototype.convertToPixel = function (ecModel, finder, value) {
        const coordSys = getCoordSys$4(finder)
        return coordSys === this ? coordSys.dataToPoint(value) : null
      }

      Calendar.prototype.convertFromPixel = function (ecModel, finder, pixel) {
        const coordSys = getCoordSys$4(finder)
        return coordSys === this ? coordSys.pointToData(pixel) : null
      }

      Calendar.prototype.containPoint = function (point) {
        console.warn('Not implemented.')
        return false
      }
      /**
       * initRange
       * Normalize to an [start, end] array
       */

      Calendar.prototype._initRangeOption = function () {
        let range = this._model.get('range')

        let normalizedRange // Convert [1990] to 1990

        if (isArray(range) && range.length === 1) {
          range = range[0]
        }

        if (!isArray(range)) {
          const rangeStr = range.toString() // One year.

          if (/^\d{4}$/.test(rangeStr)) {
            normalizedRange = [rangeStr + '-01-01', rangeStr + '-12-31']
          } // One month

          if (/^\d{4}[\/|-]\d{1,2}$/.test(rangeStr)) {
            const start = this.getDateInfo(rangeStr)
            const firstDay = start.date
            firstDay.setMonth(firstDay.getMonth() + 1)
            const end = this.getNextNDay(firstDay, -1)
            normalizedRange = [start.formatedDate, end.formatedDate]
          } // One day

          if (/^\d{4}[\/|-]\d{1,2}[\/|-]\d{1,2}$/.test(rangeStr)) {
            normalizedRange = [rangeStr, rangeStr]
          }
        } else {
          normalizedRange = range
        }

        if (!normalizedRange) {
          if ('development' !== 'production') {
            logError('Invalid date range.')
          } // Not handling it.

          return range
        }

        const tmp = this._getRangeInfo(normalizedRange)

        if (tmp.start.time > tmp.end.time) {
          normalizedRange.reverse()
        }

        return normalizedRange
      }
      /**
       * range info
       *
       * @private
       * @param  {Array} range range ['2017-01-01', '2017-07-08']
       *  If range[0] > range[1], they will not be reversed.
       * @return {Object}       obj
       */

      Calendar.prototype._getRangeInfo = function (range) {
        const parsedRange = [this.getDateInfo(range[0]), this.getDateInfo(range[1])]
        let reversed

        if (parsedRange[0].time > parsedRange[1].time) {
          reversed = true
          parsedRange.reverse()
        }

        let allDay = Math.floor(parsedRange[1].time / PROXIMATE_ONE_DAY) - Math.floor(parsedRange[0].time / PROXIMATE_ONE_DAY) + 1 // Consider case1 (#11677 #10430):
        // Set the system timezone as "UK", set the range to `['2016-07-01', '2016-12-31']`
        // Consider case2:
        // Firstly set system timezone as "Time Zone: America/Toronto",
        // ```
        // let first = new Date(1478412000000 - 3600 * 1000 * 2.5);
        // let second = new Date(1478412000000);
        // let allDays = Math.floor(second / ONE_DAY) - Math.floor(first / ONE_DAY) + 1;
        // ```
        // will get wrong result because of DST. So we should fix it.

        const date = new Date(parsedRange[0].time)
        const startDateNum = date.getDate()
        const endDateNum = parsedRange[1].date.getDate()
        date.setDate(startDateNum + allDay - 1) // The bias can not over a month, so just compare date.

        let dateNum = date.getDate()

        if (dateNum !== endDateNum) {
          const sign = date.getTime() - parsedRange[1].time > 0 ? 1 : -1

          while ((dateNum = date.getDate()) !== endDateNum && (date.getTime() - parsedRange[1].time) * sign > 0) {
            allDay -= sign
            date.setDate(dateNum - sign)
          }
        }

        const weeks = Math.floor((allDay + parsedRange[0].day + 6) / 7)
        const nthWeek = reversed ? -weeks + 1 : weeks - 1
        reversed && parsedRange.reverse()
        return {
          range: [parsedRange[0].formatedDate, parsedRange[1].formatedDate],
          start: parsedRange[0],
          end: parsedRange[1],
          allDay: allDay,
          weeks: weeks,
          // From 0.
          nthWeek: nthWeek,
          fweek: parsedRange[0].day,
          lweek: parsedRange[1].day
        }
      }
      /**
       * get date by nthWeeks and week day in range
       *
       * @private
       * @param  {number} nthWeek the week
       * @param  {number} day   the week day
       * @param  {Array} range [d1, d2]
       * @return {Object}
       */

      Calendar.prototype._getDateByWeeksAndDay = function (nthWeek, day, range) {
        const rangeInfo = this._getRangeInfo(range)

        if (nthWeek > rangeInfo.weeks || nthWeek === 0 && day < rangeInfo.fweek || nthWeek === rangeInfo.weeks && day > rangeInfo.lweek) {
          return null
        }

        const nthDay = (nthWeek - 1) * 7 - rangeInfo.fweek + day
        const date = new Date(rangeInfo.start.time)
        date.setDate(+rangeInfo.start.d + nthDay)
        return this.getDateInfo(date)
      }

      Calendar.create = function (ecModel, api) {
        const calendarList = []
        ecModel.eachComponent('calendar', function (calendarModel) {
          const calendar = new Calendar(calendarModel, ecModel, api)
          calendarList.push(calendar)
          calendarModel.coordinateSystem = calendar
        })
        ecModel.eachSeries(function (calendarSeries) {
          if (calendarSeries.get('coordinateSystem') === 'calendar') {
            // Inject coordinate system
            calendarSeries.coordinateSystem = calendarList[calendarSeries.get('calendarIndex') || 0]
          }
        })
        return calendarList
      }

      Calendar.dimensions = ['time', 'value']
      return Calendar
    }())

  function getCoordSys$4 (finder) {
    const calendarModel = finder.calendarModel
    const seriesModel = finder.seriesModel
    const coordSys = calendarModel ? calendarModel.coordinateSystem : seriesModel ? seriesModel.coordinateSystem : null
    return coordSys
  }

  function install$w (registers) {
    registers.registerComponentModel(CalendarModel)
    registers.registerComponentView(CalendarView)
    registers.registerCoordinateSystem('calendar', Calendar)
  }

  function setKeyInfoToNewElOption (resultItem, newElOption) {
    const existElOption = resultItem.existing // Set id and type after id assigned.

    newElOption.id = resultItem.keyInfo.id
    !newElOption.type && existElOption && (newElOption.type = existElOption.type) // Set parent id if not specified

    if (newElOption.parentId == null) {
      const newElParentOption = newElOption.parentOption

      if (newElParentOption) {
        newElOption.parentId = newElParentOption.id
      } else if (existElOption) {
        newElOption.parentId = existElOption.parentId
      }
    } // Clear

    newElOption.parentOption = null
  }

  function isSetLoc (obj, props) {
    let isSet
    each(props, function (prop) {
      obj[prop] != null && obj[prop] !== 'auto' && (isSet = true)
    })
    return isSet
  }

  function mergeNewElOptionToExist (existList, index, newElOption) {
    // Update existing options, for `getOption` feature.
    const newElOptCopy = extend({}, newElOption)
    const existElOption = existList[index]
    const $action = newElOption.$action || 'merge'

    if ($action === 'merge') {
      if (existElOption) {
        if ('development' !== 'production') {
          const newType = newElOption.type
          assert(!newType || existElOption.type === newType, 'Please set $action: "replace" to change `type`')
        } // We can ensure that newElOptCopy and existElOption are not
        // the same object, so `merge` will not change newElOptCopy.

        merge(existElOption, newElOptCopy, true) // Rigid body, use ignoreSize.

        mergeLayoutParam(existElOption, newElOptCopy, {
          ignoreSize: true
        }) // Will be used in render.

        copyLayoutParams(newElOption, existElOption) // Copy transition info to new option so it can be used in the transition.
        // DO IT AFTER merge

        copyTransitionInfo(newElOption, existElOption)
        copyTransitionInfo(newElOption, existElOption, 'shape')
        copyTransitionInfo(newElOption, existElOption, 'style')
        copyTransitionInfo(newElOption, existElOption, 'extra') // Copy clipPath

        newElOption.clipPath = existElOption.clipPath
      } else {
        existList[index] = newElOptCopy
      }
    } else if ($action === 'replace') {
      existList[index] = newElOptCopy
    } else if ($action === 'remove') {
      // null will be cleaned later.
      existElOption && (existList[index] = null)
    }
  }

  const TRANSITION_PROPS_TO_COPY = ['transition', 'enterFrom', 'leaveTo']
  const ROOT_TRANSITION_PROPS_TO_COPY = TRANSITION_PROPS_TO_COPY.concat(['enterAnimation', 'updateAnimation', 'leaveAnimation'])

  function copyTransitionInfo (target, source, targetProp) {
    if (targetProp) {
      if (!target[targetProp] && source[targetProp]) {
        // TODO avoid creating this empty object when there is no transition configuration.
        target[targetProp] = {}
      }

      target = target[targetProp]
      source = source[targetProp]
    }

    if (!target || !source) {
      return
    }

    const props = targetProp ? TRANSITION_PROPS_TO_COPY : ROOT_TRANSITION_PROPS_TO_COPY

    for (let i = 0; i < props.length; i++) {
      const prop = props[i]

      if (target[prop] == null && source[prop] != null) {
        target[prop] = source[prop]
      }
    }
  }

  function setLayoutInfoToExist (existItem, newElOption) {
    if (!existItem) {
      return
    }

    existItem.hv = newElOption.hv = [// Rigid body, dont care `width`.
      isSetLoc(newElOption, ['left', 'right']), // Rigid body, dont care `height`.
      isSetLoc(newElOption, ['top', 'bottom'])] // Give default group size. Otherwise layout error may occur.

    if (existItem.type === 'group') {
      const existingGroupOpt = existItem
      const newGroupOpt = newElOption
      existingGroupOpt.width == null && (existingGroupOpt.width = newGroupOpt.width = 0)
      existingGroupOpt.height == null && (existingGroupOpt.height = newGroupOpt.height = 0)
    }
  }

  const GraphicComponentModel =
    /** @class */
    (function (_super) {
      __extends(GraphicComponentModel, _super)

      function GraphicComponentModel () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = GraphicComponentModel.type
        _this.preventAutoZ = true
        return _this
      }

      GraphicComponentModel.prototype.mergeOption = function (option, ecModel) {
        // Prevent default merge to elements
        const elements = this.option.elements
        this.option.elements = null

        _super.prototype.mergeOption.call(this, option, ecModel)

        this.option.elements = elements
      }

      GraphicComponentModel.prototype.optionUpdated = function (newOption, isInit) {
        const thisOption = this.option
        const newList = (isInit ? thisOption : newOption).elements
        const existList = thisOption.elements = isInit ? [] : thisOption.elements
        const flattenedList = []

        this._flatten(newList, flattenedList, null)

        const mappingResult = mappingToExists(existList, flattenedList, 'normalMerge') // Clear elOptionsToUpdate

        const elOptionsToUpdate = this._elOptionsToUpdate = []
        each(mappingResult, function (resultItem, index) {
          const newElOption = resultItem.newOption

          if ('development' !== 'production') {
            assert(isObject(newElOption) || resultItem.existing, 'Empty graphic option definition')
          }

          if (!newElOption) {
            return
          }

          elOptionsToUpdate.push(newElOption)
          setKeyInfoToNewElOption(resultItem, newElOption)
          mergeNewElOptionToExist(existList, index, newElOption)
          setLayoutInfoToExist(existList[index], newElOption)
        }, this) // Clean

        thisOption.elements = filter(existList, function (item) {
          // $action should be volatile, otherwise option gotten from
          // `getOption` will contain unexpected $action.
          item && delete item.$action
          return item != null
        })
      }
      /**
       * Convert
       * [{
       *  type: 'group',
       *  id: 'xx',
       *  children: [{type: 'circle'}, {type: 'polygon'}]
       * }]
       * to
       * [
       *  {type: 'group', id: 'xx'},
       *  {type: 'circle', parentId: 'xx'},
       *  {type: 'polygon', parentId: 'xx'}
       * ]
       */

      GraphicComponentModel.prototype._flatten = function (optionList, result, parentOption) {
        each(optionList, function (option) {
          if (!option) {
            return
          }

          if (parentOption) {
            option.parentOption = parentOption
          }

          result.push(option)
          const children = option.children // here we don't judge if option.type is `group`
          // when new option doesn't provide `type`, it will cause that the children can't be updated.

          if (children && children.length) {
            this._flatten(children, result, option)
          } // Deleting for JSON output, and for not affecting group creation.

          delete option.children
        }, this)
      } // FIXME
      // Pass to view using payload? setOption has a payload?

      GraphicComponentModel.prototype.useElOptionsToUpdate = function () {
        const els = this._elOptionsToUpdate // Clear to avoid render duplicately when zooming.

        this._elOptionsToUpdate = null
        return els
      }

      GraphicComponentModel.type = 'graphic'
      GraphicComponentModel.defaultOption = {
        elements: [] // parentId: null

      }
      return GraphicComponentModel
    }(ComponentModel))

  const nonShapeGraphicElements = {
    // Reserved but not supported in graphic component.
    path: null,
    compoundPath: null,
    // Supported in graphic component.
    group: Group,
    image: ZRImage,
    text: ZRText
  }
  const inner$e = makeInner() // ------------------------
  // View
  // ------------------------

  const GraphicComponentView =
    /** @class */
    (function (_super) {
      __extends(GraphicComponentView, _super)

      function GraphicComponentView () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = GraphicComponentView.type
        return _this
      }

      GraphicComponentView.prototype.init = function () {
        this._elMap = createHashMap()
      }

      GraphicComponentView.prototype.render = function (graphicModel, ecModel, api) {
        // Having leveraged between use cases and algorithm complexity, a very
        // simple layout mechanism is used:
        // The size(width/height) can be determined by itself or its parent (not
        // implemented yet), but can not by its children. (Top-down travel)
        // The location(x/y) can be determined by the bounding rect of itself
        // (can including its descendants or not) and the size of its parent.
        // (Bottom-up travel)
        // When `chart.clear()` or `chart.setOption({...}, true)` with the same id,
        // view will be reused.
        if (graphicModel !== this._lastGraphicModel) {
          this._clear()
        }

        this._lastGraphicModel = graphicModel

        this._updateElements(graphicModel)

        this._relocate(graphicModel, api)
      }
      /**
       * Update graphic elements.
       */

      GraphicComponentView.prototype._updateElements = function (graphicModel) {
        const elOptionsToUpdate = graphicModel.useElOptionsToUpdate()

        if (!elOptionsToUpdate) {
          return
        }

        const elMap = this._elMap
        const rootGroup = this.group
        const globalZ = graphicModel.get('z')
        const globalZLevel = graphicModel.get('zlevel') // Top-down tranverse to assign graphic settings to each elements.

        each(elOptionsToUpdate, function (elOption) {
          const id = convertOptionIdName(elOption.id, null)
          const elExisting = id != null ? elMap.get(id) : null
          const parentId = convertOptionIdName(elOption.parentId, null)
          const targetElParent = parentId != null ? elMap.get(parentId) : rootGroup
          const elType = elOption.type
          const elOptionStyle = elOption.style

          if (elType === 'text' && elOptionStyle) {
            // In top/bottom mode, textVerticalAlign should not be used, which cause
            // inaccurately locating.
            if (elOption.hv && elOption.hv[1]) {
              elOptionStyle.textVerticalAlign = elOptionStyle.textBaseline = elOptionStyle.verticalAlign = elOptionStyle.align = null
            }
          }

          let textContentOption = elOption.textContent
          let textConfig = elOption.textConfig

          if (elOptionStyle && isEC4CompatibleStyle(elOptionStyle, elType, !!textConfig, !!textContentOption)) {
            const convertResult = convertFromEC4CompatibleStyle(elOptionStyle, elType, true)

            if (!textConfig && convertResult.textConfig) {
              textConfig = elOption.textConfig = convertResult.textConfig
            }

            if (!textContentOption && convertResult.textContent) {
              textContentOption = convertResult.textContent
            }
          } // Remove unnecessary props to avoid potential problems.

          const elOptionCleaned = getCleanedElOption(elOption) // For simple, do not support parent change, otherwise reorder is needed.

          if ('development' !== 'production') {
            elExisting && assert(targetElParent === elExisting.parent, 'Changing parent is not supported.')
          }

          const $action = elOption.$action || 'merge'
          const isMerge = $action === 'merge'
          const isReplace = $action === 'replace'

          if (isMerge) {
            var isInit = !elExisting
            let el_1 = elExisting

            if (isInit) {
              el_1 = createEl$1(id, targetElParent, elOption.type, elMap)
            } else {
              el_1 && (inner$e(el_1).isNew = false) // Stop and restore before update any other attributes.

              stopPreviousKeyframeAnimationAndRestore(el_1)
            }

            if (el_1) {
              applyUpdateTransition(el_1, elOptionCleaned, graphicModel, {
                isInit: isInit
              })
              updateCommonAttrs(el_1, elOption, globalZ, globalZLevel)
            }
          } else if (isReplace) {
            removeEl(elExisting, elOption, elMap, graphicModel)
            const el_2 = createEl$1(id, targetElParent, elOption.type, elMap)

            if (el_2) {
              applyUpdateTransition(el_2, elOptionCleaned, graphicModel, {
                isInit: true
              })
              updateCommonAttrs(el_2, elOption, globalZ, globalZLevel)
            }
          } else if ($action === 'remove') {
            updateLeaveTo(elExisting, elOption)
            removeEl(elExisting, elOption, elMap, graphicModel)
          }

          const el = elMap.get(id)

          if (el && textContentOption) {
            if (isMerge) {
              const textContentExisting = el.getTextContent()
              textContentExisting ? textContentExisting.attr(textContentOption) : el.setTextContent(new ZRText(textContentOption))
            } else if (isReplace) {
              el.setTextContent(new ZRText(textContentOption))
            }
          }

          if (el) {
            const clipPathOption = elOption.clipPath

            if (clipPathOption) {
              const clipPathType = clipPathOption.type
              let clipPath = void 0
              var isInit = false

              if (isMerge) {
                const oldClipPath = el.getClipPath()
                isInit = !oldClipPath || inner$e(oldClipPath).type !== clipPathType
                clipPath = isInit ? newEl(clipPathType) : oldClipPath
              } else if (isReplace) {
                isInit = true
                clipPath = newEl(clipPathType)
              }

              el.setClipPath(clipPath)
              applyUpdateTransition(clipPath, clipPathOption, graphicModel, {
                isInit: isInit
              })
              applyKeyframeAnimation(clipPath, clipPathOption.keyframeAnimation, graphicModel)
            }

            const elInner = inner$e(el)
            el.setTextConfig(textConfig)
            elInner.option = elOption
            setEventData(el, graphicModel, elOption)
            setTooltipConfig({
              el: el,
              componentModel: graphicModel,
              itemName: el.name,
              itemTooltipOption: elOption.tooltip
            })
            applyKeyframeAnimation(el, elOption.keyframeAnimation, graphicModel)
          }
        })
      }
      /**
       * Locate graphic elements.
       */

      GraphicComponentView.prototype._relocate = function (graphicModel, api) {
        const elOptions = graphicModel.option.elements
        const rootGroup = this.group
        const elMap = this._elMap
        const apiWidth = api.getWidth()
        const apiHeight = api.getHeight()
        const xy = ['x', 'y'] // Top-down to calculate percentage width/height of group

        for (var i = 0; i < elOptions.length; i++) {
          var elOption = elOptions[i]
          var id = convertOptionIdName(elOption.id, null)
          var el = id != null ? elMap.get(id) : null

          if (!el || !el.isGroup) {
            continue
          }

          var parentEl = el.parent
          const isParentRoot = parentEl === rootGroup // Like 'position:absolut' in css, default 0.

          const elInner = inner$e(el)
          var parentElInner = inner$e(parentEl)
          elInner.width = parsePercent$1(elInner.option.width, isParentRoot ? apiWidth : parentElInner.width) || 0
          elInner.height = parsePercent$1(elInner.option.height, isParentRoot ? apiHeight : parentElInner.height) || 0
        } // Bottom-up tranvese all elements (consider ec resize) to locate elements.

        for (var i = elOptions.length - 1; i >= 0; i--) {
          var elOption = elOptions[i]
          var id = convertOptionIdName(elOption.id, null)
          var el = id != null ? elMap.get(id) : null

          if (!el) {
            continue
          }

          var parentEl = el.parent
          var parentElInner = inner$e(parentEl)
          const containerInfo = parentEl === rootGroup
            ? {
                width: apiWidth,
                height: apiHeight
              }
            : {
                width: parentElInner.width,
                height: parentElInner.height
              } // PENDING
          // Currently, when `bounding: 'all'`, the union bounding rect of the group
          // does not include the rect of [0, 0, group.width, group.height], which
          // is probably weird for users. Should we make a break change for it?

          const layoutPos = {}
          const layouted = positionElement(el, elOption, containerInfo, null, {
            hv: elOption.hv,
            boundingMode: elOption.bounding
          }, layoutPos)

          if (!inner$e(el).isNew && layouted) {
            const transition = elOption.transition
            const animatePos = {}

            for (let k = 0; k < xy.length; k++) {
              const key = xy[k]
              const val = layoutPos[key]

              if (transition && (isTransitionAll(transition) || indexOf(transition, key) >= 0)) {
                animatePos[key] = val
              } else {
                el[key] = val
              }
            }

            updateProps(el, animatePos, graphicModel, 0)
          } else {
            el.attr(layoutPos)
          }
        }
      }
      /**
       * Clear all elements.
       */

      GraphicComponentView.prototype._clear = function () {
        const _this = this

        const elMap = this._elMap
        elMap.each(function (el) {
          removeEl(el, inner$e(el).option, elMap, _this._lastGraphicModel)
        })
        this._elMap = createHashMap()
      }

      GraphicComponentView.prototype.dispose = function () {
        this._clear()
      }

      GraphicComponentView.type = 'graphic'
      return GraphicComponentView
    }(ComponentView))

  function newEl (graphicType) {
    if ('development' !== 'production') {
      assert(graphicType, 'graphic type MUST be set')
    }

    const Clz = hasOwn(nonShapeGraphicElements, graphicType) // Those graphic elements are not shapes. They should not be
      // overwritten by users, so do them first.
      ? nonShapeGraphicElements[graphicType] : getShapeClass(graphicType)

    if ('development' !== 'production') {
      assert(Clz, 'graphic type ' + graphicType + ' can not be found')
    }

    const el = new Clz({})
    inner$e(el).type = graphicType
    return el
  }

  function createEl$1 (id, targetElParent, graphicType, elMap) {
    const el = newEl(graphicType)
    targetElParent.add(el)
    elMap.set(id, el)
    inner$e(el).id = id
    inner$e(el).isNew = true
    return el
  }

  function removeEl (elExisting, elOption, elMap, graphicModel) {
    const existElParent = elExisting && elExisting.parent

    if (existElParent) {
      elExisting.type === 'group' && elExisting.traverse(function (el) {
        removeEl(el, elOption, elMap, graphicModel)
      })
      applyLeaveTransition(elExisting, elOption, graphicModel)
      elMap.removeKey(inner$e(elExisting).id)
    }
  }

  function updateCommonAttrs (el, elOption, defaultZ, defaultZlevel) {
    if (!el.isGroup) {
      each([['cursor', Displayable.prototype.cursor], // We should not support configure z and zlevel in the element level.
        // But seems we didn't limit it previously. So here still use it to avoid breaking.
        ['zlevel', defaultZlevel || 0], ['z', defaultZ || 0], // z2 must not be null/undefined, otherwise sort error may occur.
        ['z2', 0]], function (item) {
        const prop = item[0]

        if (hasOwn(elOption, prop)) {
          el[prop] = retrieve2(elOption[prop], item[1])
        } else if (el[prop] == null) {
          el[prop] = item[1]
        }
      })
    }

    each(keys(elOption), function (key) {
      // Assign event handlers.
      // PENDING: should enumerate all event names or use pattern matching?
      if (key.indexOf('on') === 0) {
        const val = elOption[key]
        el[key] = isFunction(val) ? val : null
      }
    })

    if (hasOwn(elOption, 'draggable')) {
      el.draggable = elOption.draggable
    } // Other attributes

    elOption.name != null && (el.name = elOption.name)
    elOption.id != null && (el.id = elOption.id)
  } // Remove unnecessary props to avoid potential problems.

  function getCleanedElOption (elOption) {
    elOption = extend({}, elOption)
    each(['id', 'parentId', '$action', 'hv', 'bounding', 'textContent', 'clipPath'].concat(LOCATION_PARAMS), function (name) {
      delete elOption[name]
    })
    return elOption
  }

  function setEventData (el, graphicModel, elOption) {
    let eventData = getECData(el).eventData // Simple optimize for large amount of elements that no need event.

    if (!el.silent && !el.ignore && !eventData) {
      eventData = getECData(el).eventData = {
        componentType: 'graphic',
        componentIndex: graphicModel.componentIndex,
        name: el.name
      }
    } // `elOption.info` enables user to mount some info on
    // elements and use them in event handlers.

    if (eventData) {
      eventData.info = elOption.info
    }
  }

  function install$x (registers) {
    registers.registerComponentModel(GraphicComponentModel)
    registers.registerComponentView(GraphicComponentView)
    registers.registerPreprocessor(function (option) {
      const graphicOption = option.graphic // Convert
      // {graphic: [{left: 10, type: 'circle'}, ...]}
      // or
      // {graphic: {left: 10, type: 'circle'}}
      // to
      // {graphic: [{elements: [{left: 10, type: 'circle'}, ...]}]}

      if (isArray(graphicOption)) {
        if (!graphicOption[0] || !graphicOption[0].elements) {
          option.graphic = [{
            elements: graphicOption
          }]
        } else {
          // Only one graphic instance can be instantiated. (We dont
          // want that too many views are created in echarts._viewMap)
          option.graphic = [option.graphic[0]]
        }
      } else if (graphicOption && !graphicOption.elements) {
        option.graphic = [{
          elements: [graphicOption]
        }]
      }
    })
  }

  const DATA_ZOOM_AXIS_DIMENSIONS = ['x', 'y', 'radius', 'angle', 'single'] // Supported coords.
  // FIXME: polar has been broken (but rarely used).

  const SERIES_COORDS = ['cartesian2d', 'polar', 'singleAxis']
  function isCoordSupported (seriesModel) {
    const coordType = seriesModel.get('coordinateSystem')
    return indexOf(SERIES_COORDS, coordType) >= 0
  }
  function getAxisMainType (axisDim) {
    if ('development' !== 'production') {
      assert(axisDim)
    }

    return axisDim + 'Axis'
  }
  /**
     * If two dataZoomModels has the same axis controlled, we say that they are 'linked'.
     * This function finds all linked dataZoomModels start from the given payload.
     */

  function findEffectedDataZooms (ecModel, payload) {
    // Key: `DataZoomAxisDimension`
    const axisRecords = createHashMap()
    const effectedModels = [] // Key: uid of dataZoomModel

    const effectedModelMap = createHashMap() // Find the dataZooms specified by payload.

    ecModel.eachComponent({
      mainType: 'dataZoom',
      query: payload
    }, function (dataZoomModel) {
      if (!effectedModelMap.get(dataZoomModel.uid)) {
        addToEffected(dataZoomModel)
      }
    }) // Start from the given dataZoomModels, travel the graph to find
    // all of the linked dataZoom models.

    let foundNewLink

    do {
      foundNewLink = false
      ecModel.eachComponent('dataZoom', processSingle)
    } while (foundNewLink)

    function processSingle (dataZoomModel) {
      if (!effectedModelMap.get(dataZoomModel.uid) && isLinked(dataZoomModel)) {
        addToEffected(dataZoomModel)
        foundNewLink = true
      }
    }

    function addToEffected (dataZoom) {
      effectedModelMap.set(dataZoom.uid, true)
      effectedModels.push(dataZoom)
      markAxisControlled(dataZoom)
    }

    function isLinked (dataZoomModel) {
      let isLink = false
      dataZoomModel.eachTargetAxis(function (axisDim, axisIndex) {
        const axisIdxArr = axisRecords.get(axisDim)

        if (axisIdxArr && axisIdxArr[axisIndex]) {
          isLink = true
        }
      })
      return isLink
    }

    function markAxisControlled (dataZoomModel) {
      dataZoomModel.eachTargetAxis(function (axisDim, axisIndex) {
        (axisRecords.get(axisDim) || axisRecords.set(axisDim, []))[axisIndex] = true
      })
    }

    return effectedModels
  }
  /**
     * Find the first target coordinate system.
     * Available after model built.
     *
     * @return Like {
     *                  grid: [
     *                      {model: coord0, axisModels: [axis1, axis3], coordIndex: 1},
     *                      {model: coord1, axisModels: [axis0, axis2], coordIndex: 0},
     *                      ...
     *                  ],  // cartesians must not be null/undefined.
     *                  polar: [
     *                      {model: coord0, axisModels: [axis4], coordIndex: 0},
     *                      ...
     *                  ],  // polars must not be null/undefined.
     *                  singleAxis: [
     *                      {model: coord0, axisModels: [], coordIndex: 0}
     *                  ]
     *              }
     */

  function collectReferCoordSysModelInfo (dataZoomModel) {
    const ecModel = dataZoomModel.ecModel
    const coordSysInfoWrap = {
      infoList: [],
      infoMap: createHashMap()
    }
    dataZoomModel.eachTargetAxis(function (axisDim, axisIndex) {
      const axisModel = ecModel.getComponent(getAxisMainType(axisDim), axisIndex)

      if (!axisModel) {
        return
      }

      const coordSysModel = axisModel.getCoordSysModel()

      if (!coordSysModel) {
        return
      }

      const coordSysUid = coordSysModel.uid
      let coordSysInfo = coordSysInfoWrap.infoMap.get(coordSysUid)

      if (!coordSysInfo) {
        coordSysInfo = {
          model: coordSysModel,
          axisModels: []
        }
        coordSysInfoWrap.infoList.push(coordSysInfo)
        coordSysInfoWrap.infoMap.set(coordSysUid, coordSysInfo)
      }

      coordSysInfo.axisModels.push(axisModel)
    })
    return coordSysInfoWrap
  }

  const DataZoomAxisInfo =
    /** @class */
    (function () {
      function DataZoomAxisInfo () {
        this.indexList = []
        this.indexMap = []
      }

      DataZoomAxisInfo.prototype.add = function (axisCmptIdx) {
        // Remove duplication.
        if (!this.indexMap[axisCmptIdx]) {
          this.indexList.push(axisCmptIdx)
          this.indexMap[axisCmptIdx] = true
        }
      }

      return DataZoomAxisInfo
    }())

  const DataZoomModel =
    /** @class */
    (function (_super) {
      __extends(DataZoomModel, _super)

      function DataZoomModel () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = DataZoomModel.type
        _this._autoThrottle = true
        _this._noTarget = true
        /**
         * It is `[rangeModeForMin, rangeModeForMax]`.
         * The optional values for `rangeMode`:
         * + `'value'` mode: the axis extent will always be determined by
         *     `dataZoom.startValue` and `dataZoom.endValue`, despite
         *     how data like and how `axis.min` and `axis.max` are.
         * + `'percent'` mode: `100` represents 100% of the `[dMin, dMax]`,
         *     where `dMin` is `axis.min` if `axis.min` specified, otherwise `data.extent[0]`,
         *     and `dMax` is `axis.max` if `axis.max` specified, otherwise `data.extent[1]`.
         *     Axis extent will be determined by the result of the percent of `[dMin, dMax]`.
         *
         * For example, when users are using dynamic data (update data periodically via `setOption`),
         * if in `'value`' mode, the window will be kept in a fixed value range despite how
         * data are appended, while if in `'percent'` mode, whe window range will be changed alone with
         * the appended data (suppose `axis.min` and `axis.max` are not specified).
         */

        _this._rangePropMode = ['percent', 'percent']
        return _this
      }

      DataZoomModel.prototype.init = function (option, parentModel, ecModel) {
        const inputRawOption = retrieveRawOption(option)
        /**
         * Suppose a "main process" start at the point that model prepared (that is,
         * model initialized or merged or method called in `action`).
         * We should keep the `main process` idempotent, that is, given a set of values
         * on `option`, we get the same result.
         *
         * But sometimes, values on `option` will be updated for providing users
         * a "final calculated value" (`dataZoomProcessor` will do that). Those value
         * should not be the base/input of the `main process`.
         *
         * So in that case we should save and keep the input of the `main process`
         * separately, called `settledOption`.
         *
         * For example, consider the case:
         * (Step_1) brush zoom the grid by `toolbox.dataZoom`,
         *     where the original input `option.startValue`, `option.endValue` are earsed by
         *     calculated value.
         * (Step)2) click the legend to hide and show a series,
         *     where the new range is calculated by the earsed `startValue` and `endValue`,
         *     which brings incorrect result.
         */

        this.settledOption = inputRawOption
        this.mergeDefaultAndTheme(option, ecModel)

        this._doInit(inputRawOption)
      }

      DataZoomModel.prototype.mergeOption = function (newOption) {
        const inputRawOption = retrieveRawOption(newOption) // FIX #2591

        merge(this.option, newOption, true)
        merge(this.settledOption, inputRawOption, true)

        this._doInit(inputRawOption)
      }

      DataZoomModel.prototype._doInit = function (inputRawOption) {
        const thisOption = this.option

        this._setDefaultThrottle(inputRawOption)

        this._updateRangeUse(inputRawOption)

        const settledOption = this.settledOption
        each([['start', 'startValue'], ['end', 'endValue']], function (names, index) {
          // start/end has higher priority over startValue/endValue if they
          // both set, but we should make chart.setOption({endValue: 1000})
          // effective, rather than chart.setOption({endValue: 1000, end: null}).
          if (this._rangePropMode[index] === 'value') {
            thisOption[names[0]] = settledOption[names[0]] = null
          } // Otherwise do nothing and use the merge result.
        }, this)

        this._resetTarget()
      }

      DataZoomModel.prototype._resetTarget = function () {
        const optionOrient = this.get('orient', true)
        const targetAxisIndexMap = this._targetAxisInfoMap = createHashMap()

        const hasAxisSpecified = this._fillSpecifiedTargetAxis(targetAxisIndexMap)

        if (hasAxisSpecified) {
          this._orient = optionOrient || this._makeAutoOrientByTargetAxis()
        } else {
          this._orient = optionOrient || 'horizontal'

          this._fillAutoTargetAxisByOrient(targetAxisIndexMap, this._orient)
        }

        this._noTarget = true
        targetAxisIndexMap.each(function (axisInfo) {
          if (axisInfo.indexList.length) {
            this._noTarget = false
          }
        }, this)
      }

      DataZoomModel.prototype._fillSpecifiedTargetAxis = function (targetAxisIndexMap) {
        let hasAxisSpecified = false
        each(DATA_ZOOM_AXIS_DIMENSIONS, function (axisDim) {
          const refering = this.getReferringComponents(getAxisMainType(axisDim), MULTIPLE_REFERRING) // When user set axisIndex as a empty array, we think that user specify axisIndex
          // but do not want use auto mode. Because empty array may be encountered when
          // some error occured.

          if (!refering.specified) {
            return
          }

          hasAxisSpecified = true
          const axisInfo = new DataZoomAxisInfo()
          each(refering.models, function (axisModel) {
            axisInfo.add(axisModel.componentIndex)
          })
          targetAxisIndexMap.set(axisDim, axisInfo)
        }, this)
        return hasAxisSpecified
      }

      DataZoomModel.prototype._fillAutoTargetAxisByOrient = function (targetAxisIndexMap, orient) {
        const ecModel = this.ecModel
        let needAuto = true // Find axis that parallel to dataZoom as default.

        if (needAuto) {
          const axisDim = orient === 'vertical' ? 'y' : 'x'
          var axisModels = ecModel.findComponents({
            mainType: axisDim + 'Axis'
          })
          setParallelAxis(axisModels, axisDim)
        } // Find axis that parallel to dataZoom as default.

        if (needAuto) {
          var axisModels = ecModel.findComponents({
            mainType: 'singleAxis',
            filter: function (axisModel) {
              return axisModel.get('orient', true) === orient
            }
          })
          setParallelAxis(axisModels, 'single')
        }

        function setParallelAxis (axisModels, axisDim) {
          // At least use the first parallel axis as the target axis.
          const axisModel = axisModels[0]

          if (!axisModel) {
            return
          }

          const axisInfo = new DataZoomAxisInfo()
          axisInfo.add(axisModel.componentIndex)
          targetAxisIndexMap.set(axisDim, axisInfo)
          needAuto = false // Find parallel axes in the same grid.

          if (axisDim === 'x' || axisDim === 'y') {
            const gridModel_1 = axisModel.getReferringComponents('grid', SINGLE_REFERRING).models[0]
            gridModel_1 && each(axisModels, function (axModel) {
              if (axisModel.componentIndex !== axModel.componentIndex && gridModel_1 === axModel.getReferringComponents('grid', SINGLE_REFERRING).models[0]) {
                axisInfo.add(axModel.componentIndex)
              }
            })
          }
        }

        if (needAuto) {
          // If no parallel axis, find the first category axis as default. (Also consider polar).
          each(DATA_ZOOM_AXIS_DIMENSIONS, function (axisDim) {
            if (!needAuto) {
              return
            }

            const axisModels = ecModel.findComponents({
              mainType: getAxisMainType(axisDim),
              filter: function (axisModel) {
                return axisModel.get('type', true) === 'category'
              }
            })

            if (axisModels[0]) {
              const axisInfo = new DataZoomAxisInfo()
              axisInfo.add(axisModels[0].componentIndex)
              targetAxisIndexMap.set(axisDim, axisInfo)
              needAuto = false
            }
          }, this)
        }
      }

      DataZoomModel.prototype._makeAutoOrientByTargetAxis = function () {
        let dim // Find the first axis

        this.eachTargetAxis(function (axisDim) {
          !dim && (dim = axisDim)
        }, this)
        return dim === 'y' ? 'vertical' : 'horizontal'
      }

      DataZoomModel.prototype._setDefaultThrottle = function (inputRawOption) {
        // When first time user set throttle, auto throttle ends.
        if (inputRawOption.hasOwnProperty('throttle')) {
          this._autoThrottle = false
        }

        if (this._autoThrottle) {
          const globalOption = this.ecModel.option
          this.option.throttle = globalOption.animation && globalOption.animationDurationUpdate > 0 ? 100 : 20
        }
      }

      DataZoomModel.prototype._updateRangeUse = function (inputRawOption) {
        const rangePropMode = this._rangePropMode
        const rangeModeInOption = this.get('rangeMode')
        each([['start', 'startValue'], ['end', 'endValue']], function (names, index) {
          const percentSpecified = inputRawOption[names[0]] != null
          const valueSpecified = inputRawOption[names[1]] != null

          if (percentSpecified && !valueSpecified) {
            rangePropMode[index] = 'percent'
          } else if (!percentSpecified && valueSpecified) {
            rangePropMode[index] = 'value'
          } else if (rangeModeInOption) {
            rangePropMode[index] = rangeModeInOption[index]
          } else if (percentSpecified) {
            // percentSpecified && valueSpecified
            rangePropMode[index] = 'percent'
          } // else remain its original setting.
        })
      }

      DataZoomModel.prototype.noTarget = function () {
        return this._noTarget
      }

      DataZoomModel.prototype.getFirstTargetAxisModel = function () {
        let firstAxisModel
        this.eachTargetAxis(function (axisDim, axisIndex) {
          if (firstAxisModel == null) {
            firstAxisModel = this.ecModel.getComponent(getAxisMainType(axisDim), axisIndex)
          }
        }, this)
        return firstAxisModel
      }
      /**
       * @param {Function} callback param: axisModel, dimNames, axisIndex, dataZoomModel, ecModel
       */

      DataZoomModel.prototype.eachTargetAxis = function (callback, context) {
        this._targetAxisInfoMap.each(function (axisInfo, axisDim) {
          each(axisInfo.indexList, function (axisIndex) {
            callback.call(context, axisDim, axisIndex)
          })
        })
      }
      /**
       * @return If not found, return null/undefined.
       */

      DataZoomModel.prototype.getAxisProxy = function (axisDim, axisIndex) {
        const axisModel = this.getAxisModel(axisDim, axisIndex)

        if (axisModel) {
          return axisModel.__dzAxisProxy
        }
      }
      /**
       * @return If not found, return null/undefined.
       */

      DataZoomModel.prototype.getAxisModel = function (axisDim, axisIndex) {
        if ('development' !== 'production') {
          assert(axisDim && axisIndex != null)
        }

        const axisInfo = this._targetAxisInfoMap.get(axisDim)

        if (axisInfo && axisInfo.indexMap[axisIndex]) {
          return this.ecModel.getComponent(getAxisMainType(axisDim), axisIndex)
        }
      }
      /**
       * If not specified, set to undefined.
       */

      DataZoomModel.prototype.setRawRange = function (opt) {
        const thisOption = this.option
        const settledOption = this.settledOption
        each([['start', 'startValue'], ['end', 'endValue']], function (names) {
          // Consider the pair <start, startValue>:
          // If one has value and the other one is `null/undefined`, we both set them
          // to `settledOption`. This strategy enables the feature to clear the original
          // value in `settledOption` to `null/undefined`.
          // But if both of them are `null/undefined`, we do not set them to `settledOption`
          // and keep `settledOption` with the original value. This strategy enables users to
          // only set <end or endValue> but not set <start or startValue> when calling
          // `dispatchAction`.
          // The pair <end, endValue> is treated in the same way.
          if (opt[names[0]] != null || opt[names[1]] != null) {
            thisOption[names[0]] = settledOption[names[0]] = opt[names[0]]
            thisOption[names[1]] = settledOption[names[1]] = opt[names[1]]
          }
        }, this)

        this._updateRangeUse(opt)
      }

      DataZoomModel.prototype.setCalculatedRange = function (opt) {
        const option = this.option
        each(['start', 'startValue', 'end', 'endValue'], function (name) {
          option[name] = opt[name]
        })
      }

      DataZoomModel.prototype.getPercentRange = function () {
        const axisProxy = this.findRepresentativeAxisProxy()

        if (axisProxy) {
          return axisProxy.getDataPercentWindow()
        }
      }
      /**
       * For example, chart.getModel().getComponent('dataZoom').getValueRange('y', 0);
       *
       * @return [startValue, endValue] value can only be '-' or finite number.
       */

      DataZoomModel.prototype.getValueRange = function (axisDim, axisIndex) {
        if (axisDim == null && axisIndex == null) {
          const axisProxy = this.findRepresentativeAxisProxy()

          if (axisProxy) {
            return axisProxy.getDataValueWindow()
          }
        } else {
          return this.getAxisProxy(axisDim, axisIndex).getDataValueWindow()
        }
      }
      /**
       * @param axisModel If axisModel given, find axisProxy
       *      corresponding to the axisModel
       */

      DataZoomModel.prototype.findRepresentativeAxisProxy = function (axisModel) {
        if (axisModel) {
          return axisModel.__dzAxisProxy
        } // Find the first hosted axisProxy

        let firstProxy

        const axisDimList = this._targetAxisInfoMap.keys()

        for (let i = 0; i < axisDimList.length; i++) {
          const axisDim = axisDimList[i]

          const axisInfo = this._targetAxisInfoMap.get(axisDim)

          for (let j = 0; j < axisInfo.indexList.length; j++) {
            const proxy = this.getAxisProxy(axisDim, axisInfo.indexList[j])

            if (proxy.hostedBy(this)) {
              return proxy
            }

            if (!firstProxy) {
              firstProxy = proxy
            }
          }
        } // If no hosted proxy found, still need to return a proxy.
        // This case always happens in toolbox dataZoom, where axes are all hosted by
        // other dataZooms.

        return firstProxy
      }

      DataZoomModel.prototype.getRangePropMode = function () {
        return this._rangePropMode.slice()
      }

      DataZoomModel.prototype.getOrient = function () {
        if ('development' !== 'production') {
          // Should not be called before initialized.
          assert(this._orient)
        }

        return this._orient
      }

      DataZoomModel.type = 'dataZoom'
      DataZoomModel.dependencies = ['xAxis', 'yAxis', 'radiusAxis', 'angleAxis', 'singleAxis', 'series', 'toolbox']
      DataZoomModel.defaultOption = {
        // zlevel: 0,
        z: 4,
        filterMode: 'filter',
        start: 0,
        end: 100
      }
      return DataZoomModel
    }(ComponentModel))
    /**
     * Retrieve the those raw params from option, which will be cached separately.
     * becasue they will be overwritten by normalized/calculated values in the main
     * process.
     */

  function retrieveRawOption (option) {
    const ret = {}
    each(['start', 'end', 'startValue', 'endValue', 'throttle'], function (name) {
      option.hasOwnProperty(name) && (ret[name] = option[name])
    })
    return ret
  }

  const SelectDataZoomModel =
    /** @class */
    (function (_super) {
      __extends(SelectDataZoomModel, _super)

      function SelectDataZoomModel () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = SelectDataZoomModel.type
        return _this
      }

      SelectDataZoomModel.type = 'dataZoom.select'
      return SelectDataZoomModel
    }(DataZoomModel))

  const DataZoomView =
    /** @class */
    (function (_super) {
      __extends(DataZoomView, _super)

      function DataZoomView () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = DataZoomView.type
        return _this
      }

      DataZoomView.prototype.render = function (dataZoomModel, ecModel, api, payload) {
        this.dataZoomModel = dataZoomModel
        this.ecModel = ecModel
        this.api = api
      }

      DataZoomView.type = 'dataZoom'
      return DataZoomView
    }(ComponentView))

  const SelectDataZoomView =
    /** @class */
    (function (_super) {
      __extends(SelectDataZoomView, _super)

      function SelectDataZoomView () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = SelectDataZoomView.type
        return _this
      }

      SelectDataZoomView.type = 'dataZoom.select'
      return SelectDataZoomView
    }(DataZoomView))

  const each$8 = each
  const asc$1 = asc
  /**
     * Operate single axis.
     * One axis can only operated by one axis operator.
     * Different dataZoomModels may be defined to operate the same axis.
     * (i.e. 'inside' data zoom and 'slider' data zoom components)
     * So dataZoomModels share one axisProxy in that case.
     */

  const AxisProxy =
    /** @class */
    (function () {
      function AxisProxy (dimName, axisIndex, dataZoomModel, ecModel) {
        this._dimName = dimName
        this._axisIndex = axisIndex
        this.ecModel = ecModel
        this._dataZoomModel = dataZoomModel // /**
        //  * @readOnly
        //  * @private
        //  */
        // this.hasSeriesStacked;
      }
      /**
       * Whether the axisProxy is hosted by dataZoomModel.
       */

      AxisProxy.prototype.hostedBy = function (dataZoomModel) {
        return this._dataZoomModel === dataZoomModel
      }
      /**
       * @return Value can only be NaN or finite value.
       */

      AxisProxy.prototype.getDataValueWindow = function () {
        return this._valueWindow.slice()
      }
      /**
       * @return {Array.<number>}
       */

      AxisProxy.prototype.getDataPercentWindow = function () {
        return this._percentWindow.slice()
      }

      AxisProxy.prototype.getTargetSeriesModels = function () {
        const seriesModels = []
        this.ecModel.eachSeries(function (seriesModel) {
          if (isCoordSupported(seriesModel)) {
            const axisMainType = getAxisMainType(this._dimName)
            const axisModel = seriesModel.getReferringComponents(axisMainType, SINGLE_REFERRING).models[0]

            if (axisModel && this._axisIndex === axisModel.componentIndex) {
              seriesModels.push(seriesModel)
            }
          }
        }, this)
        return seriesModels
      }

      AxisProxy.prototype.getAxisModel = function () {
        return this.ecModel.getComponent(this._dimName + 'Axis', this._axisIndex)
      }

      AxisProxy.prototype.getMinMaxSpan = function () {
        return clone(this._minMaxSpan)
      }
      /**
       * Only calculate by given range and this._dataExtent, do not change anything.
       */

      AxisProxy.prototype.calculateDataWindow = function (opt) {
        const dataExtent = this._dataExtent
        const axisModel = this.getAxisModel()
        const scale = axisModel.axis.scale

        const rangePropMode = this._dataZoomModel.getRangePropMode()

        const percentExtent = [0, 100]
        const percentWindow = []
        const valueWindow = []
        let hasPropModeValue
        each$8(['start', 'end'], function (prop, idx) {
          let boundPercent = opt[prop]
          let boundValue = opt[prop + 'Value'] // Notice: dataZoom is based either on `percentProp` ('start', 'end') or
          // on `valueProp` ('startValue', 'endValue'). (They are based on the data extent
          // but not min/max of axis, which will be calculated by data window then).
          // The former one is suitable for cases that a dataZoom component controls multiple
          // axes with different unit or extent, and the latter one is suitable for accurate
          // zoom by pixel (e.g., in dataZoomSelect).
          // we use `getRangePropMode()` to mark which prop is used. `rangePropMode` is updated
          // only when setOption or dispatchAction, otherwise it remains its original value.
          // (Why not only record `percentProp` and always map to `valueProp`? Because
          // the map `valueProp` -> `percentProp` -> `valueProp` probably not the original
          // `valueProp`. consider two axes constrolled by one dataZoom. They have different
          // data extent. All of values that are overflow the `dataExtent` will be calculated
          // to percent '100%').

          if (rangePropMode[idx] === 'percent') {
            boundPercent == null && (boundPercent = percentExtent[idx]) // Use scale.parse to math round for category or time axis.

            boundValue = scale.parse(linearMap(boundPercent, percentExtent, dataExtent))
          } else {
            hasPropModeValue = true
            boundValue = boundValue == null ? dataExtent[idx] : scale.parse(boundValue) // Calculating `percent` from `value` may be not accurate, because
            // This calculation can not be inversed, because all of values that
            // are overflow the `dataExtent` will be calculated to percent '100%'

            boundPercent = linearMap(boundValue, dataExtent, percentExtent)
          } // valueWindow[idx] = round(boundValue);
          // percentWindow[idx] = round(boundPercent);

          valueWindow[idx] = boundValue
          percentWindow[idx] = boundPercent
        })
        asc$1(valueWindow)
        asc$1(percentWindow) // The windows from user calling of `dispatchAction` might be out of the extent,
        // or do not obey the `min/maxSpan`, `min/maxValueSpan`. But we dont restrict window
        // by `zoomLock` here, because we see `zoomLock` just as a interaction constraint,
        // where API is able to initialize/modify the window size even though `zoomLock`
        // specified.

        const spans = this._minMaxSpan
        hasPropModeValue ? restrictSet(valueWindow, percentWindow, dataExtent, percentExtent, false) : restrictSet(percentWindow, valueWindow, percentExtent, dataExtent, true)

        function restrictSet (fromWindow, toWindow, fromExtent, toExtent, toValue) {
          const suffix = toValue ? 'Span' : 'ValueSpan'
          sliderMove(0, fromWindow, fromExtent, 'all', spans['min' + suffix], spans['max' + suffix])

          for (let i = 0; i < 2; i++) {
            toWindow[i] = linearMap(fromWindow[i], fromExtent, toExtent, true)
            toValue && (toWindow[i] = scale.parse(toWindow[i]))
          }
        }

        return {
          valueWindow: valueWindow,
          percentWindow: percentWindow
        }
      }
      /**
       * Notice: reset should not be called before series.restoreData() called,
       * so it is recommanded to be called in "process stage" but not "model init
       * stage".
       */

      AxisProxy.prototype.reset = function (dataZoomModel) {
        if (dataZoomModel !== this._dataZoomModel) {
          return
        }

        const targetSeries = this.getTargetSeriesModels() // Culculate data window and data extent, and record them.

        this._dataExtent = calculateDataExtent(this, this._dimName, targetSeries) // `calculateDataWindow` uses min/maxSpan.

        this._updateMinMaxSpan()

        const dataWindow = this.calculateDataWindow(dataZoomModel.settledOption)
        this._valueWindow = dataWindow.valueWindow
        this._percentWindow = dataWindow.percentWindow // Update axis setting then.

        this._setAxisModel()
      }

      AxisProxy.prototype.filterData = function (dataZoomModel, api) {
        if (dataZoomModel !== this._dataZoomModel) {
          return
        }

        const axisDim = this._dimName
        const seriesModels = this.getTargetSeriesModels()
        const filterMode = dataZoomModel.get('filterMode')
        const valueWindow = this._valueWindow

        if (filterMode === 'none') {
          return
        } // FIXME
        // Toolbox may has dataZoom injected. And if there are stacked bar chart
        // with NaN data, NaN will be filtered and stack will be wrong.
        // So we need to force the mode to be set empty.
        // In fect, it is not a big deal that do not support filterMode-'filter'
        // when using toolbox#dataZoom, utill tooltip#dataZoom support "single axis
        // selection" some day, which might need "adapt to data extent on the
        // otherAxis", which is disabled by filterMode-'empty'.
        // But currently, stack has been fixed to based on value but not index,
        // so this is not an issue any more.
        // let otherAxisModel = this.getOtherAxisModel();
        // if (dataZoomModel.get('$fromToolbox')
        //     && otherAxisModel
        //     && otherAxisModel.hasSeriesStacked
        // ) {
        //     filterMode = 'empty';
        // }
        // TODO
        // filterMode 'weakFilter' and 'empty' is not optimized for huge data yet.

        each$8(seriesModels, function (seriesModel) {
          let seriesData = seriesModel.getData()
          const dataDims = seriesData.mapDimensionsAll(axisDim)

          if (!dataDims.length) {
            return
          }

          if (filterMode === 'weakFilter') {
            const store_1 = seriesData.getStore()
            const dataDimIndices_1 = map(dataDims, function (dim) {
              return seriesData.getDimensionIndex(dim)
            }, seriesData)
            seriesData.filterSelf(function (dataIndex) {
              let leftOut
              let rightOut
              let hasValue

              for (let i = 0; i < dataDims.length; i++) {
                const value = store_1.get(dataDimIndices_1[i], dataIndex)
                const thisHasValue = !isNaN(value)
                const thisLeftOut = value < valueWindow[0]
                const thisRightOut = value > valueWindow[1]

                if (thisHasValue && !thisLeftOut && !thisRightOut) {
                  return true
                }

                thisHasValue && (hasValue = true)
                thisLeftOut && (leftOut = true)
                thisRightOut && (rightOut = true)
              } // If both left out and right out, do not filter.

              return hasValue && leftOut && rightOut
            })
          } else {
            each$8(dataDims, function (dim) {
              if (filterMode === 'empty') {
                seriesModel.setData(seriesData = seriesData.map(dim, function (value) {
                  return !isInWindow(value) ? NaN : value
                }))
              } else {
                const range = {}
                range[dim] = valueWindow // console.time('select');

                seriesData.selectRange(range) // console.timeEnd('select');
              }
            })
          }

          each$8(dataDims, function (dim) {
            seriesData.setApproximateExtent(valueWindow, dim)
          })
        })

        function isInWindow (value) {
          return value >= valueWindow[0] && value <= valueWindow[1]
        }
      }

      AxisProxy.prototype._updateMinMaxSpan = function () {
        const minMaxSpan = this._minMaxSpan = {}
        const dataZoomModel = this._dataZoomModel
        const dataExtent = this._dataExtent
        each$8(['min', 'max'], function (minMax) {
          let percentSpan = dataZoomModel.get(minMax + 'Span')
          let valueSpan = dataZoomModel.get(minMax + 'ValueSpan')
          valueSpan != null && (valueSpan = this.getAxisModel().axis.scale.parse(valueSpan)) // minValueSpan and maxValueSpan has higher priority than minSpan and maxSpan

          if (valueSpan != null) {
            percentSpan = linearMap(dataExtent[0] + valueSpan, dataExtent, [0, 100], true)
          } else if (percentSpan != null) {
            valueSpan = linearMap(percentSpan, [0, 100], dataExtent, true) - dataExtent[0]
          }

          minMaxSpan[minMax + 'Span'] = percentSpan
          minMaxSpan[minMax + 'ValueSpan'] = valueSpan
        }, this)
      }

      AxisProxy.prototype._setAxisModel = function () {
        const axisModel = this.getAxisModel()
        const percentWindow = this._percentWindow
        const valueWindow = this._valueWindow

        if (!percentWindow) {
          return
        } // [0, 500]: arbitrary value, guess axis extent.

        let precision = getPixelPrecision(valueWindow, [0, 500])
        precision = Math.min(precision, 20) // For value axis, if min/max/scale are not set, we just use the extent obtained
        // by series data, which may be a little different from the extent calculated by
        // `axisHelper.getScaleExtent`. But the different just affects the experience a
        // little when zooming. So it will not be fixed until some users require it strongly.

        const rawExtentInfo = axisModel.axis.scale.rawExtentInfo

        if (percentWindow[0] !== 0) {
          rawExtentInfo.setDeterminedMinMax('min', +valueWindow[0].toFixed(precision))
        }

        if (percentWindow[1] !== 100) {
          rawExtentInfo.setDeterminedMinMax('max', +valueWindow[1].toFixed(precision))
        }

        rawExtentInfo.freeze()
      }

      return AxisProxy
    }())

  function calculateDataExtent (axisProxy, axisDim, seriesModels) {
    const dataExtent = [Infinity, -Infinity]
    each$8(seriesModels, function (seriesModel) {
      unionAxisExtentFromData(dataExtent, seriesModel.getData(), axisDim)
    }) // It is important to get "consistent" extent when more then one axes is
    // controlled by a `dataZoom`, otherwise those axes will not be synchronized
    // when zooming. But it is difficult to know what is "consistent", considering
    // axes have different type or even different meanings (For example, two
    // time axes are used to compare data of the same date in different years).
    // So basically dataZoom just obtains extent by series.data (in category axis
    // extent can be obtained from axis.data).
    // Nevertheless, user can set min/max/scale on axes to make extent of axes
    // consistent.

    const axisModel = axisProxy.getAxisModel()
    const rawExtentResult = ensureScaleRawExtentInfo(axisModel.axis.scale, axisModel, dataExtent).calculate()
    return [rawExtentResult.min, rawExtentResult.max]
  }

  const dataZoomProcessor = {
    // `dataZoomProcessor` will only be performed in needed series. Consider if
    // there is a line series and a pie series, it is better not to update the
    // line series if only pie series is needed to be updated.
    getTargetSeries: function (ecModel) {
      function eachAxisModel (cb) {
        ecModel.eachComponent('dataZoom', function (dataZoomModel) {
          dataZoomModel.eachTargetAxis(function (axisDim, axisIndex) {
            const axisModel = ecModel.getComponent(getAxisMainType(axisDim), axisIndex)
            cb(axisDim, axisIndex, axisModel, dataZoomModel)
          })
        })
      } // FIXME: it brings side-effect to `getTargetSeries`.
      // Prepare axis proxies.

      eachAxisModel(function (axisDim, axisIndex, axisModel, dataZoomModel) {
        // dispose all last axis proxy, in case that some axis are deleted.
        axisModel.__dzAxisProxy = null
      })
      const proxyList = []
      eachAxisModel(function (axisDim, axisIndex, axisModel, dataZoomModel) {
        // Different dataZooms may constrol the same axis. In that case,
        // an axisProxy serves both of them.
        if (!axisModel.__dzAxisProxy) {
          // Use the first dataZoomModel as the main model of axisProxy.
          axisModel.__dzAxisProxy = new AxisProxy(axisDim, axisIndex, dataZoomModel, ecModel)
          proxyList.push(axisModel.__dzAxisProxy)
        }
      })
      const seriesModelMap = createHashMap()
      each(proxyList, function (axisProxy) {
        each(axisProxy.getTargetSeriesModels(), function (seriesModel) {
          seriesModelMap.set(seriesModel.uid, seriesModel)
        })
      })
      return seriesModelMap
    },
    // Consider appendData, where filter should be performed. Because data process is
    // in block mode currently, it is not need to worry about that the overallProgress
    // execute every frame.
    overallReset: function (ecModel, api) {
      ecModel.eachComponent('dataZoom', function (dataZoomModel) {
        // We calculate window and reset axis here but not in model
        // init stage and not after action dispatch handler, because
        // reset should be called after seriesData.restoreData.
        dataZoomModel.eachTargetAxis(function (axisDim, axisIndex) {
          dataZoomModel.getAxisProxy(axisDim, axisIndex).reset(dataZoomModel)
        }) // Caution: data zoom filtering is order sensitive when using
        // percent range and no min/max/scale set on axis.
        // For example, we have dataZoom definition:
        // [
        //      {xAxisIndex: 0, start: 30, end: 70},
        //      {yAxisIndex: 0, start: 20, end: 80}
        // ]
        // In this case, [20, 80] of y-dataZoom should be based on data
        // that have filtered by x-dataZoom using range of [30, 70],
        // but should not be based on full raw data. Thus sliding
        // x-dataZoom will change both ranges of xAxis and yAxis,
        // while sliding y-dataZoom will only change the range of yAxis.
        // So we should filter x-axis after reset x-axis immediately,
        // and then reset y-axis and filter y-axis.

        dataZoomModel.eachTargetAxis(function (axisDim, axisIndex) {
          dataZoomModel.getAxisProxy(axisDim, axisIndex).filterData(dataZoomModel, api)
        })
      })
      ecModel.eachComponent('dataZoom', function (dataZoomModel) {
        // Fullfill all of the range props so that user
        // is able to get them from chart.getOption().
        const axisProxy = dataZoomModel.findRepresentativeAxisProxy()

        if (axisProxy) {
          const percentRange = axisProxy.getDataPercentWindow()
          const valueRange = axisProxy.getDataValueWindow()
          dataZoomModel.setCalculatedRange({
            start: percentRange[0],
            end: percentRange[1],
            startValue: valueRange[0],
            endValue: valueRange[1]
          })
        }
      })
    }
  }

  function installDataZoomAction (registers) {
    registers.registerAction('dataZoom', function (payload, ecModel) {
      const effectedModels = findEffectedDataZooms(ecModel, payload)
      each(effectedModels, function (dataZoomModel) {
        dataZoomModel.setRawRange({
          start: payload.start,
          end: payload.end,
          startValue: payload.startValue,
          endValue: payload.endValue
        })
      })
    })
  }

  let installed = false
  function installCommon (registers) {
    if (installed) {
      return
    }

    installed = true
    registers.registerProcessor(registers.PRIORITY.PROCESSOR.FILTER, dataZoomProcessor)
    installDataZoomAction(registers)
    registers.registerSubTypeDefaulter('dataZoom', function () {
      // Default 'slider' when no type specified.
      return 'slider'
    })
  }

  function install$y (registers) {
    registers.registerComponentModel(SelectDataZoomModel)
    registers.registerComponentView(SelectDataZoomView)
    installCommon(registers)
  }

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

  /**
     * AUTO-GENERATED FILE. DO NOT MODIFY.
     */

  const ToolboxFeature =
    /** @class */
    (function () {
      function ToolboxFeature () {}

      return ToolboxFeature
    }())
  const features = {}
  function registerFeature (name, ctor) {
    features[name] = ctor
  }
  function getFeature (name) {
    return features[name]
  }

  const ToolboxModel =
    /** @class */
    (function (_super) {
      __extends(ToolboxModel, _super)

      function ToolboxModel () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = ToolboxModel.type
        return _this
      }

      ToolboxModel.prototype.optionUpdated = function () {
        _super.prototype.optionUpdated.apply(this, arguments)

        const ecModel = this.ecModel
        each(this.option.feature, function (featureOpt, featureName) {
          const Feature = getFeature(featureName)

          if (Feature) {
            if (Feature.getDefaultOption) {
              Feature.defaultOption = Feature.getDefaultOption(ecModel)
            }

            merge(featureOpt, Feature.defaultOption)
          }
        })
      }

      ToolboxModel.type = 'toolbox'
      ToolboxModel.layoutMode = {
        type: 'box',
        ignoreSize: true
      }
      ToolboxModel.defaultOption = {
        show: true,
        z: 6,
        // zlevel: 0,
        orient: 'horizontal',
        left: 'right',
        top: 'top',
        // right
        // bottom
        backgroundColor: 'transparent',
        borderColor: '#ccc',
        borderRadius: 0,
        borderWidth: 0,
        padding: 5,
        itemSize: 15,
        itemGap: 8,
        showTitle: true,
        iconStyle: {
          borderColor: '#666',
          color: 'none'
        },
        emphasis: {
          iconStyle: {
            borderColor: '#3E98C5'
          }
        },
        // textStyle: {},
        // feature
        tooltip: {
          show: false,
          position: 'bottom'
        }
      }
      return ToolboxModel
    }(ComponentModel))

  /**
     * Layout list like component.
     * It will box layout each items in group of component and then position the whole group in the viewport
     * @param {module:zrender/group/Group} group
     * @param {module:echarts/model/Component} componentModel
     * @param {module:echarts/ExtensionAPI}
     */

  function layout$3 (group, componentModel, api) {
    const boxLayoutParams = componentModel.getBoxLayoutParams()
    const padding = componentModel.get('padding')
    const viewportSize = {
      width: api.getWidth(),
      height: api.getHeight()
    }
    const rect = getLayoutRect(boxLayoutParams, viewportSize, padding)
    box(componentModel.get('orient'), group, componentModel.get('itemGap'), rect.width, rect.height)
    positionElement(group, boxLayoutParams, viewportSize, padding)
  }
  function makeBackground (rect, componentModel) {
    const padding = normalizeCssArray$1(componentModel.get('padding'))
    const style = componentModel.getItemStyle(['color', 'opacity'])
    style.fill = componentModel.get('backgroundColor')
    rect = new Rect({
      shape: {
        x: rect.x - padding[3],
        y: rect.y - padding[0],
        width: rect.width + padding[1] + padding[3],
        height: rect.height + padding[0] + padding[2],
        r: componentModel.get('borderRadius')
      },
      style: style,
      silent: true,
      z2: -1
    }) // FIXME
    // `subPixelOptimizeRect` may bring some gap between edge of viewpart
    // and background rect when setting like `left: 0`, `top: 0`.
    // graphic.subPixelOptimizeRect(rect);

    return rect
  }

  const ToolboxView =
    /** @class */
    (function (_super) {
      __extends(ToolboxView, _super)

      function ToolboxView () {
        return _super !== null && _super.apply(this, arguments) || this
      }

      ToolboxView.prototype.render = function (toolboxModel, ecModel, api, payload) {
        const group = this.group
        group.removeAll()

        if (!toolboxModel.get('show')) {
          return
        }

        const itemSize = +toolboxModel.get('itemSize')
        const isVertical = toolboxModel.get('orient') === 'vertical'
        const featureOpts = toolboxModel.get('feature') || {}
        const features = this._features || (this._features = {})
        const featureNames = []
        each(featureOpts, function (opt, name) {
          featureNames.push(name)
        })
        new DataDiffer(this._featureNames || [], featureNames).add(processFeature).update(processFeature).remove(curry(processFeature, null)).execute() // Keep for diff.

        this._featureNames = featureNames

        function processFeature (newIndex, oldIndex) {
          const featureName = featureNames[newIndex]
          const oldName = featureNames[oldIndex]
          const featureOpt = featureOpts[featureName]
          const featureModel = new Model(featureOpt, toolboxModel, toolboxModel.ecModel)
          let feature // FIX#11236, merge feature title from MagicType newOption. TODO: consider seriesIndex ?

          if (payload && payload.newTitle != null && payload.featureName === featureName) {
            featureOpt.title = payload.newTitle
          }

          if (featureName && !oldName) {
            // Create
            if (isUserFeatureName(featureName)) {
              feature = {
                onclick: featureModel.option.onclick,
                featureName: featureName
              }
            } else {
              const Feature = getFeature(featureName)

              if (!Feature) {
                return
              }

              feature = new Feature()
            }

            features[featureName] = feature
          } else {
            feature = features[oldName] // If feature does not exsit.

            if (!feature) {
              return
            }
          }

          feature.uid = getUID('toolbox-feature')
          feature.model = featureModel
          feature.ecModel = ecModel
          feature.api = api
          const isToolboxFeature = feature instanceof ToolboxFeature

          if (!featureName && oldName) {
            isToolboxFeature && feature.dispose && feature.dispose(ecModel, api)
            return
          }

          if (!featureModel.get('show') || isToolboxFeature && feature.unusable) {
            isToolboxFeature && feature.remove && feature.remove(ecModel, api)
            return
          }

          createIconPaths(featureModel, feature, featureName)

          featureModel.setIconStatus = function (iconName, status) {
            const option = this.option
            const iconPaths = this.iconPaths
            option.iconStatus = option.iconStatus || {}
            option.iconStatus[iconName] = status

            if (iconPaths[iconName]) {
              (status === 'emphasis' ? enterEmphasis : leaveEmphasis)(iconPaths[iconName])
            }
          }

          if (feature instanceof ToolboxFeature) {
            if (feature.render) {
              feature.render(featureModel, ecModel, api, payload)
            }
          }
        }

        function createIconPaths (featureModel, feature, featureName) {
          const iconStyleModel = featureModel.getModel('iconStyle')
          const iconStyleEmphasisModel = featureModel.getModel(['emphasis', 'iconStyle']) // If one feature has mutiple icon. they are orginaized as
          // {
          //     icon: {
          //         foo: '',
          //         bar: ''
          //     },
          //     title: {
          //         foo: '',
          //         bar: ''
          //     }
          // }

          const icons = feature instanceof ToolboxFeature && feature.getIcons ? feature.getIcons() : featureModel.get('icon')
          const titles = featureModel.get('title') || {}
          let iconsMap
          let titlesMap

          if (isString(icons)) {
            iconsMap = {}
            iconsMap[featureName] = icons
          } else {
            iconsMap = icons
          }

          if (isString(titles)) {
            titlesMap = {}
            titlesMap[featureName] = titles
          } else {
            titlesMap = titles
          }

          const iconPaths = featureModel.iconPaths = {}
          each(iconsMap, function (iconStr, iconName) {
            const path = createIcon(iconStr, {}, {
              x: -itemSize / 2,
              y: -itemSize / 2,
              width: itemSize,
              height: itemSize
            }) // TODO handling image

            path.setStyle(iconStyleModel.getItemStyle())
            const pathEmphasisState = path.ensureState('emphasis')
            pathEmphasisState.style = iconStyleEmphasisModel.getItemStyle() // Text position calculation

            const textContent = new ZRText({
              style: {
                text: titlesMap[iconName],
                align: iconStyleEmphasisModel.get('textAlign'),
                borderRadius: iconStyleEmphasisModel.get('textBorderRadius'),
                padding: iconStyleEmphasisModel.get('textPadding'),
                fill: null
              },
              ignore: true
            })
            path.setTextContent(textContent)
            setTooltipConfig({
              el: path,
              componentModel: toolboxModel,
              itemName: iconName,
              formatterParamsExtra: {
                title: titlesMap[iconName]
              }
            })
            path.__title = titlesMap[iconName]
            path.on('mouseover', function () {
              // Should not reuse above hoverStyle, which might be modified.
              const hoverStyle = iconStyleEmphasisModel.getItemStyle()
              const defaultTextPosition = isVertical ? toolboxModel.get('right') == null && toolboxModel.get('left') !== 'right' ? 'right' : 'left' : toolboxModel.get('bottom') == null && toolboxModel.get('top') !== 'bottom' ? 'bottom' : 'top'
              textContent.setStyle({
                fill: iconStyleEmphasisModel.get('textFill') || hoverStyle.fill || hoverStyle.stroke || '#000',
                backgroundColor: iconStyleEmphasisModel.get('textBackgroundColor')
              })
              path.setTextConfig({
                position: iconStyleEmphasisModel.get('textPosition') || defaultTextPosition
              })
              textContent.ignore = !toolboxModel.get('showTitle') // Use enterEmphasis and leaveEmphasis provide by ec.
              // There are flags managed by the echarts.

              api.enterEmphasis(this)
            }).on('mouseout', function () {
              if (featureModel.get(['iconStatus', iconName]) !== 'emphasis') {
                api.leaveEmphasis(this)
              }

              textContent.hide()
            });
            (featureModel.get(['iconStatus', iconName]) === 'emphasis' ? enterEmphasis : leaveEmphasis)(path)
            group.add(path)
            path.on('click', bind(feature.onclick, feature, ecModel, api, iconName))
            iconPaths[iconName] = path
          })
        }

        layout$3(group, toolboxModel, api) // Render background after group is layout
        // FIXME

        group.add(makeBackground(group.getBoundingRect(), toolboxModel)) // Adjust icon title positions to avoid them out of screen

        isVertical || group.eachChild(function (icon) {
          const titleText = icon.__title // const hoverStyle = icon.hoverStyle;
          // TODO simplify code?

          const emphasisState = icon.ensureState('emphasis')
          const emphasisTextConfig = emphasisState.textConfig || (emphasisState.textConfig = {})
          const textContent = icon.getTextContent()
          const emphasisTextState = textContent && textContent.ensureState('emphasis') // May be background element

          if (emphasisTextState && !isFunction(emphasisTextState) && titleText) {
            const emphasisTextStyle = emphasisTextState.style || (emphasisTextState.style = {})
            const rect = getBoundingRect(titleText, ZRText.makeFont(emphasisTextStyle))
            const offsetX = icon.x + group.x
            const offsetY = icon.y + group.y + itemSize
            let needPutOnTop = false

            if (offsetY + rect.height > api.getHeight()) {
              emphasisTextConfig.position = 'top'
              needPutOnTop = true
            }

            const topOffset = needPutOnTop ? -5 - rect.height : itemSize + 10

            if (offsetX + rect.width / 2 > api.getWidth()) {
              emphasisTextConfig.position = ['100%', topOffset]
              emphasisTextStyle.align = 'right'
            } else if (offsetX - rect.width / 2 < 0) {
              emphasisTextConfig.position = [0, topOffset]
              emphasisTextStyle.align = 'left'
            }
          }
        })
      }

      ToolboxView.prototype.updateView = function (toolboxModel, ecModel, api, payload) {
        each(this._features, function (feature) {
          feature instanceof ToolboxFeature && feature.updateView && feature.updateView(feature.model, ecModel, api, payload)
        })
      } // updateLayout(toolboxModel, ecModel, api, payload) {
      //     zrUtil.each(this._features, function (feature) {
      //         feature.updateLayout && feature.updateLayout(feature.model, ecModel, api, payload);
      //     });
      // },

      ToolboxView.prototype.remove = function (ecModel, api) {
        each(this._features, function (feature) {
          feature instanceof ToolboxFeature && feature.remove && feature.remove(ecModel, api)
        })
        this.group.removeAll()
      }

      ToolboxView.prototype.dispose = function (ecModel, api) {
        each(this._features, function (feature) {
          feature instanceof ToolboxFeature && feature.dispose && feature.dispose(ecModel, api)
        })
      }

      ToolboxView.type = 'toolbox'
      return ToolboxView
    }(ComponentView))

  function isUserFeatureName (featureName) {
    return featureName.indexOf('my') === 0
  }

  /* global window, document */

  const SaveAsImage =
    /** @class */
    (function (_super) {
      __extends(SaveAsImage, _super)

      function SaveAsImage () {
        return _super !== null && _super.apply(this, arguments) || this
      }

      SaveAsImage.prototype.onclick = function (ecModel, api) {
        const model = this.model
        const title = model.get('name') || ecModel.get('title.0.text') || 'echarts'
        const isSvg = api.getZr().painter.getType() === 'svg'
        const type = isSvg ? 'svg' : model.get('type', true) || 'png'
        const url = api.getConnectedDataURL({
          type: type,
          backgroundColor: model.get('backgroundColor', true) || ecModel.get('backgroundColor') || '#fff',
          connectedBackgroundColor: model.get('connectedBackgroundColor'),
          excludeComponents: model.get('excludeComponents'),
          pixelRatio: model.get('pixelRatio')
        })
        const browser = env.browser // Chrome, Firefox, New Edge

        if (isFunction(MouseEvent) && (browser.newEdge || !browser.ie && !browser.edge)) {
          const $a = document.createElement('a')
          $a.download = title + '.' + type
          $a.target = '_blank'
          $a.href = url
          const evt = new MouseEvent('click', {
            // some micro front-end framework， window maybe is a Proxy
            view: document.defaultView,
            bubbles: true,
            cancelable: false
          })
          $a.dispatchEvent(evt)
        } // IE or old Edge
        else {
          // @ts-ignore
          if (window.navigator.msSaveOrOpenBlob || isSvg) {
            const parts = url.split(',') // data:[<mime type>][;charset=<charset>][;base64],<encoded data>

            const base64Encoded = parts[0].indexOf('base64') > -1
            let bstr = isSvg // should decode the svg data uri first
              ? decodeURIComponent(parts[1]) : parts[1] // only `atob` when the data uri is encoded with base64
              // otherwise, like `svg` data uri exported by zrender,
              // there will be an error, for it's not encoded with base64.
              // (just a url-encoded string through `encodeURIComponent`)

            base64Encoded && (bstr = window.atob(bstr))
            const filename = title + '.' + type // @ts-ignore

            if (window.navigator.msSaveOrOpenBlob) {
              let n = bstr.length
              const u8arr = new Uint8Array(n)

              while (n--) {
                u8arr[n] = bstr.charCodeAt(n)
              }

              const blob = new Blob([u8arr]) // @ts-ignore

              window.navigator.msSaveOrOpenBlob(blob, filename)
            } else {
              const frame = document.createElement('iframe')
              document.body.appendChild(frame)
              const cw = frame.contentWindow
              const doc = cw.document
              doc.open('image/svg+xml', 'replace')
              doc.write(bstr)
              doc.close()
              cw.focus()
              doc.execCommand('SaveAs', true, filename)
              document.body.removeChild(frame)
            }
          } else {
            const lang = model.get('lang')
            const html = '' + '<body style="margin:0;">' + '<img src="' + url + '" style="max-width:100%;" title="' + (lang && lang[0] || '') + '" />' + '</body>'
            const tab = window.open()
            tab.document.write(html)
            tab.document.title = title
          }
        }
      }

      SaveAsImage.getDefaultOption = function (ecModel) {
        const defaultOption = {
          show: true,
          icon: 'M4.7,22.9L29.3,45.5L54.7,23.4M4.6,43.6L4.6,58L53.8,58L53.8,43.6M29.2,45.1L29.2,0',
          title: ecModel.getLocaleModel().get(['toolbox', 'saveAsImage', 'title']),
          type: 'png',
          // Default use option.backgroundColor
          // backgroundColor: '#fff',
          connectedBackgroundColor: '#fff',
          name: '',
          excludeComponents: ['toolbox'],
          // use current pixel ratio of device by default
          // pixelRatio: 1,
          lang: ecModel.getLocaleModel().get(['toolbox', 'saveAsImage', 'lang'])
        }
        return defaultOption
      }

      return SaveAsImage
    }(ToolboxFeature))

  const INNER_STACK_KEYWORD = '__ec_magicType_stack__'
  const radioTypes = [['line', 'bar'], ['stack']]

  const MagicType =
    /** @class */
    (function (_super) {
      __extends(MagicType, _super)

      function MagicType () {
        return _super !== null && _super.apply(this, arguments) || this
      }

      MagicType.prototype.getIcons = function () {
        const model = this.model
        const availableIcons = model.get('icon')
        const icons = {}
        each(model.get('type'), function (type) {
          if (availableIcons[type]) {
            icons[type] = availableIcons[type]
          }
        })
        return icons
      }

      MagicType.getDefaultOption = function (ecModel) {
        const defaultOption = {
          show: true,
          type: [],
          // Icon group
          icon: {
            line: 'M4.1,28.9h7.1l9.3-22l7.4,38l9.7-19.7l3,12.8h14.9M4.1,58h51.4',
            bar: 'M6.7,22.9h10V48h-10V22.9zM24.9,13h10v35h-10V13zM43.2,2h10v46h-10V2zM3.1,58h53.7',
            // eslint-disable-next-line
            stack: 'M8.2,38.4l-8.4,4.1l30.6,15.3L60,42.5l-8.1-4.1l-21.5,11L8.2,38.4z M51.9,30l-8.1,4.2l-13.4,6.9l-13.9-6.9L8.2,30l-8.4,4.2l8.4,4.2l22.2,11l21.5-11l8.1-4.2L51.9,30z M51.9,21.7l-8.1,4.2L35.7,30l-5.3,2.8L24.9,30l-8.4-4.1l-8.3-4.2l-8.4,4.2L8.2,30l8.3,4.2l13.9,6.9l13.4-6.9l8.1-4.2l8.1-4.1L51.9,21.7zM30.4,2.2L-0.2,17.5l8.4,4.1l8.3,4.2l8.4,4.2l5.5,2.7l5.3-2.7l8.1-4.2l8.1-4.2l8.1-4.1L30.4,2.2z' // jshint ignore:line

          },
          // `line`, `bar`, `stack`, `tiled`
          title: ecModel.getLocaleModel().get(['toolbox', 'magicType', 'title']),
          option: {},
          seriesIndex: {}
        }
        return defaultOption
      }

      MagicType.prototype.onclick = function (ecModel, api, type) {
        const model = this.model
        const seriesIndex = model.get(['seriesIndex', type]) // Not supported magicType

        if (!seriesOptGenreator[type]) {
          return
        }

        const newOption = {
          series: []
        }

        const generateNewSeriesTypes = function (seriesModel) {
          const seriesType = seriesModel.subType
          const seriesId = seriesModel.id
          const newSeriesOpt = seriesOptGenreator[type](seriesType, seriesId, seriesModel, model)

          if (newSeriesOpt) {
            // PENDING If merge original option?
            defaults(newSeriesOpt, seriesModel.option)
            newOption.series.push(newSeriesOpt)
          } // Modify boundaryGap

          const coordSys = seriesModel.coordinateSystem

          if (coordSys && coordSys.type === 'cartesian2d' && (type === 'line' || type === 'bar')) {
            const categoryAxis = coordSys.getAxesByScale('ordinal')[0]

            if (categoryAxis) {
              const axisDim = categoryAxis.dim
              const axisType = axisDim + 'Axis'
              const axisModel = seriesModel.getReferringComponents(axisType, SINGLE_REFERRING).models[0]
              const axisIndex = axisModel.componentIndex
              newOption[axisType] = newOption[axisType] || []

              for (let i = 0; i <= axisIndex; i++) {
                newOption[axisType][axisIndex] = newOption[axisType][axisIndex] || {}
              }

              newOption[axisType][axisIndex].boundaryGap = type === 'bar'
            }
          }
        }

        each(radioTypes, function (radio) {
          if (indexOf(radio, type) >= 0) {
            each(radio, function (item) {
              model.setIconStatus(item, 'normal')
            })
          }
        })
        model.setIconStatus(type, 'emphasis')
        ecModel.eachComponent({
          mainType: 'series',
          query: seriesIndex == null
            ? null
            : {
                seriesIndex: seriesIndex
              }
        }, generateNewSeriesTypes)
        let newTitle
        let currentType = type // Change title of stack

        if (type === 'stack') {
          // use titles in model instead of ecModel
          // as stack and tiled appears in pair, just flip them
          // no need of checking stack state
          newTitle = merge({
            stack: model.option.title.tiled,
            tiled: model.option.title.stack
          }, model.option.title)

          if (model.get(['iconStatus', type]) !== 'emphasis') {
            currentType = 'tiled'
          }
        }

        api.dispatchAction({
          type: 'changeMagicType',
          currentType: currentType,
          newOption: newOption,
          newTitle: newTitle,
          featureName: 'magicType'
        })
      }

      return MagicType
    }(ToolboxFeature))

  var seriesOptGenreator = {
    line: function (seriesType, seriesId, seriesModel, model) {
      if (seriesType === 'bar') {
        return merge({
          id: seriesId,
          type: 'line',
          // Preserve data related option
          data: seriesModel.get('data'),
          stack: seriesModel.get('stack'),
          markPoint: seriesModel.get('markPoint'),
          markLine: seriesModel.get('markLine')
        }, model.get(['option', 'line']) || {}, true)
      }
    },
    bar: function (seriesType, seriesId, seriesModel, model) {
      if (seriesType === 'line') {
        return merge({
          id: seriesId,
          type: 'bar',
          // Preserve data related option
          data: seriesModel.get('data'),
          stack: seriesModel.get('stack'),
          markPoint: seriesModel.get('markPoint'),
          markLine: seriesModel.get('markLine')
        }, model.get(['option', 'bar']) || {}, true)
      }
    },
    stack: function (seriesType, seriesId, seriesModel, model) {
      const isStack = seriesModel.get('stack') === INNER_STACK_KEYWORD

      if (seriesType === 'line' || seriesType === 'bar') {
        model.setIconStatus('stack', isStack ? 'normal' : 'emphasis')
        return merge({
          id: seriesId,
          stack: isStack ? '' : INNER_STACK_KEYWORD
        }, model.get(['option', 'stack']) || {}, true)
      }
    }
  } // TODO: SELF REGISTERED.

  registerAction({
    type: 'changeMagicType',
    event: 'magicTypeChanged',
    update: 'prepareAndUpdate'
  }, function (payload, ecModel) {
    ecModel.mergeOption(payload.newOption)
  })

  /* global document */

  const BLOCK_SPLITER = new Array(60).join('-')
  const ITEM_SPLITER = '\t'
  /**
     * Group series into two types
     *  1. on category axis, like line, bar
     *  2. others, like scatter, pie
     */

  function groupSeries (ecModel) {
    const seriesGroupByCategoryAxis = {}
    const otherSeries = []
    const meta = []
    ecModel.eachRawSeries(function (seriesModel) {
      const coordSys = seriesModel.coordinateSystem

      if (coordSys && (coordSys.type === 'cartesian2d' || coordSys.type === 'polar')) {
        // TODO: TYPE Consider polar? Include polar may increase unecessary bundle size.
        const baseAxis = coordSys.getBaseAxis()

        if (baseAxis.type === 'category') {
          const key = baseAxis.dim + '_' + baseAxis.index

          if (!seriesGroupByCategoryAxis[key]) {
            seriesGroupByCategoryAxis[key] = {
              categoryAxis: baseAxis,
              valueAxis: coordSys.getOtherAxis(baseAxis),
              series: []
            }
            meta.push({
              axisDim: baseAxis.dim,
              axisIndex: baseAxis.index
            })
          }

          seriesGroupByCategoryAxis[key].series.push(seriesModel)
        } else {
          otherSeries.push(seriesModel)
        }
      } else {
        otherSeries.push(seriesModel)
      }
    })
    return {
      seriesGroupByCategoryAxis: seriesGroupByCategoryAxis,
      other: otherSeries,
      meta: meta
    }
  }
  /**
     * Assemble content of series on cateogory axis
     * @inner
     */

  function assembleSeriesWithCategoryAxis (groups) {
    const tables = []
    each(groups, function (group, key) {
      const categoryAxis = group.categoryAxis
      const valueAxis = group.valueAxis
      const valueAxisDim = valueAxis.dim
      const headers = [' '].concat(map(group.series, function (series) {
        return series.name
      })) // @ts-ignore TODO Polar

      const columns = [categoryAxis.model.getCategories()]
      each(group.series, function (series) {
        const rawData = series.getRawData()
        columns.push(series.getRawData().mapArray(rawData.mapDimension(valueAxisDim), function (val) {
          return val
        }))
      }) // Assemble table content

      const lines = [headers.join(ITEM_SPLITER)]

      for (let i = 0; i < columns[0].length; i++) {
        const items = []

        for (let j = 0; j < columns.length; j++) {
          items.push(columns[j][i])
        }

        lines.push(items.join(ITEM_SPLITER))
      }

      tables.push(lines.join('\n'))
    })
    return tables.join('\n\n' + BLOCK_SPLITER + '\n\n')
  }
  /**
     * Assemble content of other series
     */

  function assembleOtherSeries (series) {
    return map(series, function (series) {
      const data = series.getRawData()
      const lines = [series.name]
      const vals = []
      data.each(data.dimensions, function () {
        const argLen = arguments.length
        const dataIndex = arguments[argLen - 1]
        const name = data.getName(dataIndex)

        for (let i = 0; i < argLen - 1; i++) {
          vals[i] = arguments[i]
        }

        lines.push((name ? name + ITEM_SPLITER : '') + vals.join(ITEM_SPLITER))
      })
      return lines.join('\n')
    }).join('\n\n' + BLOCK_SPLITER + '\n\n')
  }

  function getContentFromModel (ecModel) {
    const result = groupSeries(ecModel)
    return {
      value: filter([assembleSeriesWithCategoryAxis(result.seriesGroupByCategoryAxis), assembleOtherSeries(result.other)], function (str) {
        return !!str.replace(/[\n\t\s]/g, '')
      }).join('\n\n' + BLOCK_SPLITER + '\n\n'),
      meta: result.meta
    }
  }

  function trim$1 (str) {
    return str.replace(/^\s\s*/, '').replace(/\s\s*$/, '')
  }
  /**
     * If a block is tsv format
     */

  function isTSVFormat (block) {
    // Simple method to find out if a block is tsv format
    const firstLine = block.slice(0, block.indexOf('\n'))

    if (firstLine.indexOf(ITEM_SPLITER) >= 0) {
      return true
    }
  }

  const itemSplitRegex = new RegExp('[' + ITEM_SPLITER + ']+', 'g')
  /**
     * @param {string} tsv
     * @return {Object}
     */

  function parseTSVContents (tsv) {
    const tsvLines = tsv.split(/\n+/g)
    const headers = trim$1(tsvLines.shift()).split(itemSplitRegex)
    const categories = []
    const series = map(headers, function (header) {
      return {
        name: header,
        data: []
      }
    })

    for (let i = 0; i < tsvLines.length; i++) {
      const items = trim$1(tsvLines[i]).split(itemSplitRegex)
      categories.push(items.shift())

      for (let j = 0; j < items.length; j++) {
        series[j] && (series[j].data[i] = items[j])
      }
    }

    return {
      series: series,
      categories: categories
    }
  }

  function parseListContents (str) {
    const lines = str.split(/\n+/g)
    const seriesName = trim$1(lines.shift())
    const data = []

    for (let i = 0; i < lines.length; i++) {
      // if line is empty, ignore it.
      // there is a case that a user forgot to delete `\n`.
      const line = trim$1(lines[i])

      if (!line) {
        continue
      }

      let items = line.split(itemSplitRegex)
      let name_1 = ''
      let value = void 0
      let hasName = false

      if (isNaN(items[0])) {
        // First item is name
        hasName = true
        name_1 = items[0]
        items = items.slice(1)
        data[i] = {
          name: name_1,
          value: []
        }
        value = data[i].value
      } else {
        value = data[i] = []
      }

      for (let j = 0; j < items.length; j++) {
        value.push(+items[j])
      }

      if (value.length === 1) {
        hasName ? data[i].value = value[0] : data[i] = value[0]
      }
    }

    return {
      name: seriesName,
      data: data
    }
  }

  function parseContents (str, blockMetaList) {
    const blocks = str.split(new RegExp('\n*' + BLOCK_SPLITER + '\n*', 'g'))
    const newOption = {
      series: []
    }
    each(blocks, function (block, idx) {
      if (isTSVFormat(block)) {
        var result = parseTSVContents(block)
        const blockMeta = blockMetaList[idx]
        const axisKey = blockMeta.axisDim + 'Axis'

        if (blockMeta) {
          newOption[axisKey] = newOption[axisKey] || []
          newOption[axisKey][blockMeta.axisIndex] = {
            data: result.categories
          }
          newOption.series = newOption.series.concat(result.series)
        }
      } else {
        var result = parseListContents(block)
        newOption.series.push(result)
      }
    })
    return newOption
  }

  const DataView =
    /** @class */
    (function (_super) {
      __extends(DataView, _super)

      function DataView () {
        return _super !== null && _super.apply(this, arguments) || this
      }

      DataView.prototype.onclick = function (ecModel, api) {
        // FIXME: better way?
        setTimeout(function () {
          api.dispatchAction({
            type: 'hideTip'
          })
        })
        const container = api.getDom()
        const model = this.model

        if (this._dom) {
          container.removeChild(this._dom)
        }

        const root = document.createElement('div') // use padding to avoid 5px whitespace

        root.style.cssText = 'position:absolute;top:0;bottom:0;left:0;right:0;padding:5px'
        root.style.backgroundColor = model.get('backgroundColor') || '#fff' // Create elements

        const header = document.createElement('h4')
        const lang = model.get('lang') || []
        header.innerHTML = lang[0] || model.get('title')
        header.style.cssText = 'margin:10px 20px'
        header.style.color = model.get('textColor')
        const viewMain = document.createElement('div')
        const textarea = document.createElement('textarea')
        viewMain.style.cssText = 'overflow:auto'
        const optionToContent = model.get('optionToContent')
        const contentToOption = model.get('contentToOption')
        const result = getContentFromModel(ecModel)

        if (isFunction(optionToContent)) {
          const htmlOrDom = optionToContent(api.getOption())

          if (isString(htmlOrDom)) {
            viewMain.innerHTML = htmlOrDom
          } else if (isDom(htmlOrDom)) {
            viewMain.appendChild(htmlOrDom)
          }
        } else {
          // Use default textarea
          textarea.readOnly = model.get('readOnly')
          const style = textarea.style // eslint-disable-next-line max-len

          style.cssText = 'display:block;width:100%;height:100%;font-family:monospace;font-size:14px;line-height:1.6rem;resize:none;box-sizing:border-box;outline:none'
          style.color = model.get('textColor')
          style.borderColor = model.get('textareaBorderColor')
          style.backgroundColor = model.get('textareaColor')
          textarea.value = result.value
          viewMain.appendChild(textarea)
        }

        const blockMetaList = result.meta
        const buttonContainer = document.createElement('div')
        buttonContainer.style.cssText = 'position:absolute;bottom:5px;left:0;right:0' // eslint-disable-next-line max-len

        let buttonStyle = 'float:right;margin-right:20px;border:none;cursor:pointer;padding:2px 5px;font-size:12px;border-radius:3px'
        const closeButton = document.createElement('div')
        const refreshButton = document.createElement('div')
        buttonStyle += ';background-color:' + model.get('buttonColor')
        buttonStyle += ';color:' + model.get('buttonTextColor')
        const self = this

        function close () {
          container.removeChild(root)
          self._dom = null
        }

        addEventListener(closeButton, 'click', close)
        addEventListener(refreshButton, 'click', function () {
          if (contentToOption == null && optionToContent != null || contentToOption != null && optionToContent == null) {
            if ('development' !== 'production') {
              // eslint-disable-next-line
              warn('It seems you have just provided one of `contentToOption` and `optionToContent` functions but missed the other one. Data change is ignored.');
            }

            close()
            return
          }

          let newOption

          try {
            if (isFunction(contentToOption)) {
              newOption = contentToOption(viewMain, api.getOption())
            } else {
              newOption = parseContents(textarea.value, blockMetaList)
            }
          } catch (e) {
            close()
            throw new Error('Data view format error ' + e)
          }

          if (newOption) {
            api.dispatchAction({
              type: 'changeDataView',
              newOption: newOption
            })
          }

          close()
        })
        closeButton.innerHTML = lang[1]
        refreshButton.innerHTML = lang[2]
        refreshButton.style.cssText = closeButton.style.cssText = buttonStyle
        !model.get('readOnly') && buttonContainer.appendChild(refreshButton)
        buttonContainer.appendChild(closeButton)
        root.appendChild(header)
        root.appendChild(viewMain)
        root.appendChild(buttonContainer)
        viewMain.style.height = container.clientHeight - 80 + 'px'
        container.appendChild(root)
        this._dom = root
      }

      DataView.prototype.remove = function (ecModel, api) {
        this._dom && api.getDom().removeChild(this._dom)
      }

      DataView.prototype.dispose = function (ecModel, api) {
        this.remove(ecModel, api)
      }

      DataView.getDefaultOption = function (ecModel) {
        const defaultOption = {
          show: true,
          readOnly: false,
          optionToContent: null,
          contentToOption: null,
          // eslint-disable-next-line
          icon: 'M17.5,17.3H33 M17.5,17.3H33 M45.4,29.5h-28 M11.5,2v56H51V14.8L38.4,2H11.5z M38.4,2.2v12.7H51 M45.4,41.7h-28',
          title: ecModel.getLocaleModel().get(['toolbox', 'dataView', 'title']),
          lang: ecModel.getLocaleModel().get(['toolbox', 'dataView', 'lang']),
          backgroundColor: '#fff',
          textColor: '#000',
          textareaColor: '#fff',
          textareaBorderColor: '#333',
          buttonColor: '#c23531',
          buttonTextColor: '#fff'
        }
        return defaultOption
      }

      return DataView
    }(ToolboxFeature))
    /**
     * @inner
     */

  function tryMergeDataOption (newData, originalData) {
    return map(newData, function (newVal, idx) {
      const original = originalData && originalData[idx]

      if (isObject(original) && !isArray(original)) {
        const newValIsObject = isObject(newVal) && !isArray(newVal)

        if (!newValIsObject) {
          newVal = {
            value: newVal
          }
        } // original data has name but new data has no name

        const shouldDeleteName = original.name != null && newVal.name == null // Original data has option

        newVal = defaults(newVal, original)
        shouldDeleteName && delete newVal.name
        return newVal
      } else {
        return newVal
      }
    })
  } // TODO: SELF REGISTERED.

  registerAction({
    type: 'changeDataView',
    event: 'dataViewChanged',
    update: 'prepareAndUpdate'
  }, function (payload, ecModel) {
    const newSeriesOptList = []
    each(payload.newOption.series, function (seriesOpt) {
      const seriesModel = ecModel.getSeriesByName(seriesOpt.name)[0]

      if (!seriesModel) {
        // New created series
        // Geuss the series type
        newSeriesOptList.push(extend({
          // Default is scatter
          type: 'scatter'
        }, seriesOpt))
      } else {
        const originalData = seriesModel.get('data')
        newSeriesOptList.push({
          name: seriesOpt.name,
          data: tryMergeDataOption(seriesOpt.data, originalData)
        })
      }
    })
    ecModel.mergeOption(defaults({
      series: newSeriesOptList
    }, payload.newOption))
  })

  const each$9 = each
  const inner$f = makeInner()
  /**
     * @param ecModel
     * @param newSnapshot key is dataZoomId
     */

  function push (ecModel, newSnapshot) {
    const storedSnapshots = getStoreSnapshots(ecModel) // If previous dataZoom can not be found,
    // complete an range with current range.

    each$9(newSnapshot, function (batchItem, dataZoomId) {
      let i = storedSnapshots.length - 1

      for (; i >= 0; i--) {
        const snapshot = storedSnapshots[i]

        if (snapshot[dataZoomId]) {
          break
        }
      }

      if (i < 0) {
        // No origin range set, create one by current range.
        const dataZoomModel = ecModel.queryComponents({
          mainType: 'dataZoom',
          subType: 'select',
          id: dataZoomId
        })[0]

        if (dataZoomModel) {
          const percentRange = dataZoomModel.getPercentRange()
          storedSnapshots[0][dataZoomId] = {
            dataZoomId: dataZoomId,
            start: percentRange[0],
            end: percentRange[1]
          }
        }
      }
    })
    storedSnapshots.push(newSnapshot)
  }
  function pop (ecModel) {
    const storedSnapshots = getStoreSnapshots(ecModel)
    const head = storedSnapshots[storedSnapshots.length - 1]
    storedSnapshots.length > 1 && storedSnapshots.pop() // Find top for all dataZoom.

    const snapshot = {}
    each$9(head, function (batchItem, dataZoomId) {
      for (let i = storedSnapshots.length - 1; i >= 0; i--) {
        batchItem = storedSnapshots[i][dataZoomId]

        if (batchItem) {
          snapshot[dataZoomId] = batchItem
          break
        }
      }
    })
    return snapshot
  }
  function clear$1 (ecModel) {
    inner$f(ecModel).snapshots = null
  }
  function count (ecModel) {
    return getStoreSnapshots(ecModel).length
  }
  /**
     * History length of each dataZoom may be different.
     * this._history[0] is used to store origin range.
     */

  function getStoreSnapshots (ecModel) {
    const store = inner$f(ecModel)

    if (!store.snapshots) {
      store.snapshots = [{}]
    }

    return store.snapshots
  }

  const RestoreOption =
    /** @class */
    (function (_super) {
      __extends(RestoreOption, _super)

      function RestoreOption () {
        return _super !== null && _super.apply(this, arguments) || this
      }

      RestoreOption.prototype.onclick = function (ecModel, api) {
        clear$1(ecModel)
        api.dispatchAction({
          type: 'restore',
          from: this.uid
        })
      }

      RestoreOption.getDefaultOption = function (ecModel) {
        const defaultOption = {
          show: true,
          // eslint-disable-next-line
          icon: 'M3.8,33.4 M47,18.9h9.8V8.7 M56.3,20.1 C52.1,9,40.5,0.6,26.8,2.1C12.6,3.7,1.6,16.2,2.1,30.6 M13,41.1H3.1v10.2 M3.7,39.9c4.2,11.1,15.8,19.5,29.5,18 c14.2-1.6,25.2-14.1,24.7-28.5',
          title: ecModel.getLocaleModel().get(['toolbox', 'restore', 'title'])
        }
        return defaultOption
      }

      return RestoreOption
    }(ToolboxFeature)) // TODO: SELF REGISTERED.

  registerAction({
    type: 'restore',
    event: 'restore',
    update: 'prepareAndUpdate'
  }, function (payload, ecModel) {
    ecModel.resetOption('recreate')
  })

  // how to genarialize to more coordinate systems.

  const INCLUDE_FINDER_MAIN_TYPES = ['grid', 'xAxis', 'yAxis', 'geo', 'graph', 'polar', 'radiusAxis', 'angleAxis', 'bmap']

  const BrushTargetManager =
    /** @class */
    (function () {
      /**
       * @param finder contains Index/Id/Name of xAxis/yAxis/geo/grid
       *        Each can be {number|Array.<number>}. like: {xAxisIndex: [3, 4]}
       * @param opt.include include coordinate system types.
       */
      function BrushTargetManager (finder, ecModel, opt) {
        const _this = this

        this._targetInfoList = []
        const foundCpts = parseFinder$1(ecModel, finder)
        each(targetInfoBuilders, function (builder, type) {
          if (!opt || !opt.include || indexOf(opt.include, type) >= 0) {
            builder(foundCpts, _this._targetInfoList)
          }
        })
      }

      BrushTargetManager.prototype.setOutputRanges = function (areas, ecModel) {
        this.matchOutputRanges(areas, ecModel, function (area, coordRange, coordSys) {
          (area.coordRanges || (area.coordRanges = [])).push(coordRange) // area.coordRange is the first of area.coordRanges

          if (!area.coordRange) {
            area.coordRange = coordRange // In 'category' axis, coord to pixel is not reversible, so we can not
            // rebuild range by coordRange accrately, which may bring trouble when
            // brushing only one item. So we use __rangeOffset to rebuilding range
            // by coordRange. And this it only used in brush component so it is no
            // need to be adapted to coordRanges.

            const result = coordConvert[area.brushType](0, coordSys, coordRange)
            area.__rangeOffset = {
              offset: diffProcessor[area.brushType](result.values, area.range, [1, 1]),
              xyMinMax: result.xyMinMax
            }
          }
        })
        return areas
      }

      BrushTargetManager.prototype.matchOutputRanges = function (areas, ecModel, cb) {
        each(areas, function (area) {
          const targetInfo = this.findTargetInfo(area, ecModel)

          if (targetInfo && targetInfo !== true) {
            each(targetInfo.coordSyses, function (coordSys) {
              const result = coordConvert[area.brushType](1, coordSys, area.range, true)
              cb(area, result.values, coordSys, ecModel)
            })
          }
        }, this)
      }
      /**
       * the `areas` is `BrushModel.areas`.
       * Called in layout stage.
       * convert `area.coordRange` to global range and set panelId to `area.range`.
       */

      BrushTargetManager.prototype.setInputRanges = function (areas, ecModel) {
        each(areas, function (area) {
          const targetInfo = this.findTargetInfo(area, ecModel)

          if ('development' !== 'production') {
            assert(!targetInfo || targetInfo === true || area.coordRange, 'coordRange must be specified when coord index specified.')
            assert(!targetInfo || targetInfo !== true || area.range, 'range must be specified in global brush.')
          }

          area.range = area.range || [] // convert coordRange to global range and set panelId.

          if (targetInfo && targetInfo !== true) {
            area.panelId = targetInfo.panelId // (1) area.range shoule always be calculate from coordRange but does
            // not keep its original value, for the sake of the dataZoom scenario,
            // where area.coordRange remains unchanged but area.range may be changed.
            // (2) Only support converting one coordRange to pixel range in brush
            // component. So do not consider `coordRanges`.
            // (3) About __rangeOffset, see comment above.

            const result = coordConvert[area.brushType](0, targetInfo.coordSys, area.coordRange)
            const rangeOffset = area.__rangeOffset
            area.range = rangeOffset ? diffProcessor[area.brushType](result.values, rangeOffset.offset, getScales(result.xyMinMax, rangeOffset.xyMinMax)) : result.values
          }
        }, this)
      }

      BrushTargetManager.prototype.makePanelOpts = function (api, getDefaultBrushType) {
        return map(this._targetInfoList, function (targetInfo) {
          const rect = targetInfo.getPanelRect()
          return {
            panelId: targetInfo.panelId,
            defaultBrushType: getDefaultBrushType ? getDefaultBrushType(targetInfo) : null,
            clipPath: makeRectPanelClipPath(rect),
            isTargetByCursor: makeRectIsTargetByCursor(rect, api, targetInfo.coordSysModel),
            getLinearBrushOtherExtent: makeLinearBrushOtherExtent(rect)
          }
        })
      }

      BrushTargetManager.prototype.controlSeries = function (area, seriesModel, ecModel) {
        // Check whether area is bound in coord, and series do not belong to that coord.
        // If do not do this check, some brush (like lineX) will controll all axes.
        const targetInfo = this.findTargetInfo(area, ecModel)
        return targetInfo === true || targetInfo && indexOf(targetInfo.coordSyses, seriesModel.coordinateSystem) >= 0
      }
      /**
       * If return Object, a coord found.
       * If reutrn true, global found.
       * Otherwise nothing found.
       */

      BrushTargetManager.prototype.findTargetInfo = function (area, ecModel) {
        const targetInfoList = this._targetInfoList
        const foundCpts = parseFinder$1(ecModel, area)

        for (let i = 0; i < targetInfoList.length; i++) {
          const targetInfo = targetInfoList[i]
          const areaPanelId = area.panelId

          if (areaPanelId) {
            if (targetInfo.panelId === areaPanelId) {
              return targetInfo
            }
          } else {
            for (let j = 0; j < targetInfoMatchers.length; j++) {
              if (targetInfoMatchers[j](foundCpts, targetInfo)) {
                return targetInfo
              }
            }
          }
        }

        return true
      }

      return BrushTargetManager
    }())

  function formatMinMax (minMax) {
    minMax[0] > minMax[1] && minMax.reverse()
    return minMax
  }

  function parseFinder$1 (ecModel, finder) {
    return parseFinder(ecModel, finder, {
      includeMainTypes: INCLUDE_FINDER_MAIN_TYPES
    })
  }

  var targetInfoBuilders = {
    grid: function (foundCpts, targetInfoList) {
      const xAxisModels = foundCpts.xAxisModels
      const yAxisModels = foundCpts.yAxisModels
      const gridModels = foundCpts.gridModels // Remove duplicated.

      const gridModelMap = createHashMap()
      const xAxesHas = {}
      const yAxesHas = {}

      if (!xAxisModels && !yAxisModels && !gridModels) {
        return
      }

      each(xAxisModels, function (axisModel) {
        const gridModel = axisModel.axis.grid.model
        gridModelMap.set(gridModel.id, gridModel)
        xAxesHas[gridModel.id] = true
      })
      each(yAxisModels, function (axisModel) {
        const gridModel = axisModel.axis.grid.model
        gridModelMap.set(gridModel.id, gridModel)
        yAxesHas[gridModel.id] = true
      })
      each(gridModels, function (gridModel) {
        gridModelMap.set(gridModel.id, gridModel)
        xAxesHas[gridModel.id] = true
        yAxesHas[gridModel.id] = true
      })
      gridModelMap.each(function (gridModel) {
        const grid = gridModel.coordinateSystem
        const cartesians = []
        each(grid.getCartesians(), function (cartesian, index) {
          if (indexOf(xAxisModels, cartesian.getAxis('x').model) >= 0 || indexOf(yAxisModels, cartesian.getAxis('y').model) >= 0) {
            cartesians.push(cartesian)
          }
        })
        targetInfoList.push({
          panelId: 'grid--' + gridModel.id,
          gridModel: gridModel,
          coordSysModel: gridModel,
          // Use the first one as the representitive coordSys.
          coordSys: cartesians[0],
          coordSyses: cartesians,
          getPanelRect: panelRectBuilders.grid,
          xAxisDeclared: xAxesHas[gridModel.id],
          yAxisDeclared: yAxesHas[gridModel.id]
        })
      })
    },
    geo: function (foundCpts, targetInfoList) {
      each(foundCpts.geoModels, function (geoModel) {
        const coordSys = geoModel.coordinateSystem
        targetInfoList.push({
          panelId: 'geo--' + geoModel.id,
          geoModel: geoModel,
          coordSysModel: geoModel,
          coordSys: coordSys,
          coordSyses: [coordSys],
          getPanelRect: panelRectBuilders.geo
        })
      })
    }
  }
  var targetInfoMatchers = [// grid
    function (foundCpts, targetInfo) {
      const xAxisModel = foundCpts.xAxisModel
      const yAxisModel = foundCpts.yAxisModel
      let gridModel = foundCpts.gridModel
      !gridModel && xAxisModel && (gridModel = xAxisModel.axis.grid.model)
      !gridModel && yAxisModel && (gridModel = yAxisModel.axis.grid.model)
      return gridModel && gridModel === targetInfo.gridModel
    }, // geo
    function (foundCpts, targetInfo) {
      const geoModel = foundCpts.geoModel
      return geoModel && geoModel === targetInfo.geoModel
    }]
  var panelRectBuilders = {
    grid: function () {
      // grid is not Transformable.
      return this.coordSys.master.getRect().clone()
    },
    geo: function () {
      const coordSys = this.coordSys
      const rect = coordSys.getBoundingRect().clone() // geo roam and zoom transform

      rect.applyTransform(getTransform(coordSys))
      return rect
    }
  }
  var coordConvert = {
    lineX: curry(axisConvert, 0),
    lineY: curry(axisConvert, 1),
    rect: function (to, coordSys, rangeOrCoordRange, clamp) {
      const xminymin = to ? coordSys.pointToData([rangeOrCoordRange[0][0], rangeOrCoordRange[1][0]], clamp) : coordSys.dataToPoint([rangeOrCoordRange[0][0], rangeOrCoordRange[1][0]], clamp)
      const xmaxymax = to ? coordSys.pointToData([rangeOrCoordRange[0][1], rangeOrCoordRange[1][1]], clamp) : coordSys.dataToPoint([rangeOrCoordRange[0][1], rangeOrCoordRange[1][1]], clamp)
      const values = [formatMinMax([xminymin[0], xmaxymax[0]]), formatMinMax([xminymin[1], xmaxymax[1]])]
      return {
        values: values,
        xyMinMax: values
      }
    },
    polygon: function (to, coordSys, rangeOrCoordRange, clamp) {
      const xyMinMax = [[Infinity, -Infinity], [Infinity, -Infinity]]
      const values = map(rangeOrCoordRange, function (item) {
        const p = to ? coordSys.pointToData(item, clamp) : coordSys.dataToPoint(item, clamp)
        xyMinMax[0][0] = Math.min(xyMinMax[0][0], p[0])
        xyMinMax[1][0] = Math.min(xyMinMax[1][0], p[1])
        xyMinMax[0][1] = Math.max(xyMinMax[0][1], p[0])
        xyMinMax[1][1] = Math.max(xyMinMax[1][1], p[1])
        return p
      })
      return {
        values: values,
        xyMinMax: xyMinMax
      }
    }
  }

  function axisConvert (axisNameIndex, to, coordSys, rangeOrCoordRange) {
    if ('development' !== 'production') {
      assert(coordSys.type === 'cartesian2d', 'lineX/lineY brush is available only in cartesian2d.')
    }

    const axis = coordSys.getAxis(['x', 'y'][axisNameIndex])
    const values = formatMinMax(map([0, 1], function (i) {
      return to ? axis.coordToData(axis.toLocalCoord(rangeOrCoordRange[i]), true) : axis.toGlobalCoord(axis.dataToCoord(rangeOrCoordRange[i]))
    }))
    const xyMinMax = []
    xyMinMax[axisNameIndex] = values
    xyMinMax[1 - axisNameIndex] = [NaN, NaN]
    return {
      values: values,
      xyMinMax: xyMinMax
    }
  }

  var diffProcessor = {
    lineX: curry(axisDiffProcessor, 0),
    lineY: curry(axisDiffProcessor, 1),
    rect: function (values, refer, scales) {
      return [[values[0][0] - scales[0] * refer[0][0], values[0][1] - scales[0] * refer[0][1]], [values[1][0] - scales[1] * refer[1][0], values[1][1] - scales[1] * refer[1][1]]]
    },
    polygon: function (values, refer, scales) {
      return map(values, function (item, idx) {
        return [item[0] - scales[0] * refer[idx][0], item[1] - scales[1] * refer[idx][1]]
      })
    }
  }

  function axisDiffProcessor (axisNameIndex, values, refer, scales) {
    return [values[0] - scales[axisNameIndex] * refer[0], values[1] - scales[axisNameIndex] * refer[1]]
  } // We have to process scale caused by dataZoom manually,
  // although it might be not accurate.
  // Return [0~1, 0~1]

  function getScales (xyMinMaxCurr, xyMinMaxOrigin) {
    const sizeCurr = getSize$1(xyMinMaxCurr)
    const sizeOrigin = getSize$1(xyMinMaxOrigin)
    const scales = [sizeCurr[0] / sizeOrigin[0], sizeCurr[1] / sizeOrigin[1]]
    isNaN(scales[0]) && (scales[0] = 1)
    isNaN(scales[1]) && (scales[1] = 1)
    return scales
  }

  function getSize$1 (xyMinMax) {
    return xyMinMax ? [xyMinMax[0][1] - xyMinMax[0][0], xyMinMax[1][1] - xyMinMax[1][0]] : [NaN, NaN]
  }

  const each$a = each
  const DATA_ZOOM_ID_BASE = makeInternalComponentId('toolbox-dataZoom_')

  const DataZoomFeature =
    /** @class */
    (function (_super) {
      __extends(DataZoomFeature, _super)

      function DataZoomFeature () {
        return _super !== null && _super.apply(this, arguments) || this
      }

      DataZoomFeature.prototype.render = function (featureModel, ecModel, api, payload) {
        if (!this._brushController) {
          this._brushController = new BrushController(api.getZr())

          this._brushController.on('brush', bind(this._onBrush, this)).mount()
        }

        updateZoomBtnStatus(featureModel, ecModel, this, payload, api)
        updateBackBtnStatus(featureModel, ecModel)
      }

      DataZoomFeature.prototype.onclick = function (ecModel, api, type) {
        handlers$1[type].call(this)
      }

      DataZoomFeature.prototype.remove = function (ecModel, api) {
        this._brushController && this._brushController.unmount()
      }

      DataZoomFeature.prototype.dispose = function (ecModel, api) {
        this._brushController && this._brushController.dispose()
      }

      DataZoomFeature.prototype._onBrush = function (eventParam) {
        const areas = eventParam.areas

        if (!eventParam.isEnd || !areas.length) {
          return
        }

        const snapshot = {}
        const ecModel = this.ecModel

        this._brushController.updateCovers([]) // remove cover

        const brushTargetManager = new BrushTargetManager(makeAxisFinder(this.model), ecModel, {
          include: ['grid']
        })
        brushTargetManager.matchOutputRanges(areas, ecModel, function (area, coordRange, coordSys) {
          if (coordSys.type !== 'cartesian2d') {
            return
          }

          const brushType = area.brushType

          if (brushType === 'rect') {
            setBatch('x', coordSys, coordRange[0])
            setBatch('y', coordSys, coordRange[1])
          } else {
            setBatch({
              lineX: 'x',
              lineY: 'y'
            }[brushType], coordSys, coordRange)
          }
        })
        push(ecModel, snapshot)

        this._dispatchZoomAction(snapshot)

        function setBatch (dimName, coordSys, minMax) {
          const axis = coordSys.getAxis(dimName)
          const axisModel = axis.model
          const dataZoomModel = findDataZoom(dimName, axisModel, ecModel) // Restrict range.

          const minMaxSpan = dataZoomModel.findRepresentativeAxisProxy(axisModel).getMinMaxSpan()

          if (minMaxSpan.minValueSpan != null || minMaxSpan.maxValueSpan != null) {
            minMax = sliderMove(0, minMax.slice(), axis.scale.getExtent(), 0, minMaxSpan.minValueSpan, minMaxSpan.maxValueSpan)
          }

          dataZoomModel && (snapshot[dataZoomModel.id] = {
            dataZoomId: dataZoomModel.id,
            startValue: minMax[0],
            endValue: minMax[1]
          })
        }

        function findDataZoom (dimName, axisModel, ecModel) {
          let found
          ecModel.eachComponent({
            mainType: 'dataZoom',
            subType: 'select'
          }, function (dzModel) {
            const has = dzModel.getAxisModel(dimName, axisModel.componentIndex)
            has && (found = dzModel)
          })
          return found
        }
      }

      DataZoomFeature.prototype._dispatchZoomAction = function (snapshot) {
        const batch = [] // Convert from hash map to array.

        each$a(snapshot, function (batchItem, dataZoomId) {
          batch.push(clone(batchItem))
        })
        batch.length && this.api.dispatchAction({
          type: 'dataZoom',
          from: this.uid,
          batch: batch
        })
      }

      DataZoomFeature.getDefaultOption = function (ecModel) {
        const defaultOption = {
          show: true,
          filterMode: 'filter',
          // Icon group
          icon: {
            zoom: 'M0,13.5h26.9 M13.5,26.9V0 M32.1,13.5H58V58H13.5 V32.1',
            back: 'M22,1.4L9.9,13.5l12.3,12.3 M10.3,13.5H54.9v44.6 H10.3v-26'
          },
          // `zoom`, `back`
          title: ecModel.getLocaleModel().get(['toolbox', 'dataZoom', 'title']),
          brushStyle: {
            borderWidth: 0,
            color: 'rgba(210,219,238,0.2)'
          }
        }
        return defaultOption
      }

      return DataZoomFeature
    }(ToolboxFeature))

  var handlers$1 = {
    zoom: function () {
      const nextActive = !this._isZoomActive
      this.api.dispatchAction({
        type: 'takeGlobalCursor',
        key: 'dataZoomSelect',
        dataZoomSelectActive: nextActive
      })
    },
    back: function () {
      this._dispatchZoomAction(pop(this.ecModel))
    }
  }

  function makeAxisFinder (dzFeatureModel) {
    const setting = {
      xAxisIndex: dzFeatureModel.get('xAxisIndex', true),
      yAxisIndex: dzFeatureModel.get('yAxisIndex', true),
      xAxisId: dzFeatureModel.get('xAxisId', true),
      yAxisId: dzFeatureModel.get('yAxisId', true)
    } // If both `xAxisIndex` `xAxisId` not set, it means 'all'.
    // If both `yAxisIndex` `yAxisId` not set, it means 'all'.
    // Some old cases set like this below to close yAxis control but leave xAxis control:
    // `{ feature: { dataZoom: { yAxisIndex: false } }`.

    if (setting.xAxisIndex == null && setting.xAxisId == null) {
      setting.xAxisIndex = 'all'
    }

    if (setting.yAxisIndex == null && setting.yAxisId == null) {
      setting.yAxisIndex = 'all'
    }

    return setting
  }

  function updateBackBtnStatus (featureModel, ecModel) {
    featureModel.setIconStatus('back', count(ecModel) > 1 ? 'emphasis' : 'normal')
  }

  function updateZoomBtnStatus (featureModel, ecModel, view, payload, api) {
    let zoomActive = view._isZoomActive

    if (payload && payload.type === 'takeGlobalCursor') {
      zoomActive = payload.key === 'dataZoomSelect' ? payload.dataZoomSelectActive : false
    }

    view._isZoomActive = zoomActive
    featureModel.setIconStatus('zoom', zoomActive ? 'emphasis' : 'normal')
    const brushTargetManager = new BrushTargetManager(makeAxisFinder(featureModel), ecModel, {
      include: ['grid']
    })
    const panels = brushTargetManager.makePanelOpts(api, function (targetInfo) {
      return targetInfo.xAxisDeclared && !targetInfo.yAxisDeclared ? 'lineX' : !targetInfo.xAxisDeclared && targetInfo.yAxisDeclared ? 'lineY' : 'rect'
    })

    view._brushController.setPanels(panels).enableBrush(zoomActive && panels.length
      ? {
          brushType: 'auto',
          brushStyle: featureModel.getModel('brushStyle').getItemStyle()
        }
      : false)
  }

  registerInternalOptionCreator('dataZoom', function (ecModel) {
    const toolboxModel = ecModel.getComponent('toolbox', 0)
    const featureDataZoomPath = ['feature', 'dataZoom']

    if (!toolboxModel || toolboxModel.get(featureDataZoomPath) == null) {
      return
    }

    const dzFeatureModel = toolboxModel.getModel(featureDataZoomPath)
    const dzOptions = []
    const finder = makeAxisFinder(dzFeatureModel)
    const finderResult = parseFinder(ecModel, finder)
    each$a(finderResult.xAxisModels, function (axisModel) {
      return buildInternalOptions(axisModel, 'xAxis', 'xAxisIndex')
    })
    each$a(finderResult.yAxisModels, function (axisModel) {
      return buildInternalOptions(axisModel, 'yAxis', 'yAxisIndex')
    })

    function buildInternalOptions (axisModel, axisMainType, axisIndexPropName) {
      const axisIndex = axisModel.componentIndex
      const newOpt = {
        type: 'select',
        $fromToolbox: true,
        // Default to be filter
        filterMode: dzFeatureModel.get('filterMode', true) || 'filter',
        // Id for merge mapping.
        id: DATA_ZOOM_ID_BASE + axisMainType + axisIndex
      }
      newOpt[axisIndexPropName] = axisIndex
      dzOptions.push(newOpt)
    }

    return dzOptions
  })

  function install$z (registers) {
    registers.registerComponentModel(ToolboxModel)
    registers.registerComponentView(ToolboxView)
    registerFeature('saveAsImage', SaveAsImage)
    registerFeature('magicType', MagicType)
    registerFeature('dataView', DataView)
    registerFeature('dataZoom', DataZoomFeature)
    registerFeature('restore', RestoreOption)
    use(install$y)
  }

  const TooltipModel =
    /** @class */
    (function (_super) {
      __extends(TooltipModel, _super)

      function TooltipModel () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = TooltipModel.type
        return _this
      }

      TooltipModel.type = 'tooltip'
      TooltipModel.dependencies = ['axisPointer']
      TooltipModel.defaultOption = {
        // zlevel: 0,
        z: 60,
        show: true,
        // tooltip main content
        showContent: true,
        // 'trigger' only works on coordinate system.
        // 'item' | 'axis' | 'none'
        trigger: 'item',
        // 'click' | 'mousemove' | 'none'
        triggerOn: 'mousemove|click',
        alwaysShowContent: false,
        displayMode: 'single',
        renderMode: 'auto',
        // whether restraint content inside viewRect.
        // If renderMode: 'richText', default true.
        // If renderMode: 'html', defaut false (for backward compat).
        confine: null,
        showDelay: 0,
        hideDelay: 100,
        // Animation transition time, unit is second
        transitionDuration: 0.4,
        enterable: false,
        backgroundColor: '#fff',
        // box shadow
        shadowBlur: 10,
        shadowColor: 'rgba(0, 0, 0, .2)',
        shadowOffsetX: 1,
        shadowOffsetY: 2,
        // tooltip border radius, unit is px, default is 4
        borderRadius: 4,
        // tooltip border width, unit is px, default is 0 (no border)
        borderWidth: 1,
        // Tooltip inside padding, default is 5 for all direction
        // Array is allowed to set up, right, bottom, left, same with css
        // The default value: See `tooltip/tooltipMarkup.ts#getPaddingFromTooltipModel`.
        padding: null,
        // Extra css text
        extraCssText: '',
        // axis indicator, trigger by axis
        axisPointer: {
          // default is line
          // legal values: 'line' | 'shadow' | 'cross'
          type: 'line',
          // Valid when type is line, appoint tooltip line locate on which line. Optional
          // legal values: 'x' | 'y' | 'angle' | 'radius' | 'auto'
          // default is 'auto', chose the axis which type is category.
          // for multiply y axis, cartesian coord chose x axis, polar chose angle axis
          axis: 'auto',
          animation: 'auto',
          animationDurationUpdate: 200,
          animationEasingUpdate: 'exponentialOut',
          crossStyle: {
            color: '#999',
            width: 1,
            type: 'dashed',
            // TODO formatter
            textStyle: {}
          } // lineStyle and shadowStyle should not be specified here,
          // otherwise it will always override those styles on option.axisPointer.

        },
        textStyle: {
          color: '#666',
          fontSize: 14
        }
      }
      return TooltipModel
    }(ComponentModel))

  /* global document */

  function shouldTooltipConfine (tooltipModel) {
    const confineOption = tooltipModel.get('confine')
    return confineOption != null ? !!confineOption // In richText mode, the outside part can not be visible.
      : tooltipModel.get('renderMode') === 'richText'
  }

  function testStyle (styleProps) {
    if (!env.domSupported) {
      return
    }

    const style = document.documentElement.style

    for (let i = 0, len = styleProps.length; i < len; i++) {
      if (styleProps[i] in style) {
        return styleProps[i]
      }
    }
  }

  const TRANSFORM_VENDOR = testStyle(['transform', 'webkitTransform', 'OTransform', 'MozTransform', 'msTransform'])
  const TRANSITION_VENDOR = testStyle(['webkitTransition', 'transition', 'OTransition', 'MozTransition', 'msTransition'])
  function toCSSVendorPrefix (styleVendor, styleProp) {
    if (!styleVendor) {
      return styleProp
    }

    styleProp = toCamelCase(styleProp, true)
    const idx = styleVendor.indexOf(styleProp)
    styleVendor = idx === -1 ? styleProp : '-' + styleVendor.slice(0, idx) + '-' + styleProp
    return styleVendor.toLowerCase()
  }
  function getComputedStyle (el, style) {
    const stl = el.currentStyle || document.defaultView && document.defaultView.getComputedStyle(el)
    return stl ? style ? stl[style] : stl : null
  }

  /* global document, window */

  const CSS_TRANSITION_VENDOR = toCSSVendorPrefix(TRANSITION_VENDOR, 'transition')
  const CSS_TRANSFORM_VENDOR = toCSSVendorPrefix(TRANSFORM_VENDOR, 'transform') // eslint-disable-next-line

  const gCssText = 'position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;' + (env.transform3dSupported ? 'will-change:transform;' : '')

  function mirrorPos (pos) {
    pos = pos === 'left' ? 'right' : pos === 'right' ? 'left' : pos === 'top' ? 'bottom' : 'top'
    return pos
  }

  function assembleArrow (tooltipModel, borderColor, arrowPosition) {
    if (!isString(arrowPosition) || arrowPosition === 'inside') {
      return ''
    }

    const backgroundColor = tooltipModel.get('backgroundColor')
    const borderWidth = tooltipModel.get('borderWidth')
    borderColor = convertToColorString(borderColor)
    const arrowPos = mirrorPos(arrowPosition)
    const arrowSize = Math.max(Math.round(borderWidth) * 1.5, 6)
    let positionStyle = ''
    let transformStyle = CSS_TRANSFORM_VENDOR + ':'
    let rotateDeg

    if (indexOf(['left', 'right'], arrowPos) > -1) {
      positionStyle += 'top:50%'
      transformStyle += 'translateY(-50%) rotate(' + (rotateDeg = arrowPos === 'left' ? -225 : -45) + 'deg)'
    } else {
      positionStyle += 'left:50%'
      transformStyle += 'translateX(-50%) rotate(' + (rotateDeg = arrowPos === 'top' ? 225 : 45) + 'deg)'
    }

    const rotateRadian = rotateDeg * Math.PI / 180
    const arrowWH = arrowSize + borderWidth
    const rotatedWH = arrowWH * Math.abs(Math.cos(rotateRadian)) + arrowWH * Math.abs(Math.sin(rotateRadian))
    const arrowOffset = Math.round(((rotatedWH - Math.SQRT2 * borderWidth) / 2 + Math.SQRT2 * borderWidth - (rotatedWH - arrowWH) / 2) * 100) / 100
    positionStyle += ';' + arrowPos + ':-' + arrowOffset + 'px'
    const borderStyle = borderColor + ' solid ' + borderWidth + 'px;'
    const styleCss = ['position:absolute;width:' + arrowSize + 'px;height:' + arrowSize + 'px;', positionStyle + ';' + transformStyle + ';', 'border-bottom:' + borderStyle, 'border-right:' + borderStyle, 'background-color:' + backgroundColor + ';']
    return '<div style="' + styleCss.join('') + '"></div>'
  }

  function assembleTransition (duration, onlyFade) {
    const transitionCurve = 'cubic-bezier(0.23,1,0.32,1)'
    let transitionOption = ' ' + duration / 2 + 's ' + transitionCurve
    let transitionText = 'opacity' + transitionOption + ',visibility' + transitionOption

    if (!onlyFade) {
      transitionOption = ' ' + duration + 's ' + transitionCurve
      transitionText += env.transformSupported ? ',' + CSS_TRANSFORM_VENDOR + transitionOption : ',left' + transitionOption + ',top' + transitionOption
    }

    return CSS_TRANSITION_VENDOR + ':' + transitionText
  }

  function assembleTransform (x, y, toString) {
    // If using float on style, the final width of the dom might
    // keep changing slightly while mouse move. So `toFixed(0)` them.
    const x0 = x.toFixed(0) + 'px'
    const y0 = y.toFixed(0) + 'px' // not support transform, use `left` and `top` instead.

    if (!env.transformSupported) {
      return toString ? 'top:' + y0 + ';left:' + x0 + ';' : [['top', y0], ['left', x0]]
    } // support transform

    const is3d = env.transform3dSupported
    const translate = 'translate' + (is3d ? '3d' : '') + '(' + x0 + ',' + y0 + (is3d ? ',0' : '') + ')'
    return toString ? 'top:0;left:0;' + CSS_TRANSFORM_VENDOR + ':' + translate + ';' : [['top', 0], ['left', 0], [TRANSFORM_VENDOR, translate]]
  }
  /**
     * @param {Object} textStyle
     * @return {string}
     * @inner
     */

  function assembleFont (textStyleModel) {
    const cssText = []
    const fontSize = textStyleModel.get('fontSize')
    const color = textStyleModel.getTextColor()
    color && cssText.push('color:' + color)
    cssText.push('font:' + textStyleModel.getFont())
    fontSize && // @ts-ignore, leave it to the tooltip refactor.
      cssText.push('line-height:' + Math.round(fontSize * 3 / 2) + 'px')
    const shadowColor = textStyleModel.get('textShadowColor')
    const shadowBlur = textStyleModel.get('textShadowBlur') || 0
    const shadowOffsetX = textStyleModel.get('textShadowOffsetX') || 0
    const shadowOffsetY = textStyleModel.get('textShadowOffsetY') || 0
    shadowColor && shadowBlur && cssText.push('text-shadow:' + shadowOffsetX + 'px ' + shadowOffsetY + 'px ' + shadowBlur + 'px ' + shadowColor)
    each(['decoration', 'align'], function (name) {
      const val = textStyleModel.get(name)
      val && cssText.push('text-' + name + ':' + val)
    })
    return cssText.join(';')
  }

  function assembleCssText (tooltipModel, enableTransition, onlyFade) {
    const cssText = []
    const transitionDuration = tooltipModel.get('transitionDuration')
    const backgroundColor = tooltipModel.get('backgroundColor')
    const shadowBlur = tooltipModel.get('shadowBlur')
    const shadowColor = tooltipModel.get('shadowColor')
    const shadowOffsetX = tooltipModel.get('shadowOffsetX')
    const shadowOffsetY = tooltipModel.get('shadowOffsetY')
    const textStyleModel = tooltipModel.getModel('textStyle')
    const padding = getPaddingFromTooltipModel(tooltipModel, 'html')
    const boxShadow = shadowOffsetX + 'px ' + shadowOffsetY + 'px ' + shadowBlur + 'px ' + shadowColor
    cssText.push('box-shadow:' + boxShadow) // Animation transition. Do not animate when transitionDuration is 0.

    enableTransition && transitionDuration && cssText.push(assembleTransition(transitionDuration, onlyFade))

    if (backgroundColor) {
      cssText.push('background-color:' + backgroundColor)
    } // Border style

    each(['width', 'color', 'radius'], function (name) {
      const borderName = 'border-' + name
      const camelCase = toCamelCase(borderName)
      const val = tooltipModel.get(camelCase)
      val != null && cssText.push(borderName + ':' + val + (name === 'color' ? '' : 'px'))
    }) // Text style

    cssText.push(assembleFont(textStyleModel)) // Padding

    if (padding != null) {
      cssText.push('padding:' + normalizeCssArray$1(padding).join('px ') + 'px')
    }

    return cssText.join(';') + ';'
  } // If not able to make, do not modify the input `out`.

  function makeStyleCoord (out, zr, appendToBody, zrX, zrY) {
    const zrPainter = zr && zr.painter

    if (appendToBody) {
      const zrViewportRoot = zrPainter && zrPainter.getViewportRoot()

      if (zrViewportRoot) {
        // Some APPs might use scale on body, so we support CSS transform here.
        transformLocalCoord(out, zrViewportRoot, document.body, zrX, zrY)
      }
    } else {
      out[0] = zrX
      out[1] = zrY // xy should be based on canvas root. But tooltipContent is
      // the sibling of canvas root. So padding of ec container
      // should be considered here.

      const viewportRootOffset = zrPainter && zrPainter.getViewportRootOffset()

      if (viewportRootOffset) {
        out[0] += viewportRootOffset.offsetLeft
        out[1] += viewportRootOffset.offsetTop
      }
    }

    out[2] = out[0] / zr.getWidth()
    out[3] = out[1] / zr.getHeight()
  }

  const TooltipHTMLContent =
    /** @class */
    (function () {
      function TooltipHTMLContent (container, api, opt) {
        this._show = false
        this._styleCoord = [0, 0, 0, 0]
        this._enterable = true
        this._firstShow = true
        this._longHide = true

        if (env.wxa) {
          return null
        }

        const el = document.createElement('div') // TODO: TYPE

        el.domBelongToZr = true
        this.el = el
        const zr = this._zr = api.getZr()
        const appendToBody = this._appendToBody = opt && opt.appendToBody
        makeStyleCoord(this._styleCoord, zr, appendToBody, api.getWidth() / 2, api.getHeight() / 2)

        if (appendToBody) {
          document.body.appendChild(el)
        } else {
          container.appendChild(el)
        }

        this._container = container // FIXME
        // Is it needed to trigger zr event manually if
        // the browser do not support `pointer-events: none`.

        const self = this

        el.onmouseenter = function () {
          // clear the timeout in hideLater and keep showing tooltip
          if (self._enterable) {
            clearTimeout(self._hideTimeout)
            self._show = true
          }

          self._inContent = true
        }

        el.onmousemove = function (e) {
          e = e || window.event

          if (!self._enterable) {
            // `pointer-events: none` is set to tooltip content div
            // if `enterable` is set as `false`, and `el.onmousemove`
            // can not be triggered. But in browser that do not
            // support `pointer-events`, we need to do this:
            // Try trigger zrender event to avoid mouse
            // in and out shape too frequently
            const handler = zr.handler
            const zrViewportRoot = zr.painter.getViewportRoot()
            normalizeEvent(zrViewportRoot, e, true)
            handler.dispatch('mousemove', e)
          }
        }

        el.onmouseleave = function () {
          // set `_inContent` to `false` before `hideLater`
          self._inContent = false

          if (self._enterable) {
            if (self._show) {
              self.hideLater(self._hideDelay)
            }
          }
        }
      }
      /**
       * Update when tooltip is rendered
       */

      TooltipHTMLContent.prototype.update = function (tooltipModel) {
        // FIXME
        // Move this logic to ec main?
        const container = this._container
        const position = getComputedStyle(container, 'position')
        const domStyle = container.style

        if (domStyle.position !== 'absolute' && position !== 'absolute') {
          domStyle.position = 'relative'
        } // move tooltip if chart resized

        const alwaysShowContent = tooltipModel.get('alwaysShowContent')
        alwaysShowContent && this._moveIfResized() // update className

        this.el.className = tooltipModel.get('className') || '' // Hide the tooltip
        // PENDING
        // this.hide();
      }

      TooltipHTMLContent.prototype.show = function (tooltipModel, nearPointColor) {
        clearTimeout(this._hideTimeout)
        clearTimeout(this._longHideTimeout)
        const el = this.el
        const style = el.style
        const styleCoord = this._styleCoord

        if (!el.innerHTML) {
          style.display = 'none'
        } else {
          style.cssText = gCssText + assembleCssText(tooltipModel, !this._firstShow, this._longHide) + // initial transform
          assembleTransform(styleCoord[0], styleCoord[1], true) + ('border-color:' + convertToColorString(nearPointColor) + ';') + (tooltipModel.get('extraCssText') || '') + // If mouse occasionally move over the tooltip, a mouseout event will be
          // triggered by canvas, and cause some unexpectable result like dragging
          // stop, "unfocusAdjacency". Here `pointer-events: none` is used to solve
          // it. Although it is not supported by IE8~IE10, fortunately it is a rare
          // scenario.
          (';pointer-events:' + (this._enterable ? 'auto' : 'none'))
        }

        this._show = true
        this._firstShow = false
        this._longHide = false
      }

      TooltipHTMLContent.prototype.setContent = function (content, markers, tooltipModel, borderColor, arrowPosition) {
        const el = this.el

        if (content == null) {
          el.innerHTML = ''
          return
        }

        let arrow = ''

        if (isString(arrowPosition) && tooltipModel.get('trigger') === 'item' && !shouldTooltipConfine(tooltipModel)) {
          arrow = assembleArrow(tooltipModel, borderColor, arrowPosition)
        }

        if (isString(content)) {
          el.innerHTML = content + arrow
        } else if (content) {
          // Clear previous
          el.innerHTML = ''

          if (!isArray(content)) {
            content = [content]
          }

          for (let i = 0; i < content.length; i++) {
            if (isDom(content[i]) && content[i].parentNode !== el) {
              el.appendChild(content[i])
            }
          } // no arrow if empty

          if (arrow && el.childNodes.length) {
            // no need to create a new parent element, but it's not supported by IE 10 and older.
            // const arrowEl = document.createRange().createContextualFragment(arrow);
            const arrowEl = document.createElement('div')
            arrowEl.innerHTML = arrow
            el.appendChild(arrowEl)
          }
        }
      }

      TooltipHTMLContent.prototype.setEnterable = function (enterable) {
        this._enterable = enterable
      }

      TooltipHTMLContent.prototype.getSize = function () {
        const el = this.el
        return [el.offsetWidth, el.offsetHeight]
      }

      TooltipHTMLContent.prototype.moveTo = function (zrX, zrY) {
        const styleCoord = this._styleCoord
        makeStyleCoord(styleCoord, this._zr, this._appendToBody, zrX, zrY)

        if (styleCoord[0] != null && styleCoord[1] != null) {
          const style_1 = this.el.style
          const transforms = assembleTransform(styleCoord[0], styleCoord[1])
          each(transforms, function (transform) {
            style_1[transform[0]] = transform[1]
          })
        }
      }
      /**
       * when `alwaysShowContent` is true,
       * move the tooltip after chart resized
       */

      TooltipHTMLContent.prototype._moveIfResized = function () {
        // The ratio of left to width
        const ratioX = this._styleCoord[2] // The ratio of top to height

        const ratioY = this._styleCoord[3]
        this.moveTo(ratioX * this._zr.getWidth(), ratioY * this._zr.getHeight())
      }

      TooltipHTMLContent.prototype.hide = function () {
        const _this = this

        const style = this.el.style
        style.visibility = 'hidden'
        style.opacity = '0'
        env.transform3dSupported && (style.willChange = '')
        this._show = false
        this._longHideTimeout = setTimeout(function () {
          return _this._longHide = true
        }, 500)
      }

      TooltipHTMLContent.prototype.hideLater = function (time) {
        if (this._show && !(this._inContent && this._enterable)) {
          if (time) {
            this._hideDelay = time // Set show false to avoid invoke hideLater multiple times

            this._show = false
            this._hideTimeout = setTimeout(bind(this.hide, this), time)
          } else {
            this.hide()
          }
        }
      }

      TooltipHTMLContent.prototype.isShow = function () {
        return this._show
      }

      TooltipHTMLContent.prototype.dispose = function () {
        this.el.parentNode.removeChild(this.el)
      }

      return TooltipHTMLContent
    }())

  const TooltipRichContent =
    /** @class */
    (function () {
      function TooltipRichContent (api) {
        this._show = false
        this._styleCoord = [0, 0, 0, 0]
        this._enterable = true
        this._zr = api.getZr()
        makeStyleCoord$1(this._styleCoord, this._zr, api.getWidth() / 2, api.getHeight() / 2)
      }
      /**
       * Update when tooltip is rendered
       */

      TooltipRichContent.prototype.update = function (tooltipModel) {
        const alwaysShowContent = tooltipModel.get('alwaysShowContent')
        alwaysShowContent && this._moveIfResized()
      }

      TooltipRichContent.prototype.show = function () {
        if (this._hideTimeout) {
          clearTimeout(this._hideTimeout)
        }

        this.el.show()
        this._show = true
      }
      /**
       * Set tooltip content
       */

      TooltipRichContent.prototype.setContent = function (content, markupStyleCreator, tooltipModel, borderColor, arrowPosition) {
        const _this = this

        if (isObject(content)) {
          throwError('development' !== 'production' ? 'Passing DOM nodes as content is not supported in richText tooltip!' : '')
        }

        if (this.el) {
          this._zr.remove(this.el)
        }

        const textStyleModel = tooltipModel.getModel('textStyle')
        this.el = new ZRText({
          style: {
            rich: markupStyleCreator.richTextStyles,
            text: content,
            lineHeight: 22,
            borderWidth: 1,
            borderColor: borderColor,
            textShadowColor: textStyleModel.get('textShadowColor'),
            fill: tooltipModel.get(['textStyle', 'color']),
            padding: getPaddingFromTooltipModel(tooltipModel, 'richText'),
            verticalAlign: 'top',
            align: 'left'
          },
          z: tooltipModel.get('z')
        })
        each(['backgroundColor', 'borderRadius', 'shadowColor', 'shadowBlur', 'shadowOffsetX', 'shadowOffsetY'], function (propName) {
          _this.el.style[propName] = tooltipModel.get(propName)
        })
        each(['textShadowBlur', 'textShadowOffsetX', 'textShadowOffsetY'], function (propName) {
          _this.el.style[propName] = textStyleModel.get(propName) || 0
        })

        this._zr.add(this.el)

        const self = this
        this.el.on('mouseover', function () {
          // clear the timeout in hideLater and keep showing tooltip
          if (self._enterable) {
            clearTimeout(self._hideTimeout)
            self._show = true
          }

          self._inContent = true
        })
        this.el.on('mouseout', function () {
          if (self._enterable) {
            if (self._show) {
              self.hideLater(self._hideDelay)
            }
          }

          self._inContent = false
        })
      }

      TooltipRichContent.prototype.setEnterable = function (enterable) {
        this._enterable = enterable
      }

      TooltipRichContent.prototype.getSize = function () {
        const el = this.el
        const bounding = this.el.getBoundingRect() // bounding rect does not include shadow. For renderMode richText,
        // if overflow, it will be cut. So calculate them accurately.

        const shadowOuterSize = calcShadowOuterSize(el.style)
        return [bounding.width + shadowOuterSize.left + shadowOuterSize.right, bounding.height + shadowOuterSize.top + shadowOuterSize.bottom]
      }

      TooltipRichContent.prototype.moveTo = function (x, y) {
        const el = this.el

        if (el) {
          const styleCoord = this._styleCoord
          makeStyleCoord$1(styleCoord, this._zr, x, y)
          x = styleCoord[0]
          y = styleCoord[1]
          const style = el.style
          const borderWidth = mathMaxWith0(style.borderWidth || 0)
          const shadowOuterSize = calcShadowOuterSize(style) // rich text x, y do not include border.

          el.x = x + borderWidth + shadowOuterSize.left
          el.y = y + borderWidth + shadowOuterSize.top
          el.markRedraw()
        }
      }
      /**
       * when `alwaysShowContent` is true,
       * move the tooltip after chart resized
       */

      TooltipRichContent.prototype._moveIfResized = function () {
        // The ratio of left to width
        const ratioX = this._styleCoord[2] // The ratio of top to height

        const ratioY = this._styleCoord[3]
        this.moveTo(ratioX * this._zr.getWidth(), ratioY * this._zr.getHeight())
      }

      TooltipRichContent.prototype.hide = function () {
        if (this.el) {
          this.el.hide()
        }

        this._show = false
      }

      TooltipRichContent.prototype.hideLater = function (time) {
        if (this._show && !(this._inContent && this._enterable)) {
          if (time) {
            this._hideDelay = time // Set show false to avoid invoke hideLater multiple times

            this._show = false
            this._hideTimeout = setTimeout(bind(this.hide, this), time)
          } else {
            this.hide()
          }
        }
      }

      TooltipRichContent.prototype.isShow = function () {
        return this._show
      }

      TooltipRichContent.prototype.dispose = function () {
        this._zr.remove(this.el)
      }

      return TooltipRichContent
    }())

  function mathMaxWith0 (val) {
    return Math.max(0, val)
  }

  function calcShadowOuterSize (style) {
    const shadowBlur = mathMaxWith0(style.shadowBlur || 0)
    const shadowOffsetX = mathMaxWith0(style.shadowOffsetX || 0)
    const shadowOffsetY = mathMaxWith0(style.shadowOffsetY || 0)
    return {
      left: mathMaxWith0(shadowBlur - shadowOffsetX),
      right: mathMaxWith0(shadowBlur + shadowOffsetX),
      top: mathMaxWith0(shadowBlur - shadowOffsetY),
      bottom: mathMaxWith0(shadowBlur + shadowOffsetY)
    }
  }

  function makeStyleCoord$1 (out, zr, zrX, zrY) {
    out[0] = zrX
    out[1] = zrY
    out[2] = out[0] / zr.getWidth()
    out[3] = out[1] / zr.getHeight()
  }

  const proxyRect = new Rect({
    shape: {
      x: -1,
      y: -1,
      width: 2,
      height: 2
    }
  })

  const TooltipView =
    /** @class */
    (function (_super) {
      __extends(TooltipView, _super)

      function TooltipView () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = TooltipView.type
        return _this
      }

      TooltipView.prototype.init = function (ecModel, api) {
        if (env.node || !api.getDom()) {
          return
        }

        const tooltipModel = ecModel.getComponent('tooltip')
        const renderMode = this._renderMode = getTooltipRenderMode(tooltipModel.get('renderMode'))
        this._tooltipContent = renderMode === 'richText'
          ? new TooltipRichContent(api)
          : new TooltipHTMLContent(api.getDom(), api, {
            appendToBody: tooltipModel.get('appendToBody', true)
          })
      }

      TooltipView.prototype.render = function (tooltipModel, ecModel, api) {
        if (env.node || !api.getDom()) {
          return
        } // Reset

        this.group.removeAll()
        this._tooltipModel = tooltipModel
        this._ecModel = ecModel
        this._api = api
        /**
         * @private
         * @type {boolean}
         */

        this._alwaysShowContent = tooltipModel.get('alwaysShowContent')
        const tooltipContent = this._tooltipContent
        tooltipContent.update(tooltipModel)
        tooltipContent.setEnterable(tooltipModel.get('enterable'))

        this._initGlobalListener()

        this._keepShow() // PENDING
        // `mousemove` event will be triggered very frequently when the mouse moves fast,
        // which causes that the `updatePosition` function was also called frequently.
        // In Chrome with devtools open and Firefox, tooltip looks laggy and shakes. See #14695 #16101
        // To avoid frequent triggering,
        // consider throttling it in 50ms when transition is enabled

        if (this._renderMode !== 'richText' && tooltipModel.get('transitionDuration')) {
          createOrUpdate(this, '_updatePosition', 50, 'fixRate')
        } else {
          clear(this, '_updatePosition')
        }
      }

      TooltipView.prototype._initGlobalListener = function () {
        const tooltipModel = this._tooltipModel
        const triggerOn = tooltipModel.get('triggerOn')
        register('itemTooltip', this._api, bind(function (currTrigger, e, dispatchAction) {
          // If 'none', it is not controlled by mouse totally.
          if (triggerOn !== 'none') {
            if (triggerOn.indexOf(currTrigger) >= 0) {
              this._tryShow(e, dispatchAction)
            } else if (currTrigger === 'leave') {
              this._hide(dispatchAction)
            }
          }
        }, this))
      }

      TooltipView.prototype._keepShow = function () {
        const tooltipModel = this._tooltipModel
        const ecModel = this._ecModel
        const api = this._api
        const triggerOn = tooltipModel.get('triggerOn') // Try to keep the tooltip show when refreshing

        if (this._lastX != null && this._lastY != null && // When user is willing to control tooltip totally using API,
        // self.manuallyShowTip({x, y}) might cause tooltip hide,
        // which is not expected.
        triggerOn !== 'none' && triggerOn !== 'click') {
          const self_1 = this
          clearTimeout(this._refreshUpdateTimeout)
          this._refreshUpdateTimeout = setTimeout(function () {
            // Show tip next tick after other charts are rendered
            // In case highlight action has wrong result
            // FIXME
            !api.isDisposed() && self_1.manuallyShowTip(tooltipModel, ecModel, api, {
              x: self_1._lastX,
              y: self_1._lastY,
              dataByCoordSys: self_1._lastDataByCoordSys
            })
          })
        }
      }
      /**
       * Show tip manually by
       * dispatchAction({
       *     type: 'showTip',
       *     x: 10,
       *     y: 10
       * });
       * Or
       * dispatchAction({
       *      type: 'showTip',
       *      seriesIndex: 0,
       *      dataIndex or dataIndexInside or name
       * });
       *
       *  TODO Batch
       */

      TooltipView.prototype.manuallyShowTip = function (tooltipModel, ecModel, api, payload) {
        if (payload.from === this.uid || env.node || !api.getDom()) {
          return
        }

        const dispatchAction = makeDispatchAction$1(payload, api) // Reset ticket

        this._ticket = '' // When triggered from axisPointer.

        const dataByCoordSys = payload.dataByCoordSys
        const cmptRef = findComponentReference(payload, ecModel, api)

        if (cmptRef) {
          const rect = cmptRef.el.getBoundingRect().clone()
          rect.applyTransform(cmptRef.el.transform)

          this._tryShow({
            offsetX: rect.x + rect.width / 2,
            offsetY: rect.y + rect.height / 2,
            target: cmptRef.el,
            position: payload.position,
            // When manully trigger, the mouse is not on the el, so we'd better to
            // position tooltip on the bottom of the el and display arrow is possible.
            positionDefault: 'bottom'
          }, dispatchAction)
        } else if (payload.tooltip && payload.x != null && payload.y != null) {
          const el = proxyRect
          el.x = payload.x
          el.y = payload.y
          el.update()
          getECData(el).tooltipConfig = {
            name: null,
            option: payload.tooltip
          } // Manually show tooltip while view is not using zrender elements.

          this._tryShow({
            offsetX: payload.x,
            offsetY: payload.y,
            target: el
          }, dispatchAction)
        } else if (dataByCoordSys) {
          this._tryShow({
            offsetX: payload.x,
            offsetY: payload.y,
            position: payload.position,
            dataByCoordSys: dataByCoordSys,
            tooltipOption: payload.tooltipOption
          }, dispatchAction)
        } else if (payload.seriesIndex != null) {
          if (this._manuallyAxisShowTip(tooltipModel, ecModel, api, payload)) {
            return
          }

          const pointInfo = findPointFromSeries(payload, ecModel)
          const cx = pointInfo.point[0]
          const cy = pointInfo.point[1]

          if (cx != null && cy != null) {
            this._tryShow({
              offsetX: cx,
              offsetY: cy,
              target: pointInfo.el,
              position: payload.position,
              // When manully trigger, the mouse is not on the el, so we'd better to
              // position tooltip on the bottom of the el and display arrow is possible.
              positionDefault: 'bottom'
            }, dispatchAction)
          }
        } else if (payload.x != null && payload.y != null) {
          // FIXME
          // should wrap dispatchAction like `axisPointer/globalListener` ?
          api.dispatchAction({
            type: 'updateAxisPointer',
            x: payload.x,
            y: payload.y
          })

          this._tryShow({
            offsetX: payload.x,
            offsetY: payload.y,
            position: payload.position,
            target: api.getZr().findHover(payload.x, payload.y).target
          }, dispatchAction)
        }
      }

      TooltipView.prototype.manuallyHideTip = function (tooltipModel, ecModel, api, payload) {
        const tooltipContent = this._tooltipContent

        if (!this._alwaysShowContent && this._tooltipModel) {
          tooltipContent.hideLater(this._tooltipModel.get('hideDelay'))
        }

        this._lastX = this._lastY = this._lastDataByCoordSys = null

        if (payload.from !== this.uid) {
          this._hide(makeDispatchAction$1(payload, api))
        }
      } // Be compatible with previous design, that is, when tooltip.type is 'axis' and
      // dispatchAction 'showTip' with seriesIndex and dataIndex will trigger axis pointer
      // and tooltip.

      TooltipView.prototype._manuallyAxisShowTip = function (tooltipModel, ecModel, api, payload) {
        const seriesIndex = payload.seriesIndex
        const dataIndex = payload.dataIndex // @ts-ignore

        const coordSysAxesInfo = ecModel.getComponent('axisPointer').coordSysAxesInfo

        if (seriesIndex == null || dataIndex == null || coordSysAxesInfo == null) {
          return
        }

        const seriesModel = ecModel.getSeriesByIndex(seriesIndex)

        if (!seriesModel) {
          return
        }

        const data = seriesModel.getData()
        const tooltipCascadedModel = buildTooltipModel([data.getItemModel(dataIndex), seriesModel, (seriesModel.coordinateSystem || {}).model], this._tooltipModel)

        if (tooltipCascadedModel.get('trigger') !== 'axis') {
          return
        }

        api.dispatchAction({
          type: 'updateAxisPointer',
          seriesIndex: seriesIndex,
          dataIndex: dataIndex,
          position: payload.position
        })
        return true
      }

      TooltipView.prototype._tryShow = function (e, dispatchAction) {
        const el = e.target
        const tooltipModel = this._tooltipModel

        if (!tooltipModel) {
          return
        } // Save mouse x, mouse y. So we can try to keep showing the tip if chart is refreshed

        this._lastX = e.offsetX
        this._lastY = e.offsetY
        const dataByCoordSys = e.dataByCoordSys

        if (dataByCoordSys && dataByCoordSys.length) {
          this._showAxisTooltip(dataByCoordSys, e)
        } else if (el) {
          this._lastDataByCoordSys = null
          let seriesDispatcher_1
          let cmptDispatcher_1
          findEventDispatcher(el, function (target) {
            // Always show item tooltip if mouse is on the element with dataIndex
            if (getECData(target).dataIndex != null) {
              seriesDispatcher_1 = target
              return true
            } // Tooltip provided directly. Like legend.

            if (getECData(target).tooltipConfig != null) {
              cmptDispatcher_1 = target
              return true
            }
          }, true)

          if (seriesDispatcher_1) {
            this._showSeriesItemTooltip(e, seriesDispatcher_1, dispatchAction)
          } else if (cmptDispatcher_1) {
            this._showComponentItemTooltip(e, cmptDispatcher_1, dispatchAction)
          } else {
            this._hide(dispatchAction)
          }
        } else {
          this._lastDataByCoordSys = null

          this._hide(dispatchAction)
        }
      }

      TooltipView.prototype._showOrMove = function (tooltipModel, cb) {
        // showDelay is used in this case: tooltip.enterable is set
        // as true. User intent to move mouse into tooltip and click
        // something. `showDelay` makes it easier to enter the content
        // but tooltip do not move immediately.
        const delay = tooltipModel.get('showDelay')
        cb = bind(cb, this)
        clearTimeout(this._showTimout)
        delay > 0 ? this._showTimout = setTimeout(cb, delay) : cb()
      }

      TooltipView.prototype._showAxisTooltip = function (dataByCoordSys, e) {
        const ecModel = this._ecModel
        const globalTooltipModel = this._tooltipModel
        const point = [e.offsetX, e.offsetY]
        const singleTooltipModel = buildTooltipModel([e.tooltipOption], globalTooltipModel)
        const renderMode = this._renderMode
        const cbParamsList = []
        const articleMarkup = createTooltipMarkup('section', {
          blocks: [],
          noHeader: true
        }) // Only for legacy: `Serise['formatTooltip']` returns a string.

        const markupTextArrLegacy = []
        const markupStyleCreator = new TooltipMarkupStyleCreator()
        each(dataByCoordSys, function (itemCoordSys) {
          each(itemCoordSys.dataByAxis, function (axisItem) {
            const axisModel = ecModel.getComponent(axisItem.axisDim + 'Axis', axisItem.axisIndex)
            const axisValue = axisItem.value

            if (!axisModel || axisValue == null) {
              return
            }

            const axisValueLabel = getValueLabel(axisValue, axisModel.axis, ecModel, axisItem.seriesDataIndices, axisItem.valueLabelOpt)
            const axisSectionMarkup = createTooltipMarkup('section', {
              header: axisValueLabel,
              noHeader: !trim(axisValueLabel),
              sortBlocks: true,
              blocks: []
            })
            articleMarkup.blocks.push(axisSectionMarkup)
            each(axisItem.seriesDataIndices, function (idxItem) {
              const series = ecModel.getSeriesByIndex(idxItem.seriesIndex)
              const dataIndex = idxItem.dataIndexInside
              const cbParams = series.getDataParams(dataIndex) // Can't find data.

              if (cbParams.dataIndex < 0) {
                return
              }

              cbParams.axisDim = axisItem.axisDim
              cbParams.axisIndex = axisItem.axisIndex
              cbParams.axisType = axisItem.axisType
              cbParams.axisId = axisItem.axisId
              cbParams.axisValue = getAxisRawValue(axisModel.axis, {
                value: axisValue
              })
              cbParams.axisValueLabel = axisValueLabel // Pre-create marker style for makers. Users can assemble richText
              // text in `formatter` callback and use those markers style.

              cbParams.marker = markupStyleCreator.makeTooltipMarker('item', convertToColorString(cbParams.color), renderMode)
              const seriesTooltipResult = normalizeTooltipFormatResult(series.formatTooltip(dataIndex, true, null))
              const frag = seriesTooltipResult.frag

              if (frag) {
                const valueFormatter = buildTooltipModel([series], globalTooltipModel).get('valueFormatter')
                axisSectionMarkup.blocks.push(valueFormatter
                  ? extend({
                    valueFormatter: valueFormatter
                  }, frag)
                  : frag)
              }

              if (seriesTooltipResult.text) {
                markupTextArrLegacy.push(seriesTooltipResult.text)
              }

              cbParamsList.push(cbParams)
            })
          })
        }) // In most cases, the second axis is displays upper on the first one.
        // So we reverse it to look better.

        articleMarkup.blocks.reverse()
        markupTextArrLegacy.reverse()
        const positionExpr = e.position
        const orderMode = singleTooltipModel.get('order')
        const builtMarkupText = buildTooltipMarkup(articleMarkup, markupStyleCreator, renderMode, orderMode, ecModel.get('useUTC'), singleTooltipModel.get('textStyle'))
        builtMarkupText && markupTextArrLegacy.unshift(builtMarkupText)
        const blockBreak = renderMode === 'richText' ? '\n\n' : '<br/>'
        const allMarkupText = markupTextArrLegacy.join(blockBreak)

        this._showOrMove(singleTooltipModel, function () {
          if (this._updateContentNotChangedOnAxis(dataByCoordSys, cbParamsList)) {
            this._updatePosition(singleTooltipModel, positionExpr, point[0], point[1], this._tooltipContent, cbParamsList)
          } else {
            this._showTooltipContent(singleTooltipModel, allMarkupText, cbParamsList, Math.random() + '', point[0], point[1], positionExpr, null, markupStyleCreator)
          }
        }) // Do not trigger events here, because this branch only be entered
        // from dispatchAction.
      }

      TooltipView.prototype._showSeriesItemTooltip = function (e, dispatcher, dispatchAction) {
        const ecModel = this._ecModel
        const ecData = getECData(dispatcher) // Use dataModel in element if possible
        // Used when mouseover on a element like markPoint or edge
        // In which case, the data is not main data in series.

        const seriesIndex = ecData.seriesIndex
        const seriesModel = ecModel.getSeriesByIndex(seriesIndex) // For example, graph link.

        const dataModel = ecData.dataModel || seriesModel
        const dataIndex = ecData.dataIndex
        const dataType = ecData.dataType
        const data = dataModel.getData(dataType)
        const renderMode = this._renderMode
        const positionDefault = e.positionDefault
        const tooltipModel = buildTooltipModel([data.getItemModel(dataIndex), dataModel, seriesModel && (seriesModel.coordinateSystem || {}).model], this._tooltipModel, positionDefault
          ? {
              position: positionDefault
            }
          : null)
        const tooltipTrigger = tooltipModel.get('trigger')

        if (tooltipTrigger != null && tooltipTrigger !== 'item') {
          return
        }

        const params = dataModel.getDataParams(dataIndex, dataType)
        const markupStyleCreator = new TooltipMarkupStyleCreator() // Pre-create marker style for makers. Users can assemble richText
        // text in `formatter` callback and use those markers style.

        params.marker = markupStyleCreator.makeTooltipMarker('item', convertToColorString(params.color), renderMode)
        const seriesTooltipResult = normalizeTooltipFormatResult(dataModel.formatTooltip(dataIndex, false, dataType))
        const orderMode = tooltipModel.get('order')
        const valueFormatter = tooltipModel.get('valueFormatter')
        const frag = seriesTooltipResult.frag
        const markupText = frag
          ? buildTooltipMarkup(valueFormatter
            ? extend({
              valueFormatter: valueFormatter
            }, frag)
            : frag, markupStyleCreator, renderMode, orderMode, ecModel.get('useUTC'), tooltipModel.get('textStyle'))
          : seriesTooltipResult.text
        const asyncTicket = 'item_' + dataModel.name + '_' + dataIndex

        this._showOrMove(tooltipModel, function () {
          this._showTooltipContent(tooltipModel, markupText, params, asyncTicket, e.offsetX, e.offsetY, e.position, e.target, markupStyleCreator)
        }) // FIXME
        // duplicated showtip if manuallyShowTip is called from dispatchAction.

        dispatchAction({
          type: 'showTip',
          dataIndexInside: dataIndex,
          dataIndex: data.getRawIndex(dataIndex),
          seriesIndex: seriesIndex,
          from: this.uid
        })
      }

      TooltipView.prototype._showComponentItemTooltip = function (e, el, dispatchAction) {
        const ecData = getECData(el)
        const tooltipConfig = ecData.tooltipConfig
        let tooltipOpt = tooltipConfig.option || {}

        if (isString(tooltipOpt)) {
          const content = tooltipOpt
          tooltipOpt = {
            content: content,
            // Fixed formatter
            formatter: content
          }
        }

        const tooltipModelCascade = [tooltipOpt]

        const cmpt = this._ecModel.getComponent(ecData.componentMainType, ecData.componentIndex)

        if (cmpt) {
          tooltipModelCascade.push(cmpt)
        } // In most cases, component tooltip formatter has different params with series tooltip formatter,
        // so that they can not share the same formatter. Since the global tooltip formatter is used for series
        // by convension, we do not use it as the default formatter for component.

        tooltipModelCascade.push({
          formatter: tooltipOpt.content
        })
        const positionDefault = e.positionDefault
        const subTooltipModel = buildTooltipModel(tooltipModelCascade, this._tooltipModel, positionDefault
          ? {
              position: positionDefault
            }
          : null)
        const defaultHtml = subTooltipModel.get('content')
        const asyncTicket = Math.random() + '' // PENDING: this case do not support richText style yet.

        const markupStyleCreator = new TooltipMarkupStyleCreator() // Do not check whether `trigger` is 'none' here, because `trigger`
        // only works on coordinate system. In fact, we have not found case
        // that requires setting `trigger` nothing on component yet.

        this._showOrMove(subTooltipModel, function () {
          // Use formatterParams from element defined in component
          // Avoid users modify it.
          const formatterParams = clone(subTooltipModel.get('formatterParams') || {})

          this._showTooltipContent(subTooltipModel, defaultHtml, formatterParams, asyncTicket, e.offsetX, e.offsetY, e.position, el, markupStyleCreator)
        }) // If not dispatch showTip, tip may be hide triggered by axis.

        dispatchAction({
          type: 'showTip',
          from: this.uid
        })
      }

      TooltipView.prototype._showTooltipContent = function ( // Use Model<TooltipOption> insteadof TooltipModel because this model may be from series or other options.
      // Instead of top level tooltip.
        tooltipModel, defaultHtml, params, asyncTicket, x, y, positionExpr, el, markupStyleCreator) {
        // Reset ticket
        this._ticket = ''

        if (!tooltipModel.get('showContent') || !tooltipModel.get('show')) {
          return
        }

        const tooltipContent = this._tooltipContent
        tooltipContent.setEnterable(tooltipModel.get('enterable'))
        const formatter = tooltipModel.get('formatter')
        positionExpr = positionExpr || tooltipModel.get('position')
        let html = defaultHtml

        const nearPoint = this._getNearestPoint([x, y], params, tooltipModel.get('trigger'), tooltipModel.get('borderColor'))

        const nearPointColor = nearPoint.color

        if (formatter) {
          if (isString(formatter)) {
            const useUTC = tooltipModel.ecModel.get('useUTC')
            const params0 = isArray(params) ? params[0] : params
            const isTimeAxis = params0 && params0.axisType && params0.axisType.indexOf('time') >= 0
            html = formatter

            if (isTimeAxis) {
              html = format(params0.axisValue, html, useUTC)
            }

            html = formatTpl(html, params, true)
          } else if (isFunction(formatter)) {
            const callback = bind(function (cbTicket, html) {
              if (cbTicket === this._ticket) {
                tooltipContent.setContent(html, markupStyleCreator, tooltipModel, nearPointColor, positionExpr)

                this._updatePosition(tooltipModel, positionExpr, x, y, tooltipContent, params, el)
              }
            }, this)
            this._ticket = asyncTicket
            html = formatter(params, asyncTicket, callback)
          } else {
            html = formatter
          }
        }

        tooltipContent.setContent(html, markupStyleCreator, tooltipModel, nearPointColor, positionExpr)
        tooltipContent.show(tooltipModel, nearPointColor)

        this._updatePosition(tooltipModel, positionExpr, x, y, tooltipContent, params, el)
      }

      TooltipView.prototype._getNearestPoint = function (point, tooltipDataParams, trigger, borderColor) {
        if (trigger === 'axis' || isArray(tooltipDataParams)) {
          return {
            color: borderColor || (this._renderMode === 'html' ? '#fff' : 'none')
          }
        }

        if (!isArray(tooltipDataParams)) {
          return {
            color: borderColor || tooltipDataParams.color || tooltipDataParams.borderColor
          }
        }
      }

      TooltipView.prototype._updatePosition = function (tooltipModel, positionExpr, x, // Mouse x
        y, // Mouse y
        content, params, el) {
        const viewWidth = this._api.getWidth()

        const viewHeight = this._api.getHeight()

        positionExpr = positionExpr || tooltipModel.get('position')
        const contentSize = content.getSize()
        let align = tooltipModel.get('align')
        let vAlign = tooltipModel.get('verticalAlign')
        const rect = el && el.getBoundingRect().clone()
        el && rect.applyTransform(el.transform)

        if (isFunction(positionExpr)) {
          // Callback of position can be an array or a string specify the position
          positionExpr = positionExpr([x, y], params, content.el, rect, {
            viewSize: [viewWidth, viewHeight],
            contentSize: contentSize.slice()
          })
        }

        if (isArray(positionExpr)) {
          x = parsePercent$1(positionExpr[0], viewWidth)
          y = parsePercent$1(positionExpr[1], viewHeight)
        } else if (isObject(positionExpr)) {
          const boxLayoutPosition = positionExpr
          boxLayoutPosition.width = contentSize[0]
          boxLayoutPosition.height = contentSize[1]
          const layoutRect = getLayoutRect(boxLayoutPosition, {
            width: viewWidth,
            height: viewHeight
          })
          x = layoutRect.x
          y = layoutRect.y
          align = null // When positionExpr is left/top/right/bottom,
          // align and verticalAlign will not work.

          vAlign = null
        } // Specify tooltip position by string 'top' 'bottom' 'left' 'right' around graphic element
        else if (isString(positionExpr) && el) {
          var pos = calcTooltipPosition(positionExpr, rect, contentSize, tooltipModel.get('borderWidth'))
          x = pos[0]
          y = pos[1]
        } else {
          var pos = refixTooltipPosition(x, y, content, viewWidth, viewHeight, align ? null : 20, vAlign ? null : 20)
          x = pos[0]
          y = pos[1]
        }

        align && (x -= isCenterAlign(align) ? contentSize[0] / 2 : align === 'right' ? contentSize[0] : 0)
        vAlign && (y -= isCenterAlign(vAlign) ? contentSize[1] / 2 : vAlign === 'bottom' ? contentSize[1] : 0)

        if (shouldTooltipConfine(tooltipModel)) {
          var pos = confineTooltipPosition(x, y, content, viewWidth, viewHeight)
          x = pos[0]
          y = pos[1]
        }

        content.moveTo(x, y)
      } // FIXME
      // Should we remove this but leave this to user?

      TooltipView.prototype._updateContentNotChangedOnAxis = function (dataByCoordSys, cbParamsList) {
        const lastCoordSys = this._lastDataByCoordSys
        const lastCbParamsList = this._cbParamsList
        let contentNotChanged = !!lastCoordSys && lastCoordSys.length === dataByCoordSys.length
        contentNotChanged && each(lastCoordSys, function (lastItemCoordSys, indexCoordSys) {
          const lastDataByAxis = lastItemCoordSys.dataByAxis || []
          const thisItemCoordSys = dataByCoordSys[indexCoordSys] || {}
          const thisDataByAxis = thisItemCoordSys.dataByAxis || []
          contentNotChanged = contentNotChanged && lastDataByAxis.length === thisDataByAxis.length
          contentNotChanged && each(lastDataByAxis, function (lastItem, indexAxis) {
            const thisItem = thisDataByAxis[indexAxis] || {}
            const lastIndices = lastItem.seriesDataIndices || []
            const newIndices = thisItem.seriesDataIndices || []
            contentNotChanged = contentNotChanged && lastItem.value === thisItem.value && lastItem.axisType === thisItem.axisType && lastItem.axisId === thisItem.axisId && lastIndices.length === newIndices.length
            contentNotChanged && each(lastIndices, function (lastIdxItem, j) {
              const newIdxItem = newIndices[j]
              contentNotChanged = contentNotChanged && lastIdxItem.seriesIndex === newIdxItem.seriesIndex && lastIdxItem.dataIndex === newIdxItem.dataIndex
            }) // check is cbParams data value changed

            lastCbParamsList && each(lastItem.seriesDataIndices, function (idxItem) {
              const seriesIdx = idxItem.seriesIndex
              const cbParams = cbParamsList[seriesIdx]
              const lastCbParams = lastCbParamsList[seriesIdx]

              if (cbParams && lastCbParams && lastCbParams.data !== cbParams.data) {
                contentNotChanged = false
              }
            })
          })
        })
        this._lastDataByCoordSys = dataByCoordSys
        this._cbParamsList = cbParamsList
        return !!contentNotChanged
      }

      TooltipView.prototype._hide = function (dispatchAction) {
        // Do not directly hideLater here, because this behavior may be prevented
        // in dispatchAction when showTip is dispatched.
        // FIXME
        // duplicated hideTip if manuallyHideTip is called from dispatchAction.
        this._lastDataByCoordSys = null
        dispatchAction({
          type: 'hideTip',
          from: this.uid
        })
      }

      TooltipView.prototype.dispose = function (ecModel, api) {
        if (env.node || !api.getDom()) {
          return
        }

        clear(this, '_updatePosition')

        this._tooltipContent.dispose()

        unregister('itemTooltip', api)
      }

      TooltipView.type = 'tooltip'
      return TooltipView
    }(ComponentView))
    /**
     * From top to bottom. (the last one should be globalTooltipModel);
     */

  function buildTooltipModel (modelCascade, globalTooltipModel, defaultTooltipOption) {
    // Last is always tooltip model.
    const ecModel = globalTooltipModel.ecModel
    let resultModel

    if (defaultTooltipOption) {
      resultModel = new Model(defaultTooltipOption, ecModel, ecModel)
      resultModel = new Model(globalTooltipModel.option, resultModel, ecModel)
    } else {
      resultModel = globalTooltipModel
    }

    for (let i = modelCascade.length - 1; i >= 0; i--) {
      let tooltipOpt = modelCascade[i]

      if (tooltipOpt) {
        if (tooltipOpt instanceof Model) {
          tooltipOpt = tooltipOpt.get('tooltip', true)
        } // In each data item tooltip can be simply write:
        // {
        //  value: 10,
        //  tooltip: 'Something you need to know'
        // }

        if (isString(tooltipOpt)) {
          tooltipOpt = {
            formatter: tooltipOpt
          }
        }

        if (tooltipOpt) {
          resultModel = new Model(tooltipOpt, resultModel, ecModel)
        }
      }
    }

    return resultModel
  }

  function makeDispatchAction$1 (payload, api) {
    return payload.dispatchAction || bind(api.dispatchAction, api)
  }

  function refixTooltipPosition (x, y, content, viewWidth, viewHeight, gapH, gapV) {
    const size = content.getSize()
    const width = size[0]
    const height = size[1]

    if (gapH != null) {
      // Add extra 2 pixels for this case:
      // At present the "values" in defaut tooltip are using CSS `float: right`.
      // When the right edge of the tooltip box is on the right side of the
      // viewport, the `float` layout might push the "values" to the second line.
      if (x + width + gapH + 2 > viewWidth) {
        x -= width + gapH
      } else {
        x += gapH
      }
    }

    if (gapV != null) {
      if (y + height + gapV > viewHeight) {
        y -= height + gapV
      } else {
        y += gapV
      }
    }

    return [x, y]
  }

  function confineTooltipPosition (x, y, content, viewWidth, viewHeight) {
    const size = content.getSize()
    const width = size[0]
    const height = size[1]
    x = Math.min(x + width, viewWidth) - width
    y = Math.min(y + height, viewHeight) - height
    x = Math.max(x, 0)
    y = Math.max(y, 0)
    return [x, y]
  }

  function calcTooltipPosition (position, rect, contentSize, borderWidth) {
    const domWidth = contentSize[0]
    const domHeight = contentSize[1]
    const offset = Math.ceil(Math.SQRT2 * borderWidth) + 8
    let x = 0
    let y = 0
    const rectWidth = rect.width
    const rectHeight = rect.height

    switch (position) {
      case 'inside':
        x = rect.x + rectWidth / 2 - domWidth / 2
        y = rect.y + rectHeight / 2 - domHeight / 2
        break

      case 'top':
        x = rect.x + rectWidth / 2 - domWidth / 2
        y = rect.y - domHeight - offset
        break

      case 'bottom':
        x = rect.x + rectWidth / 2 - domWidth / 2
        y = rect.y + rectHeight + offset
        break

      case 'left':
        x = rect.x - domWidth - offset
        y = rect.y + rectHeight / 2 - domHeight / 2
        break

      case 'right':
        x = rect.x + rectWidth + offset
        y = rect.y + rectHeight / 2 - domHeight / 2
    }

    return [x, y]
  }

  function isCenterAlign (align) {
    return align === 'center' || align === 'middle'
  }
  /**
     * Find target component by payload like:
     * ```js
     * { legendId: 'some_id', name: 'xxx' }
     * { toolboxIndex: 1, name: 'xxx' }
     * { geoName: 'some_name', name: 'xxx' }
     * ```
     * PENDING: at present only
     *
     * If not found, return null/undefined.
     */

  function findComponentReference (payload, ecModel, api) {
    const queryOptionMap = preParseFinder(payload).queryOptionMap
    const componentMainType = queryOptionMap.keys()[0]

    if (!componentMainType || componentMainType === 'series') {
      return
    }

    const queryResult = queryReferringComponents(ecModel, componentMainType, queryOptionMap.get(componentMainType), {
      useDefault: false,
      enableAll: false,
      enableNone: false
    })
    const model = queryResult.models[0]

    if (!model) {
      return
    }

    const view = api.getViewOfComponentModel(model)
    let el
    view.group.traverse(function (subEl) {
      const tooltipConfig = getECData(subEl).tooltipConfig

      if (tooltipConfig && tooltipConfig.name === payload.name) {
        el = subEl
        return true // stop
      }
    })

    if (el) {
      return {
        componentMainType: componentMainType,
        componentIndex: model.componentIndex,
        el: el
      }
    }
  }

  function install$A (registers) {
    use(install$s)
    registers.registerComponentModel(TooltipModel)
    registers.registerComponentView(TooltipView)
    /**
       * @action
       * @property {string} type
       * @property {number} seriesIndex
       * @property {number} dataIndex
       * @property {number} [x]
       * @property {number} [y]
       */

    registers.registerAction({
      type: 'showTip',
      event: 'showTip',
      update: 'tooltip:manuallyShowTip'
    }, noop)
    registers.registerAction({
      type: 'hideTip',
      event: 'hideTip',
      update: 'tooltip:manuallyHideTip'
    }, noop)
  }

  const DEFAULT_TOOLBOX_BTNS = ['rect', 'polygon', 'keep', 'clear']
  function brushPreprocessor (option, isNew) {
    const brushComponents = normalizeToArray(option ? option.brush : [])

    if (!brushComponents.length) {
      return
    }

    let brushComponentSpecifiedBtns = []
    each(brushComponents, function (brushOpt) {
      const tbs = brushOpt.hasOwnProperty('toolbox') ? brushOpt.toolbox : []

      if (tbs instanceof Array) {
        brushComponentSpecifiedBtns = brushComponentSpecifiedBtns.concat(tbs)
      }
    })
    let toolbox = option && option.toolbox

    if (isArray(toolbox)) {
      toolbox = toolbox[0]
    }

    if (!toolbox) {
      toolbox = {
        feature: {}
      }
      option.toolbox = [toolbox]
    }

    const toolboxFeature = toolbox.feature || (toolbox.feature = {})
    const toolboxBrush = toolboxFeature.brush || (toolboxFeature.brush = {})
    const brushTypes = toolboxBrush.type || (toolboxBrush.type = [])
    brushTypes.push.apply(brushTypes, brushComponentSpecifiedBtns)
    removeDuplicate(brushTypes)

    if (isNew && !brushTypes.length) {
      brushTypes.push.apply(brushTypes, DEFAULT_TOOLBOX_BTNS)
    }
  }

  function removeDuplicate (arr) {
    const map = {}
    each(arr, function (val) {
      map[val] = 1
    })
    arr.length = 0
    each(map, function (flag, val) {
      arr.push(val)
    })
  }

  const each$b = each

  function hasKeys (obj) {
    if (obj) {
      for (const name_1 in obj) {
        if (obj.hasOwnProperty(name_1)) {
          return true
        }
      }
    }
  }

  function createVisualMappings (option, stateList, supplementVisualOption) {
    const visualMappings = {}
    each$b(stateList, function (state) {
      const mappings = visualMappings[state] = createMappings()
      each$b(option[state], function (visualData, visualType) {
        if (!VisualMapping.isValidType(visualType)) {
          return
        }

        let mappingOption = {
          type: visualType,
          visual: visualData
        }
        supplementVisualOption && supplementVisualOption(mappingOption, state)
        mappings[visualType] = new VisualMapping(mappingOption) // Prepare a alpha for opacity, for some case that opacity
        // is not supported, such as rendering using gradient color.

        if (visualType === 'opacity') {
          mappingOption = clone(mappingOption)
          mappingOption.type = 'colorAlpha'
          mappings.__hidden.__alphaForOpacity = new VisualMapping(mappingOption)
        }
      })
    })
    return visualMappings

    function createMappings () {
      const Creater = function () {} // Make sure hidden fields will not be visited by
      // object iteration (with hasOwnProperty checking).

      Creater.prototype.__hidden = Creater.prototype
      const obj = new Creater()
      return obj
    }
  }
  function replaceVisualOption (thisOption, newOption, keys) {
    // Visual attributes merge is not supported, otherwise it
    // brings overcomplicated merge logic. See #2853. So if
    // newOption has anyone of these keys, all of these keys
    // will be reset. Otherwise, all keys remain.
    let has
    each(keys, function (key) {
      if (newOption.hasOwnProperty(key) && hasKeys(newOption[key])) {
        has = true
      }
    })
    has && each(keys, function (key) {
      if (newOption.hasOwnProperty(key) && hasKeys(newOption[key])) {
        thisOption[key] = clone(newOption[key])
      } else {
        delete thisOption[key]
      }
    })
  }
  /**
     * @param stateList
     * @param visualMappings
     * @param list
     * @param getValueState param: valueOrIndex, return: state.
     * @param scope Scope for getValueState
     * @param dimension Concrete dimension, if used.
     */
  // ???! handle brush?

  function applyVisual (stateList, visualMappings, data, getValueState, scope, dimension) {
    const visualTypesMap = {}
    each(stateList, function (state) {
      const visualTypes = VisualMapping.prepareVisualTypes(visualMappings[state])
      visualTypesMap[state] = visualTypes
    })
    let dataIndex

    function getVisual (key) {
      return getItemVisualFromData(data, dataIndex, key)
    }

    function setVisual (key, value) {
      setItemVisualFromData(data, dataIndex, key, value)
    }

    if (dimension == null) {
      data.each(eachItem)
    } else {
      data.each([dimension], eachItem)
    }

    function eachItem (valueOrIndex, index) {
      dataIndex = dimension == null ? valueOrIndex // First argument is index
        : index
      const rawDataItem = data.getRawDataItem(dataIndex) // Consider performance
      // @ts-ignore

      if (rawDataItem && rawDataItem.visualMap === false) {
        return
      }

      const valueState = getValueState.call(scope, valueOrIndex)
      const mappings = visualMappings[valueState]
      const visualTypes = visualTypesMap[valueState]

      for (let i = 0, len = visualTypes.length; i < len; i++) {
        const type = visualTypes[i]
        mappings[type] && mappings[type].applyVisual(valueOrIndex, getVisual, setVisual)
      }
    }
  }
  /**
     * @param data
     * @param stateList
     * @param visualMappings <state, Object.<visualType, module:echarts/visual/VisualMapping>>
     * @param getValueState param: valueOrIndex, return: state.
     * @param dim dimension or dimension index.
     */

  function incrementalApplyVisual (stateList, visualMappings, getValueState, dim) {
    const visualTypesMap = {}
    each(stateList, function (state) {
      const visualTypes = VisualMapping.prepareVisualTypes(visualMappings[state])
      visualTypesMap[state] = visualTypes
    })
    return {
      progress: function progress (params, data) {
        let dimIndex

        if (dim != null) {
          dimIndex = data.getDimensionIndex(dim)
        }

        function getVisual (key) {
          return getItemVisualFromData(data, dataIndex, key)
        }

        function setVisual (key, value) {
          setItemVisualFromData(data, dataIndex, key, value)
        }

        let dataIndex
        const store = data.getStore()

        while ((dataIndex = params.next()) != null) {
          const rawDataItem = data.getRawDataItem(dataIndex) // Consider performance
          // @ts-ignore

          if (rawDataItem && rawDataItem.visualMap === false) {
            continue
          }

          const value = dim != null ? store.get(dimIndex, dataIndex) : dataIndex
          const valueState = getValueState(value)
          const mappings = visualMappings[valueState]
          const visualTypes = visualTypesMap[valueState]

          for (let i = 0, len = visualTypes.length; i < len; i++) {
            const type = visualTypes[i]
            mappings[type] && mappings[type].applyVisual(value, getVisual, setVisual)
          }
        }
      }
    }
  }

  function makeBrushCommonSelectorForSeries (area) {
    const brushType = area.brushType // Do not use function binding or curry for performance.

    var selectors = {
      point: function (itemLayout) {
        return selector[brushType].point(itemLayout, selectors, area)
      },
      rect: function (itemLayout) {
        return selector[brushType].rect(itemLayout, selectors, area)
      }
    }
    return selectors
  }
  var selector = {
    lineX: getLineSelectors(0),
    lineY: getLineSelectors(1),
    rect: {
      point: function (itemLayout, selectors, area) {
        return itemLayout && area.boundingRect.contain(itemLayout[0], itemLayout[1])
      },
      rect: function (itemLayout, selectors, area) {
        return itemLayout && area.boundingRect.intersect(itemLayout)
      }
    },
    polygon: {
      point: function (itemLayout, selectors, area) {
        return itemLayout && area.boundingRect.contain(itemLayout[0], itemLayout[1]) && contain$2(area.range, itemLayout[0], itemLayout[1])
      },
      rect: function (itemLayout, selectors, area) {
        const points = area.range

        if (!itemLayout || points.length <= 1) {
          return false
        }

        const x = itemLayout.x
        const y = itemLayout.y
        const width = itemLayout.width
        const height = itemLayout.height
        const p = points[0]

        if (contain$2(points, x, y) || contain$2(points, x + width, y) || contain$2(points, x, y + height) || contain$2(points, x + width, y + height) || BoundingRect.create(itemLayout).contain(p[0], p[1]) || linePolygonIntersect(x, y, x + width, y, points) || linePolygonIntersect(x, y, x, y + height, points) || linePolygonIntersect(x + width, y, x + width, y + height, points) || linePolygonIntersect(x, y + height, x + width, y + height, points)) {
          return true
        }
      }
    }
  }

  function getLineSelectors (xyIndex) {
    const xy = ['x', 'y']
    const wh = ['width', 'height']
    return {
      point: function (itemLayout, selectors, area) {
        if (itemLayout) {
          const range = area.range
          const p = itemLayout[xyIndex]
          return inLineRange(p, range)
        }
      },
      rect: function (itemLayout, selectors, area) {
        if (itemLayout) {
          const range = area.range
          const layoutRange = [itemLayout[xy[xyIndex]], itemLayout[xy[xyIndex]] + itemLayout[wh[xyIndex]]]
          layoutRange[1] < layoutRange[0] && layoutRange.reverse()
          return inLineRange(layoutRange[0], range) || inLineRange(layoutRange[1], range) || inLineRange(range[0], layoutRange) || inLineRange(range[1], layoutRange)
        }
      }
    }
  }

  function inLineRange (p, range) {
    return range[0] <= p && p <= range[1]
  }

  const STATE_LIST = ['inBrush', 'outOfBrush']
  const DISPATCH_METHOD = '__ecBrushSelect'
  const DISPATCH_FLAG = '__ecInBrushSelectEvent'
  function layoutCovers (ecModel) {
    ecModel.eachComponent({
      mainType: 'brush'
    }, function (brushModel) {
      const brushTargetManager = brushModel.brushTargetManager = new BrushTargetManager(brushModel.option, ecModel)
      brushTargetManager.setInputRanges(brushModel.areas, ecModel)
    })
  }
  /**
     * Register the visual encoding if this modules required.
     */

  function brushVisual (ecModel, api, payload) {
    const brushSelected = []
    let throttleType
    let throttleDelay
    ecModel.eachComponent({
      mainType: 'brush'
    }, function (brushModel) {
      payload && payload.type === 'takeGlobalCursor' && brushModel.setBrushOption(payload.key === 'brush'
        ? payload.brushOption
        : {
            brushType: false
          })
    })
    layoutCovers(ecModel)
    ecModel.eachComponent({
      mainType: 'brush'
    }, function (brushModel, brushIndex) {
      const thisBrushSelected = {
        brushId: brushModel.id,
        brushIndex: brushIndex,
        brushName: brushModel.name,
        areas: clone(brushModel.areas),
        selected: []
      } // Every brush component exists in event params, convenient
      // for user to find by index.

      brushSelected.push(thisBrushSelected)
      const brushOption = brushModel.option
      const brushLink = brushOption.brushLink
      const linkedSeriesMap = []
      const selectedDataIndexForLink = []
      const rangeInfoBySeries = []
      let hasBrushExists = false

      if (!brushIndex) {
        // Only the first throttle setting works.
        throttleType = brushOption.throttleType
        throttleDelay = brushOption.throttleDelay
      } // Add boundingRect and selectors to range.

      const areas = map(brushModel.areas, function (area) {
        const builder = boundingRectBuilders[area.brushType]
        const selectableArea = defaults({
          boundingRect: builder ? builder(area) : void 0
        }, area)
        selectableArea.selectors = makeBrushCommonSelectorForSeries(selectableArea)
        return selectableArea
      })
      const visualMappings = createVisualMappings(brushModel.option, STATE_LIST, function (mappingOption) {
        mappingOption.mappingMethod = 'fixed'
      })
      isArray(brushLink) && each(brushLink, function (seriesIndex) {
        linkedSeriesMap[seriesIndex] = 1
      })

      function linkOthers (seriesIndex) {
        return brushLink === 'all' || !!linkedSeriesMap[seriesIndex]
      } // If no supported brush or no brush on the series,
      // all visuals should be in original state.

      function brushed (rangeInfoList) {
        return !!rangeInfoList.length
      }
      /**
         * Logic for each series: (If the logic has to be modified one day, do it carefully!)
         *
         * ( brushed ┬ && ┬hasBrushExist ┬ && linkOthers  ) => StepA: ┬record, ┬ StepB: ┬visualByRecord.
         *   !brushed┘    ├hasBrushExist ┤                            └nothing,┘        ├visualByRecord.
         *                └!hasBrushExist┘                                              └nothing.
         * ( !brushed  && ┬hasBrushExist ┬ && linkOthers  ) => StepA:  nothing,  StepB: ┬visualByRecord.
         *                └!hasBrushExist┘                                              └nothing.
         * ( brushed ┬ &&                     !linkOthers ) => StepA:  nothing,  StepB: ┬visualByCheck.
         *   !brushed┘                                                                  └nothing.
         * ( !brushed  &&                     !linkOthers ) => StepA:  nothing,  StepB:  nothing.
         */
      // Step A

      ecModel.eachSeries(function (seriesModel, seriesIndex) {
        const rangeInfoList = rangeInfoBySeries[seriesIndex] = []
        seriesModel.subType === 'parallel' ? stepAParallel(seriesModel, seriesIndex) : stepAOthers(seriesModel, seriesIndex, rangeInfoList)
      })

      function stepAParallel (seriesModel, seriesIndex) {
        const coordSys = seriesModel.coordinateSystem
        hasBrushExists = hasBrushExists || coordSys.hasAxisBrushed()
        linkOthers(seriesIndex) && coordSys.eachActiveState(seriesModel.getData(), function (activeState, dataIndex) {
          activeState === 'active' && (selectedDataIndexForLink[dataIndex] = 1)
        })
      }

      function stepAOthers (seriesModel, seriesIndex, rangeInfoList) {
        if (!seriesModel.brushSelector || brushModelNotControll(brushModel, seriesIndex)) {
          return
        }

        each(areas, function (area) {
          if (brushModel.brushTargetManager.controlSeries(area, seriesModel, ecModel)) {
            rangeInfoList.push(area)
          }

          hasBrushExists = hasBrushExists || brushed(rangeInfoList)
        })

        if (linkOthers(seriesIndex) && brushed(rangeInfoList)) {
          const data_1 = seriesModel.getData()
          data_1.each(function (dataIndex) {
            if (checkInRange(seriesModel, rangeInfoList, data_1, dataIndex)) {
              selectedDataIndexForLink[dataIndex] = 1
            }
          })
        }
      } // Step B

      ecModel.eachSeries(function (seriesModel, seriesIndex) {
        const seriesBrushSelected = {
          seriesId: seriesModel.id,
          seriesIndex: seriesIndex,
          seriesName: seriesModel.name,
          dataIndex: []
        } // Every series exists in event params, convenient
        // for user to find series by seriesIndex.

        thisBrushSelected.selected.push(seriesBrushSelected)
        const rangeInfoList = rangeInfoBySeries[seriesIndex]
        const data = seriesModel.getData()
        const getValueState = linkOthers(seriesIndex)
          ? function (dataIndex) {
            return selectedDataIndexForLink[dataIndex] ? (seriesBrushSelected.dataIndex.push(data.getRawIndex(dataIndex)), 'inBrush') : 'outOfBrush'
          }
          : function (dataIndex) {
            return checkInRange(seriesModel, rangeInfoList, data, dataIndex) ? (seriesBrushSelected.dataIndex.push(data.getRawIndex(dataIndex)), 'inBrush') : 'outOfBrush'
          }; // If no supported brush or no brush, all visuals are in original state.

        (linkOthers(seriesIndex) ? hasBrushExists : brushed(rangeInfoList)) && applyVisual(STATE_LIST, visualMappings, data, getValueState)
      })
    })
    dispatchAction(api, throttleType, throttleDelay, brushSelected, payload)
  }

  function dispatchAction (api, throttleType, throttleDelay, brushSelected, payload) {
    // This event will not be triggered when `setOpion`, otherwise dead lock may
    // triggered when do `setOption` in event listener, which we do not find
    // satisfactory way to solve yet. Some considered resolutions:
    // (a) Diff with prevoius selected data ant only trigger event when changed.
    // But store previous data and diff precisely (i.e., not only by dataIndex, but
    // also detect value changes in selected data) might bring complexity or fragility.
    // (b) Use spectial param like `silent` to suppress event triggering.
    // But such kind of volatile param may be weird in `setOption`.
    if (!payload) {
      return
    }

    const zr = api.getZr()

    if (zr[DISPATCH_FLAG]) {
      return
    }

    if (!zr[DISPATCH_METHOD]) {
      zr[DISPATCH_METHOD] = doDispatch
    }

    const fn = createOrUpdate(zr, DISPATCH_METHOD, throttleDelay, throttleType)
    fn(api, brushSelected)
  }

  function doDispatch (api, brushSelected) {
    if (!api.isDisposed()) {
      const zr = api.getZr()
      zr[DISPATCH_FLAG] = true
      api.dispatchAction({
        type: 'brushSelect',
        batch: brushSelected
      })
      zr[DISPATCH_FLAG] = false
    }
  }

  function checkInRange (seriesModel, rangeInfoList, data, dataIndex) {
    for (let i = 0, len = rangeInfoList.length; i < len; i++) {
      const area = rangeInfoList[i]

      if (seriesModel.brushSelector(dataIndex, data, area.selectors, area)) {
        return true
      }
    }
  }

  function brushModelNotControll (brushModel, seriesIndex) {
    const seriesIndices = brushModel.option.seriesIndex
    return seriesIndices != null && seriesIndices !== 'all' && (isArray(seriesIndices) ? indexOf(seriesIndices, seriesIndex) < 0 : seriesIndex !== seriesIndices)
  }

  var boundingRectBuilders = {
    rect: function (area) {
      return getBoundingRectFromMinMax(area.range)
    },
    polygon: function (area) {
      let minMax
      const range = area.range

      for (let i = 0, len = range.length; i < len; i++) {
        minMax = minMax || [[Infinity, -Infinity], [Infinity, -Infinity]]
        const rg = range[i]
        rg[0] < minMax[0][0] && (minMax[0][0] = rg[0])
        rg[0] > minMax[0][1] && (minMax[0][1] = rg[0])
        rg[1] < minMax[1][0] && (minMax[1][0] = rg[1])
        rg[1] > minMax[1][1] && (minMax[1][1] = rg[1])
      }

      return minMax && getBoundingRectFromMinMax(minMax)
    }
  }

  function getBoundingRectFromMinMax (minMax) {
    return new BoundingRect(minMax[0][0], minMax[1][0], minMax[0][1] - minMax[0][0], minMax[1][1] - minMax[1][0])
  }

  const BrushView =
    /** @class */
    (function (_super) {
      __extends(BrushView, _super)

      function BrushView () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = BrushView.type
        return _this
      }

      BrushView.prototype.init = function (ecModel, api) {
        this.ecModel = ecModel
        this.api = api
        this.model;
        (this._brushController = new BrushController(api.getZr())).on('brush', bind(this._onBrush, this)).mount()
      }

      BrushView.prototype.render = function (brushModel, ecModel, api, payload) {
        this.model = brushModel

        this._updateController(brushModel, ecModel, api, payload)
      }

      BrushView.prototype.updateTransform = function (brushModel, ecModel, api, payload) {
        // PENDING: `updateTransform` is a little tricky, whose layout need
        // to be calculate mandatorily and other stages will not be performed.
        // Take care the correctness of the logic. See #11754 .
        layoutCovers(ecModel)

        this._updateController(brushModel, ecModel, api, payload)
      }

      BrushView.prototype.updateVisual = function (brushModel, ecModel, api, payload) {
        this.updateTransform(brushModel, ecModel, api, payload)
      }

      BrushView.prototype.updateView = function (brushModel, ecModel, api, payload) {
        this._updateController(brushModel, ecModel, api, payload)
      }

      BrushView.prototype._updateController = function (brushModel, ecModel, api, payload) {
        // Do not update controller when drawing.
        (!payload || payload.$from !== brushModel.id) && this._brushController.setPanels(brushModel.brushTargetManager.makePanelOpts(api)).enableBrush(brushModel.brushOption).updateCovers(brushModel.areas.slice())
      } // updateLayout: updateController,
      // updateVisual: updateController,

      BrushView.prototype.dispose = function () {
        this._brushController.dispose()
      }

      BrushView.prototype._onBrush = function (eventParam) {
        const modelId = this.model.id
        const areas = this.model.brushTargetManager.setOutputRanges(eventParam.areas, this.ecModel); // Action is not dispatched on drag end, because the drag end
        // emits the same params with the last drag move event, and
        // may have some delay when using touch pad, which makes
        // animation not smooth (when using debounce).

        (!eventParam.isEnd || eventParam.removeOnClick) && this.api.dispatchAction({
          type: 'brush',
          brushId: modelId,
          areas: clone(areas),
          $from: modelId
        })
        eventParam.isEnd && this.api.dispatchAction({
          type: 'brushEnd',
          brushId: modelId,
          areas: clone(areas),
          $from: modelId
        })
      }

      BrushView.type = 'brush'
      return BrushView
    }(ComponentView))

  const DEFAULT_OUT_OF_BRUSH_COLOR = '#ddd'

  const BrushModel =
    /** @class */
    (function (_super) {
      __extends(BrushModel, _super)

      function BrushModel () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = BrushModel.type
        /**
         * @readOnly
         */

        _this.areas = []
        /**
         * Current brush painting area settings.
         * @readOnly
         */

        _this.brushOption = {}
        return _this
      }

      BrushModel.prototype.optionUpdated = function (newOption, isInit) {
        const thisOption = this.option
        !isInit && replaceVisualOption(thisOption, newOption, ['inBrush', 'outOfBrush'])
        const inBrush = thisOption.inBrush = thisOption.inBrush || {} // Always give default visual, consider setOption at the second time.

        thisOption.outOfBrush = thisOption.outOfBrush || {
          color: DEFAULT_OUT_OF_BRUSH_COLOR
        }

        if (!inBrush.hasOwnProperty('liftZ')) {
          // Bigger than the highlight z lift, otherwise it will
          // be effected by the highlight z when brush.
          inBrush.liftZ = 5
        }
      }
      /**
       * If `areas` is null/undefined, range state remain.
       */

      BrushModel.prototype.setAreas = function (areas) {
        if ('development' !== 'production') {
          assert(isArray(areas))
          each(areas, function (area) {
            assert(area.brushType, 'Illegal areas')
          })
        } // If areas is null/undefined, range state remain.
        // This helps user to dispatchAction({type: 'brush'}) with no areas
        // set but just want to get the current brush select info from a `brush` event.

        if (!areas) {
          return
        }

        this.areas = map(areas, function (area) {
          return generateBrushOption(this.option, area)
        }, this)
      }
      /**
       * Set the current painting brush option.
       */

      BrushModel.prototype.setBrushOption = function (brushOption) {
        this.brushOption = generateBrushOption(this.option, brushOption)
        this.brushType = this.brushOption.brushType
      }

      BrushModel.type = 'brush'
      BrushModel.dependencies = ['geo', 'grid', 'xAxis', 'yAxis', 'parallel', 'series']
      BrushModel.defaultOption = {
        seriesIndex: 'all',
        brushType: 'rect',
        brushMode: 'single',
        transformable: true,
        brushStyle: {
          borderWidth: 1,
          color: 'rgba(210,219,238,0.3)',
          borderColor: '#D2DBEE'
        },
        throttleType: 'fixRate',
        throttleDelay: 0,
        removeOnClick: true,
        z: 10000
      }
      return BrushModel
    }(ComponentModel))

  function generateBrushOption (option, brushOption) {
    return merge({
      brushType: option.brushType,
      brushMode: option.brushMode,
      transformable: option.transformable,
      brushStyle: new Model(option.brushStyle).getItemStyle(),
      removeOnClick: option.removeOnClick,
      z: option.z
    }, brushOption, true)
  }

  const ICON_TYPES = ['rect', 'polygon', 'lineX', 'lineY', 'keep', 'clear']

  const BrushFeature =
    /** @class */
    (function (_super) {
      __extends(BrushFeature, _super)

      function BrushFeature () {
        return _super !== null && _super.apply(this, arguments) || this
      }

      BrushFeature.prototype.render = function (featureModel, ecModel, api) {
        let brushType
        let brushMode
        let isBrushed
        ecModel.eachComponent({
          mainType: 'brush'
        }, function (brushModel) {
          brushType = brushModel.brushType
          brushMode = brushModel.brushOption.brushMode || 'single'
          isBrushed = isBrushed || !!brushModel.areas.length
        })
        this._brushType = brushType
        this._brushMode = brushMode
        each(featureModel.get('type', true), function (type) {
          featureModel.setIconStatus(type, (type === 'keep' ? brushMode === 'multiple' : type === 'clear' ? isBrushed : type === brushType) ? 'emphasis' : 'normal')
        })
      }

      BrushFeature.prototype.updateView = function (featureModel, ecModel, api) {
        this.render(featureModel, ecModel, api)
      }

      BrushFeature.prototype.getIcons = function () {
        const model = this.model
        const availableIcons = model.get('icon', true)
        const icons = {}
        each(model.get('type', true), function (type) {
          if (availableIcons[type]) {
            icons[type] = availableIcons[type]
          }
        })
        return icons
      }

      BrushFeature.prototype.onclick = function (ecModel, api, type) {
        const brushType = this._brushType
        const brushMode = this._brushMode

        if (type === 'clear') {
          // Trigger parallel action firstly
          api.dispatchAction({
            type: 'axisAreaSelect',
            intervals: []
          })
          api.dispatchAction({
            type: 'brush',
            command: 'clear',
            // Clear all areas of all brush components.
            areas: []
          })
        } else {
          api.dispatchAction({
            type: 'takeGlobalCursor',
            key: 'brush',
            brushOption: {
              brushType: type === 'keep' ? brushType : brushType === type ? false : type,
              brushMode: type === 'keep' ? brushMode === 'multiple' ? 'single' : 'multiple' : brushMode
            }
          })
        }
      }

      BrushFeature.getDefaultOption = function (ecModel) {
        const defaultOption = {
          show: true,
          type: ICON_TYPES.slice(),
          icon: {
            /* eslint-disable */
            rect: 'M7.3,34.7 M0.4,10V-0.2h9.8 M89.6,10V-0.2h-9.8 M0.4,60v10.2h9.8 M89.6,60v10.2h-9.8 M12.3,22.4V10.5h13.1 M33.6,10.5h7.8 M49.1,10.5h7.8 M77.5,22.4V10.5h-13 M12.3,31.1v8.2 M77.7,31.1v8.2 M12.3,47.6v11.9h13.1 M33.6,59.5h7.6 M49.1,59.5 h7.7 M77.5,47.6v11.9h-13',
            polygon: 'M55.2,34.9c1.7,0,3.1,1.4,3.1,3.1s-1.4,3.1-3.1,3.1 s-3.1-1.4-3.1-3.1S53.5,34.9,55.2,34.9z M50.4,51c1.7,0,3.1,1.4,3.1,3.1c0,1.7-1.4,3.1-3.1,3.1c-1.7,0-3.1-1.4-3.1-3.1 C47.3,52.4,48.7,51,50.4,51z M55.6,37.1l1.5-7.8 M60.1,13.5l1.6-8.7l-7.8,4 M59,19l-1,5.3 M24,16.1l6.4,4.9l6.4-3.3 M48.5,11.6 l-5.9,3.1 M19.1,12.8L9.7,5.1l1.1,7.7 M13.4,29.8l1,7.3l6.6,1.6 M11.6,18.4l1,6.1 M32.8,41.9 M26.6,40.4 M27.3,40.2l6.1,1.6 M49.9,52.1l-5.6-7.6l-4.9-1.2',
            lineX: 'M15.2,30 M19.7,15.6V1.9H29 M34.8,1.9H40.4 M55.3,15.6V1.9H45.9 M19.7,44.4V58.1H29 M34.8,58.1H40.4 M55.3,44.4 V58.1H45.9 M12.5,20.3l-9.4,9.6l9.6,9.8 M3.1,29.9h16.5 M62.5,20.3l9.4,9.6L62.3,39.7 M71.9,29.9H55.4',
            lineY: 'M38.8,7.7 M52.7,12h13.2v9 M65.9,26.6V32 M52.7,46.3h13.2v-9 M24.9,12H11.8v9 M11.8,26.6V32 M24.9,46.3H11.8v-9 M48.2,5.1l-9.3-9l-9.4,9.2 M38.9-3.9V12 M48.2,53.3l-9.3,9l-9.4-9.2 M38.9,62.3V46.4',
            keep: 'M4,10.5V1h10.3 M20.7,1h6.1 M33,1h6.1 M55.4,10.5V1H45.2 M4,17.3v6.6 M55.6,17.3v6.6 M4,30.5V40h10.3 M20.7,40 h6.1 M33,40h6.1 M55.4,30.5V40H45.2 M21,18.9h62.9v48.6H21V18.9z',
            clear: 'M22,14.7l30.9,31 M52.9,14.7L22,45.7 M4.7,16.8V4.2h13.1 M26,4.2h7.8 M41.6,4.2h7.8 M70.3,16.8V4.2H57.2 M4.7,25.9v8.6 M70.3,25.9v8.6 M4.7,43.2v12.6h13.1 M26,55.8h7.8 M41.6,55.8h7.8 M70.3,43.2v12.6H57.2' // jshint ignore:line

            /* eslint-enable */

          },
          // `rect`, `polygon`, `lineX`, `lineY`, `keep`, `clear`
          title: ecModel.getLocaleModel().get(['toolbox', 'brush', 'title'])
        }
        return defaultOption
      }

      return BrushFeature
    }(ToolboxFeature))

  function install$B (registers) {
    registers.registerComponentView(BrushView)
    registers.registerComponentModel(BrushModel)
    registers.registerPreprocessor(brushPreprocessor)
    registers.registerVisual(registers.PRIORITY.VISUAL.BRUSH, brushVisual)
    registers.registerAction({
      type: 'brush',
      event: 'brush',
      update: 'updateVisual'
    }, function (payload, ecModel) {
      ecModel.eachComponent({
        mainType: 'brush',
        query: payload
      }, function (brushModel) {
        brushModel.setAreas(payload.areas)
      })
    })
    /**
       * payload: {
       *      brushComponents: [
       *          {
       *              brushId,
       *              brushIndex,
       *              brushName,
       *              series: [
       *                  {
       *                      seriesId,
       *                      seriesIndex,
       *                      seriesName,
       *                      rawIndices: [21, 34, ...]
       *                  },
       *                  ...
       *              ]
       *          },
       *          ...
       *      ]
       * }
       */

    registers.registerAction({
      type: 'brushSelect',
      event: 'brushSelected',
      update: 'none'
    }, noop)
    registers.registerAction({
      type: 'brushEnd',
      event: 'brushEnd',
      update: 'none'
    }, noop)
    registerFeature('brush', BrushFeature)
  }

  const TitleModel =
    /** @class */
    (function (_super) {
      __extends(TitleModel, _super)

      function TitleModel () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = TitleModel.type
        _this.layoutMode = {
          type: 'box',
          ignoreSize: true
        }
        return _this
      }

      TitleModel.type = 'title'
      TitleModel.defaultOption = {
        // zlevel: 0,
        z: 6,
        show: true,
        text: '',
        target: 'blank',
        subtext: '',
        subtarget: 'blank',
        left: 0,
        top: 0,
        backgroundColor: 'rgba(0,0,0,0)',
        borderColor: '#ccc',
        borderWidth: 0,
        padding: 5,
        itemGap: 10,
        textStyle: {
          fontSize: 18,
          fontWeight: 'bold',
          color: '#464646'
        },
        subtextStyle: {
          fontSize: 12,
          color: '#6E7079'
        }
      }
      return TitleModel
    }(ComponentModel)) // View

  const TitleView =
    /** @class */
    (function (_super) {
      __extends(TitleView, _super)

      function TitleView () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = TitleView.type
        return _this
      }

      TitleView.prototype.render = function (titleModel, ecModel, api) {
        this.group.removeAll()

        if (!titleModel.get('show')) {
          return
        }

        const group = this.group
        const textStyleModel = titleModel.getModel('textStyle')
        const subtextStyleModel = titleModel.getModel('subtextStyle')
        let textAlign = titleModel.get('textAlign')
        let textVerticalAlign = retrieve2(titleModel.get('textBaseline'), titleModel.get('textVerticalAlign'))
        const textEl = new ZRText({
          style: createTextStyle(textStyleModel, {
            text: titleModel.get('text'),
            fill: textStyleModel.getTextColor()
          }, {
            disableBox: true
          }),
          z2: 10
        })
        const textRect = textEl.getBoundingRect()
        const subText = titleModel.get('subtext')
        const subTextEl = new ZRText({
          style: createTextStyle(subtextStyleModel, {
            text: subText,
            fill: subtextStyleModel.getTextColor(),
            y: textRect.height + titleModel.get('itemGap'),
            verticalAlign: 'top'
          }, {
            disableBox: true
          }),
          z2: 10
        })
        const link = titleModel.get('link')
        const sublink = titleModel.get('sublink')
        const triggerEvent = titleModel.get('triggerEvent', true)
        textEl.silent = !link && !triggerEvent
        subTextEl.silent = !sublink && !triggerEvent

        if (link) {
          textEl.on('click', function () {
            windowOpen(link, '_' + titleModel.get('target'))
          })
        }

        if (sublink) {
          subTextEl.on('click', function () {
            windowOpen(sublink, '_' + titleModel.get('subtarget'))
          })
        }

        getECData(textEl).eventData = getECData(subTextEl).eventData = triggerEvent
          ? {
              componentType: 'title',
              componentIndex: titleModel.componentIndex
            }
          : null
        group.add(textEl)
        subText && group.add(subTextEl) // If no subText, but add subTextEl, there will be an empty line.

        let groupRect = group.getBoundingRect()
        const layoutOption = titleModel.getBoxLayoutParams()
        layoutOption.width = groupRect.width
        layoutOption.height = groupRect.height
        const layoutRect = getLayoutRect(layoutOption, {
          width: api.getWidth(),
          height: api.getHeight()
        }, titleModel.get('padding')) // Adjust text align based on position

        if (!textAlign) {
          // Align left if title is on the left. center and right is same
          textAlign = titleModel.get('left') || titleModel.get('right') // @ts-ignore

          if (textAlign === 'middle') {
            textAlign = 'center'
          } // Adjust layout by text align

          if (textAlign === 'right') {
            layoutRect.x += layoutRect.width
          } else if (textAlign === 'center') {
            layoutRect.x += layoutRect.width / 2
          }
        }

        if (!textVerticalAlign) {
          textVerticalAlign = titleModel.get('top') || titleModel.get('bottom') // @ts-ignore

          if (textVerticalAlign === 'center') {
            textVerticalAlign = 'middle'
          }

          if (textVerticalAlign === 'bottom') {
            layoutRect.y += layoutRect.height
          } else if (textVerticalAlign === 'middle') {
            layoutRect.y += layoutRect.height / 2
          }

          textVerticalAlign = textVerticalAlign || 'top'
        }

        group.x = layoutRect.x
        group.y = layoutRect.y
        group.markRedraw()
        const alignStyle = {
          align: textAlign,
          verticalAlign: textVerticalAlign
        }
        textEl.setStyle(alignStyle)
        subTextEl.setStyle(alignStyle) // Render background
        // Get groupRect again because textAlign has been changed

        groupRect = group.getBoundingRect()
        const padding = layoutRect.margin
        const style = titleModel.getItemStyle(['color', 'opacity'])
        style.fill = titleModel.get('backgroundColor')
        const rect = new Rect({
          shape: {
            x: groupRect.x - padding[3],
            y: groupRect.y - padding[0],
            width: groupRect.width + padding[1] + padding[3],
            height: groupRect.height + padding[0] + padding[2],
            r: titleModel.get('borderRadius')
          },
          style: style,
          subPixelOptimize: true,
          silent: true
        })
        group.add(rect)
      }

      TitleView.type = 'title'
      return TitleView
    }(ComponentView))

  function install$C (registers) {
    registers.registerComponentModel(TitleModel)
    registers.registerComponentView(TitleView)
  }

  const TimelineModel =
    /** @class */
    (function (_super) {
      __extends(TimelineModel, _super)

      function TimelineModel () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = TimelineModel.type
        _this.layoutMode = 'box'
        return _this
      }
      /**
       * @override
       */

      TimelineModel.prototype.init = function (option, parentModel, ecModel) {
        this.mergeDefaultAndTheme(option, ecModel)

        this._initData()
      }
      /**
       * @override
       */

      TimelineModel.prototype.mergeOption = function (option) {
        _super.prototype.mergeOption.apply(this, arguments)

        this._initData()
      }

      TimelineModel.prototype.setCurrentIndex = function (currentIndex) {
        if (currentIndex == null) {
          currentIndex = this.option.currentIndex
        }

        const count = this._data.count()

        if (this.option.loop) {
          currentIndex = (currentIndex % count + count) % count
        } else {
          currentIndex >= count && (currentIndex = count - 1)
          currentIndex < 0 && (currentIndex = 0)
        }

        this.option.currentIndex = currentIndex
      }
      /**
       * @return {number} currentIndex
       */

      TimelineModel.prototype.getCurrentIndex = function () {
        return this.option.currentIndex
      }
      /**
       * @return {boolean}
       */

      TimelineModel.prototype.isIndexMax = function () {
        return this.getCurrentIndex() >= this._data.count() - 1
      }
      /**
       * @param {boolean} state true: play, false: stop
       */

      TimelineModel.prototype.setPlayState = function (state) {
        this.option.autoPlay = !!state
      }
      /**
       * @return {boolean} true: play, false: stop
       */

      TimelineModel.prototype.getPlayState = function () {
        return !!this.option.autoPlay
      }
      /**
       * @private
       */

      TimelineModel.prototype._initData = function () {
        const thisOption = this.option
        const dataArr = thisOption.data || []
        const axisType = thisOption.axisType
        const names = this._names = []
        let processedDataArr

        if (axisType === 'category') {
          processedDataArr = []
          each(dataArr, function (item, index) {
            const value = convertOptionIdName(getDataItemValue(item), '')
            let newItem

            if (isObject(item)) {
              newItem = clone(item)
              newItem.value = index
            } else {
              newItem = index
            }

            processedDataArr.push(newItem)
            names.push(value)
          })
        } else {
          processedDataArr = dataArr
        }

        const dimType = {
          category: 'ordinal',
          time: 'time',
          value: 'number'
        }[axisType] || 'number'
        const data = this._data = new SeriesData([{
          name: 'value',
          type: dimType
        }], this)
        data.initData(processedDataArr, names)
      }

      TimelineModel.prototype.getData = function () {
        return this._data
      }
      /**
       * @public
       * @return {Array.<string>} categoreis
       */

      TimelineModel.prototype.getCategories = function () {
        if (this.get('axisType') === 'category') {
          return this._names.slice()
        }
      }

      TimelineModel.type = 'timeline'
      /**
       * @protected
       */

      TimelineModel.defaultOption = {
        // zlevel: 0,                  // 一级层叠
        z: 4,
        show: true,
        axisType: 'time',
        realtime: true,
        left: '20%',
        top: null,
        right: '20%',
        bottom: 0,
        width: null,
        height: 40,
        padding: 5,
        controlPosition: 'left',
        autoPlay: false,
        rewind: false,
        loop: true,
        playInterval: 2000,
        currentIndex: 0,
        itemStyle: {},
        label: {
          color: '#000'
        },
        data: []
      }
      return TimelineModel
    }(ComponentModel))

  const SliderTimelineModel =
    /** @class */
    (function (_super) {
      __extends(SliderTimelineModel, _super)

      function SliderTimelineModel () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = SliderTimelineModel.type
        return _this
      }

      SliderTimelineModel.type = 'timeline.slider'
      /**
       * @protected
       */

      SliderTimelineModel.defaultOption = inheritDefaultOption(TimelineModel.defaultOption, {
        backgroundColor: 'rgba(0,0,0,0)',
        borderColor: '#ccc',
        borderWidth: 0,
        orient: 'horizontal',
        inverse: false,
        tooltip: {
          trigger: 'item' // data item may also have tootip attr.

        },
        symbol: 'circle',
        symbolSize: 12,
        lineStyle: {
          show: true,
          width: 2,
          color: '#DAE1F5'
        },
        label: {
          position: 'auto',
          // When using number, label position is not
          // restricted by viewRect.
          // positive: right/bottom, negative: left/top
          show: true,
          interval: 'auto',
          rotate: 0,
          // formatter: null,
          // 其余属性默认使用全局文本样式，详见TEXTSTYLE
          color: '#A4B1D7'
        },
        itemStyle: {
          color: '#A4B1D7',
          borderWidth: 1
        },
        checkpointStyle: {
          symbol: 'circle',
          symbolSize: 15,
          color: '#316bf3',
          borderColor: '#fff',
          borderWidth: 2,
          shadowBlur: 2,
          shadowOffsetX: 1,
          shadowOffsetY: 1,
          shadowColor: 'rgba(0, 0, 0, 0.3)',
          // borderColor: 'rgba(194,53,49, 0.5)',
          animation: true,
          animationDuration: 300,
          animationEasing: 'quinticInOut'
        },
        controlStyle: {
          show: true,
          showPlayBtn: true,
          showPrevBtn: true,
          showNextBtn: true,
          itemSize: 24,
          itemGap: 12,
          position: 'left',
          playIcon: 'path://M31.6,53C17.5,53,6,41.5,6,27.4S17.5,1.8,31.6,1.8C45.7,1.8,57.2,13.3,57.2,27.4S45.7,53,31.6,53z M31.6,3.3 C18.4,3.3,7.5,14.1,7.5,27.4c0,13.3,10.8,24.1,24.1,24.1C44.9,51.5,55.7,40.7,55.7,27.4C55.7,14.1,44.9,3.3,31.6,3.3z M24.9,21.3 c0-2.2,1.6-3.1,3.5-2l10.5,6.1c1.899,1.1,1.899,2.9,0,4l-10.5,6.1c-1.9,1.1-3.5,0.2-3.5-2V21.3z',
          stopIcon: 'path://M30.9,53.2C16.8,53.2,5.3,41.7,5.3,27.6S16.8,2,30.9,2C45,2,56.4,13.5,56.4,27.6S45,53.2,30.9,53.2z M30.9,3.5C17.6,3.5,6.8,14.4,6.8,27.6c0,13.3,10.8,24.1,24.101,24.1C44.2,51.7,55,40.9,55,27.6C54.9,14.4,44.1,3.5,30.9,3.5z M36.9,35.8c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H36c0.5,0,0.9,0.4,0.9,1V35.8z M27.8,35.8 c0,0.601-0.4,1-0.9,1h-1.3c-0.5,0-0.9-0.399-0.9-1V19.5c0-0.6,0.4-1,0.9-1H27c0.5,0,0.9,0.4,0.9,1L27.8,35.8L27.8,35.8z',
          // eslint-disable-next-line max-len
          nextIcon: 'M2,18.5A1.52,1.52,0,0,1,.92,18a1.49,1.49,0,0,1,0-2.12L7.81,9.36,1,3.11A1.5,1.5,0,1,1,3,.89l8,7.34a1.48,1.48,0,0,1,.49,1.09,1.51,1.51,0,0,1-.46,1.1L3,18.08A1.5,1.5,0,0,1,2,18.5Z',
          // eslint-disable-next-line max-len
          prevIcon: 'M10,.5A1.52,1.52,0,0,1,11.08,1a1.49,1.49,0,0,1,0,2.12L4.19,9.64,11,15.89a1.5,1.5,0,1,1-2,2.22L1,10.77A1.48,1.48,0,0,1,.5,9.68,1.51,1.51,0,0,1,1,8.58L9,.92A1.5,1.5,0,0,1,10,.5Z',
          prevBtnSize: 18,
          nextBtnSize: 18,
          color: '#A4B1D7',
          borderColor: '#A4B1D7',
          borderWidth: 1
        },
        emphasis: {
          label: {
            show: true,
            // 其余属性默认使用全局文本样式，详见TEXTSTYLE
            color: '#6f778d'
          },
          itemStyle: {
            color: '#316BF3'
          },
          controlStyle: {
            color: '#316BF3',
            borderColor: '#316BF3',
            borderWidth: 2
          }
        },
        progress: {
          lineStyle: {
            color: '#316BF3'
          },
          itemStyle: {
            color: '#316BF3'
          },
          label: {
            color: '#6f778d'
          }
        },
        data: []
      })
      return SliderTimelineModel
    }(TimelineModel))

  mixin(SliderTimelineModel, DataFormatMixin.prototype)

  const TimelineView =
    /** @class */
    (function (_super) {
      __extends(TimelineView, _super)

      function TimelineView () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = TimelineView.type
        return _this
      }

      TimelineView.type = 'timeline'
      return TimelineView
    }(ComponentView))

  /**
     * Extend axis 2d
     */

  const TimelineAxis =
    /** @class */
    (function (_super) {
      __extends(TimelineAxis, _super)

      function TimelineAxis (dim, scale, coordExtent, axisType) {
        const _this = _super.call(this, dim, scale, coordExtent) || this

        _this.type = axisType || 'value'
        return _this
      }
      /**
       * @override
       */

      TimelineAxis.prototype.getLabelModel = function () {
        // Force override
        return this.model.getModel('label')
      }
      /**
       * @override
       */

      TimelineAxis.prototype.isHorizontal = function () {
        return this.model.get('orient') === 'horizontal'
      }

      return TimelineAxis
    }(Axis))

  const PI$8 = Math.PI
  const labelDataIndexStore = makeInner()

  const SliderTimelineView =
    /** @class */
    (function (_super) {
      __extends(SliderTimelineView, _super)

      function SliderTimelineView () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = SliderTimelineView.type
        return _this
      }

      SliderTimelineView.prototype.init = function (ecModel, api) {
        this.api = api
      }
      /**
       * @override
       */

      SliderTimelineView.prototype.render = function (timelineModel, ecModel, api) {
        this.model = timelineModel
        this.api = api
        this.ecModel = ecModel
        this.group.removeAll()

        if (timelineModel.get('show', true)) {
          const layoutInfo_1 = this._layout(timelineModel, api)

          const mainGroup_1 = this._createGroup('_mainGroup')

          const labelGroup = this._createGroup('_labelGroup')

          const axis_1 = this._axis = this._createAxis(layoutInfo_1, timelineModel)

          timelineModel.formatTooltip = function (dataIndex) {
            const name = axis_1.scale.getLabel({
              value: dataIndex
            })
            return createTooltipMarkup('nameValue', {
              noName: true,
              value: name
            })
          }

          each(['AxisLine', 'AxisTick', 'Control', 'CurrentPointer'], function (name) {
            this['_render' + name](layoutInfo_1, mainGroup_1, axis_1, timelineModel)
          }, this)

          this._renderAxisLabel(layoutInfo_1, labelGroup, axis_1, timelineModel)

          this._position(layoutInfo_1, timelineModel)
        }

        this._doPlayStop()

        this._updateTicksStatus()
      }
      /**
       * @override
       */

      SliderTimelineView.prototype.remove = function () {
        this._clearTimer()

        this.group.removeAll()
      }
      /**
       * @override
       */

      SliderTimelineView.prototype.dispose = function () {
        this._clearTimer()
      }

      SliderTimelineView.prototype._layout = function (timelineModel, api) {
        const labelPosOpt = timelineModel.get(['label', 'position'])
        const orient = timelineModel.get('orient')
        const viewRect = getViewRect$5(timelineModel, api)
        let parsedLabelPos // Auto label offset.

        if (labelPosOpt == null || labelPosOpt === 'auto') {
          parsedLabelPos = orient === 'horizontal' ? viewRect.y + viewRect.height / 2 < api.getHeight() / 2 ? '-' : '+' : viewRect.x + viewRect.width / 2 < api.getWidth() / 2 ? '+' : '-'
        } else if (isString(labelPosOpt)) {
          parsedLabelPos = {
            horizontal: {
              top: '-',
              bottom: '+'
            },
            vertical: {
              left: '-',
              right: '+'
            }
          }[orient][labelPosOpt]
        } else {
          // is number
          parsedLabelPos = labelPosOpt
        }

        const labelAlignMap = {
          horizontal: 'center',
          vertical: parsedLabelPos >= 0 || parsedLabelPos === '+' ? 'left' : 'right'
        }
        const labelBaselineMap = {
          horizontal: parsedLabelPos >= 0 || parsedLabelPos === '+' ? 'top' : 'bottom',
          vertical: 'middle'
        }
        const rotationMap = {
          horizontal: 0,
          vertical: PI$8 / 2
        } // Position

        const mainLength = orient === 'vertical' ? viewRect.height : viewRect.width
        const controlModel = timelineModel.getModel('controlStyle')
        const showControl = controlModel.get('show', true)
        const controlSize = showControl ? controlModel.get('itemSize') : 0
        const controlGap = showControl ? controlModel.get('itemGap') : 0
        const sizePlusGap = controlSize + controlGap // Special label rotate.

        let labelRotation = timelineModel.get(['label', 'rotate']) || 0
        labelRotation = labelRotation * PI$8 / 180 // To radian.

        let playPosition
        let prevBtnPosition
        let nextBtnPosition
        const controlPosition = controlModel.get('position', true)
        const showPlayBtn = showControl && controlModel.get('showPlayBtn', true)
        const showPrevBtn = showControl && controlModel.get('showPrevBtn', true)
        const showNextBtn = showControl && controlModel.get('showNextBtn', true)
        let xLeft = 0
        let xRight = mainLength // position[0] means left, position[1] means middle.

        if (controlPosition === 'left' || controlPosition === 'bottom') {
          showPlayBtn && (playPosition = [0, 0], xLeft += sizePlusGap)
          showPrevBtn && (prevBtnPosition = [xLeft, 0], xLeft += sizePlusGap)
          showNextBtn && (nextBtnPosition = [xRight - controlSize, 0], xRight -= sizePlusGap)
        } else {
          // 'top' 'right'
          showPlayBtn && (playPosition = [xRight - controlSize, 0], xRight -= sizePlusGap)
          showPrevBtn && (prevBtnPosition = [0, 0], xLeft += sizePlusGap)
          showNextBtn && (nextBtnPosition = [xRight - controlSize, 0], xRight -= sizePlusGap)
        }

        const axisExtent = [xLeft, xRight]

        if (timelineModel.get('inverse')) {
          axisExtent.reverse()
        }

        return {
          viewRect: viewRect,
          mainLength: mainLength,
          orient: orient,
          rotation: rotationMap[orient],
          labelRotation: labelRotation,
          labelPosOpt: parsedLabelPos,
          labelAlign: timelineModel.get(['label', 'align']) || labelAlignMap[orient],
          labelBaseline: timelineModel.get(['label', 'verticalAlign']) || timelineModel.get(['label', 'baseline']) || labelBaselineMap[orient],
          // Based on mainGroup.
          playPosition: playPosition,
          prevBtnPosition: prevBtnPosition,
          nextBtnPosition: nextBtnPosition,
          axisExtent: axisExtent,
          controlSize: controlSize,
          controlGap: controlGap
        }
      }

      SliderTimelineView.prototype._position = function (layoutInfo, timelineModel) {
        // Position is be called finally, because bounding rect is needed for
        // adapt content to fill viewRect (auto adapt offset).
        // Timeline may be not all in the viewRect when 'offset' is specified
        // as a number, because it is more appropriate that label aligns at
        // 'offset' but not the other edge defined by viewRect.
        const mainGroup = this._mainGroup
        const labelGroup = this._labelGroup
        let viewRect = layoutInfo.viewRect

        if (layoutInfo.orient === 'vertical') {
          // transform to horizontal, inverse rotate by left-top point.
          const m = create$1()
          const rotateOriginX = viewRect.x
          const rotateOriginY = viewRect.y + viewRect.height
          translate(m, m, [-rotateOriginX, -rotateOriginY])
          rotate(m, m, -PI$8 / 2)
          translate(m, m, [rotateOriginX, rotateOriginY])
          viewRect = viewRect.clone()
          viewRect.applyTransform(m)
        }

        const viewBound = getBound(viewRect)
        const mainBound = getBound(mainGroup.getBoundingRect())
        const labelBound = getBound(labelGroup.getBoundingRect())
        const mainPosition = [mainGroup.x, mainGroup.y]
        const labelsPosition = [labelGroup.x, labelGroup.y]
        labelsPosition[0] = mainPosition[0] = viewBound[0][0]
        const labelPosOpt = layoutInfo.labelPosOpt

        if (labelPosOpt == null || isString(labelPosOpt)) {
          // '+' or '-'
          var mainBoundIdx = labelPosOpt === '+' ? 0 : 1
          toBound(mainPosition, mainBound, viewBound, 1, mainBoundIdx)
          toBound(labelsPosition, labelBound, viewBound, 1, 1 - mainBoundIdx)
        } else {
          var mainBoundIdx = labelPosOpt >= 0 ? 0 : 1
          toBound(mainPosition, mainBound, viewBound, 1, mainBoundIdx)
          labelsPosition[1] = mainPosition[1] + labelPosOpt
        }

        mainGroup.setPosition(mainPosition)
        labelGroup.setPosition(labelsPosition)
        mainGroup.rotation = labelGroup.rotation = layoutInfo.rotation
        setOrigin(mainGroup)
        setOrigin(labelGroup)

        function setOrigin (targetGroup) {
          targetGroup.originX = viewBound[0][0] - targetGroup.x
          targetGroup.originY = viewBound[1][0] - targetGroup.y
        }

        function getBound (rect) {
          // [[xmin, xmax], [ymin, ymax]]
          return [[rect.x, rect.x + rect.width], [rect.y, rect.y + rect.height]]
        }

        function toBound (fromPos, from, to, dimIdx, boundIdx) {
          fromPos[dimIdx] += to[dimIdx][boundIdx] - from[dimIdx][boundIdx]
        }
      }

      SliderTimelineView.prototype._createAxis = function (layoutInfo, timelineModel) {
        const data = timelineModel.getData()
        const axisType = timelineModel.get('axisType')
        const scale = createScaleByModel$1(timelineModel, axisType) // Customize scale. The `tickValue` is `dataIndex`.

        scale.getTicks = function () {
          return data.mapArray(['value'], function (value) {
            return {
              value: value
            }
          })
        }

        const dataExtent = data.getDataExtent('value')
        scale.setExtent(dataExtent[0], dataExtent[1])
        scale.calcNiceTicks()
        const axis = new TimelineAxis('value', scale, layoutInfo.axisExtent, axisType)
        axis.model = timelineModel
        return axis
      }

      SliderTimelineView.prototype._createGroup = function (key) {
        const newGroup = this[key] = new Group()
        this.group.add(newGroup)
        return newGroup
      }

      SliderTimelineView.prototype._renderAxisLine = function (layoutInfo, group, axis, timelineModel) {
        const axisExtent = axis.getExtent()

        if (!timelineModel.get(['lineStyle', 'show'])) {
          return
        }

        const line = new Line({
          shape: {
            x1: axisExtent[0],
            y1: 0,
            x2: axisExtent[1],
            y2: 0
          },
          style: extend({
            lineCap: 'round'
          }, timelineModel.getModel('lineStyle').getLineStyle()),
          silent: true,
          z2: 1
        })
        group.add(line)
        const progressLine = this._progressLine = new Line({
          shape: {
            x1: axisExtent[0],
            x2: this._currentPointer ? this._currentPointer.x : axisExtent[0],
            y1: 0,
            y2: 0
          },
          style: defaults({
            lineCap: 'round',
            lineWidth: line.style.lineWidth
          }, timelineModel.getModel(['progress', 'lineStyle']).getLineStyle()),
          silent: true,
          z2: 1
        })
        group.add(progressLine)
      }

      SliderTimelineView.prototype._renderAxisTick = function (layoutInfo, group, axis, timelineModel) {
        const _this = this

        const data = timelineModel.getData() // Show all ticks, despite ignoring strategy.

        const ticks = axis.scale.getTicks()
        this._tickSymbols = [] // The value is dataIndex, see the costomized scale.

        each(ticks, function (tick) {
          const tickCoord = axis.dataToCoord(tick.value)
          const itemModel = data.getItemModel(tick.value)
          const itemStyleModel = itemModel.getModel('itemStyle')
          const hoverStyleModel = itemModel.getModel(['emphasis', 'itemStyle'])
          const progressStyleModel = itemModel.getModel(['progress', 'itemStyle'])
          const symbolOpt = {
            x: tickCoord,
            y: 0,
            onclick: bind(_this._changeTimeline, _this, tick.value)
          }
          const el = giveSymbol(itemModel, itemStyleModel, group, symbolOpt)
          el.ensureState('emphasis').style = hoverStyleModel.getItemStyle()
          el.ensureState('progress').style = progressStyleModel.getItemStyle()
          enableHoverEmphasis(el)
          const ecData = getECData(el)

          if (itemModel.get('tooltip')) {
            ecData.dataIndex = tick.value
            ecData.dataModel = timelineModel
          } else {
            ecData.dataIndex = ecData.dataModel = null
          }

          _this._tickSymbols.push(el)
        })
      }

      SliderTimelineView.prototype._renderAxisLabel = function (layoutInfo, group, axis, timelineModel) {
        const _this = this

        const labelModel = axis.getLabelModel()

        if (!labelModel.get('show')) {
          return
        }

        const data = timelineModel.getData()
        const labels = axis.getViewLabels()
        this._tickLabels = []
        each(labels, function (labelItem) {
          // The tickValue is dataIndex, see the costomized scale.
          const dataIndex = labelItem.tickValue
          const itemModel = data.getItemModel(dataIndex)
          const normalLabelModel = itemModel.getModel('label')
          const hoverLabelModel = itemModel.getModel(['emphasis', 'label'])
          const progressLabelModel = itemModel.getModel(['progress', 'label'])
          const tickCoord = axis.dataToCoord(labelItem.tickValue)
          const textEl = new ZRText({
            x: tickCoord,
            y: 0,
            rotation: layoutInfo.labelRotation - layoutInfo.rotation,
            onclick: bind(_this._changeTimeline, _this, dataIndex),
            silent: false,
            style: createTextStyle(normalLabelModel, {
              text: labelItem.formattedLabel,
              align: layoutInfo.labelAlign,
              verticalAlign: layoutInfo.labelBaseline
            })
          })
          textEl.ensureState('emphasis').style = createTextStyle(hoverLabelModel)
          textEl.ensureState('progress').style = createTextStyle(progressLabelModel)
          group.add(textEl)
          enableHoverEmphasis(textEl)
          labelDataIndexStore(textEl).dataIndex = dataIndex

          _this._tickLabels.push(textEl)
        })
      }

      SliderTimelineView.prototype._renderControl = function (layoutInfo, group, axis, timelineModel) {
        const controlSize = layoutInfo.controlSize
        const rotation = layoutInfo.rotation
        const itemStyle = timelineModel.getModel('controlStyle').getItemStyle()
        const hoverStyle = timelineModel.getModel(['emphasis', 'controlStyle']).getItemStyle()
        const playState = timelineModel.getPlayState()
        const inverse = timelineModel.get('inverse', true)
        makeBtn(layoutInfo.nextBtnPosition, 'next', bind(this._changeTimeline, this, inverse ? '-' : '+'))
        makeBtn(layoutInfo.prevBtnPosition, 'prev', bind(this._changeTimeline, this, inverse ? '+' : '-'))
        makeBtn(layoutInfo.playPosition, playState ? 'stop' : 'play', bind(this._handlePlayClick, this, !playState), true)

        function makeBtn (position, iconName, onclick, willRotate) {
          if (!position) {
            return
          }

          const iconSize = parsePercent(retrieve2(timelineModel.get(['controlStyle', iconName + 'BtnSize']), controlSize), controlSize)
          const rect = [0, -iconSize / 2, iconSize, iconSize]
          const btn = makeControlIcon(timelineModel, iconName + 'Icon', rect, {
            x: position[0],
            y: position[1],
            originX: controlSize / 2,
            originY: 0,
            rotation: willRotate ? -rotation : 0,
            rectHover: true,
            style: itemStyle,
            onclick: onclick
          })
          btn.ensureState('emphasis').style = hoverStyle
          group.add(btn)
          enableHoverEmphasis(btn)
        }
      }

      SliderTimelineView.prototype._renderCurrentPointer = function (layoutInfo, group, axis, timelineModel) {
        const data = timelineModel.getData()
        const currentIndex = timelineModel.getCurrentIndex()
        const pointerModel = data.getItemModel(currentIndex).getModel('checkpointStyle')
        const me = this
        const callback = {
          onCreate: function (pointer) {
            pointer.draggable = true
            pointer.drift = bind(me._handlePointerDrag, me)
            pointer.ondragend = bind(me._handlePointerDragend, me)
            pointerMoveTo(pointer, me._progressLine, currentIndex, axis, timelineModel, true)
          },
          onUpdate: function (pointer) {
            pointerMoveTo(pointer, me._progressLine, currentIndex, axis, timelineModel)
          }
        } // Reuse when exists, for animation and drag.

        this._currentPointer = giveSymbol(pointerModel, pointerModel, this._mainGroup, {}, this._currentPointer, callback)
      }

      SliderTimelineView.prototype._handlePlayClick = function (nextState) {
        this._clearTimer()

        this.api.dispatchAction({
          type: 'timelinePlayChange',
          playState: nextState,
          from: this.uid
        })
      }

      SliderTimelineView.prototype._handlePointerDrag = function (dx, dy, e) {
        this._clearTimer()

        this._pointerChangeTimeline([e.offsetX, e.offsetY])
      }

      SliderTimelineView.prototype._handlePointerDragend = function (e) {
        this._pointerChangeTimeline([e.offsetX, e.offsetY], true)
      }

      SliderTimelineView.prototype._pointerChangeTimeline = function (mousePos, trigger) {
        let toCoord = this._toAxisCoord(mousePos)[0]

        const axis = this._axis
        const axisExtent = asc(axis.getExtent().slice())
        toCoord > axisExtent[1] && (toCoord = axisExtent[1])
        toCoord < axisExtent[0] && (toCoord = axisExtent[0])
        this._currentPointer.x = toCoord

        this._currentPointer.markRedraw()

        this._progressLine.shape.x2 = toCoord

        this._progressLine.dirty()

        const targetDataIndex = this._findNearestTick(toCoord)

        const timelineModel = this.model

        if (trigger || targetDataIndex !== timelineModel.getCurrentIndex() && timelineModel.get('realtime')) {
          this._changeTimeline(targetDataIndex)
        }
      }

      SliderTimelineView.prototype._doPlayStop = function () {
        const _this = this

        this._clearTimer()

        if (this.model.getPlayState()) {
          this._timer = setTimeout(function () {
            // Do not cache
            const timelineModel = _this.model

            _this._changeTimeline(timelineModel.getCurrentIndex() + (timelineModel.get('rewind', true) ? -1 : 1))
          }, this.model.get('playInterval'))
        }
      }

      SliderTimelineView.prototype._toAxisCoord = function (vertex) {
        const trans = this._mainGroup.getLocalTransform()

        return applyTransform$1(vertex, trans, true)
      }

      SliderTimelineView.prototype._findNearestTick = function (axisCoord) {
        const data = this.model.getData()
        let dist = Infinity
        let targetDataIndex
        const axis = this._axis
        data.each(['value'], function (value, dataIndex) {
          const coord = axis.dataToCoord(value)
          const d = Math.abs(coord - axisCoord)

          if (d < dist) {
            dist = d
            targetDataIndex = dataIndex
          }
        })
        return targetDataIndex
      }

      SliderTimelineView.prototype._clearTimer = function () {
        if (this._timer) {
          clearTimeout(this._timer)
          this._timer = null
        }
      }

      SliderTimelineView.prototype._changeTimeline = function (nextIndex) {
        const currentIndex = this.model.getCurrentIndex()

        if (nextIndex === '+') {
          nextIndex = currentIndex + 1
        } else if (nextIndex === '-') {
          nextIndex = currentIndex - 1
        }

        this.api.dispatchAction({
          type: 'timelineChange',
          currentIndex: nextIndex,
          from: this.uid
        })
      }

      SliderTimelineView.prototype._updateTicksStatus = function () {
        const currentIndex = this.model.getCurrentIndex()
        const tickSymbols = this._tickSymbols
        const tickLabels = this._tickLabels

        if (tickSymbols) {
          for (var i = 0; i < tickSymbols.length; i++) {
            tickSymbols && tickSymbols[i] && tickSymbols[i].toggleState('progress', i < currentIndex)
          }
        }

        if (tickLabels) {
          for (var i = 0; i < tickLabels.length; i++) {
            tickLabels && tickLabels[i] && tickLabels[i].toggleState('progress', labelDataIndexStore(tickLabels[i]).dataIndex <= currentIndex)
          }
        }
      }

      SliderTimelineView.type = 'timeline.slider'
      return SliderTimelineView
    }(TimelineView))

  function createScaleByModel$1 (model, axisType) {
    axisType = axisType || model.get('type')

    if (axisType) {
      switch (axisType) {
        // Buildin scale
        case 'category':
          return new OrdinalScale({
            ordinalMeta: model.getCategories(),
            extent: [Infinity, -Infinity]
          })

        case 'time':
          return new TimeScale({
            locale: model.ecModel.getLocaleModel(),
            useUTC: model.ecModel.get('useUTC')
          })

        default:
          // default to be value
          return new IntervalScale()
      }
    }
  }

  function getViewRect$5 (model, api) {
    return getLayoutRect(model.getBoxLayoutParams(), {
      width: api.getWidth(),
      height: api.getHeight()
    }, model.get('padding'))
  }

  function makeControlIcon (timelineModel, objPath, rect, opts) {
    const style = opts.style
    const icon = createIcon(timelineModel.get(['controlStyle', objPath]), opts || {}, new BoundingRect(rect[0], rect[1], rect[2], rect[3])) // TODO createIcon won't use style in opt.

    if (style) {
      icon.setStyle(style)
    }

    return icon
  }
  /**
     * Create symbol or update symbol
     * opt: basic position and event handlers
     */

  function giveSymbol (hostModel, itemStyleModel, group, opt, symbol, callback) {
    const color = itemStyleModel.get('color')

    if (!symbol) {
      const symbolType = hostModel.get('symbol')
      symbol = createSymbol(symbolType, -1, -1, 2, 2, color)
      symbol.setStyle('strokeNoScale', true)
      group.add(symbol)
      callback && callback.onCreate(symbol)
    } else {
      symbol.setColor(color)
      group.add(symbol) // Group may be new, also need to add.

      callback && callback.onUpdate(symbol)
    } // Style

    const itemStyle = itemStyleModel.getItemStyle(['color'])
    symbol.setStyle(itemStyle) // Transform and events.

    opt = merge({
      rectHover: true,
      z2: 100
    }, opt, true)
    const symbolSize = normalizeSymbolSize(hostModel.get('symbolSize'))
    opt.scaleX = symbolSize[0] / 2
    opt.scaleY = symbolSize[1] / 2
    const symbolOffset = normalizeSymbolOffset(hostModel.get('symbolOffset'), symbolSize)

    if (symbolOffset) {
      opt.x = (opt.x || 0) + symbolOffset[0]
      opt.y = (opt.y || 0) + symbolOffset[1]
    }

    const symbolRotate = hostModel.get('symbolRotate')
    opt.rotation = (symbolRotate || 0) * Math.PI / 180 || 0
    symbol.attr(opt) // FIXME
    // (1) When symbol.style.strokeNoScale is true and updateTransform is not performed,
    // getBoundingRect will return wrong result.
    // (This is supposed to be resolved in zrender, but it is a little difficult to
    // leverage performance and auto updateTransform)
    // (2) All of ancesters of symbol do not scale, so we can just updateTransform symbol.

    symbol.updateTransform()
    return symbol
  }

  function pointerMoveTo (pointer, progressLine, dataIndex, axis, timelineModel, noAnimation) {
    if (pointer.dragging) {
      return
    }

    const pointerModel = timelineModel.getModel('checkpointStyle')
    const toCoord = axis.dataToCoord(timelineModel.getData().get('value', dataIndex))

    if (noAnimation || !pointerModel.get('animation', true)) {
      pointer.attr({
        x: toCoord,
        y: 0
      })
      progressLine && progressLine.attr({
        shape: {
          x2: toCoord
        }
      })
    } else {
      const animationCfg = {
        duration: pointerModel.get('animationDuration', true),
        easing: pointerModel.get('animationEasing', true)
      }
      pointer.stopAnimation(null, true)
      pointer.animateTo({
        x: toCoord,
        y: 0
      }, animationCfg)
      progressLine && progressLine.animateTo({
        shape: {
          x2: toCoord
        }
      }, animationCfg)
    }
  }

  function installTimelineAction (registers) {
    registers.registerAction({
      type: 'timelineChange',
      event: 'timelineChanged',
      update: 'prepareAndUpdate'
    }, function (payload, ecModel, api) {
      const timelineModel = ecModel.getComponent('timeline')

      if (timelineModel && payload.currentIndex != null) {
        timelineModel.setCurrentIndex(payload.currentIndex)

        if (!timelineModel.get('loop', true) && timelineModel.isIndexMax() && timelineModel.getPlayState()) {
          timelineModel.setPlayState(false) // The timeline has played to the end, trigger event

          api.dispatchAction({
            type: 'timelinePlayChange',
            playState: false,
            from: payload.from
          })
        }
      } // Set normalized currentIndex to payload.

      ecModel.resetOption('timeline', {
        replaceMerge: timelineModel.get('replaceMerge', true)
      })
      return defaults({
        currentIndex: timelineModel.option.currentIndex
      }, payload)
    })
    registers.registerAction({
      type: 'timelinePlayChange',
      event: 'timelinePlayChanged',
      update: 'update'
    }, function (payload, ecModel) {
      const timelineModel = ecModel.getComponent('timeline')

      if (timelineModel && payload.playState != null) {
        timelineModel.setPlayState(payload.playState)
      }
    })
  }

  function timelinePreprocessor (option) {
    let timelineOpt = option && option.timeline

    if (!isArray(timelineOpt)) {
      timelineOpt = timelineOpt ? [timelineOpt] : []
    }

    each(timelineOpt, function (opt) {
      if (!opt) {
        return
      }

      compatibleEC2(opt)
    })
  }

  function compatibleEC2 (opt) {
    const type = opt.type
    const ec2Types = {
      number: 'value',
      time: 'time'
    } // Compatible with ec2

    if (ec2Types[type]) {
      opt.axisType = ec2Types[type]
      delete opt.type
    }

    transferItem(opt)

    if (has(opt, 'controlPosition')) {
      const controlStyle = opt.controlStyle || (opt.controlStyle = {})

      if (!has(controlStyle, 'position')) {
        controlStyle.position = opt.controlPosition
      }

      if (controlStyle.position === 'none' && !has(controlStyle, 'show')) {
        controlStyle.show = false
        delete controlStyle.position
      }

      delete opt.controlPosition
    }

    each(opt.data || [], function (dataItem) {
      if (isObject(dataItem) && !isArray(dataItem)) {
        if (!has(dataItem, 'value') && has(dataItem, 'name')) {
          // In ec2, using name as value.
          dataItem.value = dataItem.name
        }

        transferItem(dataItem)
      }
    })
  }

  function transferItem (opt) {
    const itemStyle = opt.itemStyle || (opt.itemStyle = {})
    const itemStyleEmphasis = itemStyle.emphasis || (itemStyle.emphasis = {}) // Transfer label out

    const label = opt.label || opt.label || {}
    const labelNormal = label.normal || (label.normal = {})
    const excludeLabelAttr = {
      normal: 1,
      emphasis: 1
    }
    each(label, function (value, name) {
      if (!excludeLabelAttr[name] && !has(labelNormal, name)) {
        labelNormal[name] = value
      }
    })

    if (itemStyleEmphasis.label && !has(label, 'emphasis')) {
      label.emphasis = itemStyleEmphasis.label
      delete itemStyleEmphasis.label
    }
  }

  function has (obj, attr) {
    return obj.hasOwnProperty(attr)
  }

  function install$D (registers) {
    registers.registerComponentModel(SliderTimelineModel)
    registers.registerComponentView(SliderTimelineView)
    registers.registerSubTypeDefaulter('timeline', function () {
      // Only slider now.
      return 'slider'
    })
    installTimelineAction(registers)
    registers.registerPreprocessor(timelinePreprocessor)
  }

  function checkMarkerInSeries (seriesOpts, markerType) {
    if (!seriesOpts) {
      return false
    }

    const seriesOptArr = isArray(seriesOpts) ? seriesOpts : [seriesOpts]

    for (let idx = 0; idx < seriesOptArr.length; idx++) {
      if (seriesOptArr[idx] && seriesOptArr[idx][markerType]) {
        return true
      }
    }

    return false
  }

  function fillLabel (opt) {
    defaultEmphasis(opt, 'label', ['show'])
  } // { [componentType]: MarkerModel }

  const inner$g = makeInner()

  const MarkerModel =
    /** @class */
    (function (_super) {
      __extends(MarkerModel, _super)

      function MarkerModel () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = MarkerModel.type
        /**
         * If marker model is created by self from series
         */

        _this.createdBySelf = false
        return _this
      }
      /**
       * @overrite
       */

      MarkerModel.prototype.init = function (option, parentModel, ecModel) {
        if ('development' !== 'production') {
          if (this.type === 'marker') {
            throw new Error('Marker component is abstract component. Use markLine, markPoint, markArea instead.')
          }
        }

        this.mergeDefaultAndTheme(option, ecModel)

        this._mergeOption(option, ecModel, false, true)
      }

      MarkerModel.prototype.isAnimationEnabled = function () {
        if (env.node) {
          return false
        }

        const hostSeries = this.__hostSeries
        return this.getShallow('animation') && hostSeries && hostSeries.isAnimationEnabled()
      }
      /**
       * @overrite
       */

      MarkerModel.prototype.mergeOption = function (newOpt, ecModel) {
        this._mergeOption(newOpt, ecModel, false, false)
      }

      MarkerModel.prototype._mergeOption = function (newOpt, ecModel, createdBySelf, isInit) {
        const componentType = this.mainType

        if (!createdBySelf) {
          ecModel.eachSeries(function (seriesModel) {
            // mainType can be markPoint, markLine, markArea
            const markerOpt = seriesModel.get(this.mainType, true)
            let markerModel = inner$g(seriesModel)[componentType]

            if (!markerOpt || !markerOpt.data) {
              inner$g(seriesModel)[componentType] = null
              return
            }

            if (!markerModel) {
              if (isInit) {
                // Default label emphasis `position` and `show`
                fillLabel(markerOpt)
              }

              each(markerOpt.data, function (item) {
                // FIXME Overwrite fillLabel method ?
                if (item instanceof Array) {
                  fillLabel(item[0])
                  fillLabel(item[1])
                } else {
                  fillLabel(item)
                }
              })
              markerModel = this.createMarkerModelFromSeries(markerOpt, this, ecModel) // markerModel = new ImplementedMarkerModel(
              //     markerOpt, this, ecModel
              // );

              extend(markerModel, {
                mainType: this.mainType,
                // Use the same series index and name
                seriesIndex: seriesModel.seriesIndex,
                name: seriesModel.name,
                createdBySelf: true
              })
              markerModel.__hostSeries = seriesModel
            } else {
              markerModel._mergeOption(markerOpt, ecModel, true)
            }

            inner$g(seriesModel)[componentType] = markerModel
          }, this)
        }
      }

      MarkerModel.prototype.formatTooltip = function (dataIndex, multipleSeries, dataType) {
        const data = this.getData()
        const value = this.getRawValue(dataIndex)
        const itemName = data.getName(dataIndex)
        return createTooltipMarkup('section', {
          header: this.name,
          blocks: [createTooltipMarkup('nameValue', {
            name: itemName,
            value: value,
            noName: !itemName,
            noValue: value == null
          })]
        })
      }

      MarkerModel.prototype.getData = function () {
        return this._data
      }

      MarkerModel.prototype.setData = function (data) {
        this._data = data
      }

      MarkerModel.getMarkerModelFromSeries = function (seriesModel, // Support three types of markers. Strict check.
        componentType) {
        return inner$g(seriesModel)[componentType]
      }

      MarkerModel.type = 'marker'
      MarkerModel.dependencies = ['series', 'grid', 'polar', 'geo']
      return MarkerModel
    }(ComponentModel))

  mixin(MarkerModel, DataFormatMixin.prototype)

  const MarkPointModel =
    /** @class */
    (function (_super) {
      __extends(MarkPointModel, _super)

      function MarkPointModel () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = MarkPointModel.type
        return _this
      }

      MarkPointModel.prototype.createMarkerModelFromSeries = function (markerOpt, masterMarkerModel, ecModel) {
        return new MarkPointModel(markerOpt, masterMarkerModel, ecModel)
      }

      MarkPointModel.type = 'markPoint'
      MarkPointModel.defaultOption = {
        // zlevel: 0,
        z: 5,
        symbol: 'pin',
        symbolSize: 50,
        // symbolRotate: 0,
        // symbolOffset: [0, 0]
        tooltip: {
          trigger: 'item'
        },
        label: {
          show: true,
          position: 'inside'
        },
        itemStyle: {
          borderWidth: 2
        },
        emphasis: {
          label: {
            show: true
          }
        }
      }
      return MarkPointModel
    }(MarkerModel))

  function hasXOrY (item) {
    return !(isNaN(parseFloat(item.x)) && isNaN(parseFloat(item.y)))
  }

  function hasXAndY (item) {
    return !isNaN(parseFloat(item.x)) && !isNaN(parseFloat(item.y))
  }

  function markerTypeCalculatorWithExtent (markerType, data, otherDataDim, targetDataDim, otherCoordIndex, targetCoordIndex) {
    const coordArr = []
    const stacked = isDimensionStacked(data, targetDataDim
      /*, otherDataDim */
    )
    const calcDataDim = stacked ? data.getCalculationInfo('stackResultDimension') : targetDataDim
    const value = numCalculate(data, calcDataDim, markerType)
    const dataIndex = data.indicesOfNearest(calcDataDim, value)[0]
    coordArr[otherCoordIndex] = data.get(otherDataDim, dataIndex)
    coordArr[targetCoordIndex] = data.get(calcDataDim, dataIndex)
    const coordArrValue = data.get(targetDataDim, dataIndex) // Make it simple, do not visit all stacked value to count precision.

    let precision = getPrecision(data.get(targetDataDim, dataIndex))
    precision = Math.min(precision, 20)

    if (precision >= 0) {
      coordArr[targetCoordIndex] = +coordArr[targetCoordIndex].toFixed(precision)
    }

    return [coordArr, coordArrValue]
  } // TODO Specified percent

  const markerTypeCalculator = {
    min: curry(markerTypeCalculatorWithExtent, 'min'),
    max: curry(markerTypeCalculatorWithExtent, 'max'),
    average: curry(markerTypeCalculatorWithExtent, 'average'),
    median: curry(markerTypeCalculatorWithExtent, 'median')
  }
  /**
     * Transform markPoint data item to format used in List by do the following
     * 1. Calculate statistic like `max`, `min`, `average`
     * 2. Convert `item.xAxis`, `item.yAxis` to `item.coord` array
     */

  function dataTransform (seriesModel, item) {
    const data = seriesModel.getData()
    const coordSys = seriesModel.coordinateSystem // 1. If not specify the position with pixel directly
    // 2. If `coord` is not a data array. Which uses `xAxis`,
    // `yAxis` to specify the coord on each dimension
    // parseFloat first because item.x and item.y can be percent string like '20%'

    if (item && !hasXAndY(item) && !isArray(item.coord) && coordSys) {
      const dims = coordSys.dimensions
      const axisInfo = getAxisInfo$1(item, data, coordSys, seriesModel) // Clone the option
      // Transform the properties xAxis, yAxis, radiusAxis, angleAxis, geoCoord to value

      item = clone(item)

      if (item.type && markerTypeCalculator[item.type] && axisInfo.baseAxis && axisInfo.valueAxis) {
        const otherCoordIndex = indexOf(dims, axisInfo.baseAxis.dim)
        const targetCoordIndex = indexOf(dims, axisInfo.valueAxis.dim)
        const coordInfo = markerTypeCalculator[item.type](data, axisInfo.baseDataDim, axisInfo.valueDataDim, otherCoordIndex, targetCoordIndex)
        item.coord = coordInfo[0] // Force to use the value of calculated value.
        // let item use the value without stack.

        item.value = coordInfo[1]
      } else {
        // FIXME Only has one of xAxis and yAxis.
        const coord = [item.xAxis != null ? item.xAxis : item.radiusAxis, item.yAxis != null ? item.yAxis : item.angleAxis] // Each coord support max, min, average

        for (let i = 0; i < 2; i++) {
          if (markerTypeCalculator[coord[i]]) {
            coord[i] = numCalculate(data, data.mapDimension(dims[i]), coord[i])
          }
        }

        item.coord = coord
      }
    }

    return item
  }
  function getAxisInfo$1 (item, data, coordSys, seriesModel) {
    const ret = {}

    if (item.valueIndex != null || item.valueDim != null) {
      ret.valueDataDim = item.valueIndex != null ? data.getDimension(item.valueIndex) : item.valueDim
      ret.valueAxis = coordSys.getAxis(dataDimToCoordDim(seriesModel, ret.valueDataDim))
      ret.baseAxis = coordSys.getOtherAxis(ret.valueAxis)
      ret.baseDataDim = data.mapDimension(ret.baseAxis.dim)
    } else {
      ret.baseAxis = seriesModel.getBaseAxis()
      ret.valueAxis = coordSys.getOtherAxis(ret.baseAxis)
      ret.baseDataDim = data.mapDimension(ret.baseAxis.dim)
      ret.valueDataDim = data.mapDimension(ret.valueAxis.dim)
    }

    return ret
  }

  function dataDimToCoordDim (seriesModel, dataDim) {
    const dimItem = seriesModel.getData().getDimensionInfo(dataDim)
    return dimItem && dimItem.coordDim
  }
  /**
     * Filter data which is out of coordinateSystem range
     * [dataFilter description]
     */

  function dataFilter$1 ( // Currently only polar and cartesian has containData.
    coordSys, item) {
    // Alwalys return true if there is no coordSys
    return coordSys && coordSys.containData && item.coord && !hasXOrY(item) ? coordSys.containData(item.coord) : true
  }
  function zoneFilter ( // Currently only polar and cartesian has containData.
    coordSys, item1, item2) {
    // Alwalys return true if there is no coordSys
    return coordSys && coordSys.containZone && item1.coord && item2.coord && !hasXOrY(item1) && !hasXOrY(item2) ? coordSys.containZone(item1.coord, item2.coord) : true
  }
  function createMarkerDimValueGetter (inCoordSys, dims) {
    return inCoordSys ? function (item, dimName, dataIndex, dimIndex) {
      const rawVal = dimIndex < 2 // x, y, radius, angle
        ? item.coord && item.coord[dimIndex] : item.value
      return parseDataValue(rawVal, dims[dimIndex])
    } : function (item, dimName, dataIndex, dimIndex) {
      return parseDataValue(item.value, dims[dimIndex])
    }
  }
  function numCalculate (data, valueDataDim, type) {
    if (type === 'average') {
      let sum_1 = 0
      let count_1 = 0
      data.each(valueDataDim, function (val, idx) {
        if (!isNaN(val)) {
          sum_1 += val
          count_1++
        }
      })
      return sum_1 / count_1
    } else if (type === 'median') {
      return data.getMedian(valueDataDim)
    } else {
      // max & min
      return data.getDataExtent(valueDataDim)[type === 'max' ? 1 : 0]
    }
  }

  const inner$h = makeInner()

  const MarkerView =
    /** @class */
    (function (_super) {
      __extends(MarkerView, _super)

      function MarkerView () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = MarkerView.type
        return _this
      }

      MarkerView.prototype.init = function () {
        this.markerGroupMap = createHashMap()
      }

      MarkerView.prototype.render = function (markerModel, ecModel, api) {
        const _this = this

        const markerGroupMap = this.markerGroupMap
        markerGroupMap.each(function (item) {
          inner$h(item).keep = false
        })
        ecModel.eachSeries(function (seriesModel) {
          const markerModel = MarkerModel.getMarkerModelFromSeries(seriesModel, _this.type)
          markerModel && _this.renderSeries(seriesModel, markerModel, ecModel, api)
        })
        markerGroupMap.each(function (item) {
          !inner$h(item).keep && _this.group.remove(item.group)
        })
      }

      MarkerView.prototype.markKeep = function (drawGroup) {
        inner$h(drawGroup).keep = true
      }

      MarkerView.prototype.toggleBlurSeries = function (seriesModelList, isBlur) {
        const _this = this

        each(seriesModelList, function (seriesModel) {
          const markerModel = MarkerModel.getMarkerModelFromSeries(seriesModel, _this.type)

          if (markerModel) {
            const data = markerModel.getData()
            data.eachItemGraphicEl(function (el) {
              if (el) {
                isBlur ? enterBlur(el) : leaveBlur(el)
              }
            })
          }
        })
      }

      MarkerView.type = 'marker'
      return MarkerView
    }(ComponentView))

  function updateMarkerLayout (mpData, seriesModel, api) {
    const coordSys = seriesModel.coordinateSystem
    mpData.each(function (idx) {
      const itemModel = mpData.getItemModel(idx)
      let point
      const xPx = parsePercent$1(itemModel.get('x'), api.getWidth())
      const yPx = parsePercent$1(itemModel.get('y'), api.getHeight())

      if (!isNaN(xPx) && !isNaN(yPx)) {
        point = [xPx, yPx]
      } // Chart like bar may have there own marker positioning logic
      else if (seriesModel.getMarkerPosition) {
        // Use the getMarkerPoisition
        point = seriesModel.getMarkerPosition(mpData.getValues(mpData.dimensions, idx))
      } else if (coordSys) {
        const x = mpData.get(coordSys.dimensions[0], idx)
        const y = mpData.get(coordSys.dimensions[1], idx)
        point = coordSys.dataToPoint([x, y])
      } // Use x, y if has any

      if (!isNaN(xPx)) {
        point[0] = xPx
      }

      if (!isNaN(yPx)) {
        point[1] = yPx
      }

      mpData.setItemLayout(idx, point)
    })
  }

  const MarkPointView =
    /** @class */
    (function (_super) {
      __extends(MarkPointView, _super)

      function MarkPointView () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = MarkPointView.type
        return _this
      }

      MarkPointView.prototype.updateTransform = function (markPointModel, ecModel, api) {
        ecModel.eachSeries(function (seriesModel) {
          const mpModel = MarkerModel.getMarkerModelFromSeries(seriesModel, 'markPoint')

          if (mpModel) {
            updateMarkerLayout(mpModel.getData(), seriesModel, api)
            this.markerGroupMap.get(seriesModel.id).updateLayout()
          }
        }, this)
      }

      MarkPointView.prototype.renderSeries = function (seriesModel, mpModel, ecModel, api) {
        const coordSys = seriesModel.coordinateSystem
        const seriesId = seriesModel.id
        const seriesData = seriesModel.getData()
        const symbolDrawMap = this.markerGroupMap
        const symbolDraw = symbolDrawMap.get(seriesId) || symbolDrawMap.set(seriesId, new SymbolDraw())
        const mpData = createData(coordSys, seriesModel, mpModel) // FIXME

        mpModel.setData(mpData)
        updateMarkerLayout(mpModel.getData(), seriesModel, api)
        mpData.each(function (idx) {
          const itemModel = mpData.getItemModel(idx)
          let symbol = itemModel.getShallow('symbol')
          let symbolSize = itemModel.getShallow('symbolSize')
          let symbolRotate = itemModel.getShallow('symbolRotate')
          let symbolOffset = itemModel.getShallow('symbolOffset')
          const symbolKeepAspect = itemModel.getShallow('symbolKeepAspect') // TODO: refactor needed: single data item should not support callback function

          if (isFunction(symbol) || isFunction(symbolSize) || isFunction(symbolRotate) || isFunction(symbolOffset)) {
            const rawIdx = mpModel.getRawValue(idx)
            const dataParams = mpModel.getDataParams(idx)

            if (isFunction(symbol)) {
              symbol = symbol(rawIdx, dataParams)
            }

            if (isFunction(symbolSize)) {
              // FIXME 这里不兼容 ECharts 2.x，2.x 貌似参数是整个数据？
              symbolSize = symbolSize(rawIdx, dataParams)
            }

            if (isFunction(symbolRotate)) {
              symbolRotate = symbolRotate(rawIdx, dataParams)
            }

            if (isFunction(symbolOffset)) {
              symbolOffset = symbolOffset(rawIdx, dataParams)
            }
          }

          const style = itemModel.getModel('itemStyle').getItemStyle()
          const color = getVisualFromData(seriesData, 'color')

          if (!style.fill) {
            style.fill = color
          }

          mpData.setItemVisual(idx, {
            symbol: symbol,
            symbolSize: symbolSize,
            symbolRotate: symbolRotate,
            symbolOffset: symbolOffset,
            symbolKeepAspect: symbolKeepAspect,
            style: style
          })
        }) // TODO Text are wrong

        symbolDraw.updateData(mpData)
        this.group.add(symbolDraw.group) // Set host model for tooltip
        // FIXME

        mpData.eachItemGraphicEl(function (el) {
          el.traverse(function (child) {
            getECData(child).dataModel = mpModel
          })
        })
        this.markKeep(symbolDraw)
        symbolDraw.group.silent = mpModel.get('silent') || seriesModel.get('silent')
      }

      MarkPointView.type = 'markPoint'
      return MarkPointView
    }(MarkerView))

  function createData (coordSys, seriesModel, mpModel) {
    let coordDimsInfos

    if (coordSys) {
      coordDimsInfos = map(coordSys && coordSys.dimensions, function (coordDim) {
        const info = seriesModel.getData().getDimensionInfo(seriesModel.getData().mapDimension(coordDim)) || {} // In map series data don't have lng and lat dimension. Fallback to same with coordSys

        return extend(extend({}, info), {
          name: coordDim,
          // DON'T use ordinalMeta to parse and collect ordinal.
          ordinalMeta: null
        })
      })
    } else {
      coordDimsInfos = [{
        name: 'value',
        type: 'float'
      }]
    }

    const mpData = new SeriesData(coordDimsInfos, mpModel)
    let dataOpt = map(mpModel.get('data'), curry(dataTransform, seriesModel))

    if (coordSys) {
      dataOpt = filter(dataOpt, curry(dataFilter$1, coordSys))
    }

    const dimValueGetter = createMarkerDimValueGetter(!!coordSys, coordDimsInfos)
    mpData.initData(dataOpt, null, dimValueGetter)
    return mpData
  }

  function install$E (registers) {
    registers.registerComponentModel(MarkPointModel)
    registers.registerComponentView(MarkPointView)
    registers.registerPreprocessor(function (opt) {
      if (checkMarkerInSeries(opt.series, 'markPoint')) {
        // Make sure markPoint component is enabled
        opt.markPoint = opt.markPoint || {}
      }
    })
  }

  const MarkLineModel =
    /** @class */
    (function (_super) {
      __extends(MarkLineModel, _super)

      function MarkLineModel () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = MarkLineModel.type
        return _this
      }

      MarkLineModel.prototype.createMarkerModelFromSeries = function (markerOpt, masterMarkerModel, ecModel) {
        return new MarkLineModel(markerOpt, masterMarkerModel, ecModel)
      }

      MarkLineModel.type = 'markLine'
      MarkLineModel.defaultOption = {
        // zlevel: 0,
        z: 5,
        symbol: ['circle', 'arrow'],
        symbolSize: [8, 16],
        // symbolRotate: 0,
        symbolOffset: 0,
        precision: 2,
        tooltip: {
          trigger: 'item'
        },
        label: {
          show: true,
          position: 'end',
          distance: 5
        },
        lineStyle: {
          type: 'dashed'
        },
        emphasis: {
          label: {
            show: true
          },
          lineStyle: {
            width: 3
          }
        },
        animationEasing: 'linear'
      }
      return MarkLineModel
    }(MarkerModel))

  const inner$i = makeInner()

  const markLineTransform = function (seriesModel, coordSys, mlModel, item) {
    const data = seriesModel.getData()
    let itemArray

    if (!isArray(item)) {
      // Special type markLine like 'min', 'max', 'average', 'median'
      const mlType = item.type

      if (mlType === 'min' || mlType === 'max' || mlType === 'average' || mlType === 'median' || // In case
        // data: [{
        //   yAxis: 10
        // }]
        item.xAxis != null || item.yAxis != null) {
        let valueAxis = void 0
        let value = void 0

        if (item.yAxis != null || item.xAxis != null) {
          valueAxis = coordSys.getAxis(item.yAxis != null ? 'y' : 'x')
          value = retrieve(item.yAxis, item.xAxis)
        } else {
          const axisInfo = getAxisInfo$1(item, data, coordSys, seriesModel)
          valueAxis = axisInfo.valueAxis
          const valueDataDim = getStackedDimension(data, axisInfo.valueDataDim)
          value = numCalculate(data, valueDataDim, mlType)
        }

        const valueIndex = valueAxis.dim === 'x' ? 0 : 1
        const baseIndex = 1 - valueIndex // Normized to 2d data with start and end point

        const mlFrom = clone(item)
        const mlTo = {
          coord: []
        }
        mlFrom.type = null
        mlFrom.coord = []
        mlFrom.coord[baseIndex] = -Infinity
        mlTo.coord[baseIndex] = Infinity
        const precision = mlModel.get('precision')

        if (precision >= 0 && isNumber(value)) {
          value = +value.toFixed(Math.min(precision, 20))
        }

        mlFrom.coord[valueIndex] = mlTo.coord[valueIndex] = value
        itemArray = [mlFrom, mlTo, {
          type: mlType,
          valueIndex: item.valueIndex,
          // Force to use the value of calculated value.
          value: value
        }]
      } else {
        // Invalid data
        if ('development' !== 'production') {
          logError('Invalid markLine data.')
        }

        itemArray = []
      }
    } else {
      itemArray = item
    }

    const normalizedItem = [dataTransform(seriesModel, itemArray[0]), dataTransform(seriesModel, itemArray[1]), extend({}, itemArray[2])] // Avoid line data type is extended by from(to) data type

    normalizedItem[2].type = normalizedItem[2].type || null // Merge from option and to option into line option

    merge(normalizedItem[2], normalizedItem[0])
    merge(normalizedItem[2], normalizedItem[1])
    return normalizedItem
  }

  function isInifinity (val) {
    return !isNaN(val) && !isFinite(val)
  } // If a markLine has one dim

  function ifMarkLineHasOnlyDim (dimIndex, fromCoord, toCoord, coordSys) {
    const otherDimIndex = 1 - dimIndex
    const dimName = coordSys.dimensions[dimIndex]
    return isInifinity(fromCoord[otherDimIndex]) && isInifinity(toCoord[otherDimIndex]) && fromCoord[dimIndex] === toCoord[dimIndex] && coordSys.getAxis(dimName).containData(fromCoord[dimIndex])
  }

  function markLineFilter (coordSys, item) {
    if (coordSys.type === 'cartesian2d') {
      const fromCoord = item[0].coord
      const toCoord = item[1].coord // In case
      // {
      //  markLine: {
      //    data: [{ yAxis: 2 }]
      //  }
      // }

      if (fromCoord && toCoord && (ifMarkLineHasOnlyDim(1, fromCoord, toCoord, coordSys) || ifMarkLineHasOnlyDim(0, fromCoord, toCoord, coordSys))) {
        return true
      }
    }

    return dataFilter$1(coordSys, item[0]) && dataFilter$1(coordSys, item[1])
  }

  function updateSingleMarkerEndLayout (data, idx, isFrom, seriesModel, api) {
    const coordSys = seriesModel.coordinateSystem
    const itemModel = data.getItemModel(idx)
    let point
    const xPx = parsePercent$1(itemModel.get('x'), api.getWidth())
    const yPx = parsePercent$1(itemModel.get('y'), api.getHeight())

    if (!isNaN(xPx) && !isNaN(yPx)) {
      point = [xPx, yPx]
    } else {
      // Chart like bar may have there own marker positioning logic
      if (seriesModel.getMarkerPosition) {
        // Use the getMarkerPoisition
        point = seriesModel.getMarkerPosition(data.getValues(data.dimensions, idx))
      } else {
        var dims = coordSys.dimensions
        const x = data.get(dims[0], idx)
        const y = data.get(dims[1], idx)
        point = coordSys.dataToPoint([x, y])
      } // Expand line to the edge of grid if value on one axis is Inifnity
      // In case
      //  markLine: {
      //    data: [{
      //      yAxis: 2
      //      // or
      //      type: 'average'
      //    }]
      //  }

      if (isCoordinateSystemType(coordSys, 'cartesian2d')) {
        // TODO: TYPE ts@4.1 may still infer it as Axis instead of Axis2D. Not sure if it's a bug
        const xAxis = coordSys.getAxis('x')
        const yAxis = coordSys.getAxis('y')
        var dims = coordSys.dimensions

        if (isInifinity(data.get(dims[0], idx))) {
          point[0] = xAxis.toGlobalCoord(xAxis.getExtent()[isFrom ? 0 : 1])
        } else if (isInifinity(data.get(dims[1], idx))) {
          point[1] = yAxis.toGlobalCoord(yAxis.getExtent()[isFrom ? 0 : 1])
        }
      } // Use x, y if has any

      if (!isNaN(xPx)) {
        point[0] = xPx
      }

      if (!isNaN(yPx)) {
        point[1] = yPx
      }
    }

    data.setItemLayout(idx, point)
  }

  const MarkLineView =
    /** @class */
    (function (_super) {
      __extends(MarkLineView, _super)

      function MarkLineView () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = MarkLineView.type
        return _this
      }

      MarkLineView.prototype.updateTransform = function (markLineModel, ecModel, api) {
        ecModel.eachSeries(function (seriesModel) {
          const mlModel = MarkerModel.getMarkerModelFromSeries(seriesModel, 'markLine')

          if (mlModel) {
            const mlData_1 = mlModel.getData()
            const fromData_1 = inner$i(mlModel).from
            const toData_1 = inner$i(mlModel).to // Update visual and layout of from symbol and to symbol

            fromData_1.each(function (idx) {
              updateSingleMarkerEndLayout(fromData_1, idx, true, seriesModel, api)
              updateSingleMarkerEndLayout(toData_1, idx, false, seriesModel, api)
            }) // Update layout of line

            mlData_1.each(function (idx) {
              mlData_1.setItemLayout(idx, [fromData_1.getItemLayout(idx), toData_1.getItemLayout(idx)])
            })
            this.markerGroupMap.get(seriesModel.id).updateLayout()
          }
        }, this)
      }

      MarkLineView.prototype.renderSeries = function (seriesModel, mlModel, ecModel, api) {
        const coordSys = seriesModel.coordinateSystem
        const seriesId = seriesModel.id
        const seriesData = seriesModel.getData()
        const lineDrawMap = this.markerGroupMap
        const lineDraw = lineDrawMap.get(seriesId) || lineDrawMap.set(seriesId, new LineDraw())
        this.group.add(lineDraw.group)
        const mlData = createList$1(coordSys, seriesModel, mlModel)
        const fromData = mlData.from
        const toData = mlData.to
        const lineData = mlData.line
        inner$i(mlModel).from = fromData
        inner$i(mlModel).to = toData // Line data for tooltip and formatter

        mlModel.setData(lineData) // TODO
        // Functionally, `symbolSize` & `symbolOffset` can also be 2D array now.
        // But the related logic and type definition are not finished yet.
        // Finish it if required

        let symbolType = mlModel.get('symbol')
        let symbolSize = mlModel.get('symbolSize')
        let symbolRotate = mlModel.get('symbolRotate')
        let symbolOffset = mlModel.get('symbolOffset') // TODO: support callback function like markPoint

        if (!isArray(symbolType)) {
          symbolType = [symbolType, symbolType]
        }

        if (!isArray(symbolSize)) {
          symbolSize = [symbolSize, symbolSize]
        }

        if (!isArray(symbolRotate)) {
          symbolRotate = [symbolRotate, symbolRotate]
        }

        if (!isArray(symbolOffset)) {
          symbolOffset = [symbolOffset, symbolOffset]
        } // Update visual and layout of from symbol and to symbol

        mlData.from.each(function (idx) {
          updateDataVisualAndLayout(fromData, idx, true)
          updateDataVisualAndLayout(toData, idx, false)
        }) // Update visual and layout of line

        lineData.each(function (idx) {
          const lineStyle = lineData.getItemModel(idx).getModel('lineStyle').getLineStyle() // lineData.setItemVisual(idx, {
          //     color: lineColor || fromData.getItemVisual(idx, 'color')
          // });

          lineData.setItemLayout(idx, [fromData.getItemLayout(idx), toData.getItemLayout(idx)])

          if (lineStyle.stroke == null) {
            lineStyle.stroke = fromData.getItemVisual(idx, 'style').fill
          }

          lineData.setItemVisual(idx, {
            fromSymbolKeepAspect: fromData.getItemVisual(idx, 'symbolKeepAspect'),
            fromSymbolOffset: fromData.getItemVisual(idx, 'symbolOffset'),
            fromSymbolRotate: fromData.getItemVisual(idx, 'symbolRotate'),
            fromSymbolSize: fromData.getItemVisual(idx, 'symbolSize'),
            fromSymbol: fromData.getItemVisual(idx, 'symbol'),
            toSymbolKeepAspect: toData.getItemVisual(idx, 'symbolKeepAspect'),
            toSymbolOffset: toData.getItemVisual(idx, 'symbolOffset'),
            toSymbolRotate: toData.getItemVisual(idx, 'symbolRotate'),
            toSymbolSize: toData.getItemVisual(idx, 'symbolSize'),
            toSymbol: toData.getItemVisual(idx, 'symbol'),
            style: lineStyle
          })
        })
        lineDraw.updateData(lineData) // Set host model for tooltip
        // FIXME

        mlData.line.eachItemGraphicEl(function (el) {
          getECData(el).dataModel = mlModel
          el.traverse(function (child) {
            getECData(child).dataModel = mlModel
          })
        })

        function updateDataVisualAndLayout (data, idx, isFrom) {
          const itemModel = data.getItemModel(idx)
          updateSingleMarkerEndLayout(data, idx, isFrom, seriesModel, api)
          const style = itemModel.getModel('itemStyle').getItemStyle()

          if (style.fill == null) {
            style.fill = getVisualFromData(seriesData, 'color')
          }

          data.setItemVisual(idx, {
            symbolKeepAspect: itemModel.get('symbolKeepAspect'),
            // `0` should be considered as a valid value, so use `retrieve2` instead of `||`
            symbolOffset: retrieve2(itemModel.get('symbolOffset', true), symbolOffset[isFrom ? 0 : 1]),
            symbolRotate: retrieve2(itemModel.get('symbolRotate', true), symbolRotate[isFrom ? 0 : 1]),
            // TODO: when 2d array is supported, it should ignore parent
            symbolSize: retrieve2(itemModel.get('symbolSize'), symbolSize[isFrom ? 0 : 1]),
            symbol: retrieve2(itemModel.get('symbol', true), symbolType[isFrom ? 0 : 1]),
            style: style
          })
        }

        this.markKeep(lineDraw)
        lineDraw.group.silent = mlModel.get('silent') || seriesModel.get('silent')
      }

      MarkLineView.type = 'markLine'
      return MarkLineView
    }(MarkerView))

  function createList$1 (coordSys, seriesModel, mlModel) {
    let coordDimsInfos

    if (coordSys) {
      coordDimsInfos = map(coordSys && coordSys.dimensions, function (coordDim) {
        const info = seriesModel.getData().getDimensionInfo(seriesModel.getData().mapDimension(coordDim)) || {} // In map series data don't have lng and lat dimension. Fallback to same with coordSys

        return extend(extend({}, info), {
          name: coordDim,
          // DON'T use ordinalMeta to parse and collect ordinal.
          ordinalMeta: null
        })
      })
    } else {
      coordDimsInfos = [{
        name: 'value',
        type: 'float'
      }]
    }

    const fromData = new SeriesData(coordDimsInfos, mlModel)
    const toData = new SeriesData(coordDimsInfos, mlModel) // No dimensions

    const lineData = new SeriesData([], mlModel)
    let optData = map(mlModel.get('data'), curry(markLineTransform, seriesModel, coordSys, mlModel))

    if (coordSys) {
      optData = filter(optData, curry(markLineFilter, coordSys))
    }

    const dimValueGetter = createMarkerDimValueGetter(!!coordSys, coordDimsInfos)
    fromData.initData(map(optData, function (item) {
      return item[0]
    }), null, dimValueGetter)
    toData.initData(map(optData, function (item) {
      return item[1]
    }), null, dimValueGetter)
    lineData.initData(map(optData, function (item) {
      return item[2]
    }))
    lineData.hasItemOption = true
    return {
      from: fromData,
      to: toData,
      line: lineData
    }
  }

  function install$F (registers) {
    registers.registerComponentModel(MarkLineModel)
    registers.registerComponentView(MarkLineView)
    registers.registerPreprocessor(function (opt) {
      if (checkMarkerInSeries(opt.series, 'markLine')) {
        // Make sure markLine component is enabled
        opt.markLine = opt.markLine || {}
      }
    })
  }

  const MarkAreaModel =
    /** @class */
    (function (_super) {
      __extends(MarkAreaModel, _super)

      function MarkAreaModel () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = MarkAreaModel.type
        return _this
      }

      MarkAreaModel.prototype.createMarkerModelFromSeries = function (markerOpt, masterMarkerModel, ecModel) {
        return new MarkAreaModel(markerOpt, masterMarkerModel, ecModel)
      }

      MarkAreaModel.type = 'markArea'
      MarkAreaModel.defaultOption = {
        // zlevel: 0,
        // PENDING
        z: 1,
        tooltip: {
          trigger: 'item'
        },
        // markArea should fixed on the coordinate system
        animation: false,
        label: {
          show: true,
          position: 'top'
        },
        itemStyle: {
          // color and borderColor default to use color from series
          // color: 'auto'
          // borderColor: 'auto'
          borderWidth: 0
        },
        emphasis: {
          label: {
            show: true,
            position: 'top'
          }
        }
      }
      return MarkAreaModel
    }(MarkerModel))

  const inner$j = makeInner()

  const markAreaTransform = function (seriesModel, coordSys, maModel, item) {
    const lt = dataTransform(seriesModel, item[0])
    const rb = dataTransform(seriesModel, item[1]) // FIXME make sure lt is less than rb

    const ltCoord = lt.coord
    const rbCoord = rb.coord
    ltCoord[0] = retrieve(ltCoord[0], -Infinity)
    ltCoord[1] = retrieve(ltCoord[1], -Infinity)
    rbCoord[0] = retrieve(rbCoord[0], Infinity)
    rbCoord[1] = retrieve(rbCoord[1], Infinity) // Merge option into one

    const result = mergeAll([{}, lt, rb])
    result.coord = [lt.coord, rb.coord]
    result.x0 = lt.x
    result.y0 = lt.y
    result.x1 = rb.x
    result.y1 = rb.y
    return result
  }

  function isInifinity$1 (val) {
    return !isNaN(val) && !isFinite(val)
  } // If a markArea has one dim

  function ifMarkAreaHasOnlyDim (dimIndex, fromCoord, toCoord, coordSys) {
    const otherDimIndex = 1 - dimIndex
    return isInifinity$1(fromCoord[otherDimIndex]) && isInifinity$1(toCoord[otherDimIndex])
  }

  function markAreaFilter (coordSys, item) {
    const fromCoord = item.coord[0]
    const toCoord = item.coord[1]
    const item0 = {
      coord: fromCoord,
      x: item.x0,
      y: item.y0
    }
    const item1 = {
      coord: toCoord,
      x: item.x1,
      y: item.y1
    }

    if (isCoordinateSystemType(coordSys, 'cartesian2d')) {
      // In case
      // {
      //  markArea: {
      //    data: [{ yAxis: 2 }]
      //  }
      // }
      if (fromCoord && toCoord && (ifMarkAreaHasOnlyDim(1, fromCoord, toCoord) || ifMarkAreaHasOnlyDim(0, fromCoord, toCoord))) {
        return true
      } // Directly returning true may also do the work,
      // because markArea will not be shown automatically
      // when it's not included in coordinate system.
      // But filtering ahead can avoid keeping rendering markArea
      // when there are too many of them.

      return zoneFilter(coordSys, item0, item1)
    }

    return dataFilter$1(coordSys, item0) || dataFilter$1(coordSys, item1)
  } // dims can be ['x0', 'y0'], ['x1', 'y1'], ['x0', 'y1'], ['x1', 'y0']

  function getSingleMarkerEndPoint (data, idx, dims, seriesModel, api) {
    const coordSys = seriesModel.coordinateSystem
    const itemModel = data.getItemModel(idx)
    let point
    const xPx = parsePercent$1(itemModel.get(dims[0]), api.getWidth())
    const yPx = parsePercent$1(itemModel.get(dims[1]), api.getHeight())

    if (!isNaN(xPx) && !isNaN(yPx)) {
      point = [xPx, yPx]
    } else {
      // Chart like bar may have there own marker positioning logic
      if (seriesModel.getMarkerPosition) {
        // Use the getMarkerPoisition
        point = seriesModel.getMarkerPosition(data.getValues(dims, idx))
      } else {
        var x = data.get(dims[0], idx)
        var y = data.get(dims[1], idx)
        const pt = [x, y]
        coordSys.clampData && coordSys.clampData(pt, pt)
        point = coordSys.dataToPoint(pt, true)
      }

      if (isCoordinateSystemType(coordSys, 'cartesian2d')) {
        // TODO: TYPE ts@4.1 may still infer it as Axis instead of Axis2D. Not sure if it's a bug
        const xAxis = coordSys.getAxis('x')
        const yAxis = coordSys.getAxis('y')
        var x = data.get(dims[0], idx)
        var y = data.get(dims[1], idx)

        if (isInifinity$1(x)) {
          point[0] = xAxis.toGlobalCoord(xAxis.getExtent()[dims[0] === 'x0' ? 0 : 1])
        } else if (isInifinity$1(y)) {
          point[1] = yAxis.toGlobalCoord(yAxis.getExtent()[dims[1] === 'y0' ? 0 : 1])
        }
      } // Use x, y if has any

      if (!isNaN(xPx)) {
        point[0] = xPx
      }

      if (!isNaN(yPx)) {
        point[1] = yPx
      }
    }

    return point
  }

  const dimPermutations = [['x0', 'y0'], ['x1', 'y0'], ['x1', 'y1'], ['x0', 'y1']]

  const MarkAreaView =
    /** @class */
    (function (_super) {
      __extends(MarkAreaView, _super)

      function MarkAreaView () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = MarkAreaView.type
        return _this
      }

      MarkAreaView.prototype.updateTransform = function (markAreaModel, ecModel, api) {
        ecModel.eachSeries(function (seriesModel) {
          const maModel = MarkerModel.getMarkerModelFromSeries(seriesModel, 'markArea')

          if (maModel) {
            const areaData_1 = maModel.getData()
            areaData_1.each(function (idx) {
              const points = map(dimPermutations, function (dim) {
                return getSingleMarkerEndPoint(areaData_1, idx, dim, seriesModel, api)
              }) // Layout

              areaData_1.setItemLayout(idx, points)
              const el = areaData_1.getItemGraphicEl(idx)
              el.setShape('points', points)
            })
          }
        }, this)
      }

      MarkAreaView.prototype.renderSeries = function (seriesModel, maModel, ecModel, api) {
        const coordSys = seriesModel.coordinateSystem
        const seriesId = seriesModel.id
        const seriesData = seriesModel.getData()
        const areaGroupMap = this.markerGroupMap
        const polygonGroup = areaGroupMap.get(seriesId) || areaGroupMap.set(seriesId, {
          group: new Group()
        })
        this.group.add(polygonGroup.group)
        this.markKeep(polygonGroup)
        const areaData = createList$2(coordSys, seriesModel, maModel) // Line data for tooltip and formatter

        maModel.setData(areaData) // Update visual and layout of line

        areaData.each(function (idx) {
          // Layout
          const points = map(dimPermutations, function (dim) {
            return getSingleMarkerEndPoint(areaData, idx, dim, seriesModel, api)
          })
          const xAxisScale = coordSys.getAxis('x').scale
          const yAxisScale = coordSys.getAxis('y').scale
          const xAxisExtent = xAxisScale.getExtent()
          const yAxisExtent = yAxisScale.getExtent()
          const xPointExtent = [xAxisScale.parse(areaData.get('x0', idx)), xAxisScale.parse(areaData.get('x1', idx))]
          const yPointExtent = [yAxisScale.parse(areaData.get('y0', idx)), yAxisScale.parse(areaData.get('y1', idx))]
          asc(xPointExtent)
          asc(yPointExtent)
          const overlapped = !(xAxisExtent[0] > xPointExtent[1] || xAxisExtent[1] < xPointExtent[0] || yAxisExtent[0] > yPointExtent[1] || yAxisExtent[1] < yPointExtent[0]) // If none of the area is inside coordSys, allClipped is set to be true
          // in layout so that label will not be displayed. See #12591

          const allClipped = !overlapped
          areaData.setItemLayout(idx, {
            points: points,
            allClipped: allClipped
          })
          const style = areaData.getItemModel(idx).getModel('itemStyle').getItemStyle()
          const color$1 = getVisualFromData(seriesData, 'color')

          if (!style.fill) {
            style.fill = color$1

            if (isString(style.fill)) {
              style.fill = modifyAlpha(style.fill, 0.4)
            }
          }

          if (!style.stroke) {
            style.stroke = color$1
          } // Visual

          areaData.setItemVisual(idx, 'style', style)
        })
        areaData.diff(inner$j(polygonGroup).data).add(function (idx) {
          const layout = areaData.getItemLayout(idx)

          if (!layout.allClipped) {
            const polygon = new Polygon({
              shape: {
                points: layout.points
              }
            })
            areaData.setItemGraphicEl(idx, polygon)
            polygonGroup.group.add(polygon)
          }
        }).update(function (newIdx, oldIdx) {
          let polygon = inner$j(polygonGroup).data.getItemGraphicEl(oldIdx)
          const layout = areaData.getItemLayout(newIdx)

          if (!layout.allClipped) {
            if (polygon) {
              updateProps(polygon, {
                shape: {
                  points: layout.points
                }
              }, maModel, newIdx)
            } else {
              polygon = new Polygon({
                shape: {
                  points: layout.points
                }
              })
            }

            areaData.setItemGraphicEl(newIdx, polygon)
            polygonGroup.group.add(polygon)
          } else if (polygon) {
            polygonGroup.group.remove(polygon)
          }
        }).remove(function (idx) {
          const polygon = inner$j(polygonGroup).data.getItemGraphicEl(idx)
          polygonGroup.group.remove(polygon)
        }).execute()
        areaData.eachItemGraphicEl(function (polygon, idx) {
          const itemModel = areaData.getItemModel(idx)
          const style = areaData.getItemVisual(idx, 'style')
          polygon.useStyle(areaData.getItemVisual(idx, 'style'))
          setLabelStyle(polygon, getLabelStatesModels(itemModel), {
            labelFetcher: maModel,
            labelDataIndex: idx,
            defaultText: areaData.getName(idx) || '',
            inheritColor: isString(style.fill) ? modifyAlpha(style.fill, 1) : '#000'
          })
          setStatesStylesFromModel(polygon, itemModel)
          toggleHoverEmphasis(polygon, null, null, itemModel.get(['emphasis', 'disabled']))
          getECData(polygon).dataModel = maModel
        })
        inner$j(polygonGroup).data = areaData
        polygonGroup.group.silent = maModel.get('silent') || seriesModel.get('silent')
      }

      MarkAreaView.type = 'markArea'
      return MarkAreaView
    }(MarkerView))

  function createList$2 (coordSys, seriesModel, maModel) {
    let areaData
    let dataDims
    const dims = ['x0', 'y0', 'x1', 'y1']

    if (coordSys) {
      const coordDimsInfos_1 = map(coordSys && coordSys.dimensions, function (coordDim) {
        const data = seriesModel.getData()
        const info = data.getDimensionInfo(data.mapDimension(coordDim)) || {} // In map series data don't have lng and lat dimension. Fallback to same with coordSys

        return extend(extend({}, info), {
          name: coordDim,
          // DON'T use ordinalMeta to parse and collect ordinal.
          ordinalMeta: null
        })
      })
      dataDims = map(dims, function (dim, idx) {
        return {
          name: dim,
          type: coordDimsInfos_1[idx % 2].type
        }
      })
      areaData = new SeriesData(dataDims, maModel)
    } else {
      dataDims = [{
        name: 'value',
        type: 'float'
      }]
      areaData = new SeriesData(dataDims, maModel)
    }

    let optData = map(maModel.get('data'), curry(markAreaTransform, seriesModel, coordSys, maModel))

    if (coordSys) {
      optData = filter(optData, curry(markAreaFilter, coordSys))
    }

    const dimValueGetter = coordSys ? function (item, dimName, dataIndex, dimIndex) {
      // TODO should convert to ParsedValue?
      const rawVal = item.coord[Math.floor(dimIndex / 2)][dimIndex % 2]
      return parseDataValue(rawVal, dataDims[dimIndex])
    } : function (item, dimName, dataIndex, dimIndex) {
      return parseDataValue(item.value, dataDims[dimIndex])
    }
    areaData.initData(optData, null, dimValueGetter)
    areaData.hasItemOption = true
    return areaData
  }

  function install$G (registers) {
    registers.registerComponentModel(MarkAreaModel)
    registers.registerComponentView(MarkAreaView)
    registers.registerPreprocessor(function (opt) {
      if (checkMarkerInSeries(opt.series, 'markArea')) {
        // Make sure markArea component is enabled
        opt.markArea = opt.markArea || {}
      }
    })
  }

  const getDefaultSelectorOptions = function (ecModel, type) {
    if (type === 'all') {
      return {
        type: 'all',
        title: ecModel.getLocaleModel().get(['legend', 'selector', 'all'])
      }
    } else if (type === 'inverse') {
      return {
        type: 'inverse',
        title: ecModel.getLocaleModel().get(['legend', 'selector', 'inverse'])
      }
    }
  }

  const LegendModel =
    /** @class */
    (function (_super) {
      __extends(LegendModel, _super)

      function LegendModel () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = LegendModel.type
        _this.layoutMode = {
          type: 'box',
          // legend.width/height are maxWidth/maxHeight actually,
          // whereas realy width/height is calculated by its content.
          // (Setting {left: 10, right: 10} does not make sense).
          // So consider the case:
          // `setOption({legend: {left: 10});`
          // then `setOption({legend: {right: 10});`
          // The previous `left` should be cleared by setting `ignoreSize`.
          ignoreSize: true
        }
        return _this
      }

      LegendModel.prototype.init = function (option, parentModel, ecModel) {
        this.mergeDefaultAndTheme(option, ecModel)
        option.selected = option.selected || {}

        this._updateSelector(option)
      }

      LegendModel.prototype.mergeOption = function (option, ecModel) {
        _super.prototype.mergeOption.call(this, option, ecModel)

        this._updateSelector(option)
      }

      LegendModel.prototype._updateSelector = function (option) {
        let selector = option.selector
        const ecModel = this.ecModel

        if (selector === true) {
          selector = option.selector = ['all', 'inverse']
        }

        if (isArray(selector)) {
          each(selector, function (item, index) {
            isString(item) && (item = {
              type: item
            })
            selector[index] = merge(item, getDefaultSelectorOptions(ecModel, item.type))
          })
        }
      }

      LegendModel.prototype.optionUpdated = function () {
        this._updateData(this.ecModel)

        const legendData = this._data // If selectedMode is single, try to select one

        if (legendData[0] && this.get('selectedMode') === 'single') {
          let hasSelected = false // If has any selected in option.selected

          for (let i = 0; i < legendData.length; i++) {
            const name_1 = legendData[i].get('name')

            if (this.isSelected(name_1)) {
              // Force to unselect others
              this.select(name_1)
              hasSelected = true
              break
            }
          } // Try select the first if selectedMode is single

          !hasSelected && this.select(legendData[0].get('name'))
        }
      }

      LegendModel.prototype._updateData = function (ecModel) {
        let potentialData = []
        let availableNames = []
        ecModel.eachRawSeries(function (seriesModel) {
          const seriesName = seriesModel.name
          availableNames.push(seriesName)
          let isPotential

          if (seriesModel.legendVisualProvider) {
            const provider = seriesModel.legendVisualProvider
            const names = provider.getAllNames()

            if (!ecModel.isSeriesFiltered(seriesModel)) {
              availableNames = availableNames.concat(names)
            }

            if (names.length) {
              potentialData = potentialData.concat(names)
            } else {
              isPotential = true
            }
          } else {
            isPotential = true
          }

          if (isPotential && isNameSpecified(seriesModel)) {
            potentialData.push(seriesModel.name)
          }
        })
        /**
         * @type {Array.<string>}
         * @private
         */

        this._availableNames = availableNames // If legend.data not specified in option, use availableNames as data,
        // which is convinient for user preparing option.

        const rawData = this.get('data') || potentialData
        const legendData = map(rawData, function (dataItem) {
          // Can be string or number
          if (isString(dataItem) || isNumber(dataItem)) {
            dataItem = {
              name: dataItem
            }
          }

          return new Model(dataItem, this, this.ecModel)
        }, this)
        /**
         * @type {Array.<module:echarts/model/Model>}
         * @private
         */

        this._data = legendData
      }

      LegendModel.prototype.getData = function () {
        return this._data
      }

      LegendModel.prototype.select = function (name) {
        const selected = this.option.selected
        const selectedMode = this.get('selectedMode')

        if (selectedMode === 'single') {
          const data = this._data
          each(data, function (dataItem) {
            selected[dataItem.get('name')] = false
          })
        }

        selected[name] = true
      }

      LegendModel.prototype.unSelect = function (name) {
        if (this.get('selectedMode') !== 'single') {
          this.option.selected[name] = false
        }
      }

      LegendModel.prototype.toggleSelected = function (name) {
        const selected = this.option.selected // Default is true

        if (!selected.hasOwnProperty(name)) {
          selected[name] = true
        }

        this[selected[name] ? 'unSelect' : 'select'](name)
      }

      LegendModel.prototype.allSelect = function () {
        const data = this._data
        const selected = this.option.selected
        each(data, function (dataItem) {
          selected[dataItem.get('name', true)] = true
        })
      }

      LegendModel.prototype.inverseSelect = function () {
        const data = this._data
        const selected = this.option.selected
        each(data, function (dataItem) {
          const name = dataItem.get('name', true) // Initially, default value is true

          if (!selected.hasOwnProperty(name)) {
            selected[name] = true
          }

          selected[name] = !selected[name]
        })
      }

      LegendModel.prototype.isSelected = function (name) {
        const selected = this.option.selected
        return !(selected.hasOwnProperty(name) && !selected[name]) && indexOf(this._availableNames, name) >= 0
      }

      LegendModel.prototype.getOrient = function () {
        return this.get('orient') === 'vertical'
          ? {
              index: 1,
              name: 'vertical'
            }
          : {
              index: 0,
              name: 'horizontal'
            }
      }

      LegendModel.type = 'legend.plain'
      LegendModel.dependencies = ['series']
      LegendModel.defaultOption = {
        // zlevel: 0,
        z: 4,
        show: true,
        orient: 'horizontal',
        left: 'center',
        // right: 'center',
        top: 0,
        // bottom: null,
        align: 'auto',
        backgroundColor: 'rgba(0,0,0,0)',
        borderColor: '#ccc',
        borderRadius: 0,
        borderWidth: 0,
        padding: 5,
        itemGap: 10,
        itemWidth: 25,
        itemHeight: 14,
        symbolRotate: 'inherit',
        symbolKeepAspect: true,
        inactiveColor: '#ccc',
        inactiveBorderColor: '#ccc',
        inactiveBorderWidth: 'auto',
        itemStyle: {
          color: 'inherit',
          opacity: 'inherit',
          borderColor: 'inherit',
          borderWidth: 'auto',
          borderCap: 'inherit',
          borderJoin: 'inherit',
          borderDashOffset: 'inherit',
          borderMiterLimit: 'inherit'
        },
        lineStyle: {
          width: 'auto',
          color: 'inherit',
          inactiveColor: '#ccc',
          inactiveWidth: 2,
          opacity: 'inherit',
          type: 'inherit',
          cap: 'inherit',
          join: 'inherit',
          dashOffset: 'inherit',
          miterLimit: 'inherit'
        },
        textStyle: {
          color: '#333'
        },
        selectedMode: true,
        selector: false,
        selectorLabel: {
          show: true,
          borderRadius: 10,
          padding: [3, 5, 3, 5],
          fontSize: 12,
          fontFamily: 'sans-serif',
          color: '#666',
          borderWidth: 1,
          borderColor: '#666'
        },
        emphasis: {
          selectorLabel: {
            show: true,
            color: '#eee',
            backgroundColor: '#666'
          }
        },
        selectorPosition: 'auto',
        selectorItemGap: 7,
        selectorButtonGap: 10,
        tooltip: {
          show: false
        }
      }
      return LegendModel
    }(ComponentModel))

  const curry$1 = curry
  const each$c = each
  const Group$2 = Group

  const LegendView =
    /** @class */
    (function (_super) {
      __extends(LegendView, _super)

      function LegendView () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = LegendView.type
        _this.newlineDisabled = false
        return _this
      }

      LegendView.prototype.init = function () {
        this.group.add(this._contentGroup = new Group$2())
        this.group.add(this._selectorGroup = new Group$2())
        this._isFirstRender = true
      }
      /**
       * @protected
       */

      LegendView.prototype.getContentGroup = function () {
        return this._contentGroup
      }
      /**
       * @protected
       */

      LegendView.prototype.getSelectorGroup = function () {
        return this._selectorGroup
      }
      /**
       * @override
       */

      LegendView.prototype.render = function (legendModel, ecModel, api) {
        const isFirstRender = this._isFirstRender
        this._isFirstRender = false
        this.resetInner()

        if (!legendModel.get('show', true)) {
          return
        }

        let itemAlign = legendModel.get('align')
        const orient = legendModel.get('orient')

        if (!itemAlign || itemAlign === 'auto') {
          itemAlign = legendModel.get('left') === 'right' && orient === 'vertical' ? 'right' : 'left'
        } // selector has been normalized to an array in model

        const selector = legendModel.get('selector', true)
        let selectorPosition = legendModel.get('selectorPosition', true)

        if (selector && (!selectorPosition || selectorPosition === 'auto')) {
          selectorPosition = orient === 'horizontal' ? 'end' : 'start'
        }

        this.renderInner(itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition) // Perform layout.

        const positionInfo = legendModel.getBoxLayoutParams()
        const viewportSize = {
          width: api.getWidth(),
          height: api.getHeight()
        }
        const padding = legendModel.get('padding')
        const maxSize = getLayoutRect(positionInfo, viewportSize, padding)
        const mainRect = this.layoutInner(legendModel, itemAlign, maxSize, isFirstRender, selector, selectorPosition) // Place mainGroup, based on the calculated `mainRect`.

        const layoutRect = getLayoutRect(defaults({
          width: mainRect.width,
          height: mainRect.height
        }, positionInfo), viewportSize, padding)
        this.group.x = layoutRect.x - mainRect.x
        this.group.y = layoutRect.y - mainRect.y
        this.group.markRedraw() // Render background after group is layout.

        this.group.add(this._backgroundEl = makeBackground(mainRect, legendModel))
      }

      LegendView.prototype.resetInner = function () {
        this.getContentGroup().removeAll()
        this._backgroundEl && this.group.remove(this._backgroundEl)
        this.getSelectorGroup().removeAll()
      }

      LegendView.prototype.renderInner = function (itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition) {
        const contentGroup = this.getContentGroup()
        const legendDrawnMap = createHashMap()
        const selectMode = legendModel.get('selectedMode')
        const excludeSeriesId = []
        ecModel.eachRawSeries(function (seriesModel) {
          !seriesModel.get('legendHoverLink') && excludeSeriesId.push(seriesModel.id)
        })
        each$c(legendModel.getData(), function (legendItemModel, dataIndex) {
          const name = legendItemModel.get('name') // Use empty string or \n as a newline string

          if (!this.newlineDisabled && (name === '' || name === '\n')) {
            const g = new Group$2() // @ts-ignore

            g.newline = true
            contentGroup.add(g)
            return
          } // Representitive series.

          const seriesModel = ecModel.getSeriesByName(name)[0]

          if (legendDrawnMap.get(name)) {
            // Have been drawed
            return
          } // Legend to control series.

          if (seriesModel) {
            const data = seriesModel.getData()
            const lineVisualStyle = data.getVisual('legendLineStyle') || {}
            const legendIcon = data.getVisual('legendIcon')
            /**
             * `data.getVisual('style')` may be the color from the register
             * in series. For example, for line series,
             */

            const style = data.getVisual('style')

            const itemGroup = this._createItem(seriesModel, name, dataIndex, legendItemModel, legendModel, itemAlign, lineVisualStyle, style, legendIcon, selectMode, api)

            itemGroup.on('click', curry$1(dispatchSelectAction, name, null, api, excludeSeriesId)).on('mouseover', curry$1(dispatchHighlightAction, seriesModel.name, null, api, excludeSeriesId)).on('mouseout', curry$1(dispatchDownplayAction, seriesModel.name, null, api, excludeSeriesId))
            legendDrawnMap.set(name, true)
          } else {
            // Legend to control data. In pie and funnel.
            ecModel.eachRawSeries(function (seriesModel) {
              // In case multiple series has same data name
              if (legendDrawnMap.get(name)) {
                return
              }

              if (seriesModel.legendVisualProvider) {
                const provider = seriesModel.legendVisualProvider

                if (!provider.containName(name)) {
                  return
                }

                const idx = provider.indexOfName(name)
                let style = provider.getItemVisual(idx, 'style')
                const legendIcon = provider.getItemVisual(idx, 'legendIcon')
                const colorArr = parse(style.fill) // Color may be set to transparent in visualMap when data is out of range.
                // Do not show nothing.

                if (colorArr && colorArr[3] === 0) {
                  colorArr[3] = 0.2 // TODO color is set to 0, 0, 0, 0. Should show correct RGBA

                  style = extend(extend({}, style), {
                    fill: stringify(colorArr, 'rgba')
                  })
                }

                const itemGroup = this._createItem(seriesModel, name, dataIndex, legendItemModel, legendModel, itemAlign, {}, style, legendIcon, selectMode, api) // FIXME: consider different series has items with the same name.

                itemGroup.on('click', curry$1(dispatchSelectAction, null, name, api, excludeSeriesId)) // Should not specify the series name, consider legend controls
                // more than one pie series.
                  .on('mouseover', curry$1(dispatchHighlightAction, null, name, api, excludeSeriesId)).on('mouseout', curry$1(dispatchDownplayAction, null, name, api, excludeSeriesId))
                legendDrawnMap.set(name, true)
              }
            }, this)
          }

          if ('development' !== 'production') {
            if (!legendDrawnMap.get(name)) {
              console.warn(name + ' series not exists. Legend data should be same with series name or data name.')
            }
          }
        }, this)

        if (selector) {
          this._createSelector(selector, legendModel, api, orient, selectorPosition)
        }
      }

      LegendView.prototype._createSelector = function (selector, legendModel, api, orient, selectorPosition) {
        const selectorGroup = this.getSelectorGroup()
        each$c(selector, function createSelectorButton (selectorItem) {
          const type = selectorItem.type
          const labelText = new ZRText({
            style: {
              x: 0,
              y: 0,
              align: 'center',
              verticalAlign: 'middle'
            },
            onclick: function () {
              api.dispatchAction({
                type: type === 'all' ? 'legendAllSelect' : 'legendInverseSelect'
              })
            }
          })
          selectorGroup.add(labelText)
          const labelModel = legendModel.getModel('selectorLabel')
          const emphasisLabelModel = legendModel.getModel(['emphasis', 'selectorLabel'])
          setLabelStyle(labelText, {
            normal: labelModel,
            emphasis: emphasisLabelModel
          }, {
            defaultText: selectorItem.title
          })
          enableHoverEmphasis(labelText)
        })
      }

      LegendView.prototype._createItem = function (seriesModel, name, dataIndex, legendItemModel, legendModel, itemAlign, lineVisualStyle, itemVisualStyle, legendIcon, selectMode, api) {
        const drawType = seriesModel.visualDrawType
        const itemWidth = legendModel.get('itemWidth')
        const itemHeight = legendModel.get('itemHeight')
        const isSelected = legendModel.isSelected(name)
        const iconRotate = legendItemModel.get('symbolRotate')
        const symbolKeepAspect = legendItemModel.get('symbolKeepAspect')
        const legendIconType = legendItemModel.get('icon')
        legendIcon = legendIconType || legendIcon || 'roundRect'
        const style = getLegendStyle(legendIcon, legendItemModel, lineVisualStyle, itemVisualStyle, drawType, isSelected, api)
        const itemGroup = new Group$2()
        const textStyleModel = legendItemModel.getModel('textStyle')

        if (isFunction(seriesModel.getLegendIcon) && (!legendIconType || legendIconType === 'inherit')) {
          // Series has specific way to define legend icon
          itemGroup.add(seriesModel.getLegendIcon({
            itemWidth: itemWidth,
            itemHeight: itemHeight,
            icon: legendIcon,
            iconRotate: iconRotate,
            itemStyle: style.itemStyle,
            lineStyle: style.lineStyle,
            symbolKeepAspect: symbolKeepAspect
          }))
        } else {
          // Use default legend icon policy for most series
          const rotate = legendIconType === 'inherit' && seriesModel.getData().getVisual('symbol') ? iconRotate === 'inherit' ? seriesModel.getData().getVisual('symbolRotate') : iconRotate : 0 // No rotation for no icon

          itemGroup.add(getDefaultLegendIcon({
            itemWidth: itemWidth,
            itemHeight: itemHeight,
            icon: legendIcon,
            iconRotate: rotate,
            itemStyle: style.itemStyle,
            lineStyle: style.lineStyle,
            symbolKeepAspect: symbolKeepAspect
          }))
        }

        const textX = itemAlign === 'left' ? itemWidth + 5 : -5
        const textAlign = itemAlign
        const formatter = legendModel.get('formatter')
        let content = name

        if (isString(formatter) && formatter) {
          content = formatter.replace('{name}', name != null ? name : '')
        } else if (isFunction(formatter)) {
          content = formatter(name)
        }

        const inactiveColor = legendItemModel.get('inactiveColor')
        itemGroup.add(new ZRText({
          style: createTextStyle(textStyleModel, {
            text: content,
            x: textX,
            y: itemHeight / 2,
            fill: isSelected ? textStyleModel.getTextColor() : inactiveColor,
            align: textAlign,
            verticalAlign: 'middle'
          })
        })) // Add a invisible rect to increase the area of mouse hover

        const hitRect = new Rect({
          shape: itemGroup.getBoundingRect(),
          invisible: true
        })
        const tooltipModel = legendItemModel.getModel('tooltip')

        if (tooltipModel.get('show')) {
          setTooltipConfig({
            el: hitRect,
            componentModel: legendModel,
            itemName: name,
            itemTooltipOption: tooltipModel.option
          })
        }

        itemGroup.add(hitRect)
        itemGroup.eachChild(function (child) {
          child.silent = true
        })
        hitRect.silent = !selectMode
        this.getContentGroup().add(itemGroup)
        enableHoverEmphasis(itemGroup) // @ts-ignore

        itemGroup.__legendDataIndex = dataIndex
        return itemGroup
      }

      LegendView.prototype.layoutInner = function (legendModel, itemAlign, maxSize, isFirstRender, selector, selectorPosition) {
        const contentGroup = this.getContentGroup()
        const selectorGroup = this.getSelectorGroup() // Place items in contentGroup.

        box(legendModel.get('orient'), contentGroup, legendModel.get('itemGap'), maxSize.width, maxSize.height)
        const contentRect = contentGroup.getBoundingRect()
        const contentPos = [-contentRect.x, -contentRect.y]
        selectorGroup.markRedraw()
        contentGroup.markRedraw()

        if (selector) {
          // Place buttons in selectorGroup
          box( // Buttons in selectorGroup always layout horizontally
            'horizontal', selectorGroup, legendModel.get('selectorItemGap', true))
          const selectorRect = selectorGroup.getBoundingRect()
          const selectorPos = [-selectorRect.x, -selectorRect.y]
          const selectorButtonGap = legendModel.get('selectorButtonGap', true)
          const orientIdx = legendModel.getOrient().index
          const wh = orientIdx === 0 ? 'width' : 'height'
          const hw = orientIdx === 0 ? 'height' : 'width'
          const yx = orientIdx === 0 ? 'y' : 'x'

          if (selectorPosition === 'end') {
            selectorPos[orientIdx] += contentRect[wh] + selectorButtonGap
          } else {
            contentPos[orientIdx] += selectorRect[wh] + selectorButtonGap
          } // Always align selector to content as 'middle'

          selectorPos[1 - orientIdx] += contentRect[hw] / 2 - selectorRect[hw] / 2
          selectorGroup.x = selectorPos[0]
          selectorGroup.y = selectorPos[1]
          contentGroup.x = contentPos[0]
          contentGroup.y = contentPos[1]
          const mainRect = {
            x: 0,
            y: 0
          }
          mainRect[wh] = contentRect[wh] + selectorButtonGap + selectorRect[wh]
          mainRect[hw] = Math.max(contentRect[hw], selectorRect[hw])
          mainRect[yx] = Math.min(0, selectorRect[yx] + selectorPos[1 - orientIdx])
          return mainRect
        } else {
          contentGroup.x = contentPos[0]
          contentGroup.y = contentPos[1]
          return this.group.getBoundingRect()
        }
      }
      /**
       * @protected
       */

      LegendView.prototype.remove = function () {
        this.getContentGroup().removeAll()
        this._isFirstRender = true
      }

      LegendView.type = 'legend.plain'
      return LegendView
    }(ComponentView))

  function getLegendStyle (iconType, legendItemModel, lineVisualStyle, itemVisualStyle, drawType, isSelected, api) {
    /**
       * Use series style if is inherit;
       * elsewise, use legend style
       */
    function handleCommonProps (style, visualStyle) {
      // If lineStyle.width is 'auto', it is set to be 2 if series has border
      if (style.lineWidth === 'auto') {
        style.lineWidth = visualStyle.lineWidth > 0 ? 2 : 0
      }

      each$c(style, function (propVal, propName) {
        style[propName] === 'inherit' && (style[propName] = visualStyle[propName])
      })
    } // itemStyle

    const itemStyleModel = legendItemModel.getModel('itemStyle')
    const itemStyle = itemStyleModel.getItemStyle()
    const iconBrushType = iconType.lastIndexOf('empty', 0) === 0 ? 'fill' : 'stroke'
    const decalStyle = itemStyleModel.getShallow('decal')
    itemStyle.decal = !decalStyle || decalStyle === 'inherit' ? itemVisualStyle.decal : createOrUpdatePatternFromDecal(decalStyle, api)

    if (itemStyle.fill === 'inherit') {
      /**
         * Series with visualDrawType as 'stroke' should have
         * series stroke as legend fill
         */
      itemStyle.fill = itemVisualStyle[drawType]
    }

    if (itemStyle.stroke === 'inherit') {
      /**
         * icon type with "emptyXXX" should use fill color
         * in visual style
         */
      itemStyle.stroke = itemVisualStyle[iconBrushType]
    }

    if (itemStyle.opacity === 'inherit') {
      /**
         * Use lineStyle.opacity if drawType is stroke
         */
      itemStyle.opacity = (drawType === 'fill' ? itemVisualStyle : lineVisualStyle).opacity
    }

    handleCommonProps(itemStyle, itemVisualStyle) // lineStyle

    const legendLineModel = legendItemModel.getModel('lineStyle')
    const lineStyle = legendLineModel.getLineStyle()
    handleCommonProps(lineStyle, lineVisualStyle) // Fix auto color to real color

    itemStyle.fill === 'auto' && (itemStyle.fill = itemVisualStyle.fill)
    itemStyle.stroke === 'auto' && (itemStyle.stroke = itemVisualStyle.fill)
    lineStyle.stroke === 'auto' && (lineStyle.stroke = itemVisualStyle.fill)

    if (!isSelected) {
      const borderWidth = legendItemModel.get('inactiveBorderWidth')
      /**
         * Since stroke is set to be inactiveBorderColor, it may occur that
         * there is no border in series but border in legend, so we need to
         * use border only when series has border if is set to be auto
         */

      const visualHasBorder = itemStyle[iconBrushType]
      itemStyle.lineWidth = borderWidth === 'auto' ? itemVisualStyle.lineWidth > 0 && visualHasBorder ? 2 : 0 : itemStyle.lineWidth
      itemStyle.fill = legendItemModel.get('inactiveColor')
      itemStyle.stroke = legendItemModel.get('inactiveBorderColor')
      lineStyle.stroke = legendLineModel.get('inactiveColor')
      lineStyle.lineWidth = legendLineModel.get('inactiveWidth')
    }

    return {
      itemStyle: itemStyle,
      lineStyle: lineStyle
    }
  }

  function getDefaultLegendIcon (opt) {
    const symboType = opt.icon || 'roundRect'
    const icon = createSymbol(symboType, 0, 0, opt.itemWidth, opt.itemHeight, opt.itemStyle.fill, opt.symbolKeepAspect)
    icon.setStyle(opt.itemStyle)
    icon.rotation = (opt.iconRotate || 0) * Math.PI / 180
    icon.setOrigin([opt.itemWidth / 2, opt.itemHeight / 2])

    if (symboType.indexOf('empty') > -1) {
      icon.style.stroke = icon.style.fill
      icon.style.fill = '#fff'
      icon.style.lineWidth = 2
    }

    return icon
  }

  function dispatchSelectAction (seriesName, dataName, api, excludeSeriesId) {
    // downplay before unselect
    dispatchDownplayAction(seriesName, dataName, api, excludeSeriesId)
    api.dispatchAction({
      type: 'legendToggleSelect',
      name: seriesName != null ? seriesName : dataName
    }) // highlight after select
    // TODO higlight immediately may cause animation loss.

    dispatchHighlightAction(seriesName, dataName, api, excludeSeriesId)
  }

  function isUseHoverLayer (api) {
    const list = api.getZr().storage.getDisplayList()
    let emphasisState
    let i = 0
    const len = list.length

    while (i < len && !(emphasisState = list[i].states.emphasis)) {
      i++
    }

    return emphasisState && emphasisState.hoverLayer
  }

  function dispatchHighlightAction (seriesName, dataName, api, excludeSeriesId) {
    // If element hover will move to a hoverLayer.
    if (!isUseHoverLayer(api)) {
      api.dispatchAction({
        type: 'highlight',
        seriesName: seriesName,
        name: dataName,
        excludeSeriesId: excludeSeriesId
      })
    }
  }

  function dispatchDownplayAction (seriesName, dataName, api, excludeSeriesId) {
    // If element hover will move to a hoverLayer.
    if (!isUseHoverLayer(api)) {
      api.dispatchAction({
        type: 'downplay',
        seriesName: seriesName,
        name: dataName,
        excludeSeriesId: excludeSeriesId
      })
    }
  }

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

  /**
     * AUTO-GENERATED FILE. DO NOT MODIFY.
     */

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
  function legendFilter (ecModel) {
    const legendModels = ecModel.findComponents({
      mainType: 'legend'
    })

    if (legendModels && legendModels.length) {
      ecModel.filterSeries(function (series) {
        // If in any legend component the status is not selected.
        // Because in legend series is assumed selected when it is not in the legend data.
        for (let i = 0; i < legendModels.length; i++) {
          if (!legendModels[i].isSelected(series.name)) {
            return false
          }
        }

        return true
      })
    }
  }

  function legendSelectActionHandler (methodName, payload, ecModel) {
    const selectedMap = {}
    const isToggleSelect = methodName === 'toggleSelected'
    let isSelected // Update all legend components

    ecModel.eachComponent('legend', function (legendModel) {
      if (isToggleSelect && isSelected != null) {
        // Force other legend has same selected status
        // Or the first is toggled to true and other are toggled to false
        // In the case one legend has some item unSelected in option. And if other legend
        // doesn't has the item, they will assume it is selected.
        legendModel[isSelected ? 'select' : 'unSelect'](payload.name)
      } else if (methodName === 'allSelect' || methodName === 'inverseSelect') {
        legendModel[methodName]()
      } else {
        legendModel[methodName](payload.name)
        isSelected = legendModel.isSelected(payload.name)
      }

      const legendData = legendModel.getData()
      each(legendData, function (model) {
        const name = model.get('name') // Wrap element

        if (name === '\n' || name === '') {
          return
        }

        const isItemSelected = legendModel.isSelected(name)

        if (selectedMap.hasOwnProperty(name)) {
          // Unselected if any legend is unselected
          selectedMap[name] = selectedMap[name] && isItemSelected
        } else {
          selectedMap[name] = isItemSelected
        }
      })
    }) // Return the event explicitly

    return methodName === 'allSelect' || methodName === 'inverseSelect'
      ? {
          selected: selectedMap
        }
      : {
          name: payload.name,
          selected: selectedMap
        }
  }

  function installLegendAction (registers) {
    /**
       * @event legendToggleSelect
       * @type {Object}
       * @property {string} type 'legendToggleSelect'
       * @property {string} [from]
       * @property {string} name Series name or data item name
       */
    registers.registerAction('legendToggleSelect', 'legendselectchanged', curry(legendSelectActionHandler, 'toggleSelected'))
    registers.registerAction('legendAllSelect', 'legendselectall', curry(legendSelectActionHandler, 'allSelect'))
    registers.registerAction('legendInverseSelect', 'legendinverseselect', curry(legendSelectActionHandler, 'inverseSelect'))
    /**
       * @event legendSelect
       * @type {Object}
       * @property {string} type 'legendSelect'
       * @property {string} name Series name or data item name
       */

    registers.registerAction('legendSelect', 'legendselected', curry(legendSelectActionHandler, 'select'))
    /**
       * @event legendUnSelect
       * @type {Object}
       * @property {string} type 'legendUnSelect'
       * @property {string} name Series name or data item name
       */

    registers.registerAction('legendUnSelect', 'legendunselected', curry(legendSelectActionHandler, 'unSelect'))
  }

  function install$H (registers) {
    registers.registerComponentModel(LegendModel)
    registers.registerComponentView(LegendView)
    registers.registerProcessor(registers.PRIORITY.PROCESSOR.SERIES_FILTER, legendFilter)
    registers.registerSubTypeDefaulter('legend', function () {
      return 'plain'
    })
    installLegendAction(registers)
  }

  const ScrollableLegendModel =
    /** @class */
    (function (_super) {
      __extends(ScrollableLegendModel, _super)

      function ScrollableLegendModel () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = ScrollableLegendModel.type
        return _this
      }
      /**
       * @param {number} scrollDataIndex
       */

      ScrollableLegendModel.prototype.setScrollDataIndex = function (scrollDataIndex) {
        this.option.scrollDataIndex = scrollDataIndex
      }

      ScrollableLegendModel.prototype.init = function (option, parentModel, ecModel) {
        const inputPositionParams = getLayoutParams(option)

        _super.prototype.init.call(this, option, parentModel, ecModel)

        mergeAndNormalizeLayoutParams$1(this, option, inputPositionParams)
      }
      /**
       * @override
       */

      ScrollableLegendModel.prototype.mergeOption = function (option, ecModel) {
        _super.prototype.mergeOption.call(this, option, ecModel)

        mergeAndNormalizeLayoutParams$1(this, this.option, option)
      }

      ScrollableLegendModel.type = 'legend.scroll'
      ScrollableLegendModel.defaultOption = inheritDefaultOption(LegendModel.defaultOption, {
        scrollDataIndex: 0,
        pageButtonItemGap: 5,
        pageButtonGap: null,
        pageButtonPosition: 'end',
        pageFormatter: '{current}/{total}',
        pageIcons: {
          horizontal: ['M0,0L12,-10L12,10z', 'M0,0L-12,-10L-12,10z'],
          vertical: ['M0,0L20,0L10,-20z', 'M0,0L20,0L10,20z']
        },
        pageIconColor: '#2f4554',
        pageIconInactiveColor: '#aaa',
        pageIconSize: 15,
        pageTextStyle: {
          color: '#333'
        },
        animationDurationUpdate: 800
      })
      return ScrollableLegendModel
    }(LegendModel))

  function mergeAndNormalizeLayoutParams$1 (legendModel, target, raw) {
    const orient = legendModel.getOrient()
    const ignoreSize = [1, 1]
    ignoreSize[orient.index] = 0
    mergeLayoutParam(target, raw, {
      type: 'box',
      ignoreSize: !!ignoreSize
    })
  }

  const Group$3 = Group
  const WH$1 = ['width', 'height']
  const XY$1 = ['x', 'y']

  const ScrollableLegendView =
    /** @class */
    (function (_super) {
      __extends(ScrollableLegendView, _super)

      function ScrollableLegendView () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = ScrollableLegendView.type
        _this.newlineDisabled = true
        _this._currentIndex = 0
        return _this
      }

      ScrollableLegendView.prototype.init = function () {
        _super.prototype.init.call(this)

        this.group.add(this._containerGroup = new Group$3())

        this._containerGroup.add(this.getContentGroup())

        this.group.add(this._controllerGroup = new Group$3())
      }
      /**
       * @override
       */

      ScrollableLegendView.prototype.resetInner = function () {
        _super.prototype.resetInner.call(this)

        this._controllerGroup.removeAll()

        this._containerGroup.removeClipPath()

        this._containerGroup.__rectSize = null
      }
      /**
       * @override
       */

      ScrollableLegendView.prototype.renderInner = function (itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition) {
        const self = this // Render content items.

        _super.prototype.renderInner.call(this, itemAlign, legendModel, ecModel, api, selector, orient, selectorPosition)

        const controllerGroup = this._controllerGroup // FIXME: support be 'auto' adapt to size number text length,
        // e.g., '3/12345' should not overlap with the control arrow button.

        const pageIconSize = legendModel.get('pageIconSize', true)
        const pageIconSizeArr = isArray(pageIconSize) ? pageIconSize : [pageIconSize, pageIconSize]
        createPageButton('pagePrev', 0)
        const pageTextStyleModel = legendModel.getModel('pageTextStyle')
        controllerGroup.add(new ZRText({
          name: 'pageText',
          style: {
            // Placeholder to calculate a proper layout.
            text: 'xx/xx',
            fill: pageTextStyleModel.getTextColor(),
            font: pageTextStyleModel.getFont(),
            verticalAlign: 'middle',
            align: 'center'
          },
          silent: true
        }))
        createPageButton('pageNext', 1)

        function createPageButton (name, iconIdx) {
          const pageDataIndexName = name + 'DataIndex'
          const icon = createIcon(legendModel.get('pageIcons', true)[legendModel.getOrient().name][iconIdx], {
            // Buttons will be created in each render, so we do not need
            // to worry about avoiding using legendModel kept in scope.
            onclick: bind(self._pageGo, self, pageDataIndexName, legendModel, api)
          }, {
            x: -pageIconSizeArr[0] / 2,
            y: -pageIconSizeArr[1] / 2,
            width: pageIconSizeArr[0],
            height: pageIconSizeArr[1]
          })
          icon.name = name
          controllerGroup.add(icon)
        }
      }
      /**
       * @override
       */

      ScrollableLegendView.prototype.layoutInner = function (legendModel, itemAlign, maxSize, isFirstRender, selector, selectorPosition) {
        const selectorGroup = this.getSelectorGroup()
        const orientIdx = legendModel.getOrient().index
        const wh = WH$1[orientIdx]
        const xy = XY$1[orientIdx]
        const hw = WH$1[1 - orientIdx]
        const yx = XY$1[1 - orientIdx]
        selector && box( // Buttons in selectorGroup always layout horizontally
          'horizontal', selectorGroup, legendModel.get('selectorItemGap', true))
        const selectorButtonGap = legendModel.get('selectorButtonGap', true)
        const selectorRect = selectorGroup.getBoundingRect()
        const selectorPos = [-selectorRect.x, -selectorRect.y]
        const processMaxSize = clone(maxSize)
        selector && (processMaxSize[wh] = maxSize[wh] - selectorRect[wh] - selectorButtonGap)

        const mainRect = this._layoutContentAndController(legendModel, isFirstRender, processMaxSize, orientIdx, wh, hw, yx, xy)

        if (selector) {
          if (selectorPosition === 'end') {
            selectorPos[orientIdx] += mainRect[wh] + selectorButtonGap
          } else {
            const offset = selectorRect[wh] + selectorButtonGap
            selectorPos[orientIdx] -= offset
            mainRect[xy] -= offset
          }

          mainRect[wh] += selectorRect[wh] + selectorButtonGap
          selectorPos[1 - orientIdx] += mainRect[yx] + mainRect[hw] / 2 - selectorRect[hw] / 2
          mainRect[hw] = Math.max(mainRect[hw], selectorRect[hw])
          mainRect[yx] = Math.min(mainRect[yx], selectorRect[yx] + selectorPos[1 - orientIdx])
          selectorGroup.x = selectorPos[0]
          selectorGroup.y = selectorPos[1]
          selectorGroup.markRedraw()
        }

        return mainRect
      }

      ScrollableLegendView.prototype._layoutContentAndController = function (legendModel, isFirstRender, maxSize, orientIdx, wh, hw, yx, xy) {
        const contentGroup = this.getContentGroup()
        const containerGroup = this._containerGroup
        const controllerGroup = this._controllerGroup // Place items in contentGroup.

        box(legendModel.get('orient'), contentGroup, legendModel.get('itemGap'), !orientIdx ? null : maxSize.width, orientIdx ? null : maxSize.height)
        box( // Buttons in controller are layout always horizontally.
          'horizontal', controllerGroup, legendModel.get('pageButtonItemGap', true))
        const contentRect = contentGroup.getBoundingRect()
        const controllerRect = controllerGroup.getBoundingRect()
        const showController = this._showController = contentRect[wh] > maxSize[wh] // In case that the inner elements of contentGroup layout do not based on [0, 0]

        const contentPos = [-contentRect.x, -contentRect.y] // Remain contentPos when scroll animation perfroming.
        // If first rendering, `contentGroup.position` is [0, 0], which
        // does not make sense and may cause unexepcted animation if adopted.

        if (!isFirstRender) {
          contentPos[orientIdx] = contentGroup[xy]
        } // Layout container group based on 0.

        const containerPos = [0, 0]
        const controllerPos = [-controllerRect.x, -controllerRect.y]
        const pageButtonGap = retrieve2(legendModel.get('pageButtonGap', true), legendModel.get('itemGap', true)) // Place containerGroup and controllerGroup and contentGroup.

        if (showController) {
          const pageButtonPosition = legendModel.get('pageButtonPosition', true) // controller is on the right / bottom.

          if (pageButtonPosition === 'end') {
            controllerPos[orientIdx] += maxSize[wh] - controllerRect[wh]
          } // controller is on the left / top.
          else {
            containerPos[orientIdx] += controllerRect[wh] + pageButtonGap
          }
        } // Always align controller to content as 'middle'.

        controllerPos[1 - orientIdx] += contentRect[hw] / 2 - controllerRect[hw] / 2
        contentGroup.setPosition(contentPos)
        containerGroup.setPosition(containerPos)
        controllerGroup.setPosition(controllerPos) // Calculate `mainRect` and set `clipPath`.
        // mainRect should not be calculated by `this.group.getBoundingRect()`
        // for sake of the overflow.

        const mainRect = {
          x: 0,
          y: 0
        } // Consider content may be overflow (should be clipped).

        mainRect[wh] = showController ? maxSize[wh] : contentRect[wh]
        mainRect[hw] = Math.max(contentRect[hw], controllerRect[hw]) // `containerRect[yx] + containerPos[1 - orientIdx]` is 0.

        mainRect[yx] = Math.min(0, controllerRect[yx] + controllerPos[1 - orientIdx])
        containerGroup.__rectSize = maxSize[wh]

        if (showController) {
          const clipShape = {
            x: 0,
            y: 0
          }
          clipShape[wh] = Math.max(maxSize[wh] - controllerRect[wh] - pageButtonGap, 0)
          clipShape[hw] = mainRect[hw]
          containerGroup.setClipPath(new Rect({
            shape: clipShape
          })) // Consider content may be larger than container, container rect
          // can not be obtained from `containerGroup.getBoundingRect()`.

          containerGroup.__rectSize = clipShape[wh]
        } else {
          // Do not remove or ignore controller. Keep them set as placeholders.
          controllerGroup.eachChild(function (child) {
            child.attr({
              invisible: true,
              silent: true
            })
          })
        } // Content translate animation.

        const pageInfo = this._getPageInfo(legendModel)

        pageInfo.pageIndex != null && updateProps(contentGroup, {
          x: pageInfo.contentPosition[0],
          y: pageInfo.contentPosition[1]
        }, // When switch from "show controller" to "not show controller", view should be
        // updated immediately without animation, otherwise causes weird effect.
        showController ? legendModel : null)

        this._updatePageInfoView(legendModel, pageInfo)

        return mainRect
      }

      ScrollableLegendView.prototype._pageGo = function (to, legendModel, api) {
        const scrollDataIndex = this._getPageInfo(legendModel)[to]

        scrollDataIndex != null && api.dispatchAction({
          type: 'legendScroll',
          scrollDataIndex: scrollDataIndex,
          legendId: legendModel.id
        })
      }

      ScrollableLegendView.prototype._updatePageInfoView = function (legendModel, pageInfo) {
        const controllerGroup = this._controllerGroup
        each(['pagePrev', 'pageNext'], function (name) {
          const key = name + 'DataIndex'
          const canJump = pageInfo[key] != null
          const icon = controllerGroup.childOfName(name)

          if (icon) {
            icon.setStyle('fill', canJump ? legendModel.get('pageIconColor', true) : legendModel.get('pageIconInactiveColor', true))
            icon.cursor = canJump ? 'pointer' : 'default'
          }
        })
        const pageText = controllerGroup.childOfName('pageText')
        const pageFormatter = legendModel.get('pageFormatter')
        const pageIndex = pageInfo.pageIndex
        const current = pageIndex != null ? pageIndex + 1 : 0
        const total = pageInfo.pageCount
        pageText && pageFormatter && pageText.setStyle('text', isString(pageFormatter)
          ? pageFormatter.replace('{current}', current == null ? '' : current + '').replace('{total}', total == null ? '' : total + '')
          : pageFormatter({
            current: current,
            total: total
          }))
      }
      /**
       *  contentPosition: Array.<number>, null when data item not found.
       *  pageIndex: number, null when data item not found.
       *  pageCount: number, always be a number, can be 0.
       *  pagePrevDataIndex: number, null when no previous page.
       *  pageNextDataIndex: number, null when no next page.
       * }
       */

      ScrollableLegendView.prototype._getPageInfo = function (legendModel) {
        const scrollDataIndex = legendModel.get('scrollDataIndex', true)
        const contentGroup = this.getContentGroup()
        const containerRectSize = this._containerGroup.__rectSize
        const orientIdx = legendModel.getOrient().index
        const wh = WH$1[orientIdx]
        const xy = XY$1[orientIdx]

        const targetItemIndex = this._findTargetItemIndex(scrollDataIndex)

        const children = contentGroup.children()
        const targetItem = children[targetItemIndex]
        const itemCount = children.length
        const pCount = !itemCount ? 0 : 1
        const result = {
          contentPosition: [contentGroup.x, contentGroup.y],
          pageCount: pCount,
          pageIndex: pCount - 1,
          pagePrevDataIndex: null,
          pageNextDataIndex: null
        }

        if (!targetItem) {
          return result
        }

        const targetItemInfo = getItemInfo(targetItem)
        result.contentPosition[orientIdx] = -targetItemInfo.s // Strategy:
        // (1) Always align based on the left/top most item.
        // (2) It is user-friendly that the last item shown in the
        // current window is shown at the begining of next window.
        // Otherwise if half of the last item is cut by the window,
        // it will have no chance to display entirely.
        // (3) Consider that item size probably be different, we
        // have calculate pageIndex by size rather than item index,
        // and we can not get page index directly by division.
        // (4) The window is to narrow to contain more than
        // one item, we should make sure that the page can be fliped.

        for (var i = targetItemIndex + 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i <= itemCount; ++i) {
          currItemInfo = getItemInfo(children[i])

          if ( // Half of the last item is out of the window.
            !currItemInfo && winEndItemInfo.e > winStartItemInfo.s + containerRectSize || // If the current item does not intersect with the window, the new page
          // can be started at the current item or the last item.
          currItemInfo && !intersect(currItemInfo, winStartItemInfo.s)) {
            if (winEndItemInfo.i > winStartItemInfo.i) {
              winStartItemInfo = winEndItemInfo
            } else {
              // e.g., when page size is smaller than item size.
              winStartItemInfo = currItemInfo
            }

            if (winStartItemInfo) {
              if (result.pageNextDataIndex == null) {
                result.pageNextDataIndex = winStartItemInfo.i
              }

              ++result.pageCount
            }
          }

          winEndItemInfo = currItemInfo
        }

        for (var i = targetItemIndex - 1, winStartItemInfo = targetItemInfo, winEndItemInfo = targetItemInfo, currItemInfo = null; i >= -1; --i) {
          currItemInfo = getItemInfo(children[i])

          if ( // If the the end item does not intersect with the window started
          // from the current item, a page can be settled.
            (!currItemInfo || !intersect(winEndItemInfo, currItemInfo.s)) && // e.g., when page size is smaller than item size.
          winStartItemInfo.i < winEndItemInfo.i) {
            winEndItemInfo = winStartItemInfo

            if (result.pagePrevDataIndex == null) {
              result.pagePrevDataIndex = winStartItemInfo.i
            }

            ++result.pageCount
            ++result.pageIndex
          }

          winStartItemInfo = currItemInfo
        }

        return result

        function getItemInfo (el) {
          if (el) {
            const itemRect = el.getBoundingRect()
            const start = itemRect[xy] + el[xy]
            return {
              s: start,
              e: start + itemRect[wh],
              i: el.__legendDataIndex
            }
          }
        }

        function intersect (itemInfo, winStart) {
          return itemInfo.e >= winStart && itemInfo.s <= winStart + containerRectSize
        }
      }

      ScrollableLegendView.prototype._findTargetItemIndex = function (targetDataIndex) {
        if (!this._showController) {
          return 0
        }

        let index
        const contentGroup = this.getContentGroup()
        let defaultIndex
        contentGroup.eachChild(function (child, idx) {
          const legendDataIdx = child.__legendDataIndex // FIXME
          // If the given targetDataIndex (from model) is illegal,
          // we use defaultIndex. But the index on the legend model and
          // action payload is still illegal. That case will not be
          // changed until some scenario requires.

          if (defaultIndex == null && legendDataIdx != null) {
            defaultIndex = idx
          }

          if (legendDataIdx === targetDataIndex) {
            index = idx
          }
        })
        return index != null ? index : defaultIndex
      }

      ScrollableLegendView.type = 'legend.scroll'
      return ScrollableLegendView
    }(LegendView))

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

  /**
     * AUTO-GENERATED FILE. DO NOT MODIFY.
     */

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
  function installScrollableLegendAction (registers) {
    /**
       * @event legendScroll
       * @type {Object}
       * @property {string} type 'legendScroll'
       * @property {string} scrollDataIndex
       */
    registers.registerAction('legendScroll', 'legendscroll', function (payload, ecModel) {
      const scrollDataIndex = payload.scrollDataIndex
      scrollDataIndex != null && ecModel.eachComponent({
        mainType: 'legend',
        subType: 'scroll',
        query: payload
      }, function (legendModel) {
        legendModel.setScrollDataIndex(scrollDataIndex)
      })
    })
  }

  function install$I (registers) {
    use(install$H)
    registers.registerComponentModel(ScrollableLegendModel)
    registers.registerComponentView(ScrollableLegendView)
    installScrollableLegendAction(registers)
  }

  function install$J (registers) {
    use(install$H)
    use(install$I)
  }

  const InsideZoomModel =
    /** @class */
    (function (_super) {
      __extends(InsideZoomModel, _super)

      function InsideZoomModel () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = InsideZoomModel.type
        return _this
      }

      InsideZoomModel.type = 'dataZoom.inside'
      InsideZoomModel.defaultOption = inheritDefaultOption(DataZoomModel.defaultOption, {
        disabled: false,
        zoomLock: false,
        zoomOnMouseWheel: true,
        moveOnMouseMove: true,
        moveOnMouseWheel: false,
        preventDefaultMouseMove: true
      })
      return InsideZoomModel
    }(DataZoomModel))

  const inner$k = makeInner()
  function setViewInfoToCoordSysRecord (api, dataZoomModel, getRange) {
    inner$k(api).coordSysRecordMap.each(function (coordSysRecord) {
      const dzInfo = coordSysRecord.dataZoomInfoMap.get(dataZoomModel.uid)

      if (dzInfo) {
        dzInfo.getRange = getRange
      }
    })
  }
  function disposeCoordSysRecordIfNeeded (api, dataZoomModel) {
    const coordSysRecordMap = inner$k(api).coordSysRecordMap
    const coordSysKeyArr = coordSysRecordMap.keys()

    for (let i = 0; i < coordSysKeyArr.length; i++) {
      const coordSysKey = coordSysKeyArr[i]
      const coordSysRecord = coordSysRecordMap.get(coordSysKey)
      const dataZoomInfoMap = coordSysRecord.dataZoomInfoMap

      if (dataZoomInfoMap) {
        const dzUid = dataZoomModel.uid
        const dzInfo = dataZoomInfoMap.get(dzUid)

        if (dzInfo) {
          dataZoomInfoMap.removeKey(dzUid)

          if (!dataZoomInfoMap.keys().length) {
            disposeCoordSysRecord(coordSysRecordMap, coordSysRecord)
          }
        }
      }
    }
  }

  function disposeCoordSysRecord (coordSysRecordMap, coordSysRecord) {
    if (coordSysRecord) {
      coordSysRecordMap.removeKey(coordSysRecord.model.uid)
      const controller = coordSysRecord.controller
      controller && controller.dispose()
    }
  }

  function createCoordSysRecord (api, coordSysModel) {
    // These init props will never change after record created.
    const coordSysRecord = {
      model: coordSysModel,
      containsPoint: curry(containsPoint, coordSysModel),
      dispatchAction: curry(dispatchAction$1, api),
      dataZoomInfoMap: null,
      controller: null
    } // Must not do anything depends on coordSysRecord outside the event handler here,
    // because coordSysRecord not completed yet.

    const controller = coordSysRecord.controller = new RoamController(api.getZr())
    each(['pan', 'zoom', 'scrollMove'], function (eventName) {
      controller.on(eventName, function (event) {
        const batch = []
        coordSysRecord.dataZoomInfoMap.each(function (dzInfo) {
          // Check whether the behaviors (zoomOnMouseWheel, moveOnMouseMove,
          // moveOnMouseWheel, ...) enabled.
          if (!event.isAvailableBehavior(dzInfo.model.option)) {
            return
          }

          const method = (dzInfo.getRange || {})[eventName]
          const range = method && method(dzInfo.dzReferCoordSysInfo, coordSysRecord.model.mainType, coordSysRecord.controller, event)
          !dzInfo.model.get('disabled', true) && range && batch.push({
            dataZoomId: dzInfo.model.id,
            start: range[0],
            end: range[1]
          })
        })
        batch.length && coordSysRecord.dispatchAction(batch)
      })
    })
    return coordSysRecord
  }
  /**
     * This action will be throttled.
     */

  function dispatchAction$1 (api, batch) {
    if (!api.isDisposed()) {
      api.dispatchAction({
        type: 'dataZoom',
        animation: {
          easing: 'cubicOut',
          duration: 100
        },
        batch: batch
      })
    }
  }

  function containsPoint (coordSysModel, e, x, y) {
    return coordSysModel.coordinateSystem.containPoint([x, y])
  }
  /**
     * Merge roamController settings when multiple dataZooms share one roamController.
     */

  function mergeControllerParams (dataZoomInfoMap) {
    let controlType // DO NOT use reserved word (true, false, undefined) as key literally. Even if encapsulated
    // as string, it is probably revert to reserved word by compress tool. See #7411.

    const prefix = 'type_'
    const typePriority = {
      type_true: 2,
      type_move: 1,
      type_false: 0,
      type_undefined: -1
    }
    let preventDefaultMouseMove = true
    dataZoomInfoMap.each(function (dataZoomInfo) {
      const dataZoomModel = dataZoomInfo.model
      const oneType = dataZoomModel.get('disabled', true) ? false : dataZoomModel.get('zoomLock', true) ? 'move' : true

      if (typePriority[prefix + oneType] > typePriority[prefix + controlType]) {
        controlType = oneType
      } // Prevent default move event by default. If one false, do not prevent. Otherwise
      // users may be confused why it does not work when multiple insideZooms exist.

      preventDefaultMouseMove = preventDefaultMouseMove && dataZoomModel.get('preventDefaultMouseMove', true)
    })
    return {
      controlType: controlType,
      opt: {
        // RoamController will enable all of these functionalities,
        // and the final behavior is determined by its event listener
        // provided by each inside zoom.
        zoomOnMouseWheel: true,
        moveOnMouseMove: true,
        moveOnMouseWheel: true,
        preventDefaultMouseMove: !!preventDefaultMouseMove
      }
    }
  }

  function installDataZoomRoamProcessor (registers) {
    registers.registerProcessor(registers.PRIORITY.PROCESSOR.FILTER, function (ecModel, api) {
      const apiInner = inner$k(api)
      const coordSysRecordMap = apiInner.coordSysRecordMap || (apiInner.coordSysRecordMap = createHashMap())
      coordSysRecordMap.each(function (coordSysRecord) {
        // `coordSysRecordMap` always exists (becuase it hold the `roam controller`, which should
        // better not re-create each time), but clear `dataZoomInfoMap` each round of the workflow.
        coordSysRecord.dataZoomInfoMap = null
      })
      ecModel.eachComponent({
        mainType: 'dataZoom',
        subType: 'inside'
      }, function (dataZoomModel) {
        const dzReferCoordSysWrap = collectReferCoordSysModelInfo(dataZoomModel)
        each(dzReferCoordSysWrap.infoList, function (dzCoordSysInfo) {
          const coordSysUid = dzCoordSysInfo.model.uid
          const coordSysRecord = coordSysRecordMap.get(coordSysUid) || coordSysRecordMap.set(coordSysUid, createCoordSysRecord(api, dzCoordSysInfo.model))
          const dataZoomInfoMap = coordSysRecord.dataZoomInfoMap || (coordSysRecord.dataZoomInfoMap = createHashMap()) // Notice these props might be changed each time for a single dataZoomModel.

          dataZoomInfoMap.set(dataZoomModel.uid, {
            dzReferCoordSysInfo: dzCoordSysInfo,
            model: dataZoomModel,
            getRange: null
          })
        })
      }) // (1) Merge dataZoom settings for each coord sys and set to the roam controller.
      // (2) Clear coord sys if not refered by any dataZoom.

      coordSysRecordMap.each(function (coordSysRecord) {
        const controller = coordSysRecord.controller
        let firstDzInfo
        const dataZoomInfoMap = coordSysRecord.dataZoomInfoMap

        if (dataZoomInfoMap) {
          const firstDzKey = dataZoomInfoMap.keys()[0]

          if (firstDzKey != null) {
            firstDzInfo = dataZoomInfoMap.get(firstDzKey)
          }
        }

        if (!firstDzInfo) {
          disposeCoordSysRecord(coordSysRecordMap, coordSysRecord)
          return
        }

        const controllerParams = mergeControllerParams(dataZoomInfoMap)
        controller.enable(controllerParams.controlType, controllerParams.opt)
        controller.setPointerChecker(coordSysRecord.containsPoint)
        createOrUpdate(coordSysRecord, 'dispatchAction', firstDzInfo.model.get('throttle', true), 'fixRate')
      })
    })
  }

  const InsideZoomView =
    /** @class */
    (function (_super) {
      __extends(InsideZoomView, _super)

      function InsideZoomView () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = 'dataZoom.inside'
        return _this
      }

      InsideZoomView.prototype.render = function (dataZoomModel, ecModel, api) {
        _super.prototype.render.apply(this, arguments)

        if (dataZoomModel.noTarget()) {
          this._clear()

          return
        } // Hence the `throttle` util ensures to preserve command order,
        // here simply updating range all the time will not cause missing
        // any of the the roam change.

        this.range = dataZoomModel.getPercentRange() // Reset controllers.

        setViewInfoToCoordSysRecord(api, dataZoomModel, {
          pan: bind(getRangeHandlers.pan, this),
          zoom: bind(getRangeHandlers.zoom, this),
          scrollMove: bind(getRangeHandlers.scrollMove, this)
        })
      }

      InsideZoomView.prototype.dispose = function () {
        this._clear()

        _super.prototype.dispose.apply(this, arguments)
      }

      InsideZoomView.prototype._clear = function () {
        disposeCoordSysRecordIfNeeded(this.api, this.dataZoomModel)
        this.range = null
      }

      InsideZoomView.type = 'dataZoom.inside'
      return InsideZoomView
    }(DataZoomView))

  var getRangeHandlers = {
    zoom: function (coordSysInfo, coordSysMainType, controller, e) {
      const lastRange = this.range
      const range = lastRange.slice() // Calculate transform by the first axis.

      const axisModel = coordSysInfo.axisModels[0]

      if (!axisModel) {
        return
      }

      const directionInfo = getDirectionInfo[coordSysMainType](null, [e.originX, e.originY], axisModel, controller, coordSysInfo)
      const percentPoint = (directionInfo.signal > 0 ? directionInfo.pixelStart + directionInfo.pixelLength - directionInfo.pixel : directionInfo.pixel - directionInfo.pixelStart) / directionInfo.pixelLength * (range[1] - range[0]) + range[0]
      const scale = Math.max(1 / e.scale, 0)
      range[0] = (range[0] - percentPoint) * scale + percentPoint
      range[1] = (range[1] - percentPoint) * scale + percentPoint // Restrict range.

      const minMaxSpan = this.dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan()
      sliderMove(0, range, [0, 100], 0, minMaxSpan.minSpan, minMaxSpan.maxSpan)
      this.range = range

      if (lastRange[0] !== range[0] || lastRange[1] !== range[1]) {
        return range
      }
    },
    pan: makeMover(function (range, axisModel, coordSysInfo, coordSysMainType, controller, e) {
      const directionInfo = getDirectionInfo[coordSysMainType]([e.oldX, e.oldY], [e.newX, e.newY], axisModel, controller, coordSysInfo)
      return directionInfo.signal * (range[1] - range[0]) * directionInfo.pixel / directionInfo.pixelLength
    }),
    scrollMove: makeMover(function (range, axisModel, coordSysInfo, coordSysMainType, controller, e) {
      const directionInfo = getDirectionInfo[coordSysMainType]([0, 0], [e.scrollDelta, e.scrollDelta], axisModel, controller, coordSysInfo)
      return directionInfo.signal * (range[1] - range[0]) * e.scrollDelta
    })
  }

  function makeMover (getPercentDelta) {
    return function (coordSysInfo, coordSysMainType, controller, e) {
      const lastRange = this.range
      const range = lastRange.slice() // Calculate transform by the first axis.

      const axisModel = coordSysInfo.axisModels[0]

      if (!axisModel) {
        return
      }

      const percentDelta = getPercentDelta(range, axisModel, coordSysInfo, coordSysMainType, controller, e)
      sliderMove(percentDelta, range, [0, 100], 'all')
      this.range = range

      if (lastRange[0] !== range[0] || lastRange[1] !== range[1]) {
        return range
      }
    }
  }

  var getDirectionInfo = {
    grid: function (oldPoint, newPoint, axisModel, controller, coordSysInfo) {
      const axis = axisModel.axis
      const ret = {}
      const rect = coordSysInfo.model.coordinateSystem.getRect()
      oldPoint = oldPoint || [0, 0]

      if (axis.dim === 'x') {
        ret.pixel = newPoint[0] - oldPoint[0]
        ret.pixelLength = rect.width
        ret.pixelStart = rect.x
        ret.signal = axis.inverse ? 1 : -1
      } else {
        // axis.dim === 'y'
        ret.pixel = newPoint[1] - oldPoint[1]
        ret.pixelLength = rect.height
        ret.pixelStart = rect.y
        ret.signal = axis.inverse ? -1 : 1
      }

      return ret
    },
    polar: function (oldPoint, newPoint, axisModel, controller, coordSysInfo) {
      const axis = axisModel.axis
      const ret = {}
      const polar = coordSysInfo.model.coordinateSystem
      const radiusExtent = polar.getRadiusAxis().getExtent()
      const angleExtent = polar.getAngleAxis().getExtent()
      oldPoint = oldPoint ? polar.pointToCoord(oldPoint) : [0, 0]
      newPoint = polar.pointToCoord(newPoint)

      if (axisModel.mainType === 'radiusAxis') {
        ret.pixel = newPoint[0] - oldPoint[0] // ret.pixelLength = Math.abs(radiusExtent[1] - radiusExtent[0]);
        // ret.pixelStart = Math.min(radiusExtent[0], radiusExtent[1]);

        ret.pixelLength = radiusExtent[1] - radiusExtent[0]
        ret.pixelStart = radiusExtent[0]
        ret.signal = axis.inverse ? 1 : -1
      } else {
        // 'angleAxis'
        ret.pixel = newPoint[1] - oldPoint[1] // ret.pixelLength = Math.abs(angleExtent[1] - angleExtent[0]);
        // ret.pixelStart = Math.min(angleExtent[0], angleExtent[1]);

        ret.pixelLength = angleExtent[1] - angleExtent[0]
        ret.pixelStart = angleExtent[0]
        ret.signal = axis.inverse ? -1 : 1
      }

      return ret
    },
    singleAxis: function (oldPoint, newPoint, axisModel, controller, coordSysInfo) {
      const axis = axisModel.axis
      const rect = coordSysInfo.model.coordinateSystem.getRect()
      const ret = {}
      oldPoint = oldPoint || [0, 0]

      if (axis.orient === 'horizontal') {
        ret.pixel = newPoint[0] - oldPoint[0]
        ret.pixelLength = rect.width
        ret.pixelStart = rect.x
        ret.signal = axis.inverse ? 1 : -1
      } else {
        // 'vertical'
        ret.pixel = newPoint[1] - oldPoint[1]
        ret.pixelLength = rect.height
        ret.pixelStart = rect.y
        ret.signal = axis.inverse ? -1 : 1
      }

      return ret
    }
  }

  function install$K (registers) {
    installCommon(registers)
    registers.registerComponentModel(InsideZoomModel)
    registers.registerComponentView(InsideZoomView)
    installDataZoomRoamProcessor(registers)
  }

  const SliderZoomModel =
    /** @class */
    (function (_super) {
      __extends(SliderZoomModel, _super)

      function SliderZoomModel () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = SliderZoomModel.type
        return _this
      }

      SliderZoomModel.type = 'dataZoom.slider'
      SliderZoomModel.layoutMode = 'box'
      SliderZoomModel.defaultOption = inheritDefaultOption(DataZoomModel.defaultOption, {
        show: true,
        // deault value can only be drived in view stage.
        right: 'ph',
        top: 'ph',
        width: 'ph',
        height: 'ph',
        left: null,
        bottom: null,
        borderColor: '#d2dbee',
        borderRadius: 3,
        backgroundColor: 'rgba(47,69,84,0)',
        // dataBackgroundColor: '#ddd',
        dataBackground: {
          lineStyle: {
            color: '#d2dbee',
            width: 0.5
          },
          areaStyle: {
            color: '#d2dbee',
            opacity: 0.2
          }
        },
        selectedDataBackground: {
          lineStyle: {
            color: '#8fb0f7',
            width: 0.5
          },
          areaStyle: {
            color: '#8fb0f7',
            opacity: 0.2
          }
        },
        // Color of selected window.
        fillerColor: 'rgba(135,175,274,0.2)',
        handleIcon: 'path://M-9.35,34.56V42m0-40V9.5m-2,0h4a2,2,0,0,1,2,2v21a2,2,0,0,1-2,2h-4a2,2,0,0,1-2-2v-21A2,2,0,0,1-11.35,9.5Z',
        // Percent of the slider height
        handleSize: '100%',
        handleStyle: {
          color: '#fff',
          borderColor: '#ACB8D1'
        },
        moveHandleSize: 7,
        moveHandleIcon: 'path://M-320.9-50L-320.9-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-348-41-339-50-320.9-50z M-212.3-50L-212.3-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-239.4-41-230.4-50-212.3-50z M-103.7-50L-103.7-50c18.1,0,27.1,9,27.1,27.1V85.7c0,18.1-9,27.1-27.1,27.1l0,0c-18.1,0-27.1-9-27.1-27.1V-22.9C-130.9-41-121.8-50-103.7-50z',
        moveHandleStyle: {
          color: '#D2DBEE',
          opacity: 0.7
        },
        showDetail: true,
        showDataShadow: 'auto',
        realtime: true,
        zoomLock: false,
        textStyle: {
          color: '#6E7079'
        },
        brushSelect: true,
        brushStyle: {
          color: 'rgba(135,175,274,0.15)'
        },
        emphasis: {
          handleStyle: {
            borderColor: '#8FB0F7'
          },
          moveHandleStyle: {
            color: '#8FB0F7'
          }
        }
      })
      return SliderZoomModel
    }(DataZoomModel))

  const Rect$2 = Rect // Constants

  const DEFAULT_LOCATION_EDGE_GAP = 7
  const DEFAULT_FRAME_BORDER_WIDTH = 1
  const DEFAULT_FILLER_SIZE = 30
  const DEFAULT_MOVE_HANDLE_SIZE = 7
  const HORIZONTAL = 'horizontal'
  const VERTICAL = 'vertical'
  const LABEL_GAP = 5
  const SHOW_DATA_SHADOW_SERIES_TYPE = ['line', 'bar', 'candlestick', 'scatter']
  const REALTIME_ANIMATION_CONFIG = {
    easing: 'cubicOut',
    duration: 100,
    delay: 0
  }

  const SliderZoomView =
    /** @class */
    (function (_super) {
      __extends(SliderZoomView, _super)

      function SliderZoomView () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = SliderZoomView.type
        _this._displayables = {}
        return _this
      }

      SliderZoomView.prototype.init = function (ecModel, api) {
        this.api = api // A unique handler for each dataZoom component

        this._onBrush = bind(this._onBrush, this)
        this._onBrushEnd = bind(this._onBrushEnd, this)
      }

      SliderZoomView.prototype.render = function (dataZoomModel, ecModel, api, payload) {
        _super.prototype.render.apply(this, arguments)

        createOrUpdate(this, '_dispatchZoomAction', dataZoomModel.get('throttle'), 'fixRate')
        this._orient = dataZoomModel.getOrient()

        if (dataZoomModel.get('show') === false) {
          this.group.removeAll()
          return
        }

        if (dataZoomModel.noTarget()) {
          this._clear()

          this.group.removeAll()
          return
        } // Notice: this._resetInterval() should not be executed when payload.type
        // is 'dataZoom', origin this._range should be maintained, otherwise 'pan'
        // or 'zoom' info will be missed because of 'throttle' of this.dispatchAction,

        if (!payload || payload.type !== 'dataZoom' || payload.from !== this.uid) {
          this._buildView()
        }

        this._updateView()
      }

      SliderZoomView.prototype.dispose = function () {
        this._clear()

        _super.prototype.dispose.apply(this, arguments)
      }

      SliderZoomView.prototype._clear = function () {
        clear(this, '_dispatchZoomAction')
        const zr = this.api.getZr()
        zr.off('mousemove', this._onBrush)
        zr.off('mouseup', this._onBrushEnd)
      }

      SliderZoomView.prototype._buildView = function () {
        const thisGroup = this.group
        thisGroup.removeAll()
        this._brushing = false
        this._displayables.brushRect = null

        this._resetLocation()

        this._resetInterval()

        const barGroup = this._displayables.sliderGroup = new Group()

        this._renderBackground()

        this._renderHandle()

        this._renderDataShadow()

        thisGroup.add(barGroup)

        this._positionGroup()
      }

      SliderZoomView.prototype._resetLocation = function () {
        const dataZoomModel = this.dataZoomModel
        const api = this.api
        const showMoveHandle = dataZoomModel.get('brushSelect')
        const moveHandleSize = showMoveHandle ? DEFAULT_MOVE_HANDLE_SIZE : 0 // If some of x/y/width/height are not specified,
        // auto-adapt according to target grid.

        const coordRect = this._findCoordRect()

        const ecSize = {
          width: api.getWidth(),
          height: api.getHeight()
        } // Default align by coordinate system rect.

        const positionInfo = this._orient === HORIZONTAL ? {
          // Why using 'right', because right should be used in vertical,
          // and it is better to be consistent for dealing with position param merge.
          right: ecSize.width - coordRect.x - coordRect.width,
          top: ecSize.height - DEFAULT_FILLER_SIZE - DEFAULT_LOCATION_EDGE_GAP - moveHandleSize,
          width: coordRect.width,
          height: DEFAULT_FILLER_SIZE
        } : {
          right: DEFAULT_LOCATION_EDGE_GAP,
          top: coordRect.y,
          width: DEFAULT_FILLER_SIZE,
          height: coordRect.height
        } // Do not write back to option and replace value 'ph', because
        // the 'ph' value should be recalculated when resize.

        const layoutParams = getLayoutParams(dataZoomModel.option) // Replace the placeholder value.

        each(['right', 'top', 'width', 'height'], function (name) {
          if (layoutParams[name] === 'ph') {
            layoutParams[name] = positionInfo[name]
          }
        })
        const layoutRect = getLayoutRect(layoutParams, ecSize)
        this._location = {
          x: layoutRect.x,
          y: layoutRect.y
        }
        this._size = [layoutRect.width, layoutRect.height]
        this._orient === VERTICAL && this._size.reverse()
      }

      SliderZoomView.prototype._positionGroup = function () {
        const thisGroup = this.group
        const location = this._location
        const orient = this._orient // Just use the first axis to determine mapping.

        const targetAxisModel = this.dataZoomModel.getFirstTargetAxisModel()
        const inverse = targetAxisModel && targetAxisModel.get('inverse')
        const sliderGroup = this._displayables.sliderGroup
        const otherAxisInverse = (this._dataShadowInfo || {}).otherAxisInverse // Transform barGroup.

        sliderGroup.attr(orient === HORIZONTAL && !inverse ? {
          scaleY: otherAxisInverse ? 1 : -1,
          scaleX: 1
        } : orient === HORIZONTAL && inverse ? {
          scaleY: otherAxisInverse ? 1 : -1,
          scaleX: -1
        } : orient === VERTICAL && !inverse ? {
          scaleY: otherAxisInverse ? -1 : 1,
          scaleX: 1,
          rotation: Math.PI / 2
        } // Dont use Math.PI, considering shadow direction.
          : {
              scaleY: otherAxisInverse ? -1 : 1,
              scaleX: -1,
              rotation: Math.PI / 2
            }) // Position barGroup

        const rect = thisGroup.getBoundingRect([sliderGroup])
        thisGroup.x = location.x - rect.x
        thisGroup.y = location.y - rect.y
        thisGroup.markRedraw()
      }

      SliderZoomView.prototype._getViewExtent = function () {
        return [0, this._size[0]]
      }

      SliderZoomView.prototype._renderBackground = function () {
        const dataZoomModel = this.dataZoomModel
        const size = this._size
        const barGroup = this._displayables.sliderGroup
        const brushSelect = dataZoomModel.get('brushSelect')
        barGroup.add(new Rect$2({
          silent: true,
          shape: {
            x: 0,
            y: 0,
            width: size[0],
            height: size[1]
          },
          style: {
            fill: dataZoomModel.get('backgroundColor')
          },
          z2: -40
        })) // Click panel, over shadow, below handles.

        const clickPanel = new Rect$2({
          shape: {
            x: 0,
            y: 0,
            width: size[0],
            height: size[1]
          },
          style: {
            fill: 'transparent'
          },
          z2: 0,
          onclick: bind(this._onClickPanel, this)
        })
        const zr = this.api.getZr()

        if (brushSelect) {
          clickPanel.on('mousedown', this._onBrushStart, this)
          clickPanel.cursor = 'crosshair'
          zr.on('mousemove', this._onBrush)
          zr.on('mouseup', this._onBrushEnd)
        } else {
          zr.off('mousemove', this._onBrush)
          zr.off('mouseup', this._onBrushEnd)
        }

        barGroup.add(clickPanel)
      }

      SliderZoomView.prototype._renderDataShadow = function () {
        const info = this._dataShadowInfo = this._prepareDataShadowInfo()

        this._displayables.dataShadowSegs = []

        if (!info) {
          return
        }

        const size = this._size
        const oldSize = this._shadowSize || []
        const seriesModel = info.series
        const data = seriesModel.getRawData()
        const otherDim = seriesModel.getShadowDim ? seriesModel.getShadowDim() // @see candlestick
          : info.otherDim

        if (otherDim == null) {
          return
        }

        let polygonPts = this._shadowPolygonPts
        let polylinePts = this._shadowPolylinePts // Not re-render if data doesn't change.

        if (data !== this._shadowData || otherDim !== this._shadowDim || size[0] !== oldSize[0] || size[1] !== oldSize[1]) {
          let otherDataExtent_1 = data.getDataExtent(otherDim) // Nice extent.

          const otherOffset = (otherDataExtent_1[1] - otherDataExtent_1[0]) * 0.3
          otherDataExtent_1 = [otherDataExtent_1[0] - otherOffset, otherDataExtent_1[1] + otherOffset]
          const otherShadowExtent_1 = [0, size[1]]
          const thisShadowExtent = [0, size[0]]
          const areaPoints_1 = [[size[0], 0], [0, 0]]
          const linePoints_1 = []
          const step_1 = thisShadowExtent[1] / (data.count() - 1)
          let thisCoord_1 = 0 // Optimize for large data shadow

          const stride_1 = Math.round(data.count() / size[0])
          let lastIsEmpty_1
          data.each([otherDim], function (value, index) {
            if (stride_1 > 0 && index % stride_1) {
              thisCoord_1 += step_1
              return
            } // FIXME
            // Should consider axis.min/axis.max when drawing dataShadow.
            // FIXME
            // 应该使用统一的空判断？还是在list里进行空判断？

            const isEmpty = value == null || isNaN(value) || value === '' // See #4235.

            const otherCoord = isEmpty ? 0 : linearMap(value, otherDataExtent_1, otherShadowExtent_1, true) // Attempt to draw data shadow precisely when there are empty value.

            if (isEmpty && !lastIsEmpty_1 && index) {
              areaPoints_1.push([areaPoints_1[areaPoints_1.length - 1][0], 0])
              linePoints_1.push([linePoints_1[linePoints_1.length - 1][0], 0])
            } else if (!isEmpty && lastIsEmpty_1) {
              areaPoints_1.push([thisCoord_1, 0])
              linePoints_1.push([thisCoord_1, 0])
            }

            areaPoints_1.push([thisCoord_1, otherCoord])
            linePoints_1.push([thisCoord_1, otherCoord])
            thisCoord_1 += step_1
            lastIsEmpty_1 = isEmpty
          })
          polygonPts = this._shadowPolygonPts = areaPoints_1
          polylinePts = this._shadowPolylinePts = linePoints_1
        }

        this._shadowData = data
        this._shadowDim = otherDim
        this._shadowSize = [size[0], size[1]]
        const dataZoomModel = this.dataZoomModel

        function createDataShadowGroup (isSelectedArea) {
          const model = dataZoomModel.getModel(isSelectedArea ? 'selectedDataBackground' : 'dataBackground')
          const group = new Group()
          const polygon = new Polygon({
            shape: {
              points: polygonPts
            },
            segmentIgnoreThreshold: 1,
            style: model.getModel('areaStyle').getAreaStyle(),
            silent: true,
            z2: -20
          })
          const polyline = new Polyline({
            shape: {
              points: polylinePts
            },
            segmentIgnoreThreshold: 1,
            style: model.getModel('lineStyle').getLineStyle(),
            silent: true,
            z2: -19
          })
          group.add(polygon)
          group.add(polyline)
          return group
        } // let dataBackgroundModel = dataZoomModel.getModel('dataBackground');

        for (let i = 0; i < 3; i++) {
          const group = createDataShadowGroup(i === 1)

          this._displayables.sliderGroup.add(group)

          this._displayables.dataShadowSegs.push(group)
        }
      }

      SliderZoomView.prototype._prepareDataShadowInfo = function () {
        const dataZoomModel = this.dataZoomModel
        const showDataShadow = dataZoomModel.get('showDataShadow')

        if (showDataShadow === false) {
          return
        } // Find a representative series.

        let result
        const ecModel = this.ecModel
        dataZoomModel.eachTargetAxis(function (axisDim, axisIndex) {
          const seriesModels = dataZoomModel.getAxisProxy(axisDim, axisIndex).getTargetSeriesModels()
          each(seriesModels, function (seriesModel) {
            if (result) {
              return
            }

            if (showDataShadow !== true && indexOf(SHOW_DATA_SHADOW_SERIES_TYPE, seriesModel.get('type')) < 0) {
              return
            }

            const thisAxis = ecModel.getComponent(getAxisMainType(axisDim), axisIndex).axis
            let otherDim = getOtherDim(axisDim)
            let otherAxisInverse
            const coordSys = seriesModel.coordinateSystem

            if (otherDim != null && coordSys.getOtherAxis) {
              otherAxisInverse = coordSys.getOtherAxis(thisAxis).inverse
            }

            otherDim = seriesModel.getData().mapDimension(otherDim)
            result = {
              thisAxis: thisAxis,
              series: seriesModel,
              thisDim: axisDim,
              otherDim: otherDim,
              otherAxisInverse: otherAxisInverse
            }
          }, this)
        }, this)
        return result
      }

      SliderZoomView.prototype._renderHandle = function () {
        const thisGroup = this.group
        const displayables = this._displayables
        const handles = displayables.handles = [null, null]
        const handleLabels = displayables.handleLabels = [null, null]
        const sliderGroup = this._displayables.sliderGroup
        const size = this._size
        const dataZoomModel = this.dataZoomModel
        const api = this.api
        const borderRadius = dataZoomModel.get('borderRadius') || 0
        const brushSelect = dataZoomModel.get('brushSelect')
        const filler = displayables.filler = new Rect$2({
          silent: brushSelect,
          style: {
            fill: dataZoomModel.get('fillerColor')
          },
          textConfig: {
            position: 'inside'
          }
        })
        sliderGroup.add(filler) // Frame border.

        sliderGroup.add(new Rect$2({
          silent: true,
          subPixelOptimize: true,
          shape: {
            x: 0,
            y: 0,
            width: size[0],
            height: size[1],
            r: borderRadius
          },
          style: {
            // deprecated option
            stroke: dataZoomModel.get('dataBackgroundColor') || dataZoomModel.get('borderColor'),
            lineWidth: DEFAULT_FRAME_BORDER_WIDTH,
            fill: 'rgba(0,0,0,0)'
          }
        })) // Left and right handle to resize

        each([0, 1], function (handleIndex) {
          let iconStr = dataZoomModel.get('handleIcon')

          if (!symbolBuildProxies[iconStr] && iconStr.indexOf('path://') < 0 && iconStr.indexOf('image://') < 0) {
            // Compatitable with the old icon parsers. Which can use a path string without path://
            iconStr = 'path://' + iconStr

            if ('development' !== 'production') {
              deprecateLog('handleIcon now needs \'path://\' prefix when using a path string')
            }
          }

          const path = createSymbol(iconStr, -1, 0, 2, 2, null, true)
          path.attr({
            cursor: getCursor(this._orient),
            draggable: true,
            drift: bind(this._onDragMove, this, handleIndex),
            ondragend: bind(this._onDragEnd, this),
            onmouseover: bind(this._showDataInfo, this, true),
            onmouseout: bind(this._showDataInfo, this, false),
            z2: 5
          })
          const bRect = path.getBoundingRect()
          const handleSize = dataZoomModel.get('handleSize')
          this._handleHeight = parsePercent$1(handleSize, this._size[1])
          this._handleWidth = bRect.width / bRect.height * this._handleHeight
          path.setStyle(dataZoomModel.getModel('handleStyle').getItemStyle())
          path.style.strokeNoScale = true
          path.rectHover = true
          path.ensureState('emphasis').style = dataZoomModel.getModel(['emphasis', 'handleStyle']).getItemStyle()
          enableHoverEmphasis(path)
          const handleColor = dataZoomModel.get('handleColor') // deprecated option
          // Compatitable with previous version

          if (handleColor != null) {
            path.style.fill = handleColor
          }

          sliderGroup.add(handles[handleIndex] = path)
          const textStyleModel = dataZoomModel.getModel('textStyle')
          thisGroup.add(handleLabels[handleIndex] = new ZRText({
            silent: true,
            invisible: true,
            style: createTextStyle(textStyleModel, {
              x: 0,
              y: 0,
              text: '',
              verticalAlign: 'middle',
              align: 'center',
              fill: textStyleModel.getTextColor(),
              font: textStyleModel.getFont()
            }),
            z2: 10
          }))
        }, this) // Handle to move. Only visible when brushSelect is set true.

        let actualMoveZone = filler

        if (brushSelect) {
          const moveHandleHeight = parsePercent$1(dataZoomModel.get('moveHandleSize'), size[1])
          const moveHandle_1 = displayables.moveHandle = new Rect({
            style: dataZoomModel.getModel('moveHandleStyle').getItemStyle(),
            silent: true,
            shape: {
              r: [0, 0, 2, 2],
              y: size[1] - 0.5,
              height: moveHandleHeight
            }
          })
          const iconSize = moveHandleHeight * 0.8
          const moveHandleIcon = displayables.moveHandleIcon = createSymbol(dataZoomModel.get('moveHandleIcon'), -iconSize / 2, -iconSize / 2, iconSize, iconSize, '#fff', true)
          moveHandleIcon.silent = true
          moveHandleIcon.y = size[1] + moveHandleHeight / 2 - 0.5
          moveHandle_1.ensureState('emphasis').style = dataZoomModel.getModel(['emphasis', 'moveHandleStyle']).getItemStyle()
          const moveZoneExpandSize = Math.min(size[1] / 2, Math.max(moveHandleHeight, 10))
          actualMoveZone = displayables.moveZone = new Rect({
            invisible: true,
            shape: {
              y: size[1] - moveZoneExpandSize,
              height: moveHandleHeight + moveZoneExpandSize
            }
          })
          actualMoveZone.on('mouseover', function () {
            api.enterEmphasis(moveHandle_1)
          }).on('mouseout', function () {
            api.leaveEmphasis(moveHandle_1)
          })
          sliderGroup.add(moveHandle_1)
          sliderGroup.add(moveHandleIcon)
          sliderGroup.add(actualMoveZone)
        }

        actualMoveZone.attr({
          draggable: true,
          cursor: getCursor(this._orient),
          drift: bind(this._onDragMove, this, 'all'),
          ondragstart: bind(this._showDataInfo, this, true),
          ondragend: bind(this._onDragEnd, this),
          onmouseover: bind(this._showDataInfo, this, true),
          onmouseout: bind(this._showDataInfo, this, false)
        })
      }

      SliderZoomView.prototype._resetInterval = function () {
        const range = this._range = this.dataZoomModel.getPercentRange()

        const viewExtent = this._getViewExtent()

        this._handleEnds = [linearMap(range[0], [0, 100], viewExtent, true), linearMap(range[1], [0, 100], viewExtent, true)]
      }

      SliderZoomView.prototype._updateInterval = function (handleIndex, delta) {
        const dataZoomModel = this.dataZoomModel
        const handleEnds = this._handleEnds

        const viewExtend = this._getViewExtent()

        const minMaxSpan = dataZoomModel.findRepresentativeAxisProxy().getMinMaxSpan()
        const percentExtent = [0, 100]
        sliderMove(delta, handleEnds, viewExtend, dataZoomModel.get('zoomLock') ? 'all' : handleIndex, minMaxSpan.minSpan != null ? linearMap(minMaxSpan.minSpan, percentExtent, viewExtend, true) : null, minMaxSpan.maxSpan != null ? linearMap(minMaxSpan.maxSpan, percentExtent, viewExtend, true) : null)
        const lastRange = this._range
        const range = this._range = asc([linearMap(handleEnds[0], viewExtend, percentExtent, true), linearMap(handleEnds[1], viewExtend, percentExtent, true)])
        return !lastRange || lastRange[0] !== range[0] || lastRange[1] !== range[1]
      }

      SliderZoomView.prototype._updateView = function (nonRealtime) {
        const displaybles = this._displayables
        const handleEnds = this._handleEnds
        const handleInterval = asc(handleEnds.slice())
        const size = this._size
        each([0, 1], function (handleIndex) {
          // Handles
          const handle = displaybles.handles[handleIndex]
          const handleHeight = this._handleHeight
          handle.attr({
            scaleX: handleHeight / 2,
            scaleY: handleHeight / 2,
            // This is a trick, by adding an extra tiny offset to let the default handle's end point align to the drag window.
            // NOTE: It may affect some custom shapes a bit. But we prefer to have better result by default.
            x: handleEnds[handleIndex] + (handleIndex ? -1 : 1),
            y: size[1] / 2 - handleHeight / 2
          })
        }, this) // Filler

        displaybles.filler.setShape({
          x: handleInterval[0],
          y: 0,
          width: handleInterval[1] - handleInterval[0],
          height: size[1]
        })
        const viewExtent = {
          x: handleInterval[0],
          width: handleInterval[1] - handleInterval[0]
        } // Move handle

        if (displaybles.moveHandle) {
          displaybles.moveHandle.setShape(viewExtent)
          displaybles.moveZone.setShape(viewExtent) // Force update path on the invisible object

          displaybles.moveZone.getBoundingRect()
          displaybles.moveHandleIcon && displaybles.moveHandleIcon.attr('x', viewExtent.x + viewExtent.width / 2)
        } // update clip path of shadow.

        const dataShadowSegs = displaybles.dataShadowSegs
        const segIntervals = [0, handleInterval[0], handleInterval[1], size[0]]

        for (let i = 0; i < dataShadowSegs.length; i++) {
          const segGroup = dataShadowSegs[i]
          let clipPath = segGroup.getClipPath()

          if (!clipPath) {
            clipPath = new Rect()
            segGroup.setClipPath(clipPath)
          }

          clipPath.setShape({
            x: segIntervals[i],
            y: 0,
            width: segIntervals[i + 1] - segIntervals[i],
            height: size[1]
          })
        }

        this._updateDataInfo(nonRealtime)
      }

      SliderZoomView.prototype._updateDataInfo = function (nonRealtime) {
        const dataZoomModel = this.dataZoomModel
        const displaybles = this._displayables
        const handleLabels = displaybles.handleLabels
        const orient = this._orient
        let labelTexts = ['', ''] // FIXME
        // date型，支持formatter，autoformatter（ec2 date.getAutoFormatter）

        if (dataZoomModel.get('showDetail')) {
          const axisProxy = dataZoomModel.findRepresentativeAxisProxy()

          if (axisProxy) {
            const axis = axisProxy.getAxisModel().axis
            const range = this._range
            const dataInterval = nonRealtime // See #4434, data and axis are not processed and reset yet in non-realtime mode.
              ? axisProxy.calculateDataWindow({
                start: range[0],
                end: range[1]
              }).valueWindow : axisProxy.getDataValueWindow()
            labelTexts = [this._formatLabel(dataInterval[0], axis), this._formatLabel(dataInterval[1], axis)]
          }
        }

        const orderedHandleEnds = asc(this._handleEnds.slice())
        setLabel.call(this, 0)
        setLabel.call(this, 1)

        function setLabel (handleIndex) {
          // Label
          // Text should not transform by barGroup.
          // Ignore handlers transform
          const barTransform = getTransform(displaybles.handles[handleIndex].parent, this.group)
          const direction = transformDirection(handleIndex === 0 ? 'right' : 'left', barTransform)
          const offset = this._handleWidth / 2 + LABEL_GAP
          const textPoint = applyTransform$1([orderedHandleEnds[handleIndex] + (handleIndex === 0 ? -offset : offset), this._size[1] / 2], barTransform)
          handleLabels[handleIndex].setStyle({
            x: textPoint[0],
            y: textPoint[1],
            verticalAlign: orient === HORIZONTAL ? 'middle' : direction,
            align: orient === HORIZONTAL ? direction : 'center',
            text: labelTexts[handleIndex]
          })
        }
      }

      SliderZoomView.prototype._formatLabel = function (value, axis) {
        const dataZoomModel = this.dataZoomModel
        const labelFormatter = dataZoomModel.get('labelFormatter')
        let labelPrecision = dataZoomModel.get('labelPrecision')

        if (labelPrecision == null || labelPrecision === 'auto') {
          labelPrecision = axis.getPixelPrecision()
        }

        const valueStr = value == null || isNaN(value) ? '' // FIXME Glue code
          : axis.type === 'category' || axis.type === 'time' ? axis.scale.getLabel({
            value: Math.round(value)
          }) // param of toFixed should less then 20.
            : value.toFixed(Math.min(labelPrecision, 20))
        return isFunction(labelFormatter) ? labelFormatter(value, valueStr) : isString(labelFormatter) ? labelFormatter.replace('{value}', valueStr) : valueStr
      }
      /**
       * @param showOrHide true: show, false: hide
       */

      SliderZoomView.prototype._showDataInfo = function (showOrHide) {
        // Always show when drgging.
        showOrHide = this._dragging || showOrHide
        const displayables = this._displayables
        const handleLabels = displayables.handleLabels
        handleLabels[0].attr('invisible', !showOrHide)
        handleLabels[1].attr('invisible', !showOrHide) // Highlight move handle

        displayables.moveHandle && this.api[showOrHide ? 'enterEmphasis' : 'leaveEmphasis'](displayables.moveHandle, 1)
      }

      SliderZoomView.prototype._onDragMove = function (handleIndex, dx, dy, event) {
        this._dragging = true // For mobile device, prevent screen slider on the button.

        stop(event.event) // Transform dx, dy to bar coordination.

        const barTransform = this._displayables.sliderGroup.getLocalTransform()

        const vertex = applyTransform$1([dx, dy], barTransform, true)

        const changed = this._updateInterval(handleIndex, vertex[0])

        const realtime = this.dataZoomModel.get('realtime')

        this._updateView(!realtime) // Avoid dispatch dataZoom repeatly but range not changed,
        // which cause bad visual effect when progressive enabled.

        changed && realtime && this._dispatchZoomAction(true)
      }

      SliderZoomView.prototype._onDragEnd = function () {
        this._dragging = false

        this._showDataInfo(false) // While in realtime mode and stream mode, dispatch action when
        // drag end will cause the whole view rerender, which is unnecessary.

        const realtime = this.dataZoomModel.get('realtime')
        !realtime && this._dispatchZoomAction(false)
      }

      SliderZoomView.prototype._onClickPanel = function (e) {
        const size = this._size

        const localPoint = this._displayables.sliderGroup.transformCoordToLocal(e.offsetX, e.offsetY)

        if (localPoint[0] < 0 || localPoint[0] > size[0] || localPoint[1] < 0 || localPoint[1] > size[1]) {
          return
        }

        const handleEnds = this._handleEnds
        const center = (handleEnds[0] + handleEnds[1]) / 2

        const changed = this._updateInterval('all', localPoint[0] - center)

        this._updateView()

        changed && this._dispatchZoomAction(false)
      }

      SliderZoomView.prototype._onBrushStart = function (e) {
        const x = e.offsetX
        const y = e.offsetY
        this._brushStart = new Point(x, y)
        this._brushing = true
        this._brushStartTime = +new Date() // this._updateBrushRect(x, y);
      }

      SliderZoomView.prototype._onBrushEnd = function (e) {
        if (!this._brushing) {
          return
        }

        const brushRect = this._displayables.brushRect
        this._brushing = false

        if (!brushRect) {
          return
        }

        brushRect.attr('ignore', true)
        const brushShape = brushRect.shape
        const brushEndTime = +new Date() // console.log(brushEndTime - this._brushStartTime);

        if (brushEndTime - this._brushStartTime < 200 && Math.abs(brushShape.width) < 5) {
          // Will treat it as a click
          return
        }

        const viewExtend = this._getViewExtent()

        const percentExtent = [0, 100]
        this._range = asc([linearMap(brushShape.x, viewExtend, percentExtent, true), linearMap(brushShape.x + brushShape.width, viewExtend, percentExtent, true)])
        this._handleEnds = [brushShape.x, brushShape.x + brushShape.width]

        this._updateView()

        this._dispatchZoomAction(false)
      }

      SliderZoomView.prototype._onBrush = function (e) {
        if (this._brushing) {
          // For mobile device, prevent screen slider on the button.
          stop(e.event)

          this._updateBrushRect(e.offsetX, e.offsetY)
        }
      }

      SliderZoomView.prototype._updateBrushRect = function (mouseX, mouseY) {
        const displayables = this._displayables
        const dataZoomModel = this.dataZoomModel
        let brushRect = displayables.brushRect

        if (!brushRect) {
          brushRect = displayables.brushRect = new Rect$2({
            silent: true,
            style: dataZoomModel.getModel('brushStyle').getItemStyle()
          })
          displayables.sliderGroup.add(brushRect)
        }

        brushRect.attr('ignore', false)
        const brushStart = this._brushStart
        const sliderGroup = this._displayables.sliderGroup
        const endPoint = sliderGroup.transformCoordToLocal(mouseX, mouseY)
        const startPoint = sliderGroup.transformCoordToLocal(brushStart.x, brushStart.y)
        const size = this._size
        endPoint[0] = Math.max(Math.min(size[0], endPoint[0]), 0)
        brushRect.setShape({
          x: startPoint[0],
          y: 0,
          width: endPoint[0] - startPoint[0],
          height: size[1]
        })
      }
      /**
       * This action will be throttled.
       */

      SliderZoomView.prototype._dispatchZoomAction = function (realtime) {
        const range = this._range
        this.api.dispatchAction({
          type: 'dataZoom',
          from: this.uid,
          dataZoomId: this.dataZoomModel.id,
          animation: realtime ? REALTIME_ANIMATION_CONFIG : null,
          start: range[0],
          end: range[1]
        })
      }

      SliderZoomView.prototype._findCoordRect = function () {
        // Find the grid coresponding to the first axis referred by dataZoom.
        let rect
        const coordSysInfoList = collectReferCoordSysModelInfo(this.dataZoomModel).infoList

        if (!rect && coordSysInfoList.length) {
          const coordSys = coordSysInfoList[0].model.coordinateSystem
          rect = coordSys.getRect && coordSys.getRect()
        }

        if (!rect) {
          const width = this.api.getWidth()
          const height = this.api.getHeight()
          rect = {
            x: width * 0.2,
            y: height * 0.2,
            width: width * 0.6,
            height: height * 0.6
          }
        }

        return rect
      }

      SliderZoomView.type = 'dataZoom.slider'
      return SliderZoomView
    }(DataZoomView))

  function getOtherDim (thisDim) {
    // FIXME
    // 这个逻辑和getOtherAxis里一致，但是写在这里是否不好
    const map = {
      x: 'y',
      y: 'x',
      radius: 'angle',
      angle: 'radius'
    }
    return map[thisDim]
  }

  function getCursor (orient) {
    return orient === 'vertical' ? 'ns-resize' : 'ew-resize'
  }

  function install$L (registers) {
    registers.registerComponentModel(SliderZoomModel)
    registers.registerComponentView(SliderZoomView)
    installCommon(registers)
  }

  function install$M (registers) {
    use(install$K)
    use(install$L) // Do not install './dataZoomSelect',
    // since it only work for toolbox dataZoom.
  }

  const visualDefault = {
    /**
       * @public
       */
    get: function (visualType, key, isCategory) {
      const value = clone((defaultOption$1[visualType] || {})[key])
      return isCategory ? isArray(value) ? value[value.length - 1] : value : value
    }
  }
  var defaultOption$1 = {
    color: {
      active: ['#006edd', '#e0ffff'],
      inactive: ['rgba(0,0,0,0)']
    },
    colorHue: {
      active: [0, 360],
      inactive: [0, 0]
    },
    colorSaturation: {
      active: [0.3, 1],
      inactive: [0, 0]
    },
    colorLightness: {
      active: [0.9, 0.5],
      inactive: [0, 0]
    },
    colorAlpha: {
      active: [0.3, 1],
      inactive: [0, 0]
    },
    opacity: {
      active: [0.3, 1],
      inactive: [0, 0]
    },
    symbol: {
      active: ['circle', 'roundRect', 'diamond'],
      inactive: ['none']
    },
    symbolSize: {
      active: [10, 50],
      inactive: [0, 0]
    }
  }

  const mapVisual$1 = VisualMapping.mapVisual
  const eachVisual = VisualMapping.eachVisual
  const isArray$1 = isArray
  const each$d = each
  const asc$2 = asc
  const linearMap$1 = linearMap

  const VisualMapModel =
    /** @class */
    (function (_super) {
      __extends(VisualMapModel, _super)

      function VisualMapModel () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = VisualMapModel.type
        _this.stateList = ['inRange', 'outOfRange']
        _this.replacableOptionKeys = ['inRange', 'outOfRange', 'target', 'controller', 'color']
        _this.layoutMode = {
          type: 'box',
          ignoreSize: true
        }
        /**
         * [lowerBound, upperBound]
         */

        _this.dataBound = [-Infinity, Infinity]
        _this.targetVisuals = {}
        _this.controllerVisuals = {}
        return _this
      }

      VisualMapModel.prototype.init = function (option, parentModel, ecModel) {
        this.mergeDefaultAndTheme(option, ecModel)
      }
      /**
       * @protected
       */

      VisualMapModel.prototype.optionUpdated = function (newOption, isInit) {
        const thisOption = this.option
        !isInit && replaceVisualOption(thisOption, newOption, this.replacableOptionKeys)
        this.textStyleModel = this.getModel('textStyle')
        this.resetItemSize()
        this.completeVisualOption()
      }
      /**
       * @protected
       */

      VisualMapModel.prototype.resetVisual = function (supplementVisualOption) {
        const stateList = this.stateList
        supplementVisualOption = bind(supplementVisualOption, this)
        this.controllerVisuals = createVisualMappings(this.option.controller, stateList, supplementVisualOption)
        this.targetVisuals = createVisualMappings(this.option.target, stateList, supplementVisualOption)
      }
      /**
       * @public
       */

      VisualMapModel.prototype.getItemSymbol = function () {
        return null
      }
      /**
       * @protected
       * @return {Array.<number>} An array of series indices.
       */

      VisualMapModel.prototype.getTargetSeriesIndices = function () {
        const optionSeriesIndex = this.option.seriesIndex
        let seriesIndices = []

        if (optionSeriesIndex == null || optionSeriesIndex === 'all') {
          this.ecModel.eachSeries(function (seriesModel, index) {
            seriesIndices.push(index)
          })
        } else {
          seriesIndices = normalizeToArray(optionSeriesIndex)
        }

        return seriesIndices
      }
      /**
       * @public
       */

      VisualMapModel.prototype.eachTargetSeries = function (callback, context) {
        each(this.getTargetSeriesIndices(), function (seriesIndex) {
          const seriesModel = this.ecModel.getSeriesByIndex(seriesIndex)

          if (seriesModel) {
            callback.call(context, seriesModel)
          }
        }, this)
      }
      /**
       * @pubilc
       */

      VisualMapModel.prototype.isTargetSeries = function (seriesModel) {
        let is = false
        this.eachTargetSeries(function (model) {
          model === seriesModel && (is = true)
        })
        return is
      }
      /**
       * @example
       * this.formatValueText(someVal); // format single numeric value to text.
       * this.formatValueText(someVal, true); // format single category value to text.
       * this.formatValueText([min, max]); // format numeric min-max to text.
       * this.formatValueText([this.dataBound[0], max]); // using data lower bound.
       * this.formatValueText([min, this.dataBound[1]]); // using data upper bound.
       *
       * @param value Real value, or this.dataBound[0 or 1].
       * @param isCategory Only available when value is number.
       * @param edgeSymbols Open-close symbol when value is interval.
       * @protected
       */

      VisualMapModel.prototype.formatValueText = function (value, isCategory, edgeSymbols) {
        const option = this.option
        const precision = option.precision
        const dataBound = this.dataBound
        const formatter = option.formatter
        let isMinMax
        edgeSymbols = edgeSymbols || ['<', '>']

        if (isArray(value)) {
          value = value.slice()
          isMinMax = true
        }

        const textValue = isCategory ? value // Value is string when isCategory
          : isMinMax ? [toFixed(value[0]), toFixed(value[1])] : toFixed(value)

        if (isString(formatter)) {
          return formatter.replace('{value}', isMinMax ? textValue[0] : textValue).replace('{value2}', isMinMax ? textValue[1] : textValue)
        } else if (isFunction(formatter)) {
          return isMinMax ? formatter(value[0], value[1]) : formatter(value)
        }

        if (isMinMax) {
          if (value[0] === dataBound[0]) {
            return edgeSymbols[0] + ' ' + textValue[1]
          } else if (value[1] === dataBound[1]) {
            return edgeSymbols[1] + ' ' + textValue[0]
          } else {
            return textValue[0] + ' - ' + textValue[1]
          }
        } else {
          // Format single value (includes category case).
          return textValue
        }

        function toFixed (val) {
          return val === dataBound[0] ? 'min' : val === dataBound[1] ? 'max' : (+val).toFixed(Math.min(precision, 20))
        }
      }
      /**
       * @protected
       */

      VisualMapModel.prototype.resetExtent = function () {
        const thisOption = this.option // Can not calculate data extent by data here.
        // Because series and data may be modified in processing stage.
        // So we do not support the feature "auto min/max".

        const extent = asc$2([thisOption.min, thisOption.max])
        this._dataExtent = extent
      }
      /**
       * PENDING:
       * delete this method if no outer usage.
       *
       * Return  Concrete dimention. If return null/undefined, no dimension used.
       */
      // getDataDimension(data: SeriesData) {
      //     const optDim = this.option.dimension;
      //     if (optDim != null) {
      //         return data.getDimension(optDim);
      //     }
      //     const dimNames = data.dimensions;
      //     for (let i = dimNames.length - 1; i >= 0; i--) {
      //         const dimName = dimNames[i];
      //         const dimInfo = data.getDimensionInfo(dimName);
      //         if (!dimInfo.isCalculationCoord) {
      //             return dimName;
      //         }
      //     }
      // }

      VisualMapModel.prototype.getDataDimensionIndex = function (data) {
        const optDim = this.option.dimension

        if (optDim != null) {
          return data.getDimensionIndex(optDim)
        }

        const dimNames = data.dimensions

        for (let i = dimNames.length - 1; i >= 0; i--) {
          const dimName = dimNames[i]
          const dimInfo = data.getDimensionInfo(dimName)

          if (!dimInfo.isCalculationCoord) {
            return dimInfo.storeDimIndex
          }
        }
      }

      VisualMapModel.prototype.getExtent = function () {
        return this._dataExtent.slice()
      }

      VisualMapModel.prototype.completeVisualOption = function () {
        const ecModel = this.ecModel
        const thisOption = this.option
        const base = {
          inRange: thisOption.inRange,
          outOfRange: thisOption.outOfRange
        }
        const target = thisOption.target || (thisOption.target = {})
        const controller = thisOption.controller || (thisOption.controller = {})
        merge(target, base) // Do not override

        merge(controller, base) // Do not override

        const isCategory = this.isCategory()
        completeSingle.call(this, target)
        completeSingle.call(this, controller)
        completeInactive.call(this, target, 'inRange', 'outOfRange') // completeInactive.call(this, target, 'outOfRange', 'inRange');

        completeController.call(this, controller)

        function completeSingle (base) {
          // Compatible with ec2 dataRange.color.
          // The mapping order of dataRange.color is: [high value, ..., low value]
          // whereas inRange.color and outOfRange.color is [low value, ..., high value]
          // Notice: ec2 has no inverse.
          if (isArray$1(thisOption.color) && // If there has been inRange: {symbol: ...}, adding color is a mistake.
          // So adding color only when no inRange defined.
          !base.inRange) {
            base.inRange = {
              color: thisOption.color.slice().reverse()
            }
          } // Compatible with previous logic, always give a defautl color, otherwise
          // simple config with no inRange and outOfRange will not work.
          // Originally we use visualMap.color as the default color, but setOption at
          // the second time the default color will be erased. So we change to use
          // constant DEFAULT_COLOR.
          // If user do not want the default color, set inRange: {color: null}.

          base.inRange = base.inRange || {
            color: ecModel.get('gradientColor')
          }
        }

        function completeInactive (base, stateExist, stateAbsent) {
          const optExist = base[stateExist]
          let optAbsent = base[stateAbsent]

          if (optExist && !optAbsent) {
            optAbsent = base[stateAbsent] = {}
            each$d(optExist, function (visualData, visualType) {
              if (!VisualMapping.isValidType(visualType)) {
                return
              }

              const defa = visualDefault.get(visualType, 'inactive', isCategory)

              if (defa != null) {
                optAbsent[visualType] = defa // Compatibable with ec2:
                // Only inactive color to rgba(0,0,0,0) can not
                // make label transparent, so use opacity also.

                if (visualType === 'color' && !optAbsent.hasOwnProperty('opacity') && !optAbsent.hasOwnProperty('colorAlpha')) {
                  optAbsent.opacity = [0, 0]
                }
              }
            })
          }
        }

        function completeController (controller) {
          const symbolExists = (controller.inRange || {}).symbol || (controller.outOfRange || {}).symbol
          const symbolSizeExists = (controller.inRange || {}).symbolSize || (controller.outOfRange || {}).symbolSize
          const inactiveColor = this.get('inactiveColor')
          const itemSymbol = this.getItemSymbol()
          const defaultSymbol = itemSymbol || 'roundRect'
          each$d(this.stateList, function (state) {
            const itemSize = this.itemSize
            let visuals = controller[state] // Set inactive color for controller if no other color
            // attr (like colorAlpha) specified.

            if (!visuals) {
              visuals = controller[state] = {
                color: isCategory ? inactiveColor : [inactiveColor]
              }
            } // Consistent symbol and symbolSize if not specified.

            if (visuals.symbol == null) {
              visuals.symbol = symbolExists && clone(symbolExists) || (isCategory ? defaultSymbol : [defaultSymbol])
            }

            if (visuals.symbolSize == null) {
              visuals.symbolSize = symbolSizeExists && clone(symbolSizeExists) || (isCategory ? itemSize[0] : [itemSize[0], itemSize[0]])
            } // Filter none

            visuals.symbol = mapVisual$1(visuals.symbol, function (symbol) {
              return symbol === 'none' ? defaultSymbol : symbol
            }) // Normalize symbolSize

            const symbolSize = visuals.symbolSize

            if (symbolSize != null) {
              let max_1 = -Infinity // symbolSize can be object when categories defined.

              eachVisual(symbolSize, function (value) {
                value > max_1 && (max_1 = value)
              })
              visuals.symbolSize = mapVisual$1(symbolSize, function (value) {
                return linearMap$1(value, [0, max_1], [0, itemSize[0]], true)
              })
            }
          }, this)
        }
      }

      VisualMapModel.prototype.resetItemSize = function () {
        this.itemSize = [parseFloat(this.get('itemWidth')), parseFloat(this.get('itemHeight'))]
      }

      VisualMapModel.prototype.isCategory = function () {
        return !!this.option.categories
      }
      /**
       * @public
       * @abstract
       */

      VisualMapModel.prototype.setSelected = function (selected) {}

      VisualMapModel.prototype.getSelected = function () {
        return null
      }
      /**
       * @public
       * @abstract
       */

      VisualMapModel.prototype.getValueState = function (value) {
        return null
      }
      /**
       * FIXME
       * Do not publish to thirt-part-dev temporarily
       * util the interface is stable. (Should it return
       * a function but not visual meta?)
       *
       * @pubilc
       * @abstract
       * @param getColorVisual
       *        params: value, valueState
       *        return: color
       * @return {Object} visualMeta
       *        should includes {stops, outerColors}
       *        outerColor means [colorBeyondMinValue, colorBeyondMaxValue]
       */

      VisualMapModel.prototype.getVisualMeta = function (getColorVisual) {
        return null
      }

      VisualMapModel.type = 'visualMap'
      VisualMapModel.dependencies = ['series']
      VisualMapModel.defaultOption = {
        show: true,
        // zlevel: 0,
        z: 4,
        seriesIndex: 'all',
        min: 0,
        max: 200,
        left: 0,
        right: null,
        top: null,
        bottom: 0,
        itemWidth: null,
        itemHeight: null,
        inverse: false,
        orient: 'vertical',
        backgroundColor: 'rgba(0,0,0,0)',
        borderColor: '#ccc',
        contentColor: '#5793f3',
        inactiveColor: '#aaa',
        borderWidth: 0,
        padding: 5,
        // 接受数组分别设定上右下左边距，同css
        textGap: 10,
        precision: 0,
        textStyle: {
          color: '#333' // 值域文字颜色

        }
      }
      return VisualMapModel
    }(ComponentModel))

  const DEFAULT_BAR_BOUND = [20, 140]

  const ContinuousModel =
    /** @class */
    (function (_super) {
      __extends(ContinuousModel, _super)

      function ContinuousModel () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = ContinuousModel.type
        return _this
      }
      /**
       * @override
       */

      ContinuousModel.prototype.optionUpdated = function (newOption, isInit) {
        _super.prototype.optionUpdated.apply(this, arguments)

        this.resetExtent()
        this.resetVisual(function (mappingOption) {
          mappingOption.mappingMethod = 'linear'
          mappingOption.dataExtent = this.getExtent()
        })

        this._resetRange()
      }
      /**
       * @protected
       * @override
       */

      ContinuousModel.prototype.resetItemSize = function () {
        _super.prototype.resetItemSize.apply(this, arguments)

        const itemSize = this.itemSize;
        (itemSize[0] == null || isNaN(itemSize[0])) && (itemSize[0] = DEFAULT_BAR_BOUND[0]);
        (itemSize[1] == null || isNaN(itemSize[1])) && (itemSize[1] = DEFAULT_BAR_BOUND[1])
      }
      /**
       * @private
       */

      ContinuousModel.prototype._resetRange = function () {
        const dataExtent = this.getExtent()
        const range = this.option.range

        if (!range || range.auto) {
          // `range` should always be array (so we dont use other
          // value like 'auto') for user-friend. (consider getOption).
          dataExtent.auto = 1
          this.option.range = dataExtent
        } else if (isArray(range)) {
          if (range[0] > range[1]) {
            range.reverse()
          }

          range[0] = Math.max(range[0], dataExtent[0])
          range[1] = Math.min(range[1], dataExtent[1])
        }
      }
      /**
       * @protected
       * @override
       */

      ContinuousModel.prototype.completeVisualOption = function () {
        _super.prototype.completeVisualOption.apply(this, arguments)

        each(this.stateList, function (state) {
          const symbolSize = this.option.controller[state].symbolSize

          if (symbolSize && symbolSize[0] !== symbolSize[1]) {
            symbolSize[0] = symbolSize[1] / 3 // For good looking.
          }
        }, this)
      }
      /**
       * @override
       */

      ContinuousModel.prototype.setSelected = function (selected) {
        this.option.range = selected.slice()

        this._resetRange()
      }
      /**
       * @public
       */

      ContinuousModel.prototype.getSelected = function () {
        const dataExtent = this.getExtent()
        const dataInterval = asc((this.get('range') || []).slice()) // Clamp

        dataInterval[0] > dataExtent[1] && (dataInterval[0] = dataExtent[1])
        dataInterval[1] > dataExtent[1] && (dataInterval[1] = dataExtent[1])
        dataInterval[0] < dataExtent[0] && (dataInterval[0] = dataExtent[0])
        dataInterval[1] < dataExtent[0] && (dataInterval[1] = dataExtent[0])
        return dataInterval
      }
      /**
       * @override
       */

      ContinuousModel.prototype.getValueState = function (value) {
        const range = this.option.range
        const dataExtent = this.getExtent() // When range[0] === dataExtent[0], any value larger than dataExtent[0] maps to 'inRange'.
        // range[1] is processed likewise.

        return (range[0] <= dataExtent[0] || range[0] <= value) && (range[1] >= dataExtent[1] || value <= range[1]) ? 'inRange' : 'outOfRange'
      }

      ContinuousModel.prototype.findTargetDataIndices = function (range) {
        const result = []
        this.eachTargetSeries(function (seriesModel) {
          const dataIndices = []
          const data = seriesModel.getData()
          data.each(this.getDataDimensionIndex(data), function (value, dataIndex) {
            range[0] <= value && value <= range[1] && dataIndices.push(dataIndex)
          }, this)
          result.push({
            seriesId: seriesModel.id,
            dataIndex: dataIndices
          })
        }, this)
        return result
      }
      /**
       * @implement
       */

      ContinuousModel.prototype.getVisualMeta = function (getColorVisual) {
        const oVals = getColorStopValues(this, 'outOfRange', this.getExtent())
        const iVals = getColorStopValues(this, 'inRange', this.option.range.slice())
        const stops = []

        function setStop (value, valueState) {
          stops.push({
            value: value,
            color: getColorVisual(value, valueState)
          })
        } // Format to: outOfRange -- inRange -- outOfRange.

        let iIdx = 0
        let oIdx = 0
        const iLen = iVals.length
        const oLen = oVals.length

        for (; oIdx < oLen && (!iVals.length || oVals[oIdx] <= iVals[0]); oIdx++) {
          // If oVal[oIdx] === iVals[iIdx], oVal[oIdx] should be ignored.
          if (oVals[oIdx] < iVals[iIdx]) {
            setStop(oVals[oIdx], 'outOfRange')
          }
        }

        for (var first = 1; iIdx < iLen; iIdx++, first = 0) {
          // If range is full, value beyond min, max will be clamped.
          // make a singularity
          first && stops.length && setStop(iVals[iIdx], 'outOfRange')
          setStop(iVals[iIdx], 'inRange')
        }

        for (var first = 1; oIdx < oLen; oIdx++) {
          if (!iVals.length || iVals[iVals.length - 1] < oVals[oIdx]) {
            // make a singularity
            if (first) {
              stops.length && setStop(stops[stops.length - 1].value, 'outOfRange')
              first = 0
            }

            setStop(oVals[oIdx], 'outOfRange')
          }
        }

        const stopsLen = stops.length
        return {
          stops: stops,
          outerColors: [stopsLen ? stops[0].color : 'transparent', stopsLen ? stops[stopsLen - 1].color : 'transparent']
        }
      }

      ContinuousModel.type = 'visualMap.continuous'
      ContinuousModel.defaultOption = inheritDefaultOption(VisualMapModel.defaultOption, {
        align: 'auto',
        calculable: false,
        hoverLink: true,
        realtime: true,
        handleIcon: 'path://M-11.39,9.77h0a3.5,3.5,0,0,1-3.5,3.5h-22a3.5,3.5,0,0,1-3.5-3.5h0a3.5,3.5,0,0,1,3.5-3.5h22A3.5,3.5,0,0,1-11.39,9.77Z',
        handleSize: '120%',
        handleStyle: {
          borderColor: '#fff',
          borderWidth: 1
        },
        indicatorIcon: 'circle',
        indicatorSize: '50%',
        indicatorStyle: {
          borderColor: '#fff',
          borderWidth: 2,
          shadowBlur: 2,
          shadowOffsetX: 1,
          shadowOffsetY: 1,
          shadowColor: 'rgba(0,0,0,0.2)'
        } // emphasis: {
        //     handleStyle: {
        //         shadowBlur: 3,
        //         shadowOffsetX: 1,
        //         shadowOffsetY: 1,
        //         shadowColor: 'rgba(0,0,0,0.2)'
        //     }
        // }

      })
      return ContinuousModel
    }(VisualMapModel))

  function getColorStopValues (visualMapModel, valueState, dataExtent) {
    if (dataExtent[0] === dataExtent[1]) {
      return dataExtent.slice()
    } // When using colorHue mapping, it is not linear color any more.
    // Moreover, canvas gradient seems not to be accurate linear.
    // FIXME
    // Should be arbitrary value 100? or based on pixel size?

    const count = 200
    const step = (dataExtent[1] - dataExtent[0]) / count
    let value = dataExtent[0]
    const stopValues = []

    for (let i = 0; i <= count && value < dataExtent[1]; i++) {
      stopValues.push(value)
      value += step
    }

    stopValues.push(dataExtent[1])
    return stopValues
  }

  const VisualMapView =
    /** @class */
    (function (_super) {
      __extends(VisualMapView, _super)

      function VisualMapView () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = VisualMapView.type
        _this.autoPositionValues = {
          left: 1,
          right: 1,
          top: 1,
          bottom: 1
        }
        return _this
      }

      VisualMapView.prototype.init = function (ecModel, api) {
        this.ecModel = ecModel
        this.api = api
      }
      /**
       * @protected
       */

      VisualMapView.prototype.render = function (visualMapModel, ecModel, api, payload // TODO: TYPE
      ) {
        this.visualMapModel = visualMapModel

        if (visualMapModel.get('show') === false) {
          this.group.removeAll()
          return
        }

        this.doRender(visualMapModel, ecModel, api, payload)
      }
      /**
       * @protected
       */

      VisualMapView.prototype.renderBackground = function (group) {
        const visualMapModel = this.visualMapModel
        const padding = normalizeCssArray$1(visualMapModel.get('padding') || 0)
        const rect = group.getBoundingRect()
        group.add(new Rect({
          z2: -1,
          silent: true,
          shape: {
            x: rect.x - padding[3],
            y: rect.y - padding[0],
            width: rect.width + padding[3] + padding[1],
            height: rect.height + padding[0] + padding[2]
          },
          style: {
            fill: visualMapModel.get('backgroundColor'),
            stroke: visualMapModel.get('borderColor'),
            lineWidth: visualMapModel.get('borderWidth')
          }
        }))
      }
      /**
       * @protected
       * @param targetValue can be Infinity or -Infinity
       * @param visualCluster Only can be 'color' 'opacity' 'symbol' 'symbolSize'
       * @param opts
       * @param opts.forceState Specify state, instead of using getValueState method.
       * @param opts.convertOpacityToAlpha For color gradient in controller widget.
       * @return {*} Visual value.
       */

      VisualMapView.prototype.getControllerVisual = function (targetValue, visualCluster, opts) {
        opts = opts || {}
        const forceState = opts.forceState
        const visualMapModel = this.visualMapModel
        const visualObj = {} // Default values.

        if (visualCluster === 'color') {
          const defaultColor = visualMapModel.get('contentColor')
          visualObj.color = defaultColor
        }

        function getter (key) {
          return visualObj[key]
        }

        function setter (key, value) {
          visualObj[key] = value
        }

        const mappings = visualMapModel.controllerVisuals[forceState || visualMapModel.getValueState(targetValue)]
        const visualTypes = VisualMapping.prepareVisualTypes(mappings)
        each(visualTypes, function (type) {
          let visualMapping = mappings[type]

          if (opts.convertOpacityToAlpha && type === 'opacity') {
            type = 'colorAlpha'
            visualMapping = mappings.__alphaForOpacity
          }

          if (VisualMapping.dependsOn(type, visualCluster)) {
            visualMapping && visualMapping.applyVisual(targetValue, getter, setter)
          }
        })
        return visualObj[visualCluster]
      }

      VisualMapView.prototype.positionGroup = function (group) {
        const model = this.visualMapModel
        const api = this.api
        positionElement(group, model.getBoxLayoutParams(), {
          width: api.getWidth(),
          height: api.getHeight()
        })
      }

      VisualMapView.prototype.doRender = function (visualMapModel, ecModel, api, payload) {}

      VisualMapView.type = 'visualMap'
      return VisualMapView
    }(ComponentView))

  const paramsSet = [['left', 'right', 'width'], ['top', 'bottom', 'height']]
  /**
     * @param visualMapModel
     * @param api
     * @param itemSize always [short, long]
     * @return {string} 'left' or 'right' or 'top' or 'bottom'
     */

  function getItemAlign (visualMapModel, api, itemSize) {
    const modelOption = visualMapModel.option
    const itemAlign = modelOption.align

    if (itemAlign != null && itemAlign !== 'auto') {
      return itemAlign
    } // Auto decision align.

    const ecSize = {
      width: api.getWidth(),
      height: api.getHeight()
    }
    const realIndex = modelOption.orient === 'horizontal' ? 1 : 0
    const reals = paramsSet[realIndex]
    const fakeValue = [0, null, 10]
    const layoutInput = {}

    for (let i = 0; i < 3; i++) {
      layoutInput[paramsSet[1 - realIndex][i]] = fakeValue[i]
      layoutInput[reals[i]] = i === 2 ? itemSize[0] : modelOption[reals[i]]
    }

    const rParam = [['x', 'width', 3], ['y', 'height', 0]][realIndex]
    const rect = getLayoutRect(layoutInput, ecSize, modelOption.padding)
    return reals[(rect.margin[rParam[2]] || 0) + rect[rParam[0]] + rect[rParam[1]] * 0.5 < ecSize[rParam[1]] * 0.5 ? 0 : 1]
  }
  /**
     * Prepare dataIndex for outside usage, where dataIndex means rawIndex, and
     * dataIndexInside means filtered index.
     */
  // TODO: TYPE more specified payload types.

  function makeHighDownBatch (batch, visualMapModel) {
    each(batch || [], function (batchItem) {
      if (batchItem.dataIndex != null) {
        batchItem.dataIndexInside = batchItem.dataIndex
        batchItem.dataIndex = null
      }

      batchItem.highlightKey = 'visualMap' + (visualMapModel ? visualMapModel.componentIndex : '')
    })
    return batch
  }

  const linearMap$2 = linearMap
  const each$e = each
  const mathMin$a = Math.min
  const mathMax$a = Math.max // Arbitrary value

  const HOVER_LINK_SIZE = 12
  const HOVER_LINK_OUT = 6 // Notice:
  // Any "interval" should be by the order of [low, high].
  // "handle0" (handleIndex === 0) maps to
  // low data value: this._dataInterval[0] and has low coord.
  // "handle1" (handleIndex === 1) maps to
  // high data value: this._dataInterval[1] and has high coord.
  // The logic of transform is implemented in this._createBarGroup.

  const ContinuousView =
    /** @class */
    (function (_super) {
      __extends(ContinuousView, _super)

      function ContinuousView () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = ContinuousView.type
        _this._shapes = {}
        _this._dataInterval = []
        _this._handleEnds = []
        _this._hoverLinkDataIndices = []
        return _this
      }

      ContinuousView.prototype.doRender = function (visualMapModel, ecModel, api, payload) {
        this._api = api

        if (!payload || payload.type !== 'selectDataRange' || payload.from !== this.uid) {
          this._buildView()
        }
      }

      ContinuousView.prototype._buildView = function () {
        this.group.removeAll()
        const visualMapModel = this.visualMapModel
        const thisGroup = this.group
        this._orient = visualMapModel.get('orient')
        this._useHandle = visualMapModel.get('calculable')

        this._resetInterval()

        this._renderBar(thisGroup)

        const dataRangeText = visualMapModel.get('text')

        this._renderEndsText(thisGroup, dataRangeText, 0)

        this._renderEndsText(thisGroup, dataRangeText, 1) // Do this for background size calculation.

        this._updateView(true) // After updating view, inner shapes is built completely,
        // and then background can be rendered.

        this.renderBackground(thisGroup) // Real update view

        this._updateView()

        this._enableHoverLinkToSeries()

        this._enableHoverLinkFromSeries()

        this.positionGroup(thisGroup)
      }

      ContinuousView.prototype._renderEndsText = function (group, dataRangeText, endsIndex) {
        if (!dataRangeText) {
          return
        } // Compatible with ec2, text[0] map to high value, text[1] map low value.

        let text = dataRangeText[1 - endsIndex]
        text = text != null ? text + '' : ''
        const visualMapModel = this.visualMapModel
        const textGap = visualMapModel.get('textGap')
        const itemSize = visualMapModel.itemSize
        const barGroup = this._shapes.mainGroup

        const position = this._applyTransform([itemSize[0] / 2, endsIndex === 0 ? -textGap : itemSize[1] + textGap], barGroup)

        const align = this._applyTransform(endsIndex === 0 ? 'bottom' : 'top', barGroup)

        const orient = this._orient
        const textStyleModel = this.visualMapModel.textStyleModel
        this.group.add(new ZRText({
          style: createTextStyle(textStyleModel, {
            x: position[0],
            y: position[1],
            verticalAlign: orient === 'horizontal' ? 'middle' : align,
            align: orient === 'horizontal' ? align : 'center',
            text: text
          })
        }))
      }

      ContinuousView.prototype._renderBar = function (targetGroup) {
        const visualMapModel = this.visualMapModel
        const shapes = this._shapes
        const itemSize = visualMapModel.itemSize
        const orient = this._orient
        const useHandle = this._useHandle
        const itemAlign = getItemAlign(visualMapModel, this.api, itemSize)

        const mainGroup = shapes.mainGroup = this._createBarGroup(itemAlign)

        const gradientBarGroup = new Group()
        mainGroup.add(gradientBarGroup) // Bar

        gradientBarGroup.add(shapes.outOfRange = createPolygon())
        gradientBarGroup.add(shapes.inRange = createPolygon(null, useHandle ? getCursor$1(this._orient) : null, bind(this._dragHandle, this, 'all', false), bind(this._dragHandle, this, 'all', true))) // A border radius clip.

        gradientBarGroup.setClipPath(new Rect({
          shape: {
            x: 0,
            y: 0,
            width: itemSize[0],
            height: itemSize[1],
            r: 3
          }
        }))
        const textRect = visualMapModel.textStyleModel.getTextRect('国')
        const textSize = mathMax$a(textRect.width, textRect.height) // Handle

        if (useHandle) {
          shapes.handleThumbs = []
          shapes.handleLabels = []
          shapes.handleLabelPoints = []

          this._createHandle(visualMapModel, mainGroup, 0, itemSize, textSize, orient)

          this._createHandle(visualMapModel, mainGroup, 1, itemSize, textSize, orient)
        }

        this._createIndicator(visualMapModel, mainGroup, itemSize, textSize, orient)

        targetGroup.add(mainGroup)
      }

      ContinuousView.prototype._createHandle = function (visualMapModel, mainGroup, handleIndex, itemSize, textSize, orient) {
        const onDrift = bind(this._dragHandle, this, handleIndex, false)
        const onDragEnd = bind(this._dragHandle, this, handleIndex, true)
        const handleSize = parsePercent(visualMapModel.get('handleSize'), itemSize[0])
        const handleThumb = createSymbol(visualMapModel.get('handleIcon'), -handleSize / 2, -handleSize / 2, handleSize, handleSize, null, true)
        const cursor = getCursor$1(this._orient)
        handleThumb.attr({
          cursor: cursor,
          draggable: true,
          drift: onDrift,
          ondragend: onDragEnd,
          onmousemove: function (e) {
            stop(e.event)
          }
        })
        handleThumb.x = itemSize[0] / 2
        handleThumb.useStyle(visualMapModel.getModel('handleStyle').getItemStyle())
        handleThumb.setStyle({
          strokeNoScale: true,
          strokeFirst: true
        })
        handleThumb.style.lineWidth *= 2
        handleThumb.ensureState('emphasis').style = visualMapModel.getModel(['emphasis', 'handleStyle']).getItemStyle()
        setAsHighDownDispatcher(handleThumb, true)
        mainGroup.add(handleThumb) // Text is always horizontal layout but should not be effected by
        // transform (orient/inverse). So label is built separately but not
        // use zrender/graphic/helper/RectText, and is located based on view
        // group (according to handleLabelPoint) but not barGroup.

        const textStyleModel = this.visualMapModel.textStyleModel
        const handleLabel = new ZRText({
          cursor: cursor,
          draggable: true,
          drift: onDrift,
          onmousemove: function (e) {
            // Fot mobile devicem, prevent screen slider on the button.
            stop(e.event)
          },
          ondragend: onDragEnd,
          style: createTextStyle(textStyleModel, {
            x: 0,
            y: 0,
            text: ''
          })
        })
        handleLabel.ensureState('blur').style = {
          opacity: 0.1
        }
        handleLabel.stateTransition = {
          duration: 200
        }
        this.group.add(handleLabel)
        const handleLabelPoint = [handleSize, 0]
        const shapes = this._shapes
        shapes.handleThumbs[handleIndex] = handleThumb
        shapes.handleLabelPoints[handleIndex] = handleLabelPoint
        shapes.handleLabels[handleIndex] = handleLabel
      }

      ContinuousView.prototype._createIndicator = function (visualMapModel, mainGroup, itemSize, textSize, orient) {
        const scale = parsePercent(visualMapModel.get('indicatorSize'), itemSize[0])
        const indicator = createSymbol(visualMapModel.get('indicatorIcon'), -scale / 2, -scale / 2, scale, scale, null, true)
        indicator.attr({
          cursor: 'move',
          invisible: true,
          silent: true,
          x: itemSize[0] / 2
        })
        const indicatorStyle = visualMapModel.getModel('indicatorStyle').getItemStyle()

        if (indicator instanceof ZRImage) {
          const pathStyle = indicator.style
          indicator.useStyle(extend({
            // TODO other properties like x, y ?
            image: pathStyle.image,
            x: pathStyle.x,
            y: pathStyle.y,
            width: pathStyle.width,
            height: pathStyle.height
          }, indicatorStyle))
        } else {
          indicator.useStyle(indicatorStyle)
        }

        mainGroup.add(indicator)
        const textStyleModel = this.visualMapModel.textStyleModel
        const indicatorLabel = new ZRText({
          silent: true,
          invisible: true,
          style: createTextStyle(textStyleModel, {
            x: 0,
            y: 0,
            text: ''
          })
        })
        this.group.add(indicatorLabel)
        const indicatorLabelPoint = [(orient === 'horizontal' ? textSize / 2 : HOVER_LINK_OUT) + itemSize[0] / 2, 0]
        const shapes = this._shapes
        shapes.indicator = indicator
        shapes.indicatorLabel = indicatorLabel
        shapes.indicatorLabelPoint = indicatorLabelPoint
        this._firstShowIndicator = true
      }

      ContinuousView.prototype._dragHandle = function (handleIndex, isEnd, // dx is event from ondragend if isEnd is true. It's not used
        dx, dy) {
        if (!this._useHandle) {
          return
        }

        this._dragging = !isEnd

        if (!isEnd) {
          // Transform dx, dy to bar coordination.
          const vertex = this._applyTransform([dx, dy], this._shapes.mainGroup, true)

          this._updateInterval(handleIndex, vertex[1])

          this._hideIndicator() // Considering realtime, update view should be executed
          // before dispatch action.

          this._updateView()
        } // dragEnd do not dispatch action when realtime.

        if (isEnd === !this.visualMapModel.get('realtime')) {
          // jshint ignore:line
          this.api.dispatchAction({
            type: 'selectDataRange',
            from: this.uid,
            visualMapId: this.visualMapModel.id,
            selected: this._dataInterval.slice()
          })
        }

        if (isEnd) {
          !this._hovering && this._clearHoverLinkToSeries()
        } else if (useHoverLinkOnHandle(this.visualMapModel)) {
          this._doHoverLinkToSeries(this._handleEnds[handleIndex], false)
        }
      }

      ContinuousView.prototype._resetInterval = function () {
        const visualMapModel = this.visualMapModel
        const dataInterval = this._dataInterval = visualMapModel.getSelected()
        const dataExtent = visualMapModel.getExtent()
        const sizeExtent = [0, visualMapModel.itemSize[1]]
        this._handleEnds = [linearMap$2(dataInterval[0], dataExtent, sizeExtent, true), linearMap$2(dataInterval[1], dataExtent, sizeExtent, true)]
      }
      /**
       * @private
       * @param {(number|string)} handleIndex 0 or 1 or 'all'
       * @param {number} dx
       * @param {number} dy
       */

      ContinuousView.prototype._updateInterval = function (handleIndex, delta) {
        delta = delta || 0
        const visualMapModel = this.visualMapModel
        const handleEnds = this._handleEnds
        const sizeExtent = [0, visualMapModel.itemSize[1]]
        sliderMove(delta, handleEnds, sizeExtent, handleIndex, // cross is forbiden
          0)
        const dataExtent = visualMapModel.getExtent() // Update data interval.

        this._dataInterval = [linearMap$2(handleEnds[0], sizeExtent, dataExtent, true), linearMap$2(handleEnds[1], sizeExtent, dataExtent, true)]
      }

      ContinuousView.prototype._updateView = function (forSketch) {
        const visualMapModel = this.visualMapModel
        const dataExtent = visualMapModel.getExtent()
        const shapes = this._shapes
        const outOfRangeHandleEnds = [0, visualMapModel.itemSize[1]]
        const inRangeHandleEnds = forSketch ? outOfRangeHandleEnds : this._handleEnds

        const visualInRange = this._createBarVisual(this._dataInterval, dataExtent, inRangeHandleEnds, 'inRange')

        const visualOutOfRange = this._createBarVisual(dataExtent, dataExtent, outOfRangeHandleEnds, 'outOfRange')

        shapes.inRange.setStyle({
          fill: visualInRange.barColor // opacity: visualInRange.opacity

        }).setShape('points', visualInRange.barPoints)
        shapes.outOfRange.setStyle({
          fill: visualOutOfRange.barColor // opacity: visualOutOfRange.opacity

        }).setShape('points', visualOutOfRange.barPoints)

        this._updateHandle(inRangeHandleEnds, visualInRange)
      }

      ContinuousView.prototype._createBarVisual = function (dataInterval, dataExtent, handleEnds, forceState) {
        const opts = {
          forceState: forceState,
          convertOpacityToAlpha: true
        }

        const colorStops = this._makeColorGradient(dataInterval, opts)

        const symbolSizes = [this.getControllerVisual(dataInterval[0], 'symbolSize', opts), this.getControllerVisual(dataInterval[1], 'symbolSize', opts)]

        const barPoints = this._createBarPoints(handleEnds, symbolSizes)

        return {
          barColor: new LinearGradient(0, 0, 0, 1, colorStops),
          barPoints: barPoints,
          handlesColor: [colorStops[0].color, colorStops[colorStops.length - 1].color]
        }
      }

      ContinuousView.prototype._makeColorGradient = function (dataInterval, opts) {
        // Considering colorHue, which is not linear, so we have to sample
        // to calculate gradient color stops, but not only caculate head
        // and tail.
        const sampleNumber = 100 // Arbitrary value.

        const colorStops = []
        const step = (dataInterval[1] - dataInterval[0]) / sampleNumber
        colorStops.push({
          color: this.getControllerVisual(dataInterval[0], 'color', opts),
          offset: 0
        })

        for (let i = 1; i < sampleNumber; i++) {
          const currValue = dataInterval[0] + step * i

          if (currValue > dataInterval[1]) {
            break
          }

          colorStops.push({
            color: this.getControllerVisual(currValue, 'color', opts),
            offset: i / sampleNumber
          })
        }

        colorStops.push({
          color: this.getControllerVisual(dataInterval[1], 'color', opts),
          offset: 1
        })
        return colorStops
      }

      ContinuousView.prototype._createBarPoints = function (handleEnds, symbolSizes) {
        const itemSize = this.visualMapModel.itemSize
        return [[itemSize[0] - symbolSizes[0], handleEnds[0]], [itemSize[0], handleEnds[0]], [itemSize[0], handleEnds[1]], [itemSize[0] - symbolSizes[1], handleEnds[1]]]
      }

      ContinuousView.prototype._createBarGroup = function (itemAlign) {
        const orient = this._orient
        const inverse = this.visualMapModel.get('inverse')
        return new Group(orient === 'horizontal' && !inverse
          ? {
              scaleX: itemAlign === 'bottom' ? 1 : -1,
              rotation: Math.PI / 2
            }
          : orient === 'horizontal' && inverse
            ? {
                scaleX: itemAlign === 'bottom' ? -1 : 1,
                rotation: -Math.PI / 2
              }
            : orient === 'vertical' && !inverse
              ? {
                  scaleX: itemAlign === 'left' ? 1 : -1,
                  scaleY: -1
                }
              : {
                  scaleX: itemAlign === 'left' ? 1 : -1
                })
      }

      ContinuousView.prototype._updateHandle = function (handleEnds, visualInRange) {
        if (!this._useHandle) {
          return
        }

        const shapes = this._shapes
        const visualMapModel = this.visualMapModel
        const handleThumbs = shapes.handleThumbs
        const handleLabels = shapes.handleLabels
        const itemSize = visualMapModel.itemSize
        const dataExtent = visualMapModel.getExtent()
        each$e([0, 1], function (handleIndex) {
          const handleThumb = handleThumbs[handleIndex]
          handleThumb.setStyle('fill', visualInRange.handlesColor[handleIndex])
          handleThumb.y = handleEnds[handleIndex]
          const val = linearMap$2(handleEnds[handleIndex], [0, itemSize[1]], dataExtent, true)
          const symbolSize = this.getControllerVisual(val, 'symbolSize')
          handleThumb.scaleX = handleThumb.scaleY = symbolSize / itemSize[0]
          handleThumb.x = itemSize[0] - symbolSize / 2 // Update handle label position.

          const textPoint = applyTransform$1(shapes.handleLabelPoints[handleIndex], getTransform(handleThumb, this.group))
          handleLabels[handleIndex].setStyle({
            x: textPoint[0],
            y: textPoint[1],
            text: visualMapModel.formatValueText(this._dataInterval[handleIndex]),
            verticalAlign: 'middle',
            align: this._orient === 'vertical' ? this._applyTransform('left', shapes.mainGroup) : 'center'
          })
        }, this)
      }

      ContinuousView.prototype._showIndicator = function (cursorValue, textValue, rangeSymbol, halfHoverLinkSize) {
        const visualMapModel = this.visualMapModel
        const dataExtent = visualMapModel.getExtent()
        const itemSize = visualMapModel.itemSize
        const sizeExtent = [0, itemSize[1]]
        const shapes = this._shapes
        const indicator = shapes.indicator

        if (!indicator) {
          return
        }

        indicator.attr('invisible', false)
        const opts = {
          convertOpacityToAlpha: true
        }
        const color = this.getControllerVisual(cursorValue, 'color', opts)
        const symbolSize = this.getControllerVisual(cursorValue, 'symbolSize')
        const y = linearMap$2(cursorValue, dataExtent, sizeExtent, true)
        const x = itemSize[0] - symbolSize / 2
        const oldIndicatorPos = {
          x: indicator.x,
          y: indicator.y
        } // Update handle label position.

        indicator.y = y
        indicator.x = x
        const textPoint = applyTransform$1(shapes.indicatorLabelPoint, getTransform(indicator, this.group))
        const indicatorLabel = shapes.indicatorLabel
        indicatorLabel.attr('invisible', false)

        const align = this._applyTransform('left', shapes.mainGroup)

        const orient = this._orient
        const isHorizontal = orient === 'horizontal'
        indicatorLabel.setStyle({
          text: (rangeSymbol || '') + visualMapModel.formatValueText(textValue),
          verticalAlign: isHorizontal ? align : 'middle',
          align: isHorizontal ? 'center' : align
        })
        const indicatorNewProps = {
          x: x,
          y: y,
          style: {
            fill: color
          }
        }
        const labelNewProps = {
          style: {
            x: textPoint[0],
            y: textPoint[1]
          }
        }

        if (visualMapModel.ecModel.isAnimationEnabled() && !this._firstShowIndicator) {
          const animationCfg = {
            duration: 100,
            easing: 'cubicInOut',
            additive: true
          }
          indicator.x = oldIndicatorPos.x
          indicator.y = oldIndicatorPos.y
          indicator.animateTo(indicatorNewProps, animationCfg)
          indicatorLabel.animateTo(labelNewProps, animationCfg)
        } else {
          indicator.attr(indicatorNewProps)
          indicatorLabel.attr(labelNewProps)
        }

        this._firstShowIndicator = false
        const handleLabels = this._shapes.handleLabels

        if (handleLabels) {
          for (let i = 0; i < handleLabels.length; i++) {
            // Fade out handle labels.
            // NOTE: Must use api enter/leave on emphasis/blur/select state. Or the global states manager will change it.
            this._api.enterBlur(handleLabels[i])
          }
        }
      }

      ContinuousView.prototype._enableHoverLinkToSeries = function () {
        const self = this

        this._shapes.mainGroup.on('mousemove', function (e) {
          self._hovering = true

          if (!self._dragging) {
            const itemSize = self.visualMapModel.itemSize

            const pos = self._applyTransform([e.offsetX, e.offsetY], self._shapes.mainGroup, true, true) // For hover link show when hover handle, which might be
            // below or upper than sizeExtent.

            pos[1] = mathMin$a(mathMax$a(0, pos[1]), itemSize[1])

            self._doHoverLinkToSeries(pos[1], pos[0] >= 0 && pos[0] <= itemSize[0])
          }
        }).on('mouseout', function () {
          // When mouse is out of handle, hoverLink still need
          // to be displayed when realtime is set as false.
          self._hovering = false
          !self._dragging && self._clearHoverLinkToSeries()
        })
      }

      ContinuousView.prototype._enableHoverLinkFromSeries = function () {
        const zr = this.api.getZr()

        if (this.visualMapModel.option.hoverLink) {
          zr.on('mouseover', this._hoverLinkFromSeriesMouseOver, this)
          zr.on('mouseout', this._hideIndicator, this)
        } else {
          this._clearHoverLinkFromSeries()
        }
      }

      ContinuousView.prototype._doHoverLinkToSeries = function (cursorPos, hoverOnBar) {
        const visualMapModel = this.visualMapModel
        const itemSize = visualMapModel.itemSize

        if (!visualMapModel.option.hoverLink) {
          return
        }

        const sizeExtent = [0, itemSize[1]]
        const dataExtent = visualMapModel.getExtent() // For hover link show when hover handle, which might be below or upper than sizeExtent.

        cursorPos = mathMin$a(mathMax$a(sizeExtent[0], cursorPos), sizeExtent[1])
        const halfHoverLinkSize = getHalfHoverLinkSize(visualMapModel, dataExtent, sizeExtent)
        const hoverRange = [cursorPos - halfHoverLinkSize, cursorPos + halfHoverLinkSize]
        const cursorValue = linearMap$2(cursorPos, sizeExtent, dataExtent, true)
        const valueRange = [linearMap$2(hoverRange[0], sizeExtent, dataExtent, true), linearMap$2(hoverRange[1], sizeExtent, dataExtent, true)] // Consider data range is out of visualMap range, see test/visualMap-continuous.html,
        // where china and india has very large population.

        hoverRange[0] < sizeExtent[0] && (valueRange[0] = -Infinity)
        hoverRange[1] > sizeExtent[1] && (valueRange[1] = Infinity) // Do not show indicator when mouse is over handle,
        // otherwise labels overlap, especially when dragging.

        if (hoverOnBar) {
          if (valueRange[0] === -Infinity) {
            this._showIndicator(cursorValue, valueRange[1], '< ', halfHoverLinkSize)
          } else if (valueRange[1] === Infinity) {
            this._showIndicator(cursorValue, valueRange[0], '> ', halfHoverLinkSize)
          } else {
            this._showIndicator(cursorValue, cursorValue, '≈ ', halfHoverLinkSize)
          }
        } // When realtime is set as false, handles, which are in barGroup,
        // also trigger hoverLink, which help user to realize where they
        // focus on when dragging. (see test/heatmap-large.html)
        // When realtime is set as true, highlight will not show when hover
        // handle, because the label on handle, which displays a exact value
        // but not range, might mislead users.

        const oldBatch = this._hoverLinkDataIndices
        let newBatch = []

        if (hoverOnBar || useHoverLinkOnHandle(visualMapModel)) {
          newBatch = this._hoverLinkDataIndices = visualMapModel.findTargetDataIndices(valueRange)
        }

        const resultBatches = compressBatches(oldBatch, newBatch)

        this._dispatchHighDown('downplay', makeHighDownBatch(resultBatches[0], visualMapModel))

        this._dispatchHighDown('highlight', makeHighDownBatch(resultBatches[1], visualMapModel))
      }

      ContinuousView.prototype._hoverLinkFromSeriesMouseOver = function (e) {
        const el = e.target
        const visualMapModel = this.visualMapModel

        if (!el || getECData(el).dataIndex == null) {
          return
        }

        const ecData = getECData(el)
        const dataModel = this.ecModel.getSeriesByIndex(ecData.seriesIndex)

        if (!visualMapModel.isTargetSeries(dataModel)) {
          return
        }

        const data = dataModel.getData(ecData.dataType)
        const value = data.getStore().get(visualMapModel.getDataDimensionIndex(data), ecData.dataIndex)

        if (!isNaN(value)) {
          this._showIndicator(value, value)
        }
      }

      ContinuousView.prototype._hideIndicator = function () {
        const shapes = this._shapes
        shapes.indicator && shapes.indicator.attr('invisible', true)
        shapes.indicatorLabel && shapes.indicatorLabel.attr('invisible', true)
        const handleLabels = this._shapes.handleLabels

        if (handleLabels) {
          for (let i = 0; i < handleLabels.length; i++) {
            // Fade out handle labels.
            // NOTE: Must use api enter/leave on emphasis/blur/select state. Or the global states manager will change it.
            this._api.leaveBlur(handleLabels[i])
          }
        }
      }

      ContinuousView.prototype._clearHoverLinkToSeries = function () {
        this._hideIndicator()

        const indices = this._hoverLinkDataIndices

        this._dispatchHighDown('downplay', makeHighDownBatch(indices, this.visualMapModel))

        indices.length = 0
      }

      ContinuousView.prototype._clearHoverLinkFromSeries = function () {
        this._hideIndicator()

        const zr = this.api.getZr()
        zr.off('mouseover', this._hoverLinkFromSeriesMouseOver)
        zr.off('mouseout', this._hideIndicator)
      }

      ContinuousView.prototype._applyTransform = function (vertex, element, inverse, global) {
        const transform = getTransform(element, global ? null : this.group)
        return isArray(vertex) ? applyTransform$1(vertex, transform, inverse) : transformDirection(vertex, transform, inverse)
      } // TODO: TYPE more specified payload types.

      ContinuousView.prototype._dispatchHighDown = function (type, batch) {
        batch && batch.length && this.api.dispatchAction({
          type: type,
          batch: batch
        })
      }
      /**
       * @override
       */

      ContinuousView.prototype.dispose = function () {
        this._clearHoverLinkFromSeries()

        this._clearHoverLinkToSeries()
      }
      /**
       * @override
       */

      ContinuousView.prototype.remove = function () {
        this._clearHoverLinkFromSeries()

        this._clearHoverLinkToSeries()
      }

      ContinuousView.type = 'visualMap.continuous'
      return ContinuousView
    }(VisualMapView))

  function createPolygon (points, cursor, onDrift, onDragEnd) {
    return new Polygon({
      shape: {
        points: points
      },
      draggable: !!onDrift,
      cursor: cursor,
      drift: onDrift,
      onmousemove: function (e) {
        // Fot mobile devicem, prevent screen slider on the button.
        stop(e.event)
      },
      ondragend: onDragEnd
    })
  }

  function getHalfHoverLinkSize (visualMapModel, dataExtent, sizeExtent) {
    let halfHoverLinkSize = HOVER_LINK_SIZE / 2
    const hoverLinkDataSize = visualMapModel.get('hoverLinkDataSize')

    if (hoverLinkDataSize) {
      halfHoverLinkSize = linearMap$2(hoverLinkDataSize, dataExtent, sizeExtent, true) / 2
    }

    return halfHoverLinkSize
  }

  function useHoverLinkOnHandle (visualMapModel) {
    const hoverLinkOnHandle = visualMapModel.get('hoverLinkOnHandle')
    return !!(hoverLinkOnHandle == null ? visualMapModel.get('realtime') : hoverLinkOnHandle)
  }

  function getCursor$1 (orient) {
    return orient === 'vertical' ? 'ns-resize' : 'ew-resize'
  }

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */

  /**
     * AUTO-GENERATED FILE. DO NOT MODIFY.
     */

  /*
    * Licensed to the Apache Software Foundation (ASF) under one
    * or more contributor license agreements.  See the NOTICE file
    * distributed with this work for additional information
    * regarding copyright ownership.  The ASF licenses this file
    * to you under the Apache License, Version 2.0 (the
    * "License"); you may not use this file except in compliance
    * with the License.  You may obtain a copy of the License at
    *
    *   http://www.apache.org/licenses/LICENSE-2.0
    *
    * Unless required by applicable law or agreed to in writing,
    * software distributed under the License is distributed on an
    * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    * KIND, either express or implied.  See the License for the
    * specific language governing permissions and limitations
    * under the License.
    */
  const visualMapActionInfo = {
    type: 'selectDataRange',
    event: 'dataRangeSelected',
    // FIXME use updateView appears wrong
    update: 'update'
  }
  const visualMapActionHander = function (payload, ecModel) {
    ecModel.eachComponent({
      mainType: 'visualMap',
      query: payload
    }, function (model) {
      model.setSelected(payload.selected)
    })
  }

  const visualMapEncodingHandlers = [{
    createOnAllSeries: true,
    reset: function (seriesModel, ecModel) {
      const resetDefines = []
      ecModel.eachComponent('visualMap', function (visualMapModel) {
        const pipelineContext = seriesModel.pipelineContext

        if (!visualMapModel.isTargetSeries(seriesModel) || pipelineContext && pipelineContext.large) {
          return
        }

        resetDefines.push(incrementalApplyVisual(visualMapModel.stateList, visualMapModel.targetVisuals, bind(visualMapModel.getValueState, visualMapModel), visualMapModel.getDataDimensionIndex(seriesModel.getData())))
      })
      return resetDefines
    }
  }, // Only support color.
  {
    createOnAllSeries: true,
    reset: function (seriesModel, ecModel) {
      const data = seriesModel.getData()
      const visualMetaList = []
      ecModel.eachComponent('visualMap', function (visualMapModel) {
        if (visualMapModel.isTargetSeries(seriesModel)) {
          const visualMeta = visualMapModel.getVisualMeta(bind(getColorVisual, null, seriesModel, visualMapModel)) || {
            stops: [],
            outerColors: []
          }
          const dimIdx = visualMapModel.getDataDimensionIndex(data)

          if (dimIdx >= 0) {
            // visualMeta.dimension should be dimension index, but not concrete dimension.
            visualMeta.dimension = dimIdx
            visualMetaList.push(visualMeta)
          }
        }
      }) // console.log(JSON.stringify(visualMetaList.map(a => a.stops)));

      seriesModel.getData().setVisual('visualMeta', visualMetaList)
    }
  }] // FIXME
  // performance and export for heatmap?
  // value can be Infinity or -Infinity

  function getColorVisual (seriesModel, visualMapModel, value, valueState) {
    const mappings = visualMapModel.targetVisuals[valueState]
    const visualTypes = VisualMapping.prepareVisualTypes(mappings)
    const resultVisual = {
      color: getVisualFromData(seriesModel.getData(), 'color') // default color.

    }

    for (let i = 0, len = visualTypes.length; i < len; i++) {
      const type = visualTypes[i]
      const mapping = mappings[type === 'opacity' ? '__alphaForOpacity' : type]
      mapping && mapping.applyVisual(value, getVisual, setVisual)
    }

    return resultVisual.color

    function getVisual (key) {
      return resultVisual[key]
    }

    function setVisual (key, value) {
      resultVisual[key] = value
    }
  }

  const each$f = each
  function visualMapPreprocessor (option) {
    let visualMap = option && option.visualMap

    if (!isArray(visualMap)) {
      visualMap = visualMap ? [visualMap] : []
    }

    each$f(visualMap, function (opt) {
      if (!opt) {
        return
      } // rename splitList to pieces

      if (has$1(opt, 'splitList') && !has$1(opt, 'pieces')) {
        opt.pieces = opt.splitList
        delete opt.splitList
      }

      const pieces = opt.pieces

      if (pieces && isArray(pieces)) {
        each$f(pieces, function (piece) {
          if (isObject(piece)) {
            if (has$1(piece, 'start') && !has$1(piece, 'min')) {
              piece.min = piece.start
            }

            if (has$1(piece, 'end') && !has$1(piece, 'max')) {
              piece.max = piece.end
            }
          }
        })
      }
    })
  }

  function has$1 (obj, name) {
    return obj && obj.hasOwnProperty && obj.hasOwnProperty(name)
  }

  let installed$1 = false
  function installCommon$1 (registers) {
    if (installed$1) {
      return
    }

    installed$1 = true
    registers.registerSubTypeDefaulter('visualMap', function (option) {
      // Compatible with ec2, when splitNumber === 0, continuous visualMap will be used.
      return !option.categories && (!(option.pieces ? option.pieces.length > 0 : option.splitNumber > 0) || option.calculable) ? 'continuous' : 'piecewise'
    })
    registers.registerAction(visualMapActionInfo, visualMapActionHander)
    each(visualMapEncodingHandlers, function (handler) {
      registers.registerVisual(registers.PRIORITY.VISUAL.COMPONENT, handler)
    })
    registers.registerPreprocessor(visualMapPreprocessor)
  }

  function install$N (registers) {
    registers.registerComponentModel(ContinuousModel)
    registers.registerComponentView(ContinuousView)
    installCommon$1(registers)
  }

  const PiecewiseModel =
    /** @class */
    (function (_super) {
      __extends(PiecewiseModel, _super)

      function PiecewiseModel () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = PiecewiseModel.type
        /**
         * The order is always [low, ..., high].
         * [{text: string, interval: Array.<number>}, ...]
         */

        _this._pieceList = []
        return _this
      }

      PiecewiseModel.prototype.optionUpdated = function (newOption, isInit) {
        _super.prototype.optionUpdated.apply(this, arguments)

        this.resetExtent()

        const mode = this._mode = this._determineMode()

        this._pieceList = []

        resetMethods[this._mode].call(this, this._pieceList)

        this._resetSelected(newOption, isInit)

        const categories = this.option.categories
        this.resetVisual(function (mappingOption, state) {
          if (mode === 'categories') {
            mappingOption.mappingMethod = 'category'
            mappingOption.categories = clone(categories)
          } else {
            mappingOption.dataExtent = this.getExtent()
            mappingOption.mappingMethod = 'piecewise'
            mappingOption.pieceList = map(this._pieceList, function (piece) {
              piece = clone(piece)

              if (state !== 'inRange') {
                // FIXME
                // outOfRange do not support special visual in pieces.
                piece.visual = null
              }

              return piece
            })
          }
        })
      }
      /**
       * @protected
       * @override
       */

      PiecewiseModel.prototype.completeVisualOption = function () {
        // Consider this case:
        // visualMap: {
        //      pieces: [{symbol: 'circle', lt: 0}, {symbol: 'rect', gte: 0}]
        // }
        // where no inRange/outOfRange set but only pieces. So we should make
        // default inRange/outOfRange for this case, otherwise visuals that only
        // appear in `pieces` will not be taken into account in visual encoding.
        const option = this.option
        const visualTypesInPieces = {}
        const visualTypes = VisualMapping.listVisualTypes()
        const isCategory = this.isCategory()
        each(option.pieces, function (piece) {
          each(visualTypes, function (visualType) {
            if (piece.hasOwnProperty(visualType)) {
              visualTypesInPieces[visualType] = 1
            }
          })
        })
        each(visualTypesInPieces, function (v, visualType) {
          let exists = false
          each(this.stateList, function (state) {
            exists = exists || has(option, state, visualType) || has(option.target, state, visualType)
          }, this)
          !exists && each(this.stateList, function (state) {
            (option[state] || (option[state] = {}))[visualType] = visualDefault.get(visualType, state === 'inRange' ? 'active' : 'inactive', isCategory)
          })
        }, this)

        function has (obj, state, visualType) {
          return obj && obj[state] && obj[state].hasOwnProperty(visualType)
        }

        _super.prototype.completeVisualOption.apply(this, arguments)
      }

      PiecewiseModel.prototype._resetSelected = function (newOption, isInit) {
        const thisOption = this.option
        const pieceList = this._pieceList // Selected do not merge but all override.

        const selected = (isInit ? thisOption : newOption).selected || {}
        thisOption.selected = selected // Consider 'not specified' means true.

        each(pieceList, function (piece, index) {
          const key = this.getSelectedMapKey(piece)

          if (!selected.hasOwnProperty(key)) {
            selected[key] = true
          }
        }, this)

        if (thisOption.selectedMode === 'single') {
          // Ensure there is only one selected.
          let hasSel_1 = false
          each(pieceList, function (piece, index) {
            const key = this.getSelectedMapKey(piece)

            if (selected[key]) {
              hasSel_1 ? selected[key] = false : hasSel_1 = true
            }
          }, this)
        } // thisOption.selectedMode === 'multiple', default: all selected.
      }
      /**
       * @public
       */

      PiecewiseModel.prototype.getItemSymbol = function () {
        return this.get('itemSymbol')
      }
      /**
       * @public
       */

      PiecewiseModel.prototype.getSelectedMapKey = function (piece) {
        return this._mode === 'categories' ? piece.value + '' : piece.index + ''
      }
      /**
       * @public
       */

      PiecewiseModel.prototype.getPieceList = function () {
        return this._pieceList
      }
      /**
       * @return {string}
       */

      PiecewiseModel.prototype._determineMode = function () {
        const option = this.option
        return option.pieces && option.pieces.length > 0 ? 'pieces' : this.option.categories ? 'categories' : 'splitNumber'
      }
      /**
       * @override
       */

      PiecewiseModel.prototype.setSelected = function (selected) {
        this.option.selected = clone(selected)
      }
      /**
       * @override
       */

      PiecewiseModel.prototype.getValueState = function (value) {
        const index = VisualMapping.findPieceIndex(value, this._pieceList)
        return index != null ? this.option.selected[this.getSelectedMapKey(this._pieceList[index])] ? 'inRange' : 'outOfRange' : 'outOfRange'
      }
      /**
       * @public
       * @param pieceIndex piece index in visualMapModel.getPieceList()
       */

      PiecewiseModel.prototype.findTargetDataIndices = function (pieceIndex) {
        const result = []
        const pieceList = this._pieceList
        this.eachTargetSeries(function (seriesModel) {
          const dataIndices = []
          const data = seriesModel.getData()
          data.each(this.getDataDimensionIndex(data), function (value, dataIndex) {
            // Should always base on model pieceList, because it is order sensitive.
            const pIdx = VisualMapping.findPieceIndex(value, pieceList)
            pIdx === pieceIndex && dataIndices.push(dataIndex)
          }, this)
          result.push({
            seriesId: seriesModel.id,
            dataIndex: dataIndices
          })
        }, this)
        return result
      }
      /**
       * @private
       * @param piece piece.value or piece.interval is required.
       * @return  Can be Infinity or -Infinity
       */

      PiecewiseModel.prototype.getRepresentValue = function (piece) {
        let representValue

        if (this.isCategory()) {
          representValue = piece.value
        } else {
          if (piece.value != null) {
            representValue = piece.value
          } else {
            const pieceInterval = piece.interval || []
            representValue = pieceInterval[0] === -Infinity && pieceInterval[1] === Infinity ? 0 : (pieceInterval[0] + pieceInterval[1]) / 2
          }
        }

        return representValue
      }

      PiecewiseModel.prototype.getVisualMeta = function (getColorVisual) {
        // Do not support category. (category axis is ordinal, numerical)
        if (this.isCategory()) {
          return
        }

        const stops = []
        const outerColors = ['', '']
        const visualMapModel = this

        function setStop (interval, valueState) {
          const representValue = visualMapModel.getRepresentValue({
            interval: interval
          }) // Not category

          if (!valueState) {
            valueState = visualMapModel.getValueState(representValue)
          }

          const color = getColorVisual(representValue, valueState)

          if (interval[0] === -Infinity) {
            outerColors[0] = color
          } else if (interval[1] === Infinity) {
            outerColors[1] = color
          } else {
            stops.push({
              value: interval[0],
              color: color
            }, {
              value: interval[1],
              color: color
            })
          }
        } // Suplement

        const pieceList = this._pieceList.slice()

        if (!pieceList.length) {
          pieceList.push({
            interval: [-Infinity, Infinity]
          })
        } else {
          let edge = pieceList[0].interval[0]
          edge !== -Infinity && pieceList.unshift({
            interval: [-Infinity, edge]
          })
          edge = pieceList[pieceList.length - 1].interval[1]
          edge !== Infinity && pieceList.push({
            interval: [edge, Infinity]
          })
        }

        let curr = -Infinity
        each(pieceList, function (piece) {
          const interval = piece.interval

          if (interval) {
            // Fulfill gap.
            interval[0] > curr && setStop([curr, interval[0]], 'outOfRange')
            setStop(interval.slice())
            curr = interval[1]
          }
        }, this)
        return {
          stops: stops,
          outerColors: outerColors
        }
      }

      PiecewiseModel.type = 'visualMap.piecewise'
      PiecewiseModel.defaultOption = inheritDefaultOption(VisualMapModel.defaultOption, {
        selected: null,
        minOpen: false,
        maxOpen: false,
        align: 'auto',
        itemWidth: 20,
        itemHeight: 14,
        itemSymbol: 'roundRect',
        pieces: null,
        categories: null,
        splitNumber: 5,
        selectedMode: 'multiple',
        itemGap: 10,
        hoverLink: true // Enable hover highlight.

      })
      return PiecewiseModel
    }(VisualMapModel))
    /**
     * Key is this._mode
     * @type {Object}
     * @this {module:echarts/component/viusalMap/PiecewiseMode}
     */

  var resetMethods = {
    splitNumber: function (outPieceList) {
      const thisOption = this.option
      let precision = Math.min(thisOption.precision, 20)
      const dataExtent = this.getExtent()
      let splitNumber = thisOption.splitNumber
      splitNumber = Math.max(parseInt(splitNumber, 10), 1)
      thisOption.splitNumber = splitNumber
      let splitStep = (dataExtent[1] - dataExtent[0]) / splitNumber // Precision auto-adaption

      while (+splitStep.toFixed(precision) !== splitStep && precision < 5) {
        precision++
      }

      thisOption.precision = precision
      splitStep = +splitStep.toFixed(precision)

      if (thisOption.minOpen) {
        outPieceList.push({
          interval: [-Infinity, dataExtent[0]],
          close: [0, 0]
        })
      }

      for (let index = 0, curr = dataExtent[0]; index < splitNumber; curr += splitStep, index++) {
        const max = index === splitNumber - 1 ? dataExtent[1] : curr + splitStep
        outPieceList.push({
          interval: [curr, max],
          close: [1, 1]
        })
      }

      if (thisOption.maxOpen) {
        outPieceList.push({
          interval: [dataExtent[1], Infinity],
          close: [0, 0]
        })
      }

      reformIntervals(outPieceList)
      each(outPieceList, function (piece, index) {
        piece.index = index
        piece.text = this.formatValueText(piece.interval)
      }, this)
    },
    categories: function (outPieceList) {
      const thisOption = this.option
      each(thisOption.categories, function (cate) {
        // FIXME category模式也使用pieceList，但在visualMapping中不是使用pieceList。
        // 是否改一致。
        outPieceList.push({
          text: this.formatValueText(cate, true),
          value: cate
        })
      }, this) // See "Order Rule".

      normalizeReverse(thisOption, outPieceList)
    },
    pieces: function (outPieceList) {
      const thisOption = this.option
      each(thisOption.pieces, function (pieceListItem, index) {
        if (!isObject(pieceListItem)) {
          pieceListItem = {
            value: pieceListItem
          }
        }

        const item = {
          text: '',
          index: index
        }

        if (pieceListItem.label != null) {
          item.text = pieceListItem.label
        }

        if (pieceListItem.hasOwnProperty('value')) {
          const value = item.value = pieceListItem.value
          item.interval = [value, value]
          item.close = [1, 1]
        } else {
          // `min` `max` is legacy option.
          // `lt` `gt` `lte` `gte` is recommanded.
          const interval = item.interval = []
          const close_1 = item.close = [0, 0]
          const closeList = [1, 0, 1]
          const infinityList = [-Infinity, Infinity]
          const useMinMax = []

          for (let lg = 0; lg < 2; lg++) {
            const names = [['gte', 'gt', 'min'], ['lte', 'lt', 'max']][lg]

            for (let i = 0; i < 3 && interval[lg] == null; i++) {
              interval[lg] = pieceListItem[names[i]]
              close_1[lg] = closeList[i]
              useMinMax[lg] = i === 2
            }

            interval[lg] == null && (interval[lg] = infinityList[lg])
          }

          useMinMax[0] && interval[1] === Infinity && (close_1[0] = 0)
          useMinMax[1] && interval[0] === -Infinity && (close_1[1] = 0)

          if ('development' !== 'production') {
            if (interval[0] > interval[1]) {
              console.warn('Piece ' + index + 'is illegal: ' + interval + ' lower bound should not greater then uppper bound.')
            }
          }

          if (interval[0] === interval[1] && close_1[0] && close_1[1]) {
            // Consider: [{min: 5, max: 5, visual: {...}}, {min: 0, max: 5}],
            // we use value to lift the priority when min === max
            item.value = interval[0]
          }
        }

        item.visual = VisualMapping.retrieveVisuals(pieceListItem)
        outPieceList.push(item)
      }, this) // See "Order Rule".

      normalizeReverse(thisOption, outPieceList) // Only pieces

      reformIntervals(outPieceList)
      each(outPieceList, function (piece) {
        const close = piece.close
        const edgeSymbols = [['<', '≤'][close[1]], ['>', '≥'][close[0]]]
        piece.text = piece.text || this.formatValueText(piece.value != null ? piece.value : piece.interval, false, edgeSymbols)
      }, this)
    }
  }

  function normalizeReverse (thisOption, pieceList) {
    const inverse = thisOption.inverse

    if (thisOption.orient === 'vertical' ? !inverse : inverse) {
      pieceList.reverse()
    }
  }

  const PiecewiseVisualMapView =
    /** @class */
    (function (_super) {
      __extends(PiecewiseVisualMapView, _super)

      function PiecewiseVisualMapView () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = PiecewiseVisualMapView.type
        return _this
      }

      PiecewiseVisualMapView.prototype.doRender = function () {
        const thisGroup = this.group
        thisGroup.removeAll()
        const visualMapModel = this.visualMapModel
        const textGap = visualMapModel.get('textGap')
        const textStyleModel = visualMapModel.textStyleModel
        const textFont = textStyleModel.getFont()
        const textFill = textStyleModel.getTextColor()

        const itemAlign = this._getItemAlign()

        const itemSize = visualMapModel.itemSize

        const viewData = this._getViewData()

        const endsText = viewData.endsText
        const showLabel = retrieve(visualMapModel.get('showLabel', true), !endsText)
        endsText && this._renderEndsText(thisGroup, endsText[0], itemSize, showLabel, itemAlign)
        each(viewData.viewPieceList, function (item) {
          const piece = item.piece
          const itemGroup = new Group()
          itemGroup.onclick = bind(this._onItemClick, this, piece)

          this._enableHoverLink(itemGroup, item.indexInModelPieceList) // TODO Category

          const representValue = visualMapModel.getRepresentValue(piece)

          this._createItemSymbol(itemGroup, representValue, [0, 0, itemSize[0], itemSize[1]])

          if (showLabel) {
            const visualState = this.visualMapModel.getValueState(representValue)
            itemGroup.add(new ZRText({
              style: {
                x: itemAlign === 'right' ? -textGap : itemSize[0] + textGap,
                y: itemSize[1] / 2,
                text: piece.text,
                verticalAlign: 'middle',
                align: itemAlign,
                font: textFont,
                fill: textFill,
                opacity: visualState === 'outOfRange' ? 0.5 : 1
              }
            }))
          }

          thisGroup.add(itemGroup)
        }, this)
        endsText && this._renderEndsText(thisGroup, endsText[1], itemSize, showLabel, itemAlign)
        box(visualMapModel.get('orient'), thisGroup, visualMapModel.get('itemGap'))
        this.renderBackground(thisGroup)
        this.positionGroup(thisGroup)
      }

      PiecewiseVisualMapView.prototype._enableHoverLink = function (itemGroup, pieceIndex) {
        const _this = this

        itemGroup.on('mouseover', function () {
          return onHoverLink('highlight')
        }).on('mouseout', function () {
          return onHoverLink('downplay')
        })

        var onHoverLink = function (method) {
          const visualMapModel = _this.visualMapModel // TODO: TYPE More detailed action types

          visualMapModel.option.hoverLink && _this.api.dispatchAction({
            type: method,
            batch: makeHighDownBatch(visualMapModel.findTargetDataIndices(pieceIndex), visualMapModel)
          })
        }
      }

      PiecewiseVisualMapView.prototype._getItemAlign = function () {
        const visualMapModel = this.visualMapModel
        const modelOption = visualMapModel.option

        if (modelOption.orient === 'vertical') {
          return getItemAlign(visualMapModel, this.api, visualMapModel.itemSize)
        } else {
          // horizontal, most case left unless specifying right.
          let align = modelOption.align

          if (!align || align === 'auto') {
            align = 'left'
          }

          return align
        }
      }

      PiecewiseVisualMapView.prototype._renderEndsText = function (group, text, itemSize, showLabel, itemAlign) {
        if (!text) {
          return
        }

        const itemGroup = new Group()
        const textStyleModel = this.visualMapModel.textStyleModel
        itemGroup.add(new ZRText({
          style: createTextStyle(textStyleModel, {
            x: showLabel ? itemAlign === 'right' ? itemSize[0] : 0 : itemSize[0] / 2,
            y: itemSize[1] / 2,
            verticalAlign: 'middle',
            align: showLabel ? itemAlign : 'center',
            text: text
          })
        }))
        group.add(itemGroup)
      }
      /**
       * @private
       * @return {Object} {peiceList, endsText} The order is the same as screen pixel order.
       */

      PiecewiseVisualMapView.prototype._getViewData = function () {
        const visualMapModel = this.visualMapModel
        const viewPieceList = map(visualMapModel.getPieceList(), function (piece, index) {
          return {
            piece: piece,
            indexInModelPieceList: index
          }
        })
        let endsText = visualMapModel.get('text') // Consider orient and inverse.

        const orient = visualMapModel.get('orient')
        const inverse = visualMapModel.get('inverse') // Order of model pieceList is always [low, ..., high]

        if (orient === 'horizontal' ? inverse : !inverse) {
          viewPieceList.reverse()
        } // Origin order of endsText is [high, low]
        else if (endsText) {
          endsText = endsText.slice().reverse()
        }

        return {
          viewPieceList: viewPieceList,
          endsText: endsText
        }
      }

      PiecewiseVisualMapView.prototype._createItemSymbol = function (group, representValue, shapeParam) {
        group.add(createSymbol( // symbol will be string
          this.getControllerVisual(representValue, 'symbol'), shapeParam[0], shapeParam[1], shapeParam[2], shapeParam[3], // color will be string
          this.getControllerVisual(representValue, 'color')))
      }

      PiecewiseVisualMapView.prototype._onItemClick = function (piece) {
        const visualMapModel = this.visualMapModel
        const option = visualMapModel.option
        const selectedMode = option.selectedMode

        if (!selectedMode) {
          return
        }

        const selected = clone(option.selected)
        const newKey = visualMapModel.getSelectedMapKey(piece)

        if (selectedMode === 'single' || selectedMode === true) {
          selected[newKey] = true
          each(selected, function (o, key) {
            selected[key] = key === newKey
          })
        } else {
          selected[newKey] = !selected[newKey]
        }

        this.api.dispatchAction({
          type: 'selectDataRange',
          from: this.uid,
          visualMapId: this.visualMapModel.id,
          selected: selected
        })
      }

      PiecewiseVisualMapView.type = 'visualMap.piecewise'
      return PiecewiseVisualMapView
    }(VisualMapView))

  function install$O (registers) {
    registers.registerComponentModel(PiecewiseModel)
    registers.registerComponentView(PiecewiseVisualMapView)
    installCommon$1(registers)
  }

  function install$P (registers) {
    use(install$N)
    use(install$O) // Do not install './dataZoomSelect',
    // since it only work for toolbox dataZoom.
  }

  const DEFAULT_OPTION = {
    label: {
      enabled: true
    },
    decal: {
      show: false
    }
  }
  const inner$l = makeInner()
  const decalPaletteScope = {}
  function ariaVisual (ecModel, api) {
    const ariaModel = ecModel.getModel('aria') // See "area enabled" detection code in `GlobalModel.ts`.

    if (!ariaModel.get('enabled')) {
      return
    }

    const defaultOption = clone(DEFAULT_OPTION)
    merge(defaultOption.label, ecModel.getLocaleModel().get('aria'), false)
    merge(ariaModel.option, defaultOption, false)
    setDecal()
    setLabel()

    function setDecal () {
      const decalModel = ariaModel.getModel('decal')
      const useDecal = decalModel.get('show')

      if (useDecal) {
        // Each type of series use one scope.
        // Pie and funnel are using diferrent scopes
        const paletteScopeGroupByType_1 = createHashMap()
        ecModel.eachSeries(function (seriesModel) {
          if (seriesModel.isColorBySeries()) {
            return
          }

          let decalScope = paletteScopeGroupByType_1.get(seriesModel.type)

          if (!decalScope) {
            decalScope = {}
            paletteScopeGroupByType_1.set(seriesModel.type, decalScope)
          }

          inner$l(seriesModel).scope = decalScope
        })
        ecModel.eachRawSeries(function (seriesModel) {
          if (ecModel.isSeriesFiltered(seriesModel)) {
            return
          }

          if (isFunction(seriesModel.enableAriaDecal)) {
            // Let series define how to use decal palette on data
            seriesModel.enableAriaDecal()
            return
          }

          const data = seriesModel.getData()

          if (!seriesModel.isColorBySeries()) {
            const dataAll_1 = seriesModel.getRawData()
            const idxMap_1 = {}
            const decalScope_1 = inner$l(seriesModel).scope
            data.each(function (idx) {
              const rawIdx = data.getRawIndex(idx)
              idxMap_1[rawIdx] = idx
            })
            const dataCount_1 = dataAll_1.count()
            dataAll_1.each(function (rawIdx) {
              const idx = idxMap_1[rawIdx]
              const name = dataAll_1.getName(rawIdx) || rawIdx + ''
              const paletteDecal = getDecalFromPalette(seriesModel.ecModel, name, decalScope_1, dataCount_1)
              const specifiedDecal = data.getItemVisual(idx, 'decal')
              data.setItemVisual(idx, 'decal', mergeDecal(specifiedDecal, paletteDecal))
            })
          } else {
            const paletteDecal = getDecalFromPalette(seriesModel.ecModel, seriesModel.name, decalPaletteScope, ecModel.getSeriesCount())
            const specifiedDecal = data.getVisual('decal')
            data.setVisual('decal', mergeDecal(specifiedDecal, paletteDecal))
          }

          function mergeDecal (specifiedDecal, paletteDecal) {
            // Merge decal from palette to decal from itemStyle.
            // User do not need to specify all of the decal props.
            const resultDecal = specifiedDecal ? extend(extend({}, paletteDecal), specifiedDecal) : paletteDecal
            resultDecal.dirty = true
            return resultDecal
          }
        })
      }
    }

    function setLabel () {
      const labelLocale = ecModel.getLocaleModel().get('aria')
      const labelModel = ariaModel.getModel('label')
      labelModel.option = defaults(labelModel.option, labelLocale)

      if (!labelModel.get('enabled')) {
        return
      }

      const dom = api.getZr().dom

      if (labelModel.get('description')) {
        dom.setAttribute('aria-label', labelModel.get('description'))
        return
      }

      const seriesCnt = ecModel.getSeriesCount()
      const maxDataCnt = labelModel.get(['data', 'maxCount']) || 10
      const maxSeriesCnt = labelModel.get(['series', 'maxCount']) || 10
      const displaySeriesCnt = Math.min(seriesCnt, maxSeriesCnt)
      let ariaLabel

      if (seriesCnt < 1) {
        // No series, no aria label

      } else {
        const title = getTitle()

        if (title) {
          const withTitle = labelModel.get(['general', 'withTitle'])
          ariaLabel = replace(withTitle, {
            title: title
          })
        } else {
          ariaLabel = labelModel.get(['general', 'withoutTitle'])
        }

        const seriesLabels_1 = []
        const prefix = seriesCnt > 1 ? labelModel.get(['series', 'multiple', 'prefix']) : labelModel.get(['series', 'single', 'prefix'])
        ariaLabel += replace(prefix, {
          seriesCount: seriesCnt
        })
        ecModel.eachSeries(function (seriesModel, idx) {
          if (idx < displaySeriesCnt) {
            let seriesLabel = void 0
            const seriesName = seriesModel.get('name')
            const withName = seriesName ? 'withName' : 'withoutName'
            seriesLabel = seriesCnt > 1 ? labelModel.get(['series', 'multiple', withName]) : labelModel.get(['series', 'single', withName])
            seriesLabel = replace(seriesLabel, {
              seriesId: seriesModel.seriesIndex,
              seriesName: seriesModel.get('name'),
              seriesType: getSeriesTypeName(seriesModel.subType)
            })
            const data = seriesModel.getData()

            if (data.count() > maxDataCnt) {
              // Show part of data
              const partialLabel = labelModel.get(['data', 'partialData'])
              seriesLabel += replace(partialLabel, {
                displayCnt: maxDataCnt
              })
            } else {
              seriesLabel += labelModel.get(['data', 'allData'])
            }

            const middleSeparator_1 = labelModel.get(['data', 'separator', 'middle'])
            const endSeparator_1 = labelModel.get(['data', 'separator', 'end'])
            const dataLabels = []

            for (let i = 0; i < data.count(); i++) {
              if (i < maxDataCnt) {
                const name_1 = data.getName(i)
                const value = data.getValues(i)
                const dataLabel = labelModel.get(['data', name_1 ? 'withName' : 'withoutName'])
                dataLabels.push(replace(dataLabel, {
                  name: name_1,
                  value: value.join(middleSeparator_1)
                }))
              }
            }

            seriesLabel += dataLabels.join(middleSeparator_1) + endSeparator_1
            seriesLabels_1.push(seriesLabel)
          }
        })
        const separatorModel = labelModel.getModel(['series', 'multiple', 'separator'])
        const middleSeparator = separatorModel.get('middle')
        const endSeparator = separatorModel.get('end')
        ariaLabel += seriesLabels_1.join(middleSeparator) + endSeparator
        dom.setAttribute('aria-label', ariaLabel)
      }
    }

    function replace (str, keyValues) {
      if (!isString(str)) {
        return str
      }

      let result = str
      each(keyValues, function (value, key) {
        result = result.replace(new RegExp('\\{\\s*' + key + '\\s*\\}', 'g'), value)
      })
      return result
    }

    function getTitle () {
      let title = ecModel.get('title')

      if (title && title.length) {
        title = title[0]
      }

      return title && title.text
    }

    function getSeriesTypeName (type) {
      return ecModel.getLocaleModel().get(['series', 'typeNames'])[type] || '自定义图'
    }
  }

  function ariaPreprocessor (option) {
    if (!option || !option.aria) {
      return
    }

    const aria = option.aria // aria.show is deprecated and should use aria.enabled instead

    if (aria.show != null) {
      aria.enabled = aria.show
    }

    aria.label = aria.label || {} // move description, general, series, data to be under aria.label

    each(['description', 'general', 'series', 'data'], function (name) {
      if (aria[name] != null) {
        aria.label[name] = aria[name]
      }
    })
  }

  function install$Q (registers) {
    registers.registerPreprocessor(ariaPreprocessor)
    registers.registerVisual(registers.PRIORITY.VISUAL.ARIA, ariaVisual)
  }

  const RELATIONAL_EXPRESSION_OP_ALIAS_MAP = {
    value: 'eq',
    // PENDING: not good for literal semantic?
    '<': 'lt',
    '<=': 'lte',
    '>': 'gt',
    '>=': 'gte',
    '=': 'eq',
    '!=': 'ne',
    '<>': 'ne' // Might mileading for sake of the different between '==' and '===',
    // So dont support them.
    // '==': 'eq',
    // '===': 'seq',
    // '!==': 'sne'
    // PENDING: Whether support some common alias "ge", "le", "neq"?
    // ge: 'gte',
    // le: 'lte',
    // neq: 'ne',

  } // type RelationalExpressionOpEvaluate = (tarVal: unknown, condVal: unknown) => boolean;

  const RegExpEvaluator =
    /** @class */
    (function () {
      function RegExpEvaluator (rVal) {
        // Support condVal: RegExp | string
        const condValue = this._condVal = isString(rVal) ? new RegExp(rVal) : isRegExp(rVal) ? rVal : null

        if (condValue == null) {
          let errMsg = ''

          if ('development' !== 'production') {
            errMsg = makePrintable('Illegal regexp', rVal, 'in')
          }

          throwError(errMsg)
        }
      }

      RegExpEvaluator.prototype.evaluate = function (lVal) {
        const type = typeof lVal
        return isString(type) ? this._condVal.test(lVal) : isNumber(type) ? this._condVal.test(lVal + '') : false
      }

      return RegExpEvaluator
    }())

  const ConstConditionInternal =
    /** @class */
    (function () {
      function ConstConditionInternal () {}

      ConstConditionInternal.prototype.evaluate = function () {
        return this.value
      }

      return ConstConditionInternal
    }())

  const AndConditionInternal =
    /** @class */
    (function () {
      function AndConditionInternal () {}

      AndConditionInternal.prototype.evaluate = function () {
        const children = this.children

        for (let i = 0; i < children.length; i++) {
          if (!children[i].evaluate()) {
            return false
          }
        }

        return true
      }

      return AndConditionInternal
    }())

  const OrConditionInternal =
    /** @class */
    (function () {
      function OrConditionInternal () {}

      OrConditionInternal.prototype.evaluate = function () {
        const children = this.children

        for (let i = 0; i < children.length; i++) {
          if (children[i].evaluate()) {
            return true
          }
        }

        return false
      }

      return OrConditionInternal
    }())

  const NotConditionInternal =
    /** @class */
    (function () {
      function NotConditionInternal () {}

      NotConditionInternal.prototype.evaluate = function () {
        return !this.child.evaluate()
      }

      return NotConditionInternal
    }())

  const RelationalConditionInternal =
    /** @class */
    (function () {
      function RelationalConditionInternal () {}

      RelationalConditionInternal.prototype.evaluate = function () {
        const needParse = !!this.valueParser // Call getValue with no `this`.

        const getValue = this.getValue
        const tarValRaw = getValue(this.valueGetterParam)
        const tarValParsed = needParse ? this.valueParser(tarValRaw) : null // Relational cond follow "and" logic internally.

        for (let i = 0; i < this.subCondList.length; i++) {
          if (!this.subCondList[i].evaluate(needParse ? tarValParsed : tarValRaw)) {
            return false
          }
        }

        return true
      }

      return RelationalConditionInternal
    }())

  function parseOption (exprOption, getters) {
    if (exprOption === true || exprOption === false) {
      const cond = new ConstConditionInternal()
      cond.value = exprOption
      return cond
    }

    let errMsg = ''

    if (!isObjectNotArray(exprOption)) {
      if ('development' !== 'production') {
        errMsg = makePrintable('Illegal config. Expect a plain object but actually', exprOption)
      }

      throwError(errMsg)
    }

    if (exprOption.and) {
      return parseAndOrOption('and', exprOption, getters)
    } else if (exprOption.or) {
      return parseAndOrOption('or', exprOption, getters)
    } else if (exprOption.not) {
      return parseNotOption(exprOption, getters)
    }

    return parseRelationalOption(exprOption, getters)
  }

  function parseAndOrOption (op, exprOption, getters) {
    const subOptionArr = exprOption[op]
    let errMsg = ''

    if ('development' !== 'production') {
      errMsg = makePrintable('"and"/"or" condition should only be `' + op + ': [...]` and must not be empty array.', 'Illegal condition:', exprOption)
    }

    if (!isArray(subOptionArr)) {
      throwError(errMsg)
    }

    if (!subOptionArr.length) {
      throwError(errMsg)
    }

    const cond = op === 'and' ? new AndConditionInternal() : new OrConditionInternal()
    cond.children = map(subOptionArr, function (subOption) {
      return parseOption(subOption, getters)
    })

    if (!cond.children.length) {
      throwError(errMsg)
    }

    return cond
  }

  function parseNotOption (exprOption, getters) {
    const subOption = exprOption.not
    let errMsg = ''

    if ('development' !== 'production') {
      errMsg = makePrintable('"not" condition should only be `not: {}`.', 'Illegal condition:', exprOption)
    }

    if (!isObjectNotArray(subOption)) {
      throwError(errMsg)
    }

    const cond = new NotConditionInternal()
    cond.child = parseOption(subOption, getters)

    if (!cond.child) {
      throwError(errMsg)
    }

    return cond
  }

  function parseRelationalOption (exprOption, getters) {
    let errMsg = ''
    const valueGetterParam = getters.prepareGetValue(exprOption)
    const subCondList = []
    const exprKeys = keys(exprOption)
    const parserName = exprOption.parser
    const valueParser = parserName ? getRawValueParser(parserName) : null

    for (let i = 0; i < exprKeys.length; i++) {
      const keyRaw = exprKeys[i]

      if (keyRaw === 'parser' || getters.valueGetterAttrMap.get(keyRaw)) {
        continue
      }

      const op = hasOwn(RELATIONAL_EXPRESSION_OP_ALIAS_MAP, keyRaw) ? RELATIONAL_EXPRESSION_OP_ALIAS_MAP[keyRaw] : keyRaw
      const condValueRaw = exprOption[keyRaw]
      const condValueParsed = valueParser ? valueParser(condValueRaw) : condValueRaw
      const evaluator = createFilterComparator(op, condValueParsed) || op === 'reg' && new RegExpEvaluator(condValueParsed)

      if (!evaluator) {
        if ('development' !== 'production') {
          errMsg = makePrintable('Illegal relational operation: "' + keyRaw + '" in condition:', exprOption)
        }

        throwError(errMsg)
      }

      subCondList.push(evaluator)
    }

    if (!subCondList.length) {
      if ('development' !== 'production') {
        errMsg = makePrintable('Relational condition must have at least one operator.', 'Illegal condition:', exprOption)
      } // No relational operator always disabled in case of dangers result.

      throwError(errMsg)
    }

    const cond = new RelationalConditionInternal()
    cond.valueGetterParam = valueGetterParam
    cond.valueParser = valueParser
    cond.getValue = getters.getValue
    cond.subCondList = subCondList
    return cond
  }

  function isObjectNotArray (val) {
    return isObject(val) && !isArrayLike(val)
  }

  const ConditionalExpressionParsed =
    /** @class */
    (function () {
      function ConditionalExpressionParsed (exprOption, getters) {
        this._cond = parseOption(exprOption, getters)
      }

      ConditionalExpressionParsed.prototype.evaluate = function () {
        return this._cond.evaluate()
      }

      return ConditionalExpressionParsed
    }())
  function parseConditionalExpression (exprOption, getters) {
    return new ConditionalExpressionParsed(exprOption, getters)
  }

  const filterTransform = {
    type: 'echarts:filter',
    // PEDING: enhance to filter by index rather than create new data
    transform: function (params) {
      // [Caveat] Fail-Fast:
      // Do not return the whole dataset unless user config indicate it explicitly.
      // For example, if no condition specified by mistake, return an empty result
      // is better than return the entire raw soruce for user to find the mistake.
      const upstream = params.upstream
      let rawItem
      const condition = parseConditionalExpression(params.config, {
        valueGetterAttrMap: createHashMap({
          dimension: true
        }),
        prepareGetValue: function (exprOption) {
          let errMsg = ''
          const dimLoose = exprOption.dimension

          if (!hasOwn(exprOption, 'dimension')) {
            if ('development' !== 'production') {
              errMsg = makePrintable('Relation condition must has prop "dimension" specified.', 'Illegal condition:', exprOption)
            }

            throwError(errMsg)
          }

          const dimInfo = upstream.getDimensionInfo(dimLoose)

          if (!dimInfo) {
            if ('development' !== 'production') {
              errMsg = makePrintable('Can not find dimension info via: ' + dimLoose + '.\n', 'Existing dimensions: ', upstream.cloneAllDimensionInfo(), '.\n', 'Illegal condition:', exprOption, '.\n')
            }

            throwError(errMsg)
          }

          return {
            dimIdx: dimInfo.index
          }
        },
        getValue: function (param) {
          return upstream.retrieveValueFromItem(rawItem, param.dimIdx)
        }
      })
      const resultData = []

      for (let i = 0, len = upstream.count(); i < len; i++) {
        rawItem = upstream.getRawDataItem(i)

        if (condition.evaluate()) {
          resultData.push(rawItem)
        }
      }

      return {
        data: resultData
      }
    }
  }

  let sampleLog = ''

  if ('development' !== 'production') {
    sampleLog = ['Valid config is like:', '{ dimension: "age", order: "asc" }', 'or [{ dimension: "age", order: "asc"], { dimension: "date", order: "desc" }]'].join(' ')
  }

  const sortTransform = {
    type: 'echarts:sort',
    transform: function (params) {
      const upstream = params.upstream
      const config = params.config
      let errMsg = '' // Normalize
      // const orderExprList: OrderExpression[] = isArray(config[0])
      //     ? config as OrderExpression[]
      //     : [config as OrderExpression];

      const orderExprList = normalizeToArray(config)

      if (!orderExprList.length) {
        if ('development' !== 'production') {
          errMsg = 'Empty `config` in sort transform.'
        }

        throwError(errMsg)
      }

      const orderDefList = []
      each(orderExprList, function (orderExpr) {
        const dimLoose = orderExpr.dimension
        const order = orderExpr.order
        const parserName = orderExpr.parser
        const incomparable = orderExpr.incomparable

        if (dimLoose == null) {
          if ('development' !== 'production') {
            errMsg = 'Sort transform config must has "dimension" specified.' + sampleLog
          }

          throwError(errMsg)
        }

        if (order !== 'asc' && order !== 'desc') {
          if ('development' !== 'production') {
            errMsg = 'Sort transform config must has "order" specified.' + sampleLog
          }

          throwError(errMsg)
        }

        if (incomparable && incomparable !== 'min' && incomparable !== 'max') {
          let errMsg_1 = ''

          if ('development' !== 'production') {
            errMsg_1 = 'incomparable must be "min" or "max" rather than "' + incomparable + '".'
          }

          throwError(errMsg_1)
        }

        if (order !== 'asc' && order !== 'desc') {
          let errMsg_2 = ''

          if ('development' !== 'production') {
            errMsg_2 = 'order must be "asc" or "desc" rather than "' + order + '".'
          }

          throwError(errMsg_2)
        }

        const dimInfo = upstream.getDimensionInfo(dimLoose)

        if (!dimInfo) {
          if ('development' !== 'production') {
            errMsg = makePrintable('Can not find dimension info via: ' + dimLoose + '.\n', 'Existing dimensions: ', upstream.cloneAllDimensionInfo(), '.\n', 'Illegal config:', orderExpr, '.\n')
          }

          throwError(errMsg)
        }

        const parser = parserName ? getRawValueParser(parserName) : null

        if (parserName && !parser) {
          if ('development' !== 'production') {
            errMsg = makePrintable('Invalid parser name ' + parserName + '.\n', 'Illegal config:', orderExpr, '.\n')
          }

          throwError(errMsg)
        }

        orderDefList.push({
          dimIdx: dimInfo.index,
          parser: parser,
          comparator: new SortOrderComparator(order, incomparable)
        })
      }) // TODO: support it?

      const sourceFormat = upstream.sourceFormat

      if (sourceFormat !== SOURCE_FORMAT_ARRAY_ROWS && sourceFormat !== SOURCE_FORMAT_OBJECT_ROWS) {
        if ('development' !== 'production') {
          errMsg = 'sourceFormat "' + sourceFormat + '" is not supported yet'
        }

        throwError(errMsg)
      } // Other upstream format are all array.

      const resultData = []

      for (let i = 0, len = upstream.count(); i < len; i++) {
        resultData.push(upstream.getRawDataItem(i))
      }

      resultData.sort(function (item0, item1) {
        for (let i = 0; i < orderDefList.length; i++) {
          const orderDef = orderDefList[i]
          let val0 = upstream.retrieveValueFromItem(item0, orderDef.dimIdx)
          let val1 = upstream.retrieveValueFromItem(item1, orderDef.dimIdx)

          if (orderDef.parser) {
            val0 = orderDef.parser(val0)
            val1 = orderDef.parser(val1)
          }

          const result = orderDef.comparator.evaluate(val0, val1)

          if (result !== 0) {
            return result
          }
        }

        return 0
      })
      return {
        data: resultData
      }
    }
  }

  function install$R (registers) {
    registers.registerTransform(filterTransform)
    registers.registerTransform(sortTransform)
  }

  const DatasetModel =
    /** @class */
    (function (_super) {
      __extends(DatasetModel, _super)

      function DatasetModel () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = 'dataset'
        return _this
      }

      DatasetModel.prototype.init = function (option, parentModel, ecModel) {
        _super.prototype.init.call(this, option, parentModel, ecModel)

        this._sourceManager = new SourceManager(this)
        disableTransformOptionMerge(this)
      }

      DatasetModel.prototype.mergeOption = function (newOption, ecModel) {
        _super.prototype.mergeOption.call(this, newOption, ecModel)

        disableTransformOptionMerge(this)
      }

      DatasetModel.prototype.optionUpdated = function () {
        this._sourceManager.dirty()
      }

      DatasetModel.prototype.getSourceManager = function () {
        return this._sourceManager
      }

      DatasetModel.type = 'dataset'
      DatasetModel.defaultOption = {
        seriesLayoutBy: SERIES_LAYOUT_BY_COLUMN
      }
      return DatasetModel
    }(ComponentModel))

  const DatasetView =
    /** @class */
    (function (_super) {
      __extends(DatasetView, _super)

      function DatasetView () {
        const _this = _super !== null && _super.apply(this, arguments) || this

        _this.type = 'dataset'
        return _this
      }

      DatasetView.type = 'dataset'
      return DatasetView
    }(ComponentView))

  function install$S (registers) {
    registers.registerComponentModel(DatasetModel)
    registers.registerComponentView(DatasetView)
  }

  const CMD$4 = PathProxy.CMD
  function aroundEqual (a, b) {
    return Math.abs(a - b) < 1e-5
  }
  function pathToBezierCurves (path) {
    const data = path.data
    const len = path.len()
    const bezierArrayGroups = []
    let currentSubpath
    let xi = 0
    let yi = 0
    let x0 = 0
    let y0 = 0
    function createNewSubpath (x, y) {
      if (currentSubpath && currentSubpath.length > 2) {
        bezierArrayGroups.push(currentSubpath)
      }
      currentSubpath = [x, y]
    }
    function addLine (x0, y0, x1, y1) {
      if (!(aroundEqual(x0, x1) && aroundEqual(y0, y1))) {
        currentSubpath.push(x0, y0, x1, y1, x1, y1)
      }
    }
    function addArc (startAngle, endAngle, cx, cy, rx, ry) {
      const delta = Math.abs(endAngle - startAngle)
      const len = Math.tan(delta / 4) * 4 / 3
      const dir = endAngle < startAngle ? -1 : 1
      const c1 = Math.cos(startAngle)
      const s1 = Math.sin(startAngle)
      const c2 = Math.cos(endAngle)
      const s2 = Math.sin(endAngle)
      const x1 = c1 * rx + cx
      const y1 = s1 * ry + cy
      const x4 = c2 * rx + cx
      const y4 = s2 * ry + cy
      const hx = rx * len * dir
      const hy = ry * len * dir
      currentSubpath.push(x1 - hx * s1, y1 + hy * c1, x4 + hx * s2, y4 - hy * c2, x4, y4)
    }
    let x1
    let y1
    let x2
    let y2
    for (let i = 0; i < len;) {
      const cmd = data[i++]
      const isFirst = i === 1
      if (isFirst) {
        xi = data[i]
        yi = data[i + 1]
        x0 = xi
        y0 = yi
        if (cmd === CMD$4.L || cmd === CMD$4.C || cmd === CMD$4.Q) {
          currentSubpath = [x0, y0]
        }
      }
      switch (cmd) {
        case CMD$4.M:
          xi = x0 = data[i++]
          yi = y0 = data[i++]
          createNewSubpath(x0, y0)
          break
        case CMD$4.L:
          x1 = data[i++]
          y1 = data[i++]
          addLine(xi, yi, x1, y1)
          xi = x1
          yi = y1
          break
        case CMD$4.C:
          currentSubpath.push(data[i++], data[i++], data[i++], data[i++], xi = data[i++], yi = data[i++])
          break
        case CMD$4.Q:
          x1 = data[i++]
          y1 = data[i++]
          x2 = data[i++]
          y2 = data[i++]
          currentSubpath.push(xi + 2 / 3 * (x1 - xi), yi + 2 / 3 * (y1 - yi), x2 + 2 / 3 * (x1 - x2), y2 + 2 / 3 * (y1 - y2), x2, y2)
          xi = x2
          yi = y2
          break
        case CMD$4.A:
          var cx = data[i++]
          var cy = data[i++]
          var rx = data[i++]
          var ry = data[i++]
          var startAngle = data[i++]
          var endAngle = data[i++] + startAngle
          i += 1
          var anticlockwise = !data[i++]
          x1 = Math.cos(startAngle) * rx + cx
          y1 = Math.sin(startAngle) * ry + cy
          if (isFirst) {
            x0 = x1
            y0 = y1
            createNewSubpath(x0, y0)
          } else {
            addLine(xi, yi, x1, y1)
          }
          xi = Math.cos(endAngle) * rx + cx
          yi = Math.sin(endAngle) * ry + cy
          var step = (anticlockwise ? -1 : 1) * Math.PI / 2
          for (let angle = startAngle; anticlockwise ? angle > endAngle : angle < endAngle; angle += step) {
            const nextAngle = anticlockwise
              ? Math.max(angle + step, endAngle)
              : Math.min(angle + step, endAngle)
            addArc(angle, nextAngle, cx, cy, rx, ry)
          }
          break
        case CMD$4.R:
          x0 = xi = data[i++]
          y0 = yi = data[i++]
          x1 = x0 + data[i++]
          y1 = y0 + data[i++]
          createNewSubpath(x1, y0)
          addLine(x1, y0, x1, y1)
          addLine(x1, y1, x0, y1)
          addLine(x0, y1, x0, y0)
          addLine(x0, y0, x1, y0)
          break
        case CMD$4.Z:
          currentSubpath && addLine(xi, yi, x0, y0)
          xi = x0
          yi = y0
          break
      }
    }
    if (currentSubpath && currentSubpath.length > 2) {
      bezierArrayGroups.push(currentSubpath)
    }
    return bezierArrayGroups
  }
  function adpativeBezier (x0, y0, x1, y1, x2, y2, x3, y3, out, scale) {
    if (aroundEqual(x0, x1) && aroundEqual(y0, y1) && aroundEqual(x2, x3) && aroundEqual(y2, y3)) {
      out.push(x3, y3)
      return
    }
    const PIXEL_DISTANCE = 2 / scale
    const PIXEL_DISTANCE_SQR = PIXEL_DISTANCE * PIXEL_DISTANCE
    let dx = x3 - x0
    let dy = y3 - y0
    const d = Math.sqrt(dx * dx + dy * dy)
    dx /= d
    dy /= d
    const dx1 = x1 - x0
    const dy1 = y1 - y0
    const dx2 = x2 - x3
    const dy2 = y2 - y3
    const cp1LenSqr = dx1 * dx1 + dy1 * dy1
    const cp2LenSqr = dx2 * dx2 + dy2 * dy2
    if (cp1LenSqr < PIXEL_DISTANCE_SQR && cp2LenSqr < PIXEL_DISTANCE_SQR) {
      out.push(x3, y3)
      return
    }
    const projLen1 = dx * dx1 + dy * dy1
    const projLen2 = -dx * dx2 - dy * dy2
    const d1Sqr = cp1LenSqr - projLen1 * projLen1
    const d2Sqr = cp2LenSqr - projLen2 * projLen2
    if (d1Sqr < PIXEL_DISTANCE_SQR && projLen1 >= 0 &&
            d2Sqr < PIXEL_DISTANCE_SQR && projLen2 >= 0) {
      out.push(x3, y3)
      return
    }
    const tmpSegX = []
    const tmpSegY = []
    cubicSubdivide(x0, x1, x2, x3, 0.5, tmpSegX)
    cubicSubdivide(y0, y1, y2, y3, 0.5, tmpSegY)
    adpativeBezier(tmpSegX[0], tmpSegY[0], tmpSegX[1], tmpSegY[1], tmpSegX[2], tmpSegY[2], tmpSegX[3], tmpSegY[3], out, scale)
    adpativeBezier(tmpSegX[4], tmpSegY[4], tmpSegX[5], tmpSegY[5], tmpSegX[6], tmpSegY[6], tmpSegX[7], tmpSegY[7], out, scale)
  }
  function pathToPolygons (path, scale) {
    const bezierArrayGroups = pathToBezierCurves(path)
    const polygons = []
    scale = scale || 1
    for (let i = 0; i < bezierArrayGroups.length; i++) {
      const beziers = bezierArrayGroups[i]
      const polygon = []
      let x0 = beziers[0]
      let y0 = beziers[1]
      polygon.push(x0, y0)
      for (let k = 2; k < beziers.length;) {
        const x1 = beziers[k++]
        const y1 = beziers[k++]
        const x2 = beziers[k++]
        const y2 = beziers[k++]
        const x3 = beziers[k++]
        const y3 = beziers[k++]
        adpativeBezier(x0, y0, x1, y1, x2, y2, x3, y3, polygon, scale)
        x0 = x3
        y0 = y3
      }
      polygons.push(polygon)
    }
    return polygons
  }

  function getDividingGrids (dimSize, rowDim, count) {
    const rowSize = dimSize[rowDim]
    const columnSize = dimSize[1 - rowDim]
    const ratio = Math.abs(rowSize / columnSize)
    let rowCount = Math.ceil(Math.sqrt(ratio * count))
    let columnCount = Math.floor(count / rowCount)
    if (columnCount === 0) {
      columnCount = 1
      rowCount = count
    }
    const grids = []
    for (var i = 0; i < rowCount; i++) {
      grids.push(columnCount)
    }
    const currentCount = rowCount * columnCount
    const remained = count - currentCount
    if (remained > 0) {
      for (var i = 0; i < remained; i++) {
        grids[i % rowCount] += 1
      }
    }
    return grids
  }
  function divideSector (sectorShape, count, outShapes) {
    const r0 = sectorShape.r0
    const r = sectorShape.r
    const startAngle = sectorShape.startAngle
    const endAngle = sectorShape.endAngle
    const angle = Math.abs(endAngle - startAngle)
    const arcLen = angle * r
    const deltaR = r - r0
    const isAngleRow = arcLen > Math.abs(deltaR)
    const grids = getDividingGrids([arcLen, deltaR], isAngleRow ? 0 : 1, count)
    const rowSize = (isAngleRow ? angle : deltaR) / grids.length
    for (let row = 0; row < grids.length; row++) {
      const columnSize = (isAngleRow ? deltaR : angle) / grids[row]
      for (let column = 0; column < grids[row]; column++) {
        const newShape = {}
        if (isAngleRow) {
          newShape.startAngle = startAngle + rowSize * row
          newShape.endAngle = startAngle + rowSize * (row + 1)
          newShape.r0 = r0 + columnSize * column
          newShape.r = r0 + columnSize * (column + 1)
        } else {
          newShape.startAngle = startAngle + columnSize * column
          newShape.endAngle = startAngle + columnSize * (column + 1)
          newShape.r0 = r0 + rowSize * row
          newShape.r = r0 + rowSize * (row + 1)
        }
        newShape.clockwise = sectorShape.clockwise
        newShape.cx = sectorShape.cx
        newShape.cy = sectorShape.cy
        outShapes.push(newShape)
      }
    }
  }
  function divideRect (rectShape, count, outShapes) {
    const width = rectShape.width
    const height = rectShape.height
    const isHorizontalRow = width > height
    const grids = getDividingGrids([width, height], isHorizontalRow ? 0 : 1, count)
    const rowSizeDim = isHorizontalRow ? 'width' : 'height'
    const columnSizeDim = isHorizontalRow ? 'height' : 'width'
    const rowDim = isHorizontalRow ? 'x' : 'y'
    const columnDim = isHorizontalRow ? 'y' : 'x'
    const rowSize = rectShape[rowSizeDim] / grids.length
    for (let row = 0; row < grids.length; row++) {
      const columnSize = rectShape[columnSizeDim] / grids[row]
      for (let column = 0; column < grids[row]; column++) {
        const newShape = {}
        newShape[rowDim] = row * rowSize
        newShape[columnDim] = column * columnSize
        newShape[rowSizeDim] = rowSize
        newShape[columnSizeDim] = columnSize
        newShape.x += rectShape.x
        newShape.y += rectShape.y
        outShapes.push(newShape)
      }
    }
  }
  function crossProduct2d$1 (x1, y1, x2, y2) {
    return x1 * y2 - x2 * y1
  }
  function lineLineIntersect$1 (a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y) {
    const mx = a2x - a1x
    const my = a2y - a1y
    const nx = b2x - b1x
    const ny = b2y - b1y
    const nmCrossProduct = crossProduct2d$1(nx, ny, mx, my)
    if (Math.abs(nmCrossProduct) < 1e-6) {
      return null
    }
    const b1a1x = a1x - b1x
    const b1a1y = a1y - b1y
    const p = crossProduct2d$1(b1a1x, b1a1y, nx, ny) / nmCrossProduct
    if (p < 0 || p > 1) {
      return null
    }
    return new Point(p * mx + a1x, p * my + a1y)
  }
  function projPtOnLine (pt, lineA, lineB) {
    const dir = new Point()
    Point.sub(dir, lineB, lineA)
    dir.normalize()
    const dir2 = new Point()
    Point.sub(dir2, pt, lineA)
    const len = dir2.dot(dir)
    return len
  }
  function addToPoly (poly, pt) {
    const last = poly[poly.length - 1]
    if (last && last[0] === pt[0] && last[1] === pt[1]) {
      return
    }
    poly.push(pt)
  }
  function splitPolygonByLine (points, lineA, lineB) {
    const len = points.length
    const intersections = []
    for (var i = 0; i < len; i++) {
      const p0 = points[i]
      const p1 = points[(i + 1) % len]
      const intersectionPt = lineLineIntersect$1(p0[0], p0[1], p1[0], p1[1], lineA.x, lineA.y, lineB.x, lineB.y)
      if (intersectionPt) {
        intersections.push({
          projPt: projPtOnLine(intersectionPt, lineA, lineB),
          pt: intersectionPt,
          idx: i
        })
      }
    }
    if (intersections.length < 2) {
      return [{ points: points }, { points: points }]
    }
    intersections.sort(function (a, b) {
      return a.projPt - b.projPt
    })
    let splitPt0 = intersections[0]
    let splitPt1 = intersections[intersections.length - 1]
    if (splitPt1.idx < splitPt0.idx) {
      const tmp = splitPt0
      splitPt0 = splitPt1
      splitPt1 = tmp
    }
    const splitPt0Arr = [splitPt0.pt.x, splitPt0.pt.y]
    const splitPt1Arr = [splitPt1.pt.x, splitPt1.pt.y]
    const newPolyA = [splitPt0Arr]
    const newPolyB = [splitPt1Arr]
    for (var i = splitPt0.idx + 1; i <= splitPt1.idx; i++) {
      addToPoly(newPolyA, points[i].slice())
    }
    addToPoly(newPolyA, splitPt1Arr)
    addToPoly(newPolyA, splitPt0Arr)
    for (var i = splitPt1.idx + 1; i <= splitPt0.idx + len; i++) {
      addToPoly(newPolyB, points[i % len].slice())
    }
    addToPoly(newPolyB, splitPt0Arr)
    addToPoly(newPolyB, splitPt1Arr)
    return [{
      points: newPolyA
    }, {
      points: newPolyB
    }]
  }
  function binaryDividePolygon (polygonShape) {
    const points = polygonShape.points
    const min = []
    const max = []
    fromPoints(points, min, max)
    const boundingRect = new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1])
    const width = boundingRect.width
    const height = boundingRect.height
    const x = boundingRect.x
    const y = boundingRect.y
    const pt0 = new Point()
    const pt1 = new Point()
    if (width > height) {
      pt0.x = pt1.x = x + width / 2
      pt0.y = y
      pt1.y = y + height
    } else {
      pt0.y = pt1.y = y + height / 2
      pt0.x = x
      pt1.x = x + width
    }
    return splitPolygonByLine(points, pt0, pt1)
  }
  function binaryDivideRecursive (divider, shape, count, out) {
    if (count === 1) {
      out.push(shape)
    } else {
      const mid = Math.floor(count / 2)
      const sub = divider(shape)
      binaryDivideRecursive(divider, sub[0], mid, out)
      binaryDivideRecursive(divider, sub[1], count - mid, out)
    }
    return out
  }
  function clone$4 (path, count) {
    const paths = []
    for (let i = 0; i < count; i++) {
      paths.push(clonePath(path))
    }
    return paths
  }
  function copyPathProps (source, target) {
    target.setStyle(source.style)
    target.z = source.z
    target.z2 = source.z2
    target.zlevel = source.zlevel
  }
  function polygonConvert (points) {
    const out = []
    for (let i = 0; i < points.length;) {
      out.push([points[i++], points[i++]])
    }
    return out
  }
  function split (path, count) {
    const outShapes = []
    const shape = path.shape
    let OutShapeCtor
    switch (path.type) {
      case 'rect':
        divideRect(shape, count, outShapes)
        OutShapeCtor = Rect
        break
      case 'sector':
        divideSector(shape, count, outShapes)
        OutShapeCtor = Sector
        break
      case 'circle':
        divideSector({
          r0: 0,
          r: shape.r,
          startAngle: 0,
          endAngle: Math.PI * 2,
          cx: shape.cx,
          cy: shape.cy
        }, count, outShapes)
        OutShapeCtor = Sector
        break
      default:
        var m = path.getComputedTransform()
        var scale = m ? Math.sqrt(Math.max(m[0] * m[0] + m[1] * m[1], m[2] * m[2] + m[3] * m[3])) : 1
        var polygons = map(pathToPolygons(path.getUpdatedPathProxy(), scale), function (poly) { return polygonConvert(poly) })
        var polygonCount = polygons.length
        if (polygonCount === 0) {
          binaryDivideRecursive(binaryDividePolygon, {
            points: polygons[0]
          }, count, outShapes)
        } else if (polygonCount === count) {
          for (var i = 0; i < polygonCount; i++) {
            outShapes.push({
              points: polygons[i]
            })
          }
        } else {
          let totalArea_1 = 0
          const items = map(polygons, function (poly) {
            const min = []
            const max = []
            fromPoints(poly, min, max)
            const area = (max[1] - min[1]) * (max[0] - min[0])
            totalArea_1 += area
            return { poly: poly, area: area }
          })
          items.sort(function (a, b) { return b.area - a.area })
          let left = count
          for (var i = 0; i < polygonCount; i++) {
            const item = items[i]
            if (left <= 0) {
              break
            }
            const selfCount = i === polygonCount - 1
              ? left
              : Math.ceil(item.area / totalArea_1 * count)
            if (selfCount < 0) {
              continue
            }
            binaryDivideRecursive(binaryDividePolygon, {
              points: item.poly
            }, selfCount, outShapes)
            left -= selfCount
          }
        }
        OutShapeCtor = Polygon
        break
    }
    if (!OutShapeCtor) {
      return clone$4(path, count)
    }
    const out = []
    for (var i = 0; i < outShapes.length; i++) {
      const subPath = new OutShapeCtor()
      subPath.setShape(outShapes[i])
      copyPathProps(path, subPath)
      out.push(subPath)
    }
    return out
  }

  function alignSubpath (subpath1, subpath2) {
    const len1 = subpath1.length
    const len2 = subpath2.length
    if (len1 === len2) {
      return [subpath1, subpath2]
    }
    const tmpSegX = []
    const tmpSegY = []
    const shorterPath = len1 < len2 ? subpath1 : subpath2
    const shorterLen = Math.min(len1, len2)
    const diff = Math.abs(len2 - len1) / 6
    const shorterBezierCount = (shorterLen - 2) / 6
    const eachCurveSubDivCount = Math.ceil(diff / shorterBezierCount) + 1
    const newSubpath = [shorterPath[0], shorterPath[1]]
    let remained = diff
    for (let i = 2; i < shorterLen;) {
      let x0 = shorterPath[i - 2]
      let y0 = shorterPath[i - 1]
      let x1 = shorterPath[i++]
      let y1 = shorterPath[i++]
      let x2 = shorterPath[i++]
      let y2 = shorterPath[i++]
      const x3 = shorterPath[i++]
      const y3 = shorterPath[i++]
      if (remained <= 0) {
        newSubpath.push(x1, y1, x2, y2, x3, y3)
        continue
      }
      const actualSubDivCount = Math.min(remained, eachCurveSubDivCount - 1) + 1
      for (let k = 1; k <= actualSubDivCount; k++) {
        const p = k / actualSubDivCount
        cubicSubdivide(x0, x1, x2, x3, p, tmpSegX)
        cubicSubdivide(y0, y1, y2, y3, p, tmpSegY)
        x0 = tmpSegX[3]
        y0 = tmpSegY[3]
        newSubpath.push(tmpSegX[1], tmpSegY[1], tmpSegX[2], tmpSegY[2], x0, y0)
        x1 = tmpSegX[5]
        y1 = tmpSegY[5]
        x2 = tmpSegX[6]
        y2 = tmpSegY[6]
      }
      remained -= actualSubDivCount - 1
    }
    return shorterPath === subpath1 ? [newSubpath, subpath2] : [subpath1, newSubpath]
  }
  function createSubpath (lastSubpathSubpath, otherSubpath) {
    const len = lastSubpathSubpath.length
    const lastX = lastSubpathSubpath[len - 2]
    const lastY = lastSubpathSubpath[len - 1]
    const newSubpath = []
    for (let i = 0; i < otherSubpath.length;) {
      newSubpath[i++] = lastX
      newSubpath[i++] = lastY
    }
    return newSubpath
  }
  function alignBezierCurves (array1, array2) {
    let _a
    let lastSubpath1
    let lastSubpath2
    const newArray1 = []
    const newArray2 = []
    for (let i = 0; i < Math.max(array1.length, array2.length); i++) {
      const subpath1 = array1[i]
      const subpath2 = array2[i]
      let newSubpath1 = void 0
      let newSubpath2 = void 0
      if (!subpath1) {
        newSubpath1 = createSubpath(lastSubpath1 || subpath2, subpath2)
        newSubpath2 = subpath2
      } else if (!subpath2) {
        newSubpath2 = createSubpath(lastSubpath2 || subpath1, subpath1)
        newSubpath1 = subpath1
      } else {
        _a = alignSubpath(subpath1, subpath2), newSubpath1 = _a[0], newSubpath2 = _a[1]
        lastSubpath1 = newSubpath1
        lastSubpath2 = newSubpath2
      }
      newArray1.push(newSubpath1)
      newArray2.push(newSubpath2)
    }
    return [newArray1, newArray2]
  }
  function centroid$1 (array) {
    let signedArea = 0
    let cx = 0
    let cy = 0
    const len = array.length
    for (let i = 0, j = len - 2; i < len; j = i, i += 2) {
      const x0 = array[j]
      const y0 = array[j + 1]
      const x1 = array[i]
      const y1 = array[i + 1]
      const a = x0 * y1 - x1 * y0
      signedArea += a
      cx += (x0 + x1) * a
      cy += (y0 + y1) * a
    }
    if (signedArea === 0) {
      return [array[0] || 0, array[1] || 0]
    }
    return [cx / signedArea / 3, cy / signedArea / 3, signedArea]
  }
  function findBestRingOffset (fromSubBeziers, toSubBeziers, fromCp, toCp) {
    const bezierCount = (fromSubBeziers.length - 2) / 6
    let bestScore = Infinity
    let bestOffset = 0
    const len = fromSubBeziers.length
    const len2 = len - 2
    for (let offset = 0; offset < bezierCount; offset++) {
      const cursorOffset = offset * 6
      let score = 0
      for (let k = 0; k < len; k += 2) {
        const idx = k === 0 ? cursorOffset : ((cursorOffset + k - 2) % len2 + 2)
        const x0 = fromSubBeziers[idx] - fromCp[0]
        const y0 = fromSubBeziers[idx + 1] - fromCp[1]
        const x1 = toSubBeziers[k] - toCp[0]
        const y1 = toSubBeziers[k + 1] - toCp[1]
        const dx = x1 - x0
        const dy = y1 - y0
        score += dx * dx + dy * dy
      }
      if (score < bestScore) {
        bestScore = score
        bestOffset = offset
      }
    }
    return bestOffset
  }
  function reverse (array) {
    const newArr = []
    const len = array.length
    for (let i = 0; i < len; i += 2) {
      newArr[i] = array[len - i - 2]
      newArr[i + 1] = array[len - i - 1]
    }
    return newArr
  }
  function findBestMorphingRotation (fromArr, toArr, searchAngleIteration, searchAngleRange) {
    const result = []
    let fromNeedsReverse
    for (let i = 0; i < fromArr.length; i++) {
      let fromSubpathBezier = fromArr[i]
      const toSubpathBezier = toArr[i]
      const fromCp = centroid$1(fromSubpathBezier)
      const toCp = centroid$1(toSubpathBezier)
      if (fromNeedsReverse == null) {
        fromNeedsReverse = fromCp[2] < 0 !== toCp[2] < 0
      }
      const newFromSubpathBezier = []
      const newToSubpathBezier = []
      let bestAngle = 0
      let bestScore = Infinity
      const tmpArr = []
      const len = fromSubpathBezier.length
      if (fromNeedsReverse) {
        fromSubpathBezier = reverse(fromSubpathBezier)
      }
      const offset = findBestRingOffset(fromSubpathBezier, toSubpathBezier, fromCp, toCp) * 6
      const len2 = len - 2
      for (var k = 0; k < len2; k += 2) {
        const idx = (offset + k) % len2 + 2
        newFromSubpathBezier[k + 2] = fromSubpathBezier[idx] - fromCp[0]
        newFromSubpathBezier[k + 3] = fromSubpathBezier[idx + 1] - fromCp[1]
      }
      newFromSubpathBezier[0] = fromSubpathBezier[offset] - fromCp[0]
      newFromSubpathBezier[1] = fromSubpathBezier[offset + 1] - fromCp[1]
      if (searchAngleIteration > 0) {
        const step = searchAngleRange / searchAngleIteration
        for (let angle = -searchAngleRange / 2; angle <= searchAngleRange / 2; angle += step) {
          const sa = Math.sin(angle)
          const ca = Math.cos(angle)
          let score = 0
          for (var k = 0; k < fromSubpathBezier.length; k += 2) {
            const x0 = newFromSubpathBezier[k]
            const y0 = newFromSubpathBezier[k + 1]
            const x1 = toSubpathBezier[k] - toCp[0]
            const y1 = toSubpathBezier[k + 1] - toCp[1]
            const newX1 = x1 * ca - y1 * sa
            const newY1 = x1 * sa + y1 * ca
            tmpArr[k] = newX1
            tmpArr[k + 1] = newY1
            const dx = newX1 - x0
            const dy = newY1 - y0
            score += dx * dx + dy * dy
          }
          if (score < bestScore) {
            bestScore = score
            bestAngle = angle
            for (let m = 0; m < tmpArr.length; m++) {
              newToSubpathBezier[m] = tmpArr[m]
            }
          }
        }
      } else {
        for (let i_1 = 0; i_1 < len; i_1 += 2) {
          newToSubpathBezier[i_1] = toSubpathBezier[i_1] - toCp[0]
          newToSubpathBezier[i_1 + 1] = toSubpathBezier[i_1 + 1] - toCp[1]
        }
      }
      result.push({
        from: newFromSubpathBezier,
        to: newToSubpathBezier,
        fromCp: fromCp,
        toCp: toCp,
        rotation: -bestAngle
      })
    }
    return result
  }
  function isCombineMorphing (path) {
    return path.__isCombineMorphing
  }
  const SAVED_METHOD_PREFIX = '__mOriginal_'
  function saveAndModifyMethod (obj, methodName, modifiers) {
    const savedMethodName = SAVED_METHOD_PREFIX + methodName
    const originalMethod = obj[savedMethodName] || obj[methodName]
    if (!obj[savedMethodName]) {
      obj[savedMethodName] = obj[methodName]
    }
    const replace = modifiers.replace
    const after = modifiers.after
    const before = modifiers.before
    obj[methodName] = function () {
      const args = arguments
      let res
      before && before.apply(this, args)
      if (replace) {
        res = replace.apply(this, args)
      } else {
        res = originalMethod.apply(this, args)
      }
      after && after.apply(this, args)
      return res
    }
  }
  function restoreMethod (obj, methodName) {
    const savedMethodName = SAVED_METHOD_PREFIX + methodName
    if (obj[savedMethodName]) {
      obj[methodName] = obj[savedMethodName]
      obj[savedMethodName] = null
    }
  }
  function applyTransformOnBeziers (bezierCurves, mm) {
    for (let i = 0; i < bezierCurves.length; i++) {
      const subBeziers = bezierCurves[i]
      for (let k = 0; k < subBeziers.length;) {
        const x = subBeziers[k]
        const y = subBeziers[k + 1]
        subBeziers[k++] = mm[0] * x + mm[2] * y + mm[4]
        subBeziers[k++] = mm[1] * x + mm[3] * y + mm[5]
      }
    }
  }
  function prepareMorphPath (fromPath, toPath) {
    const fromPathProxy = fromPath.getUpdatedPathProxy()
    const toPathProxy = toPath.getUpdatedPathProxy()
    const _a = alignBezierCurves(pathToBezierCurves(fromPathProxy), pathToBezierCurves(toPathProxy)); const fromBezierCurves = _a[0]; const toBezierCurves = _a[1]
    const fromPathTransform = fromPath.getComputedTransform()
    const toPathTransform = toPath.getComputedTransform()
    function updateIdentityTransform () {
      this.transform = null
    }
    fromPathTransform && applyTransformOnBeziers(fromBezierCurves, fromPathTransform)
    toPathTransform && applyTransformOnBeziers(toBezierCurves, toPathTransform)
    saveAndModifyMethod(toPath, 'updateTransform', { replace: updateIdentityTransform })
    toPath.transform = null
    const morphingData = findBestMorphingRotation(fromBezierCurves, toBezierCurves, 10, Math.PI)
    const tmpArr = []
    saveAndModifyMethod(toPath, 'buildPath', {
      replace: function (path) {
        const t = toPath.__morphT
        const onet = 1 - t
        const newCp = []
        for (let i = 0; i < morphingData.length; i++) {
          const item = morphingData[i]
          const from = item.from
          const to = item.to
          const angle = item.rotation * t
          const fromCp = item.fromCp
          const toCp = item.toCp
          const sa = Math.sin(angle)
          const ca = Math.cos(angle)
          lerp(newCp, fromCp, toCp, t)
          for (var m = 0; m < from.length; m += 2) {
            const x0_1 = from[m]
            const y0_1 = from[m + 1]
            var x1 = to[m]
            var y1 = to[m + 1]
            const x = x0_1 * onet + x1 * t
            const y = y0_1 * onet + y1 * t
            tmpArr[m] = (x * ca - y * sa) + newCp[0]
            tmpArr[m + 1] = (x * sa + y * ca) + newCp[1]
          }
          let x0 = tmpArr[0]
          let y0 = tmpArr[1]
          path.moveTo(x0, y0)
          for (var m = 2; m < from.length;) {
            var x1 = tmpArr[m++]
            var y1 = tmpArr[m++]
            const x2 = tmpArr[m++]
            const y2 = tmpArr[m++]
            const x3 = tmpArr[m++]
            const y3 = tmpArr[m++]
            if (x0 === x1 && y0 === y1 && x2 === x3 && y2 === y3) {
              path.lineTo(x3, y3)
            } else {
              path.bezierCurveTo(x1, y1, x2, y2, x3, y3)
            }
            x0 = x3
            y0 = y3
          }
        }
      }
    })
  }
  function morphPath (fromPath, toPath, animationOpts) {
    if (!fromPath || !toPath) {
      return toPath
    }
    const oldDone = animationOpts.done
    const oldDuring = animationOpts.during
    prepareMorphPath(fromPath, toPath)
    toPath.__morphT = 0
    function restoreToPath () {
      restoreMethod(toPath, 'buildPath')
      restoreMethod(toPath, 'updateTransform')
      toPath.__morphT = -1
      toPath.createPathProxy()
      toPath.dirtyShape()
    }
    toPath.animateTo({
      __morphT: 1
    }, defaults({
      during: function (p) {
        toPath.dirtyShape()
        oldDuring && oldDuring(p)
      },
      done: function () {
        restoreToPath()
        oldDone && oldDone()
      }
    }, animationOpts))
    return toPath
  }
  function hilbert (x, y, minX, minY, maxX, maxY) {
    const bits = 16
    x = (maxX === minX) ? 0 : Math.round(32767 * (x - minX) / (maxX - minX))
    y = (maxY === minY) ? 0 : Math.round(32767 * (y - minY) / (maxY - minY))
    let d = 0
    let tmp
    for (let s = (1 << bits) / 2; s > 0; s /= 2) {
      let rx = 0
      let ry = 0
      if ((x & s) > 0) {
        rx = 1
      }
      if ((y & s) > 0) {
        ry = 1
      }
      d += s * s * ((3 * rx) ^ ry)
      if (ry === 0) {
        if (rx === 1) {
          x = s - 1 - x
          y = s - 1 - y
        }
        tmp = x
        x = y
        y = tmp
      }
    }
    return d
  }
  function sortPaths (pathList) {
    let xMin = Infinity
    let yMin = Infinity
    let xMax = -Infinity
    let yMax = -Infinity
    const cps = map(pathList, function (path) {
      const rect = path.getBoundingRect()
      const m = path.getComputedTransform()
      const x = rect.x + rect.width / 2 + (m ? m[4] : 0)
      const y = rect.y + rect.height / 2 + (m ? m[5] : 0)
      xMin = Math.min(x, xMin)
      yMin = Math.min(y, yMin)
      xMax = Math.max(x, xMax)
      yMax = Math.max(y, yMax)
      return [x, y]
    })
    const items = map(cps, function (cp, idx) {
      return {
        cp: cp,
        z: hilbert(cp[0], cp[1], xMin, yMin, xMax, yMax),
        path: pathList[idx]
      }
    })
    return items.sort(function (a, b) { return a.z - b.z }).map(function (item) { return item.path })
  }
  function defaultDividePath (param) {
    return split(param.path, param.count)
  }
  function createEmptyReturn () {
    return {
      fromIndividuals: [],
      toIndividuals: [],
      count: 0
    }
  }
  function combineMorph (fromList, toPath, animationOpts) {
    let fromPathList = []
    function addFromPath (fromList) {
      for (let i = 0; i < fromList.length; i++) {
        const from = fromList[i]
        if (isCombineMorphing(from)) {
          addFromPath(from.childrenRef())
        } else if (from instanceof Path) {
          fromPathList.push(from)
        }
      }
    }
    addFromPath(fromList)
    const separateCount = fromPathList.length
    if (!separateCount) {
      return createEmptyReturn()
    }
    const dividePath = animationOpts.dividePath || defaultDividePath
    let toSubPathList = dividePath({
      path: toPath, count: separateCount
    })
    if (toSubPathList.length !== separateCount) {
      console.error('Invalid morphing: unmatched splitted path')
      return createEmptyReturn()
    }
    fromPathList = sortPaths(fromPathList)
    toSubPathList = sortPaths(toSubPathList)
    const oldDone = animationOpts.done
    const oldDuring = animationOpts.during
    const individualDelay = animationOpts.individualDelay
    const identityTransform = new Transformable()
    for (var i = 0; i < separateCount; i++) {
      const from = fromPathList[i]
      const to = toSubPathList[i]
      to.parent = toPath
      to.copyTransform(identityTransform)
      if (!individualDelay) {
        prepareMorphPath(from, to)
      }
    }
    toPath.__isCombineMorphing = true
    toPath.childrenRef = function () {
      return toSubPathList
    }
    function addToSubPathListToZr (zr) {
      for (let i = 0; i < toSubPathList.length; i++) {
        toSubPathList[i].addSelfToZr(zr)
      }
    }
    saveAndModifyMethod(toPath, 'addSelfToZr', {
      after: function (zr) {
        addToSubPathListToZr(zr)
      }
    })
    saveAndModifyMethod(toPath, 'removeSelfFromZr', {
      after: function (zr) {
        for (let i = 0; i < toSubPathList.length; i++) {
          toSubPathList[i].removeSelfFromZr(zr)
        }
      }
    })
    function restoreToPath () {
      toPath.__isCombineMorphing = false
      toPath.__morphT = -1
      toPath.childrenRef = null
      restoreMethod(toPath, 'addSelfToZr')
      restoreMethod(toPath, 'removeSelfFromZr')
    }
    const toLen = toSubPathList.length
    if (individualDelay) {
      let animating_1 = toLen
      const eachDone = function () {
        animating_1--
        if (animating_1 === 0) {
          restoreToPath()
          oldDone && oldDone()
        }
      }
      for (var i = 0; i < toLen; i++) {
        const indivdualAnimationOpts = individualDelay
          ? defaults({
            delay: (animationOpts.delay || 0) + individualDelay(i, toLen, fromPathList[i], toSubPathList[i]),
            done: eachDone
          }, animationOpts)
          : animationOpts
        morphPath(fromPathList[i], toSubPathList[i], indivdualAnimationOpts)
      }
    } else {
      toPath.__morphT = 0
      toPath.animateTo({
        __morphT: 1
      }, defaults({
        during: function (p) {
          for (let i = 0; i < toLen; i++) {
            const child = toSubPathList[i]
            child.__morphT = toPath.__morphT
            child.dirtyShape()
          }
          oldDuring && oldDuring(p)
        },
        done: function () {
          restoreToPath()
          for (let i = 0; i < fromList.length; i++) {
            restoreMethod(fromList[i], 'updateTransform')
          }
          oldDone && oldDone()
        }
      }, animationOpts))
    }
    if (toPath.__zr) {
      addToSubPathListToZr(toPath.__zr)
    }
    return {
      fromIndividuals: fromPathList,
      toIndividuals: toSubPathList,
      count: toLen
    }
  }
  function separateMorph (fromPath, toPathList, animationOpts) {
    const toLen = toPathList.length
    let fromPathList = []
    const dividePath = animationOpts.dividePath || defaultDividePath
    function addFromPath (fromList) {
      for (let i = 0; i < fromList.length; i++) {
        const from = fromList[i]
        if (isCombineMorphing(from)) {
          addFromPath(from.childrenRef())
        } else if (from instanceof Path) {
          fromPathList.push(from)
        }
      }
    }
    if (isCombineMorphing(fromPath)) {
      addFromPath(fromPath.childrenRef())
      const fromLen = fromPathList.length
      if (fromLen < toLen) {
        let k = 0
        for (var i = fromLen; i < toLen; i++) {
          fromPathList.push(clonePath(fromPathList[k++ % fromLen]))
        }
      }
      fromPathList.length = toLen
    } else {
      fromPathList = dividePath({ path: fromPath, count: toLen })
      const fromPathTransform = fromPath.getComputedTransform()
      for (var i = 0; i < fromPathList.length; i++) {
        fromPathList[i].setLocalTransform(fromPathTransform)
      }
      if (fromPathList.length !== toLen) {
        console.error('Invalid morphing: unmatched splitted path')
        return createEmptyReturn()
      }
    }
    fromPathList = sortPaths(fromPathList)
    toPathList = sortPaths(toPathList)
    const individualDelay = animationOpts.individualDelay
    for (var i = 0; i < toLen; i++) {
      const indivdualAnimationOpts = individualDelay
        ? defaults({
          delay: (animationOpts.delay || 0) + individualDelay(i, toLen, fromPathList[i], toPathList[i])
        }, animationOpts)
        : animationOpts
      morphPath(fromPathList[i], toPathList[i], indivdualAnimationOpts)
    }
    return {
      fromIndividuals: fromPathList,
      toIndividuals: toPathList,
      count: toPathList.length
    }
  }

  function isMultiple (elements) {
    return isArray(elements[0])
  }

  function prepareMorphBatches (one, many) {
    const batches = []
    const batchCount = one.length

    for (var i = 0; i < batchCount; i++) {
      batches.push({
        one: one[i],
        many: []
      })
    }

    for (var i = 0; i < many.length; i++) {
      var len = many[i].length
      let k = void 0

      for (k = 0; k < len; k++) {
        batches[k % batchCount].many.push(many[i][k])
      }
    }

    let off = 0 // If one has more paths than each one of many. average them.

    for (var i = batchCount - 1; i >= 0; i--) {
      if (!batches[i].many.length) {
        const moveFrom = batches[off].many

        if (moveFrom.length <= 1) {
          // Not enough
          // Start from the first one.
          if (off) {
            off = 0
          } else {
            return batches
          }
        }

        var len = moveFrom.length
        const mid = Math.ceil(len / 2)
        batches[i].many = moveFrom.slice(mid, len)
        batches[off].many = moveFrom.slice(0, mid)
        off++
      }
    }

    return batches
  }

  const pathDividers = {
    clone: function (params) {
      const ret = [] // Fitting the alpha

      const approxOpacity = 1 - Math.pow(1 - params.path.style.opacity, 1 / params.count)

      for (let i = 0; i < params.count; i++) {
        const cloned = clonePath(params.path)
        cloned.setStyle('opacity', approxOpacity)
        ret.push(cloned)
      }

      return ret
    },
    // Use the default divider
    split: null
  }
  function applyMorphAnimation (from, to, divideShape, seriesModel, dataIndex, animateOtherProps) {
    if (!from.length || !to.length) {
      return
    }

    const updateAnimationCfg = getAnimationConfig('update', seriesModel, dataIndex)

    if (!(updateAnimationCfg && updateAnimationCfg.duration > 0)) {
      return
    }

    const animationDelay = seriesModel.getModel('universalTransition').get('delay')
    const animationCfg = Object.assign({
      // Need to setToFinal so the further calculation based on the style can be correct.
      // Like emphasis color.
      setToFinal: true
    }, updateAnimationCfg)
    let many
    let one

    if (isMultiple(from)) {
      // manyToOne
      many = from
      one = to
    }

    if (isMultiple(to)) {
      // oneToMany
      many = to
      one = from
    }

    function morphOneBatch (batch, fromIsMany, animateIndex, animateCount, forceManyOne) {
      const batchMany = batch.many
      const batchOne = batch.one

      if (batchMany.length === 1 && !forceManyOne) {
        // Is one to one
        const batchFrom = fromIsMany ? batchMany[0] : batchOne
        const batchTo = fromIsMany ? batchOne : batchMany[0]

        if (isCombineMorphing(batchFrom)) {
          // Keep doing combine animation.
          morphOneBatch({
            many: [batchFrom],
            one: batchTo
          }, true, animateIndex, animateCount, true)
        } else {
          var individualAnimationCfg = animationDelay
            ? defaults({
              delay: animationDelay(animateIndex, animateCount)
            }, animationCfg)
            : animationCfg
          morphPath(batchFrom, batchTo, individualAnimationCfg)
          animateOtherProps(batchFrom, batchTo, batchFrom, batchTo, individualAnimationCfg)
        }
      } else {
        const separateAnimationCfg = defaults({
          dividePath: pathDividers[divideShape],
          individualDelay: animationDelay && function (idx, count, fromPath, toPath) {
            return animationDelay(idx + animateIndex, animateCount)
          }
        }, animationCfg)

        const _a = fromIsMany ? combineMorph(batchMany, batchOne, separateAnimationCfg) : separateMorph(batchOne, batchMany, separateAnimationCfg)
        const fromIndividuals = _a.fromIndividuals
        const toIndividuals = _a.toIndividuals

        const count = fromIndividuals.length

        for (let k = 0; k < count; k++) {
          var individualAnimationCfg = animationDelay
            ? defaults({
              delay: animationDelay(k, count)
            }, animationCfg)
            : animationCfg
          animateOtherProps(fromIndividuals[k], toIndividuals[k], fromIsMany ? batchMany[k] : batch.one, fromIsMany ? batch.one : batchMany[k], individualAnimationCfg)
        }
      }
    }

    const fromIsMany = many ? many === from // Is one to one. If the path number not match. also needs do merge and separate morphing.
      : from.length > to.length
    const morphBatches = many ? prepareMorphBatches(one, many) : prepareMorphBatches(fromIsMany ? to : from, [fromIsMany ? from : to])
    let animateCount = 0

    for (var i = 0; i < morphBatches.length; i++) {
      animateCount += morphBatches[i].many.length
    }

    let animateIndex = 0

    for (var i = 0; i < morphBatches.length; i++) {
      morphOneBatch(morphBatches[i], fromIsMany, animateIndex, animateCount)
      animateIndex += morphBatches[i].many.length
    }
  }
  function getPathList (elements) {
    if (!elements) {
      return []
    }

    if (isArray(elements)) {
      const pathList_1 = []

      for (let i = 0; i < elements.length; i++) {
        pathList_1.push(getPathList(elements[i]))
      }

      return pathList_1
    }

    const pathList = []
    elements.traverse(function (el) {
      if (el instanceof Path && !el.disableMorphing && !el.invisible && !el.ignore) {
        pathList.push(el)
      }
    })
    return pathList
  }

  const DATA_COUNT_THRESHOLD = 1e4
  const getUniversalTransitionGlobalStore = makeInner()

  function getGroupIdDimension (data) {
    const dimensions = data.dimensions

    for (let i = 0; i < dimensions.length; i++) {
      const dimInfo = data.getDimensionInfo(dimensions[i])

      if (dimInfo && dimInfo.otherDims.itemGroupId === 0) {
        return dimensions[i]
      }
    }
  }

  function flattenDataDiffItems (list) {
    const items = []
    each(list, function (seriesInfo) {
      const data = seriesInfo.data

      if (data.count() > DATA_COUNT_THRESHOLD) {
        if ('development' !== 'production') {
          warn('Universal transition is disabled on large data > 10k.')
        }

        return
      }

      const indices = data.getIndices()
      const groupDim = getGroupIdDimension(data)

      for (let dataIndex = 0; dataIndex < indices.length; dataIndex++) {
        items.push({
          data: data,
          dim: seriesInfo.dim || groupDim,
          divide: seriesInfo.divide,
          dataIndex: dataIndex
        })
      }
    })
    return items
  }

  function fadeInElement (newEl, newSeries, newIndex) {
    newEl.traverse(function (el) {
      if (el instanceof Path) {
        // TODO use fade in animation for target element.
        initProps(el, {
          style: {
            opacity: 0
          }
        }, newSeries, {
          dataIndex: newIndex,
          isFrom: true
        })
      }
    })
  }

  function removeEl$1 (el) {
    if (el.parent) {
      // Bake parent transform to element.
      // So it can still have proper transform to transition after it's removed.
      const computedTransform = el.getComputedTransform()
      el.setLocalTransform(computedTransform)
      el.parent.remove(el)
    }
  }

  function stopAnimation (el) {
    el.stopAnimation()

    if (el.isGroup) {
      el.traverse(function (child) {
        child.stopAnimation()
      })
    }
  }

  function animateElementStyles (el, dataIndex, seriesModel) {
    const animationConfig = getAnimationConfig('update', seriesModel, dataIndex)
    animationConfig && el.traverse(function (child) {
      if (child instanceof Displayable) {
        const oldStyle = getOldStyle(child)

        if (oldStyle) {
          child.animateFrom({
            style: oldStyle
          }, animationConfig)
        }
      }
    })
  }

  function isAllIdSame (oldDiffItems, newDiffItems) {
    const len = oldDiffItems.length

    if (len !== newDiffItems.length) {
      return false
    }

    for (let i = 0; i < len; i++) {
      const oldItem = oldDiffItems[i]
      const newItem = newDiffItems[i]

      if (oldItem.data.getId(oldItem.dataIndex) !== newItem.data.getId(newItem.dataIndex)) {
        return false
      }
    }

    return true
  }

  function transitionBetween (oldList, newList, api) {
    const oldDiffItems = flattenDataDiffItems(oldList)
    const newDiffItems = flattenDataDiffItems(newList)

    function updateMorphingPathProps (from, to, rawFrom, rawTo, animationCfg) {
      if (rawFrom || from) {
        to.animateFrom({
          style: rawFrom && rawFrom !== from // dividingMethod like clone may override the style(opacity)
            // So extend it to raw style.
            ? extend(extend({}, rawFrom.style), from.style) : from.style
        }, animationCfg)
      }
    }

    function findKeyDim (items) {
      for (let i = 0; i < items.length; i++) {
        if (items[i].dim) {
          return items[i].dim
        }
      }
    }

    const oldKeyDim = findKeyDim(oldDiffItems)
    const newKeyDim = findKeyDim(newDiffItems)
    let hasMorphAnimation = false

    function createKeyGetter (isOld, onlyGetId) {
      return function (diffItem) {
        const data = diffItem.data
        const dataIndex = diffItem.dataIndex // TODO if specified dim

        if (onlyGetId) {
          return data.getId(dataIndex)
        } // Use group id as transition key by default.
        // So we can achieve multiple to multiple animation like drilldown / up naturally.
        // If group id not exits. Use id instead. If so, only one to one transition will be applied.

        const dataGroupId = data.hostModel && data.hostModel.get('dataGroupId') // If specified key dimension(itemGroupId by default). Use this same dimension from other data.
        // PENDING: If only use key dimension of newData.

        const keyDim = isOld ? oldKeyDim || newKeyDim : newKeyDim || oldKeyDim
        const dimInfo = keyDim && data.getDimensionInfo(keyDim)
        const dimOrdinalMeta = dimInfo && dimInfo.ordinalMeta

        if (dimInfo) {
          // Get from encode.itemGroupId.
          const key = data.get(dimInfo.name, dataIndex)

          if (dimOrdinalMeta) {
            return dimOrdinalMeta.categories[key] || key + ''
          }

          return key + ''
        } // Get groupId from raw item. { groupId: '' }

        const itemVal = data.getRawDataItem(dataIndex)

        if (itemVal && itemVal.groupId) {
          return itemVal.groupId + ''
        }

        return dataGroupId || data.getId(dataIndex)
      }
    } // Use id if it's very likely to be an one to one animation
    // It's more robust than groupId
    // TODO Check if key dimension is specified.

    const useId = isAllIdSame(oldDiffItems, newDiffItems)
    const isElementStillInChart = {}

    if (!useId) {
      // We may have different diff strategy with basicTransition if we use other dimension as key.
      // If so, we can't simply check if oldEl is same with newEl. We need a map to check if oldEl is still being used in the new chart.
      // We can't use the elements that already being morphed. Let it keep it's original basic transition.
      for (let i = 0; i < newDiffItems.length; i++) {
        const newItem = newDiffItems[i]
        const el = newItem.data.getItemGraphicEl(newItem.dataIndex)

        if (el) {
          isElementStillInChart[el.id] = true
        }
      }
    }

    function updateOneToOne (newIndex, oldIndex) {
      const oldItem = oldDiffItems[oldIndex]
      const newItem = newDiffItems[newIndex]
      const newSeries = newItem.data.hostModel // TODO Mark this elements is morphed and don't morph them anymore

      const oldEl = oldItem.data.getItemGraphicEl(oldItem.dataIndex)
      const newEl = newItem.data.getItemGraphicEl(newItem.dataIndex) // Can't handle same elements.

      if (oldEl === newEl) {
        newEl && animateElementStyles(newEl, newItem.dataIndex, newSeries)
        return
      }

      if ( // We can't use the elements that already being morphed
        oldEl && isElementStillInChart[oldEl.id]) {
        return
      }

      if (newEl) {
        // TODO: If keep animating the group in case
        // some of the elements don't want to be morphed.
        // TODO Label?
        stopAnimation(newEl)

        if (oldEl) {
          stopAnimation(oldEl) // If old element is doing leaving animation. stop it and remove it immediately.

          removeEl$1(oldEl)
          hasMorphAnimation = true
          applyMorphAnimation(getPathList(oldEl), getPathList(newEl), newItem.divide, newSeries, newIndex, updateMorphingPathProps)
        } else {
          fadeInElement(newEl, newSeries, newIndex)
        }
      } // else keep oldEl leaving animation.
    }

    new DataDiffer(oldDiffItems, newDiffItems, createKeyGetter(true, useId), createKeyGetter(false, useId), null, 'multiple').update(updateOneToOne).updateManyToOne(function (newIndex, oldIndices) {
      const newItem = newDiffItems[newIndex]
      const newData = newItem.data
      const newSeries = newData.hostModel
      const newEl = newData.getItemGraphicEl(newItem.dataIndex)
      const oldElsList = filter(map(oldIndices, function (idx) {
        return oldDiffItems[idx].data.getItemGraphicEl(oldDiffItems[idx].dataIndex)
      }), function (oldEl) {
        return oldEl && oldEl !== newEl && !isElementStillInChart[oldEl.id]
      })

      if (newEl) {
        stopAnimation(newEl)

        if (oldElsList.length) {
          // If old element is doing leaving animation. stop it and remove it immediately.
          each(oldElsList, function (oldEl) {
            stopAnimation(oldEl)
            removeEl$1(oldEl)
          })
          hasMorphAnimation = true
          applyMorphAnimation(getPathList(oldElsList), getPathList(newEl), newItem.divide, newSeries, newIndex, updateMorphingPathProps)
        } else {
          fadeInElement(newEl, newSeries, newItem.dataIndex)
        }
      } // else keep oldEl leaving animation.
    }).updateOneToMany(function (newIndices, oldIndex) {
      const oldItem = oldDiffItems[oldIndex]
      const oldEl = oldItem.data.getItemGraphicEl(oldItem.dataIndex) // We can't use the elements that already being morphed

      if (oldEl && isElementStillInChart[oldEl.id]) {
        return
      }

      const newElsList = filter(map(newIndices, function (idx) {
        return newDiffItems[idx].data.getItemGraphicEl(newDiffItems[idx].dataIndex)
      }), function (el) {
        return el && el !== oldEl
      })
      const newSeris = newDiffItems[newIndices[0]].data.hostModel

      if (newElsList.length) {
        each(newElsList, function (newEl) {
          return stopAnimation(newEl)
        })

        if (oldEl) {
          stopAnimation(oldEl) // If old element is doing leaving animation. stop it and remove it immediately.

          removeEl$1(oldEl)
          hasMorphAnimation = true
          applyMorphAnimation(getPathList(oldEl), getPathList(newElsList), oldItem.divide, // Use divide on old.
            newSeris, newIndices[0], updateMorphingPathProps)
        } else {
          each(newElsList, function (newEl) {
            return fadeInElement(newEl, newSeris, newIndices[0])
          })
        }
      } // else keep oldEl leaving animation.
    }).updateManyToMany(function (newIndices, oldIndices) {
      // If two data are same and both have groupId.
      // Normally they should be diff by id.
      new DataDiffer(oldIndices, newIndices, function (rawIdx) {
        return oldDiffItems[rawIdx].data.getId(oldDiffItems[rawIdx].dataIndex)
      }, function (rawIdx) {
        return newDiffItems[rawIdx].data.getId(newDiffItems[rawIdx].dataIndex)
      }).update(function (newIndex, oldIndex) {
        // Use the original index
        updateOneToOne(newIndices[newIndex], oldIndices[oldIndex])
      }).execute()
    }).execute()

    if (hasMorphAnimation) {
      each(newList, function (_a) {
        const data = _a.data
        const seriesModel = data.hostModel
        const view = seriesModel && api.getViewOfSeriesModel(seriesModel)
        const animationCfg = getAnimationConfig('update', seriesModel, 0) // use 0 index.

        if (view && seriesModel.isAnimationEnabled() && animationCfg && animationCfg.duration > 0) {
          view.group.traverse(function (el) {
            if (el instanceof Path && !el.animators.length) {
              // We can't accept there still exists element that has no animation
              // if universalTransition is enabled
              el.animateFrom({
                style: {
                  opacity: 0
                }
              }, animationCfg)
            }
          })
        }
      })
    }
  }

  function getSeriesTransitionKey (series) {
    const seriesKey = series.getModel('universalTransition').get('seriesKey')

    if (!seriesKey) {
      // Use series id by default.
      return series.id
    }

    return seriesKey
  }

  function convertArraySeriesKeyToString (seriesKey) {
    if (isArray(seriesKey)) {
      // Order independent.
      return seriesKey.sort().join(',')
    }

    return seriesKey
  }

  function getDivideShapeFromData (data) {
    if (data.hostModel) {
      return data.hostModel.getModel('universalTransition').get('divideShape')
    }
  }

  function findTransitionSeriesBatches (globalStore, params) {
    const updateBatches = createHashMap()
    const oldDataMap = createHashMap() // Map that only store key in array seriesKey.
    // Which is used to query the old data when transition from one to multiple series.

    const oldDataMapForSplit = createHashMap()
    each(globalStore.oldSeries, function (series, idx) {
      const oldData = globalStore.oldData[idx]
      const transitionKey = getSeriesTransitionKey(series)
      const transitionKeyStr = convertArraySeriesKeyToString(transitionKey)
      oldDataMap.set(transitionKeyStr, oldData)

      if (isArray(transitionKey)) {
        // Same key can't in different array seriesKey.
        each(transitionKey, function (key) {
          oldDataMapForSplit.set(key, {
            data: oldData,
            key: transitionKeyStr
          })
        })
      }
    })

    function checkTransitionSeriesKeyDuplicated (transitionKeyStr) {
      if (updateBatches.get(transitionKeyStr)) {
        warn('Duplicated seriesKey in universalTransition ' + transitionKeyStr)
      }
    }

    each(params.updatedSeries, function (series) {
      if (series.isUniversalTransitionEnabled() && series.isAnimationEnabled()) {
        const newData = series.getData()
        const transitionKey = getSeriesTransitionKey(series)
        const transitionKeyStr = convertArraySeriesKeyToString(transitionKey) // Only transition between series with same id.

        const oldData = oldDataMap.get(transitionKeyStr) // string transition key is the best match.

        if (oldData) {
          if ('development' !== 'production') {
            checkTransitionSeriesKeyDuplicated(transitionKeyStr)
          } // TODO check if data is same?

          updateBatches.set(transitionKeyStr, {
            oldSeries: [{
              divide: getDivideShapeFromData(oldData),
              data: oldData
            }],
            newSeries: [{
              divide: getDivideShapeFromData(newData),
              data: newData
            }]
          })
        } else {
          // Transition from multiple series.
          if (isArray(transitionKey)) {
            if ('development' !== 'production') {
              checkTransitionSeriesKeyDuplicated(transitionKeyStr)
            }

            const oldSeries_1 = []
            each(transitionKey, function (key) {
              const oldData = oldDataMap.get(key)

              if (oldData) {
                oldSeries_1.push({
                  divide: getDivideShapeFromData(oldData),
                  data: oldData
                })
              }
            })

            if (oldSeries_1.length) {
              updateBatches.set(transitionKeyStr, {
                oldSeries: oldSeries_1,
                newSeries: [{
                  data: newData,
                  divide: getDivideShapeFromData(newData)
                }]
              })
            }
          } else {
            // Try transition to multiple series.
            const oldData_1 = oldDataMapForSplit.get(transitionKey)

            if (oldData_1) {
              let batch = updateBatches.get(oldData_1.key)

              if (!batch) {
                batch = {
                  oldSeries: [{
                    data: oldData_1.data,
                    divide: getDivideShapeFromData(oldData_1.data)
                  }],
                  newSeries: []
                }
                updateBatches.set(oldData_1.key, batch)
              }

              batch.newSeries.push({
                data: newData,
                divide: getDivideShapeFromData(newData)
              })
            }
          }
        }
      }
    })
    return updateBatches
  }

  function querySeries (series, finder) {
    for (let i = 0; i < series.length; i++) {
      const found = finder.seriesIndex != null && finder.seriesIndex === series[i].seriesIndex || finder.seriesId != null && finder.seriesId === series[i].id

      if (found) {
        return i
      }
    }
  }

  function transitionSeriesFromOpt (transitionOpt, globalStore, params, api) {
    const from = []
    const to = []
    each(normalizeToArray(transitionOpt.from), function (finder) {
      const idx = querySeries(globalStore.oldSeries, finder)

      if (idx >= 0) {
        from.push({
          data: globalStore.oldData[idx],
          // TODO can specify divideShape in transition.
          divide: getDivideShapeFromData(globalStore.oldData[idx]),
          dim: finder.dimension
        })
      }
    })
    each(normalizeToArray(transitionOpt.to), function (finder) {
      const idx = querySeries(params.updatedSeries, finder)

      if (idx >= 0) {
        const data = params.updatedSeries[idx].getData()
        to.push({
          data: data,
          divide: getDivideShapeFromData(data),
          dim: finder.dimension
        })
      }
    })

    if (from.length > 0 && to.length > 0) {
      transitionBetween(from, to, api)
    }
  }

  function installUniversalTransition (registers) {
    registers.registerUpdateLifecycle('series:beforeupdate', function (ecMOdel, api, params) {
      each(normalizeToArray(params.seriesTransition), function (transOpt) {
        each(normalizeToArray(transOpt.to), function (finder) {
          const series = params.updatedSeries

          for (let i = 0; i < series.length; i++) {
            if (finder.seriesIndex != null && finder.seriesIndex === series[i].seriesIndex || finder.seriesId != null && finder.seriesId === series[i].id) {
              series[i][SERIES_UNIVERSAL_TRANSITION_PROP] = true
            }
          }
        })
      })
    })
    registers.registerUpdateLifecycle('series:transition', function (ecModel, api, params) {
      // TODO api provide an namespace that can save stuff per instance
      const globalStore = getUniversalTransitionGlobalStore(api) // TODO multiple to multiple series.

      if (globalStore.oldSeries && params.updatedSeries && params.optionChanged) {
        // Use give transition config if its' give;
        const transitionOpt = params.seriesTransition

        if (transitionOpt) {
          each(normalizeToArray(transitionOpt), function (opt) {
            transitionSeriesFromOpt(opt, globalStore, params, api)
          })
        } else {
          // Else guess from series based on transition series key.
          const updateBatches_1 = findTransitionSeriesBatches(globalStore, params)
          each(updateBatches_1.keys(), function (key) {
            const batch = updateBatches_1.get(key)
            transitionBetween(batch.oldSeries, batch.newSeries, api)
          })
        } // Reset

        each(params.updatedSeries, function (series) {
          // Reset;
          if (series[SERIES_UNIVERSAL_TRANSITION_PROP]) {
            series[SERIES_UNIVERSAL_TRANSITION_PROP] = false
          }
        })
      } // Save all series of current update. Not only the updated one.

      const allSeries = ecModel.getSeries()
      const savedSeries = globalStore.oldSeries = []
      const savedData = globalStore.oldData = []

      for (let i = 0; i < allSeries.length; i++) {
        const data = allSeries[i].getData() // Only save the data that can have transition.
        // Avoid large data costing too much extra memory

        if (data.count() < DATA_COUNT_THRESHOLD) {
          savedSeries.push(allSeries[i])
          savedData.push(data)
        }
      }
    })
  }

  // Render engines
  // -----------------
  // Render via Canvas.
  // echarts.init(dom, null, { renderer: 'canvas' })

  use([install$1]) // Render via SVG.
  // echarts.init(dom, null, { renderer: 'svg' })

  use([install]) // ----------------
  // Charts (series)
  // ----------------
  // All of the series types, for example:
  // chart.setOption({
  //     series: [{
  //         type: 'line' // or 'bar', 'pie', ...
  //     }]
  // });

  use([install$2, install$3, install$4, install$6, install$8, install$a, install$b, install$c, install$d, install$e, install$f, install$h, install$i, install$j, install$k, install$l, install$m, install$n, install$o, install$p, install$q, install$r]) // -------------------
  // Coordinate systems
  // -------------------
  // All of the axis modules have been included in the
  // coordinate system module below, do not need to
  // make extra import.
  // `cartesian` coordinate system. For some historical
  // reasons, it is named as grid, for example:
  // chart.setOption({
  //     grid: {...},
  //     xAxis: {...},
  //     yAxis: {...},
  //     series: [{...}]
  // });

  use(install$t) // `polar` coordinate system, for example:
  // chart.setOption({
  //     polar: {...},
  //     radiusAxis: {...},
  //     angleAxis: {...},
  //     series: [{
  //         coordinateSystem: 'polar'
  //     }]
  // });

  use(install$u) // `geo` coordinate system, for example:
  // chart.setOption({
  //     geo: {...},
  //     series: [{
  //         coordinateSystem: 'geo'
  //     }]
  // });

  use(install$9) // `singleAxis` coordinate system (notice, it is a coordinate system
  // with only one axis, work for chart like theme river), for example:
  // chart.setOption({
  //     singleAxis: {...}
  //     series: [{type: 'themeRiver', ...}]
  // });

  use(install$v) // `parallel` coordinate system, only work for parallel series, for example:
  // chart.setOption({
  //     parallel: {...},
  //     parallelAxis: [{...}, ...],
  //     series: [{
  //         type: 'parallel'
  //     }]
  // });

  use(install$g) // `calendar` coordinate system. for example,
  // chart.setOptionp({
  //     calendar: {...},
  //     series: [{
  //         coordinateSystem: 'calendar'
  //     }]
  // );

  use(install$w) // ------------------
  // Other components
  // ------------------
  // `graphic` component, for example:
  // chart.setOption({
  //     graphic: {...}
  // });

  use(install$x) // `toolbox` component, for example:
  // chart.setOption({
  //     toolbox: {...}
  // });

  use(install$z) // `tooltip` component, for example:
  // chart.setOption({
  //     tooltip: {...}
  // });

  use(install$A) // `axisPointer` component, for example:
  // chart.setOption({
  //     tooltip: {axisPointer: {...}, ...}
  // });
  // Or
  // chart.setOption({
  //     axisPointer: {...}
  // });

  use(install$s) // `brush` component, for example:
  // chart.setOption({
  //     brush: {...}
  // });
  // Or
  // chart.setOption({
  //     tooltip: {feature: {brush: {...}}
  // })

  use(install$B) // `title` component, for example:
  // chart.setOption({
  //     title: {...}
  // });

  use(install$C) // `timeline` component, for example:
  // chart.setOption({
  //     timeline: {...}
  // });

  use(install$D) // `markPoint` component, for example:
  // chart.setOption({
  //     series: [{markPoint: {...}}]
  // });

  use(install$E) // `markLine` component, for example:
  // chart.setOption({
  //     series: [{markLine: {...}}]
  // });

  use(install$F) // `markArea` component, for example:
  // chart.setOption({
  //     series: [{markArea: {...}}]
  // });

  use(install$G) // `legend` component not scrollable. for example:
  // chart.setOption({
  //     legend: {...}
  // });

  use(install$J) // `dataZoom` component including both `dataZoomInside` and `dataZoomSlider`.

  use(install$M) // `dataZoom` component providing drag, pinch, wheel behaviors
  // inside coodinate system, for example:
  // chart.setOption({
  //     dataZoom: {type: 'inside'}
  // });

  use(install$K) // `dataZoom` component providing a slider bar, for example:
  // chart.setOption({
  //     dataZoom: {type: 'slider'}
  // });

  use(install$L) // `visualMap` component including both `visualMapContinuous` and `visualMapPiecewise`.

  use(install$P) // `visualMap` component providing continuous bar, for example:
  // chart.setOption({
  //     visualMap: {type: 'continuous'}
  // });

  use(install$N) // `visualMap` component providing pieces bar, for example:
  // chart.setOption({
  //     visualMap: {type: 'piecewise'}
  // });

  use(install$O) // `aria` component providing aria, for example:
  // chart.setOption({
  //     aria: {...}
  // });

  use(install$Q) // dataset transform
  // chart.setOption({
  //     dataset: {
  //          transform: []
  //     }
  // });

  use(install$R)
  use(install$S) // universal transition
  // chart.setOption({
  //     series: {
  //         universalTransition: { enabled: true }
  //     }
  // })

  use(installUniversalTransition) // label layout
  // chart.setOption({
  //     series: {
  //         labelLayout: { hideOverlap: true }
  //     }
  // })

  use(installLabelLayout)

  exports.Axis = Axis
  exports.ChartView = ChartView
  exports.ComponentModel = ComponentModel
  exports.ComponentView = ComponentView
  exports.List = SeriesData
  exports.Model = Model
  exports.PRIORITY = PRIORITY
  exports.SeriesModel = SeriesModel
  exports.color = color
  exports.connect = connect
  exports.dataTool = dataTool
  exports.dependencies = dependencies
  exports.disConnect = disConnect
  exports.disconnect = disconnect
  exports.dispose = dispose$1
  exports.env = env
  exports.extendChartView = extendChartView
  exports.extendComponentModel = extendComponentModel
  exports.extendComponentView = extendComponentView
  exports.extendSeriesModel = extendSeriesModel
  exports.format = format$1
  exports.getCoordinateSystemDimensions = getCoordinateSystemDimensions
  exports.getInstanceByDom = getInstanceByDom
  exports.getInstanceById = getInstanceById
  exports.getMap = getMap
  exports.graphic = graphic$1
  exports.helper = helper
  exports.init = init$1
  exports.innerDrawElementOnCanvas = brushSingle
  exports.matrix = matrix
  exports.number = number
  exports.parseGeoJSON = parseGeoJSON
  exports.parseGeoJson = parseGeoJSON
  exports.registerAction = registerAction
  exports.registerCoordinateSystem = registerCoordinateSystem
  exports.registerLayout = registerLayout
  exports.registerLoading = registerLoading
  exports.registerLocale = registerLocale
  exports.registerMap = registerMap
  exports.registerPostInit = registerPostInit
  exports.registerPostUpdate = registerPostUpdate
  exports.registerPreprocessor = registerPreprocessor
  exports.registerProcessor = registerProcessor
  exports.registerTheme = registerTheme
  exports.registerTransform = registerTransform
  exports.registerUpdateLifecycle = registerUpdateLifecycle
  exports.registerVisual = registerVisual
  exports.setCanvasCreator = setCanvasCreator
  exports.setPlatformAPI = setPlatformAPI
  exports.throttle = throttle
  exports.time = time
  exports.use = use
  exports.util = util$1
  exports.vector = vector
  exports.version = version$1
  exports.zrUtil = util
  exports.zrender = zrender

  Object.defineProperty(exports, '__esModule', { value: true })
}))
// # sourceMappingURL=echarts.js.map
